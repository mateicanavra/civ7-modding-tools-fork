This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_archive/
  plugin-mapgen-archives/
    config-resolution-and-entry-simplification.md
    diagnostic-fix.md
    earth-forces-and-layer-contracts.md
  plugins-mapgen/
    climate-story/
      hotspot-trails-and-rift-valleys.md
      overview.md
      roadmap-additional-motifs.md
    overview.md
  clean-room-plan.md
  docs-inventory-pre-refactor.md
  epic-diverse-map-guide.md
  plate-generation-refactor.md
  swooper-maps-architecture-audit.md
  terrain-feature-verification.md
  xml-first-crawl-plan.md
process/
  CONTRIBUTING.md
  GRAPHITE.md
  LINEAR.md
projects/
  engine-refactor-v1/
    issues/
      pipeline-config-refactor.md
      plate-pipeline-followups.md
    MAPS-engine-refactor/
      overview.md
      status.md
    resources/
      slideshows/
        map-generation-pipeline.json
        map-generation-pipeline.outline.md
        voronoi-plate-generation.json
        voronoi-plate-generation.outline.md
      era-tagged-morphology-review.md
      swooper-map-plan.md
    README.md
system/
  cli/
    overview.md
  mods/
    swooper-maps/
      reference/
        legacy-climate-story-tldr.md
        legacy-layer-contracts.md
        README.md
      adr.md
      design.md
      margins-narrative.md
      overview.md
  sdk/
    overview.md
  ADR.md
  ARCHITECTURE.md
  DEFERRALS.md
  TESTING.md
templates/
  issue.md
  milestone.md
  project.md
  service.md
DOCS.md
PROCESS.md
PRODUCT.md
ROADMAP.md
SYSTEM.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_archive/plugin-mapgen-archives/config-resolution-and-entry-simplification.md">
# TEMP PLAN — Config Resolution and Entry Simplification

Owner: Map Systems
Status: In Progress (Entry pattern decided; Phase 1 complete)
Scope: v1.2+ refactor; low-risk, incremental; no functional behavior change until flip

---

## 1) Goals

- Make each map entry file the single source of truth for configuration.
- Eliminate “implicit defaults” scattered across modules; move them into explicit defaults/presets.
- Provide one unified “resolved” config surface that all layers/orchestrator/dev tooling read from.
- Reduce entry boilerplate to a tiny, memorable pattern.

Non-goals:
- Changing gameplay balance or pass ordering.
- Introducing heavyweight runtime merging across large graphs (keep O(1) per read with one O(N) merge per run).

---

## 2) Pain Points Today

- Two config sources:
  - Per-entry runtime config (set via `runtime.setConfig`) used in orchestrator for a few keys.
  - Static `map_config.js` used by most layers/WorldModel/dev via `tunables.js`.
- Friction:
  - Per-entry overrides for world model, features, etc. do not flow into layers.
  - Static toggles in `tunables.js` can disagree with runtime toggles used in the orchestrator.
  - Defaults are embedded in multiple places instead of one explicit defaults file.

---

## 3) Proposed Architecture

### Components

- defaults/base.js
  - A single, explicit default config object (`BASE_CONFIG`), frozen.

- presets/*.js
  - Small, named preset objects (e.g., `temperate.js`, `classic.js`, `rifted.js`), each exporting a partial config.
  - Naming: concise and descriptive.

- runtime.js (existing)
  - Role: storage for “active per-entry” config set by a map script before generation.
  - Keep for now to avoid touching engine bootstrap timing; may be folded later.

- resolved.js (new)
  - Role: single source of resolved config for all consumers.
  - Responsibilities:
    - Build a config snapshot: defaults <- presets[] (left→right) <- runtime overrides.
    - Expose read APIs that return values from the current snapshot.
    - Provide `refresh()` to rebuild the snapshot at GenerateMap time.
    - Ensure immutability (freeze snapshot) for predictability.

- tunables.js (transition shim)
  - Short-term: Re-export from `resolved.js` or call `resolved.get*()` so we can migrate layers without large churn.
  - Long-term: Deprecate once all imports move to `resolved.js`.

- entry.js (optional bootstrap helper)
  - To minimize entry boilerplate: one function that sets per-entry config and ensures the orchestrator is loaded, with optional presets composition.

### Merge Semantics

- Precedence and order:
  1) `defaults/base.js` (lowest precedence)
  2) Zero or more presets, applied left-to-right
  3) Per-entry runtime overrides (highest precedence)
- Merge operation:
  - Safe deep-merge (object-only, arrays replace by default; keep simple/explicit).
  - Freeze the final snapshot to prevent accidental mutation.
- Determinism: One `refresh()` call per generation (start of `generateMap`).

---

## 4) Module Layout (Names are illustrative)

- `maps/config/defaults/base.js` → `export const BASE_CONFIG = Object.freeze({...});`
- `maps/config/presets/temperate.js` → `export const TEMPERATE_PRESET = Object.freeze({...});`
- `maps/config/presets/classic.js` → `export const CLASSIC_PRESET = Object.freeze({...});`
- `maps/config/presets/rifted.js` → `export const RIFTED_PRESET = Object.freeze({...});`
- `maps/config/runtime.js` → unchanged (storage API used by entries)
- `maps/config/resolved.js` → new resolver/provider (see API below)
- `maps/config/tunables.js` → transition shim: read from `resolved.js`
- `maps/config/entry.js` → optional helper to bootstrap entries with minimal boilerplate

---

## 5) Resolved API Sketch (Read-Oriented)

- Lifecycle
  - `initialize({ defaults, presets[] })` — called at module import with known defaults/presets (or lazy-register).
  - `refresh()` — rebuilds snapshot using current `runtime.getConfig()` and registered defaults/presets.
  - Internals: hold frozen `SNAPSHOT` object; getters read from it.

- Accessors (examples; names can align with existing usage)
  - `getSnapshot()` → full frozen object (debugging/dev)
  - `getToggles()` → `{ STORY_ENABLE_* ... }`
  - `getGroup(name)` → generic (e.g., `"landmass"`, `"worldModel"`, `"corridors"`, etc.)
  - Named helpers:
    - `LANDMASS_CFG()`, `COASTLINES_CFG()`, `CLIMATE_BASELINE_CFG()`, `CLIMATE_REFINE_CFG()`, `WORLDMODEL_CFG()`, `WORLDMODEL_DIRECTIONALITY()`, `CORRIDORS_CFG()`, `PLACEMENT_CFG()`, etc.
  - Dev config:
    - `DEV_LOG_CFG()` → dev logger flags read at runtime

- Guarantees
  - Consumers get current run’s resolved config (not import-time snapshots).
  - Frozen returns to avoid accidental mutation.

---

## 6) Entry Boilerplate: Minimal Patterns

### Pattern A — Bootstrap Helper (recommended)

- Entry file does only:
  - Choose presets by name
  - Provide overrides
  - Call a bootstrap function (sets runtime, imports orchestrator)

- Example (pseudocode):
  - `import { bootstrap } from "./config/entry.js";`
  - `bootstrap({ presets: ["classic", "temperate"], overrides: { toggles: {...}, worldModel: {...} } });`

- Behavior:
  - `bootstrap` composes an inline config object (presets + overrides), calls `runtime.setConfig`, then loads the orchestrator once.
  - No need to remember multiple imports in entries.

### Pattern B — Explicit Composition (supported)

- For advanced cases, entries can import preset objects and compose:
  - `import { setConfig } from "./config/runtime.js";`
  - `import { TEMPERATE_PRESET } from "./config/presets/temperate.js";`
  - `setConfig({ ...TEMPERATE_PRESET, ...{ overrides here } });`
  - `import "./map_orchestrator.js";`

- Decision: Adopt Pattern A (explicit bootstrap + explicit orchestrator import) as the standard entry pattern. Pattern B (“one import”) remains documented but deferred. Rationale: explicit import ordering is robust on the game VM today; moving to a single import safely would require making all config reads lazy and resolving at runtime (GenerateMap), which we may revisit later.

---

## 7) Orchestrator Hook-Up

- Start of `generateMap()`:
  - Call `resolved.refresh()` once.
  - Replace any direct `getConfig()` usages with reads from `resolved` (e.g., toggles, geometry).
- Layers and WorldModel:
  - Migrate imports from `config/tunables.js` to `config/resolved.js` (or to the shim initially).
  - Ensure they call functions/getters (not static consts) so they always see the refreshed snapshot.

---

## 8) Dev Logger Alignment

- `dev.js` should read dev flags from `resolved.DEV_LOG_CFG()` once at the beginning of a generation (or reactively allow live toggles in dev mode).
- Default dev flags live in `defaults/base.js` under `dev` group; presets/overrides can change them per entry.
- For release builds, we can set dev flags off in defaults and keep per-entry overrides minimal.

---

## 9) Migration Plan (Incremental)

Phase 0 — Prepare — COMPLETED
- Added `defaults/base.js` and initial `presets/*` (`classic`, `temperate`).
- Added `resolved.js` with deep-merge and deep-freeze; no compatibility shim.
- Rewired `tunables.js` to resolved getters; snapshot refresh occurs at import.

Phase 1 — Switch Orchestrator — COMPLETED
- Orchestrator now reads toggles and geometry via `config/tunables.js` (backed by `resolved.js`).
- Entries use presets via `runtime.setConfig({ presets: [...] })` (`classic`, `temperate`).
- Removed experimental/legacy modules; pruned unused imports; removed orphaned localization row.
- Fixed `deepFreeze` to be non-mutating and safe with frozen inputs.

Phase 2 — Align Dev Logger with Resolved Config (NEXT)
- Read dev flags from `resolved.DEV_LOG_CFG()` at generation start.
- Keep defaults quiet; allow per-entry/preset overrides.

Phase 3 — Defaults Consolidation (NEXT)
- Move literal defaults from `map_config.js` into `defaults/base.js`.
- Retire `map_config.js` or make it a thin passthrough to `BASE_CONFIG`.
- Update docs to reference `defaults/base.js` as the canonical source.

Phase 4 — Entry Bootstrap Helper (NEXT)
- Add `config/entry.js` with `bootstrap({ presets, overrides })` to further reduce entry boilerplate.
- Migrate entries to the helper; keep manual composition supported.

Phase 5 — Cleanup and Docs (NEXT)
- Verify all consumers rely on resolved config; remove any remaining scattered defaults.
- Update DESIGN.md with Layer Contracts and call out resolved config as the source of truth.

---

## 10) Risks and Mitigations

- Risk: Partial migration leads to mixed sources (resolved vs static).
  - Mitigation: Transition shim in `tunables.js` and an acceptance gate to confirm all consumers read from resolved.

- Risk: Entry config timing vs import timing (import-time snapshots).
  - Mitigation: Ensure every consumer uses functions/getters and orchestrator calls `refresh()` per run.

- Risk: Merge ambiguity (arrays/objects).
  - Mitigation: Keep merge rules simple; document array replacement semantics; test representative overrides.

---

## 11) Acceptance Criteria

- Each map entry can define/compose its configuration strictly from defaults/presets plus inline overrides.
- All toggles/tunables observed by orchestrator, layers, story, and WorldModel match the entry’s resolved config.
- No implicit or scattered defaults remain; they live in `defaults/base.js` (and documented presets).
- Dev logger flags honor per-entry resolved dev config.

---

## 12) Work Breakdown (Estimates: S/M/L)

- Create `defaults/base.js` and 2–3 presets (S)
- Add `resolved.js` with merge/refresh and read APIs (M)
- Update `tunables.js` to a shim (S)
- Orchestrator: call `refresh()`; switch reads to resolved (S)
- Layers/Story/WorldModel: import getters (M)
- Add `entry.js` bootstrap and migrate `temperate` entry (S)
- Remove legacy static bits in `tunables.js`; update docs (S)
- Validation: smoke test per-pass logs + quick histograms (S)
- Final cleanup and enable plan docs in DESIGN.md (S)

---

## 13) Open Questions

- Do we want arrays to merge (concat/dedup) or replace? Proposal: replace for predictability; add a helper for advanced merging later if needed.
- Should `resolved.js` also offer a minimal schema validation (dev only)? Optional; can add warnings in dev mode if keys are misspelled.
- Long-term: fold `runtime.setConfig` into a re-export in `resolved.js` to remove one import from entries (further reducing boilerplate).

---
</file>

<file path="_archive/plugin-mapgen-archives/diagnostic-fix.md">
# Epic Diverse Map Generator — Diagnostic Guide (v1.0.0)

Scope
- This guide helps diagnose issues where the game crashes or returns to menu after map generation.
- It reflects the current v1.0.0 design: no aggressive cliff systems, mountains/lakes primarily from base generators, and slightly increased natural wonders (+1 vs. map defaults).

Summary
- In v1.0.0, generation relies heavily on the base systems for elevation/hills/lakes/wonders/resources/biomes and then applies gentle climate/biome refinements.
- Most failures observed in practice are due to configuration mismatches, mod conflicts, or environment issues—not the terrain algorithms themselves.

Common Symptoms
- Generation logs report successful terrain/feature/biome passes, but the game exits or returns to the setup screen after “Generate Map.”
- Starts are assigned, but the session fails to launch.
- No obvious JavaScript errors appear in logs, or errors are unrelated to generation passes.

Quick Checklist (Do These First)
1) Run on Huge map size (this mapgen is tuned for Huge).
2) Disable other heavy map or terrain mods temporarily.
3) Reduce player count and/or city-state count to verify capacity.
4) Restart the game after enabling/disabling mods.
5) Confirm the mod is in the user mods directory.

Map Configuration Verification
The script expects certain fields from the map database entry. Ensure your map row provides these (names must match the game’s schema). In particular, v1.0.0 reads:
- NumNaturalWonders (baseline; script adds +1 at runtime)
- LakeGenerationFrequency
- PlayersLandmass1, PlayersLandmass2
- StartSectorRows, StartSectorCols (if applicable in your build)

Example map row (adjust attributes as appropriate for your build):
<Maps>
  <Row
    File="{epic-diverse-huge-map}maps/epic-diverse-huge.js"
    Name="LOC_MAP_EPIC_DIVERSE_HUGE_NAME"
    Description="LOC_MAP_EPIC_DIVERSE_HUGE_DESCRIPTION"
    SortIndex="100"
    DefaultSize="5"
    MinSize="3"
    MaxSize="6"
    LakeGenerationFrequency="30"
    NumNaturalWonders="10"
    PlayersLandmass1="6"
    PlayersLandmass2="6"
    StartSectorRows="3"
    StartSectorCols="4"
  />
</Maps>

Notes:
- The script sets iNumNaturalWonders = max(mapInfo.NumNaturalWonders + 1, mapInfo.NumNaturalWonders).
- LakeGenerationFrequency is consumed by the base generator; v1.0.0 uses moderated lakes.
- PlayersLandmass1/PlayersLandmass2 and sector rows/cols should be consistent with the target player count.

Start Placement Constraints
- If you request more players than the configured landmasses/start sectors support, start assignment can fail in non-obvious ways.
- For a quick sanity check:
  - Try 6–8 players on Huge first.
  - Avoid additional map scripts that override start placement simultaneously.
  - Confirm human-player-near-equator logic is allowed by your settings.

Base Module Availability
- This script imports core/base “standard” generation modules at runtime (elevation, rainfall base map, biomes, resources, wonders, snow, etc.).
- Ensure the base modules referenced by the imports are available and loaded in your environment.
- If a base module path is incorrect or the module is disabled, generation may appear to succeed but fail later.

Monitoring and Logs
- The map script prints clear phase markers (e.g., “Building enhanced rainfall patterns...”, “Creating enhanced biome diversity...”, “Adding diverse terrain features...”).
- Optional JSON start/complete logs (commented out by default) can make troubleshooting easier:
  - Search for EPIC_MAP_GEN_START and EPIC_MAP_GEN_COMPLETE in the script and uncomment the console.log blocks.
  - Use the included Python monitor script (external_map_monitor.py) to tail and summarize.
- If these events log successfully yet a crash occurs afterward, the issue is most likely outside the terrain/feature passes (e.g., configuration, content conflicts, or post-gen initialization).

Minimal Repro Steps (to isolate mod conflicts)
1) Enable only Epic Diverse Huge and core/base modules. Disable other map/terrain-altering mods.
2) Use Huge size, 6–8 players, standard speed.
3) Try a few different seeds (or default/random) to rule out seed-specific anomalies.
4) If stable, re-enable additional mods incrementally to identify conflicts.

Environment Considerations
- Memory/CPU pressure can surface on large scripts/maps with many concurrent mods. If you suspect resource issues:
  - Close background apps.
  - Temporarily reduce the number of AI players or city-states.
  - Keep island/coastline-heavy mods disabled while testing.

What Not To Change (v1.0.0)
- Do not re-enable aggressive cliff systems or add heavy global mountain amplification; these were intentionally removed for stability and playability.
- Avoid large global multipliers for lakes or rivers; v1.0.0 is tuned around base behavior plus climate/biome refinements.

If Problems Persist
- Verify the exact attributes your build expects in the map database row; some builds gate certain fields differently.
- Test a vanilla map type to confirm your base environment is stable.
- Re-check the mod load order and make sure there aren’t duplicate map type names clashing with other mods.
- Collect the log segment from map generation through to the failure point; include the visible phase markers and any subsequent errors when asking for help.

Expected v1.0.0 Behavior (for reference)
- Landmasses: three organic continental bands with true oceans.
- Coasts/Islands: lightly ruggedized coasts; small deep-water island clusters that preserve sea lanes.
- Climate: base rainfall blended with latitude bands, then refined with coastal/lake humidity, prevailing-wind orographic shadows, river-corridor greening, and low-basin wetness.
- Biomes/Features: base pass + gentle nudges toward tropical coasts (near equator, wet), temperate river grasslands, and restrained tundra; validated feature density increases for rainforest/forest/taiga.
- Wonders: +1 vs. map defaults.
- Lakes: moderated (not “tripled”).
- Starts: chosen with the compatible standard method.

Contact/Next Steps
- If you share logs, include:
  - Map size and player count
  - The relevant console markers (phase messages, optional JSON start/complete if enabled)
  - Any errors after “Generate Map” completes
- We can then correlate failures with config, environment, or post-gen steps and suggest precise fixes.
</file>

<file path="_archive/plugin-mapgen-archives/earth-forces-and-layer-contracts.md">
# TEMP PLAN — Earth Forces and Layer Contracts

Owner: Map Systems
Status: Draft (temporary planning document)
Scope: v1.2+ exploration (low-risk phased rollout); no heavy simulation

1) Purpose

Define:
- Clear layer contracts (inputs/outputs/order) for the current pipeline so dependencies remain explicit and maintainable.
- A phased, lightweight “Earth Forces” foundation (WorldModel) that precomputes coherent global fields (plates, winds, currents, pressure) to drive tagging, climate, and corridor selection in a controlled way without heavy simulation or breaking vanilla compatibility.

2) Snapshot — Current Pipeline and Dependencies

Orchestrated order (maps/epic-diverse-huge.js):
1. Start Sectors
   - chooseStartSectors → start-sector grid for later placement.
   - Outputs: sector grid and optional equatorial bias for human.
   - Reads: map size (mapInfo), globals, utilities.

2. Landmass
   - createDiverseLandmasses → 3-band continents with jitter/curvature.
   - Outputs: initial land/water mask.
   - Reads: globals (seams/polar/ocean), size.

3. Coasts + Margins
   - expandCoasts (base)
   - storyTagContinentalMargins → tags: StoryTags.activeMargin, StoryTags.passiveShelf.
   - addRuggedCoasts → margin-aware bay/fjord shaping.
   - Outputs: refined coasts; margin tags consumed downstream.
   - Reads: coastal tiles; StoryTags.activeMargin/passiveShelf.

4. Climate Story (pre-Islands tags)
   - storyTagHotspotTrails → tags: hotspot.
   - storyTagRiftValleys → tags: riftLine, riftShoulder.
   - storyTagOrogenyBelts → tags: mountain belts, windward/lee cache.
   - storyTagContinentalMargins (re-run for consumers)
   - Outputs: sparsely tagged motifs used by islands/refinement/biomes.
   - Reads: elevation, latitude, water mask.

5. Strategic Corridors (pre-Islands)
   - storyTagStrategicCorridors("preIslands") → sea lanes, island‑hop, land‑open; assigns kind/style.
   - Outputs: StoryTags.corridorSeaLane/IslandHop/LandOpen + style metadata.
   - Reads: water mask, coasts, hotspots, rift shoulders.

6. Islands
   - addIslandChains → respects sea-lane avoidance and margins; hotspot‑biased.
   - Outputs: small offshore islands; hotspot paradise/volcanic tagging for features/climate.

7. Elevation + Water (base)
   - addMountains, addVolcanoes, generateLakes, addHills, buildElevation.
   - Outputs: elevation terrain finalized.

8. Climate A (baseline)
   - buildEnhancedRainfall → band-blended rainfall with local coastal/orographic bonuses and noise.

9. Swatches + Paleo
   - storyTagClimateSwatches → one macro swatch with soft edges; optionally runs Paleo humidity overlays (deltas/oxbows/fossil channels).

10. Rivers (base)
   - modelRivers / validate / defineNamedRivers.

11. Strategic Corridors (post-Rivers)
   - storyTagStrategicCorridors("postRivers") → river chains + style metadata.

12. Climate B (earthlike refinement)
   - refineRainfallEarthlike → water gradient, upwind barrier dryness, river corridor greening, rift humidity, orogeny windward/lee, hotspot microclimates.
   - Requires: rivers, rifts, orogeny, hotspots.

13. Biomes (nudges)
   - designateEnhancedBiomes → tundra restraint; tropical coasts; river valleys grassland; rift shoulder bias; corridor land/river style-aware nudges.
   - Reads: rainfall, tags (rifts/corridors), latitude, elevation.

14. Features (validated)
   - addDiverseFeatures → paradise reefs and passive shelf reefs; volcanic vegetation; density tweaks (rainforest/forest/taiga).
   - Reads: StoryTags.hotspotParadise/Volcanic, margins.

15. Placement
   - runPlacement → wonders +1, floodplains, snow, resources, discoveries, starts, fertility.
   - Reads: start sectors, landmass windows; recalculates areas/water data.

3) Layer Contracts — Summary

Notation:
- Inputs: data read (engine surfaces, StoryTags, world fields).
- Outputs: data written (engine surfaces, StoryTags).
- Order: must run after/before.

A) Landmass (layers/landmass.js)
- Inputs: map size, globals.
- Outputs: initial land/water tiles.
- Order: first terrain stage; before coasts/margins.
- Consumers: all downstream layers read land/water.

B) Margins (story/tagging.js: storyTagContinentalMargins)
- Inputs: coastal land/water.
- Outputs: StoryTags.activeMargin, StoryTags.passiveShelf.
- Order: after expandCoasts; before rugged coasts/islands.
- Consumers: coasts/islands/features.

C) Coasts (layers/coastlines.js)
- Inputs: StoryTags.activeMargin/passiveShelf; corridor sea-lane policy (soft/hard).
- Outputs: bay/fjord coast edits (conservative).
- Order: after margins; before islands.

D) Climate Story: Hotspots/Rifts/Orogeny (story/tagging.js)
- Inputs: elevation, water, latitude.
- Outputs: sparse tags: hotspot/riftLine/riftShoulder/orogeny windward/lee.
- Order: before islands (hotspot bias); before climate refinement.

E) Strategic Corridors (story/corridors.js)
- Inputs: water/coasts/hotspots/rift shoulders/rivers (post-rivers).
- Outputs: StoryTags.corridor* sets; style metadata; dev logs.
- Order: sea/land/islandHop pre-Islands; river post-Rivers.
- Consumers: coasts (policy & edge effects), islands (avoid lanes), biomes (corridor style nudges).

F) Islands (layers/islands.js)
- Inputs: StoryTags.hotspot; StoryTags.corridorSeaLane; margins.
- Outputs: island tiles; hotspot paradise/volcanic tags.
- Order: after corridors pre-Islands.

G) Climate Baseline (layers/climate-baseline.js)
- Inputs: latitude bands, elevation/coast adjacency.
- Outputs: rainfall base field.
- Order: before rivers and refinement.

H) Swatches & Paleo (story/tagging.js)
- Inputs: rainfall/latitude/elevation; optional orogeny cache (for mountainForests).
- Outputs: rainfall deltas; optional paleo overlays.
- Order: after baseline, before rivers for blended effect.

I) Rivers (engine)
- Inputs: rainfall/elevation.
- Outputs: river network; named rivers.
- Order: before refinement and post-rivers corridors.

J) Climate Refinement (layers/climate-refinement.js)
- Inputs: rivers; StoryTags (rifts, orogeny windward/lee, hotspots); coastal distances; elevation; latitude.
- Outputs: rainfall deltas per refinement passes; clamped [0,200].
- Order: after rivers.

K) Biomes (layers/biomes.js)
- Inputs: rainfall/elevation/latitude; StoryTags (rift shoulders, corridors with kinds/styles).
- Outputs: biome types (nudges only; base-compatible).
- Order: after refinement and corridors tagging.

L) Features (layers/features.js)
- Inputs: biomes/terrain/water; StoryTags (hotspot paradise/volcanic, margins).
- Outputs: validated features (reefs/forests/taiga/jungle tweaks).
- Order: after biomes.

M) Placement (layers/placement.js)
- Inputs: finalized terrain/biomes/features; mapInfo; start sectors.
- Outputs: wonders/resources/discoveries/starts etc.
- Order: last.

4) Gaps and Improvements in Dependency Clarity

- Today’s clarity comes mainly from ordering in epic-diverse-huge.js and local comments; add “Layer Contracts” to DESIGN.md with Inputs/Outputs/Order for each layer (A–M).
- Tag lifecycle: state that StoryTags are cleared/reset at key points and listing who writes/reads each set (including corridor style metadata).
- Climate refinement: document assumption “requires rivers, rifts, orogeny” explicitly in the contract.

5) Proposed Foundation — Earth Forces (WorldModel)

Objective: precompute lightweight global “world fields” for coherence, not heavy sim.
- Location: maps/world/model.js (new); exported singleton WorldModel.
- Fields (per-tile, sparse or dense arrays):
  1) Plates
     - plateId: Int16Array (Voronoi partition of N seed plates)
     - plateBoundaryStrength: Uint8Array (normalized distance to nearest plate boundary)
     - boundaryType: Uint8Array enum { convergent, divergent, transform }
     - tectonicStress, upliftPotential, riftPotential: Float32Array 0..1
     - shieldStability: Float32Array 0..1 (distance to plate interior)
  2) Mantle Pressure
     - pressure: Float32Array 0..1 (sum of a few Gaussian bumps + very-low-frequency noise aligned to plate vectors)
  3) Wind
     - windU, windV: Float32Array (zonal baseline + jet stream streaks + orographic perturbations)
  4) Ocean Currents (water tiles)
     - currentU, currentV: Float32Array (equatorial westward, western boundary, subpolar recirculation, basin gyres)

Config additions (map_config.js → worldModel):
- plates: { count, axisAngles[], convergenceMix, seedJitter, interiorSmooth }
- wind: { jetStreaks, jetStrength, variance, coriolisZonalScale }
- currents: { basinGyreCountMax, westernBoundaryBias, currentStrength }
- pressure: { bumps, amplitude, scale }

Insertion point:
- Phase 0: compute WorldModel after Landmass/ExpandCoasts (so basins/coasts exist); fields remain read-only to other layers initially.

6) How WorldModel Drives Existing Layers (Opt-in, No Heavy Changes)

Tagging
- Rifts: replace random rift seeding with paths along divergent plate boundaries (high riftPotential).
- Orogeny belts: draw belts where upliftPotential/tectonicStress are high (convergent boundaries).
- Margins: reinforce active/passive based on boundaryType for long coherent segments.

Climate
- Replace simple zonal winds in refinement: use local windU, windV to evaluate upwind barriers (cast rays along vectors).
- Water gradient: damp/boost humidity where warm/cold currents meet coasts (small deltas; clamped).

Coasts/Islands/Features
- Fjords/bays: bias slightly near convergent boundaries (steeper passive/active cues).
- Reef chance: bias along passive shelves with warm currents (coastal).
- Island chains: subtle bias along transform/divergent oceanic boundaries (corresponds to hotspot trails).

Corridors
- Sea-lane scoring adds a positive term for alignment with current vectors and for minimum channel width along flow.
- Land-open selection can prefer shield interiors (stable cores) or rift shoulders depending on style policy.

Landmass (optional, later)
- Small curvature/banding adjustments based on plate axes (guardrails to preserve true oceans and vanilla expectations).

7) Phased Plan

Phase A (Foundational Fields + Tagging/Wind Integration)
- Add WorldModel singleton and config (worldModel.*).
- Compute:
  - Voronoi plates & boundaryType, tectonicStress/uplift/riftPotential.
  - WindU/V: zonal + jet streams; simple orographic perturbation (base on upliftPotential).
- Wire consumers:
  - storyTagRiftValleys → follow divergent boundaries (limit to N segments; size-aware).
  - storyTagOrogenyBelts → use upliftPotential for belts; keep cache for windward/lee.
  - refineRainfallEarthlike → replace zonal dx with windU/V vector traversal in hasUpwindBarrier; keep same clamp and steps.
- Logs: plate counts, boundary length by type, wind magnitude histogram.

Phase B (Currents + Coastal Humidity/Sea-lane Scoring)
- Compute currentU/V (basin-wise + gyres; simple masks from land/water).
- Refinement: small coastal humidity bias using current direction/magnitude (warm vs cold heuristic).
- Coasts/Islands: slight fjord/bay bias near convergent boundaries; reef multiplier near warm passive shelves.
- Corridors: sea-lane candidate scoring adds a current-alignment term; spacing preserved.

Phase C (Pressure & Optional Terrain/Style Coupling)
- Compute mantle pressure; optionally bias hill density (very lightly).
- Style selection for land corridors: use avg elevation, rainfall, relief, and plate proximity to pick canyon/plateau/flatMtn/desert/grass styles (we already added heuristics; refine with WorldModel fields).
- Optional: tiny landmass curvature by plate axes (strict guardrails).

8) Risks and Mitigations

- Overstacking/overlap (motifs + corridors + swatches)
  - Mitigation: composition caps (diminishing returns) and per-layer policy strengths. Start with no stacking changes; add cap if we observe amplifications.
- Performance
  - Mitigation: O(width×height) computations with constant-time local checks; avoid flood fills; small fixed number of plates and jet streaks.
- Compatibility
  - Mitigation: no changes to engine APIs; optional, opt-in influences; rainfall strict clamp [0,200]; features validated; lanes preserved.

9) Acceptance Criteria (for Phase A/B)

- Rifts: long, coherent lines following plausible boundaries; shoulders remain narrow; no noisy zig-zag.
- Orogeny: windward/lee reflect belts produced from upliftPotential; rain shadow patterns remain believable and clamped.
- Winds: replacing zonal dx with windU/V yields similar or better coherence (no perf regressions).
- Currents (Phase B): subtle coastal humidity biases; no saturation; reefs gently concentrated near warm shelves; lanes do not choke.

10) Diagnostics and Dev Logging

- New logs:
  - WorldModel summary (plates count, boundary type lengths).
  - Wind/current magnitude histograms; optional quiver-like ASCII sampler.
- Existing:
  - StoryTags summary includes new rift/orogeny counts; corridor style distribution summary; ASCII overlay.

11) Layer Contracts — Minimal Doc Stub (to add to DESIGN.md)

For each layer (A–M above), include:
- Inputs (engine surfaces, StoryTags, WorldModel fields).
- Outputs (engine changes, StoryTags).
- Order constraints (runs-before, runs-after).
- Guardrails (O(W×H), clamps, validation).
- Example consumers (which layers read these outputs).

12) Open Questions / Decision Points

- Where to compute WorldModel precisely in the pipeline?
  - Option 1 (recommended): after Landmass/ExpandCoasts before Margins (so coasts/basins exist; tags will immediately benefit).
- Plate count and axes defaults per map size:
  - Suggest 6–10 plates on Huge; axisAngles randomized but with a seed.
- How strong should currents/winds modulate rainfall?
  - Start with tiny deltas (≤ ±6) and clamp; expose policy multipliers in config.
- Should islands favor transform/divergent oceanic boundaries more strongly?
  - Start with subtle bias; keep island size/spacing caps conservative.

13) Rollout Plan and Revert Strategy

- Implement Phase A behind a master toggle worldModel.enabled (default true for dev only; off for release until stabilized).
- Keep quick kill-switch; if regressions occur, disable influences while keeping WorldModel code paths inert.
- Maintain minimal diffs to existing layer signatures; use read-only world fields to avoid tight coupling.


— End of TEMP PLAN —
</file>

<file path="_archive/plugins-mapgen/climate-story/hotspot-trails-and-rift-valleys.md">
# Hotspot Trails and Rift Valleys — First Iteration (v0.1)

Status: Proposed
Layer: Climate Story (Narrative Imprint)
Targets: Huge maps (compatible with v1.0.0 pipeline and guardrails)

Summary
- This document specifies the first two narrative motifs to “imprint history” onto the map without heavy simulation:
  - Hotspot Trails (deep-ocean volcanic chains)
  - Rift Valleys (continental interior rifting with long lakes and greener shoulders)
- Both motifs are implemented as sparse “StoryTags” that bias existing passes (islands, climate refinements, biome nudges) without breaking compatibility or performance constraints.


1) Design Goals

- Readable Story Signals:
  - Hotspot Trails: aligned island/seamount chains with decaying activity.
  - Rift Valleys: linear lake chains, slightly greener shoulders, subtle humidity belt.
- Composable and Safe:
  - Use O(width × height) scans with small local radii (≤ 4).
  - Never reduce sea-lane widths below acceptance criteria.
  - Keep rainfall within [0, 200]; validate all features against engine rules.
- Compatibility-First:
  - Integrate with addIslandChains, refineRainfallEarthlike, and designateEnhancedBiomes.
  - Avoid altering base elevation generation or reintroducing aggressive cliffs/mountain amplification.


2) Shared Infrastructure

2.1 StoryTags data model (transient)
- Represent per-tile tags in small parallel 2D arrays or sparse sets of coordinates:
  - HOTSPOT_TRAIL: boolean or small int for strength/age index.
  - RIFT_LINE: boolean for the rift centerline.
  - RIFT_SHOULDER: boolean or small int (0..2) for lateral shoulder tiles near the line.
  - RIFT_LAKE_CANDIDATE: boolean (subset of RIFT_LINE positions).
- Optional sparse polyline representation for each motif for diagnostics and easier iteration.

2.2 Randomness and determinism
- Use the generator’s seed and derive stable sub-seeds per motif:
  - seed_hotspot, seed_rift
- This ensures reproducible placement conditioned on the global map seed.

2.3 Performance
- Construction of tags must be single-pass/sparse:
  - Hotspot Trails: pick a handful (≤ 3) of deep-ocean polylines; compute points via incremental stepping; write tags; done.
  - Rift Valleys: 1–2 lines per large continent; project a small number of tiles; done.
- Integration reads tags locally (e.g., in addIslandChains or refineRainfallEarthlike) without any global heavy work.


3) Motif A — Hotspot Trails

3.1 Narrative intent
- Emulate mantle hotspots forming linear chains of islands/seamounts moving with plate drift. The visual cue: a sparse, gently curving line of small islands across deep ocean, with spacing and decaying density along the chain.

3.2 Visual targets
- 2–3 trails on Huge.
- 3–6 island placements per trail, spaced generously, with 1–3 tile clusters at most.
- Avoid creating bridges or chokepoints. Keep lanes robust.

3.3 Tunables
- maxHotspotTrails (map): 3
- hotspotTrailLength (steps): 8–14
- hotspotTrailStep (tiles between points): 3–6
- hotspotTrailDecayStart: 0.4 (probability)
- hotspotTrailDecayRate: 0.8 per subsequent point (multiplicative)
- hotspotMinOceanDepth: deep-ocean requirement (implementation-defined check)
- hotspotMinDistanceFromLand: 3–4 tiles (to avoid coastal clutter)
- hotspotMinLaneWidth: maintain global acceptance width (no violations)
- hotspotClusterSizeRange: 1–3 tiles
- hotspotMinTrailSeparation: 10–14 tiles (avoid parallel clutter)

3.4 Generation algorithm (tagging)
- Choose N ∈ [1..maxHotspotTrails] deep-ocean seeds far from land and each other (respect hotspotMinTrailSeparation).
- For each trail:
  - Pick a heading (theta) and a small bend factor based on low-frequency noise evaluated along the path to simulate plate drift.
  - March hotspotTrailLength steps:
    - Advance by hotspotTrailStep in the current heading.
    - Evaluate probability p = hotspotTrailDecayStart × (hotspotTrailDecayRate^stepIndex).
    - If within deep-ocean and far from land, mark HOTSPOT_TRAIL at this point with strength ∝ p.
- Notes:
  - Store the polyline points for diagnostics (optional).
  - Do not place islands here—only tag, to be consumed by island pass.

3.5 Integration points
- addIslandChains:
  - When evaluating potential deep-ocean island placement, bias probability if HOTSPOT_TRAIL is set:
    - islandChance += f(strength) where strength comes from the trail step probability.
  - Enforce spacing and lane width; hard-cap total island count per trail.
  - Cluster size: use existing cluster logic but restrict to hotspotClusterSizeRange for trail points.
- refineRainfallEarthlike:
  - Optional tiny fertility signal:
    - Near HOTSPOT_TRAIL tiles, apply volcanicFertilityBoost (+5..+10) to rainfall within radius ≤ 2 if elevation is moderate/low and still clamped.
  - Keep off by default for first iteration if risk of over-stacking with coastal humidity is high.
- designateEnhancedBiomes:
  - If volcanic fertility boost is enabled:
    - For tiles near HOTSPOT_TRAIL and with sufficient rainfall, prefer lusher variants (forest/tropical) as gentle nudges.

3.6 Guardrails
- Never reduce lane widths below hotspotMinLaneWidth.
- Keep all rainfall adjustments clamped [0, 200].
- Keep total hotspot islands small; cap per trail and globally.
- Respect minDistanceFromStarts for intrusive changes (rarely needed for deep ocean but retain).

3.7 Diagnostics and validation
- Logs:
  - “Drawing hotspot trails…” with count and per-trail length.
- Optional overlay dumps:
  - HOTSPOT_TRAIL polyline points and island placements.
- Acceptance checklist:
  - Lanes unchanged in width; islands align on trails; density is sparse.
  - No accidental coastal clutter; trails read as single clean lines.


4) Motif B — Rift Valleys

4.1 Narrative intent
- Emulate continental rifting: linear lakes, slightly greener shoulders, and a subtle humidity corridor. Optional continuation to coastlines in later phases.

4.2 Visual targets
- 1–2 rift lines per large continent (or zero for small fragments).
- 6–10 total lake tiles per continent (distributed across 1–3 lake chains).
- Visible greener shoulders adjacent to rift without overriding base biomes.

4.3 Tunables
- maxRiftLinesPerContinent: 2
- riftMinContinentArea: threshold to qualify for rift consideration
- riftLineLength (steps): 12–24 (scaled with continent size)
- riftStep (tiles between points): 2–3
- riftLakeDensity: 0.15–0.25 chance for a line tile to become lake (if lowland)
- riftMaxLakeTilesPerContinent: 8–12
- riftHumidityBoost: +5..+12 (clamped; applied near line)
- riftHumidityRadius: 1–2
- riftShoulderWidth: 1–2 tiles on each side (derive via perpendicular projection)
- riftShoulderBiomePreference:
  - Temperate: grassland > plains when rainfall allows
  - Tropical: forest/jungle if wet enough (validated)
- riftMinDistanceFromStarts: 8–10 (avoid carving lakes next to starts)
- riftMinSeparation: 12 tiles between parallel rifts

4.4 Generation algorithm (tagging and lake carving)
- For each continent meeting riftMinContinentArea:
  - Choose R ∈ [0..maxRiftLinesPerContinent] rift seeds with long span potential, avoiding mountains and high elevations if possible.
  - For each rift:
    - March riftLineLength steps with low curvature (long linear feel). Step size riftStep.
    - Tag RIFT_LINE along the path.
    - Determine lateral RIFT_SHOULDER tiles by projecting perpendicular offsets up to riftShoulderWidth on both sides (in-bounds, land-only).
    - If a RIFT_LINE tile is lowland, sufficiently far from starts (≥ riftMinDistanceFromStarts), and riftLake budget remains:
      - With probability riftLakeDensity, convert to a 1–2 tile lake micro-cluster (if valid).
      - Tag these converted tiles for diagnostics (RIFT_LAKE_CANDIDATE).
  - Stop carving when riftMaxLakeTilesPerContinent is reached.

4.5 Integration points
- buildEnhancedRainfall (no change):
  - Keep baseline intact for band blending.
- refineRainfallEarthlike (after rivers):
  - For tiles at distance d ≤ riftHumidityRadius from RIFT_LINE:
    - rainfall += scaled(riftHumidityBoost, by elevation: stronger at low elevation)
    - Clamp to [0, 200].
- designateEnhancedBiomes:
  - For RIFT_SHOULDER tiles:
    - If rainfall permits, bias toward grassland/forest in temperate zones.
    - In tropical zones, gentle increase toward forest/rainforest probabilities when wet enough.
  - Always leave base biome eligibility in control; this is a preference, not an override.
- addDiverseFeatures:
  - No special additions in v0.1. Optionally, allow slightly higher forest density on shoulders (validated) in later iterations.

4.6 Guardrails
- Lake conversions:
  - Only in lowland; respect adjacency and not near starts; avoid excessive clustering.
- Humidity stacking:
  - Rift boost is small; clamps applied per-application.
  - Avoid compounding with multiple motifs by either capping cumulative boosts or applying diminishing returns when a tile has multiple StoryTags.
- Performance:
  - Tagging is linear and sparse; shoulder calculation uses fixed small offsets.
- Visual restraint:
  - Hard caps on lake tiles and number of rift lines per continent.

4.7 Diagnostics and validation
- Logs:
  - “Marking rift lines and basins…” with per-continent counts and lake tile totals.
- Optional overlay dumps:
  - RIFT_LINE polyline, RIFT_LAKE_CANDIDATE tiles, RIFT_SHOULDER bands.
- Acceptance checklist:
  - Lake chains appear in long valleys, not peppered randomly.
  - Shoulder greening visible but modest; biome transitions remain believable.
  - Starts remain fair; no accidental excessive freshwater near spawns.


5) Pipeline Placement

- After landmasses and coasts exist, before Climate Phase A:
  - Compute StoryTags for HOTSPOT_TRAIL and RIFT_LINE/SHOULDER.
- In addIslandChains:
  - Read HOTSPOT_TRAIL to bias deep-ocean island placement with strict spacing and lane safeguards.
- In refineRainfallEarthlike (Phase B, after rivers):
  - Apply riftHumidityBoost around RIFT_LINE (radius ≤ 2).
  - Optionally apply volcanicFertilityBoost around HOTSPOT_TRAIL (off by default for v0.1).
- In designateEnhancedBiomes:
  - Apply shoulder biome preferences (temperate grassland corridors, tropical forest bias when appropriate).
- Optional later:
  - Reef chances along passive shelves (not part of this doc).
  - Orogeny amplifiers (windward/lee)—defined in Climate Story README, separate doc.


6) Logging and Telemetry

- Phase messages:
  - “Drawing hotspot trails…”
  - “Marking rift lines and basins…”
- Suggested per-motif summaries:
  - Trails: count, average length, total tagged points, islands realized.
  - Rifts: per-continent count, lake tiles placed, humidity boost stats (mean/95th).
- Optional JSON events:
  - STORY_HOTSPOTS_BEGIN/END, STORY_RIFTS_BEGIN/END with counts and seeds for reproducibility.

- Temporary dump toggles (dev only):
  - dumpStoryHotspots(), dumpStoryRifts()
  - Visualize overlays and save compact logs for quick scouting against outputs/1.0.0.


7) QA and Acceptance

- Oceans:
  - Lanes must remain open; hotspot islands cannot chain into bridges.
- Interiors:
  - Rift lake chains align along long axes; shoulder greening visible but not dominant.
- Rainfall:
  - All boosts are clamped; histograms stay close to v1.0.0 with small local deviations.
- Biomes:
  - Temperate river corridors + rift shoulders yield plausible grassland/forest transitions.
  - No tundra regression; tropical regions remain consistent where rainfall allows.
- Starts and Balance:
  - No lakes or heavy fertility adjacent to starts (respect min distances).
  - Wonders/resources remain base-driven; this layer is cosmetic/low-impact mechanically.


8) Risks and Mitigations

- Sea-lane narrowing due to hotspot islands:
  - Enforce hotspotMinLaneWidth; skip placement if violation detected.
- Over-greening from multiple small boosts stacking:
  - Apply diminishing returns when multiple StoryTags apply to the same tile (e.g., cap net boost or halve the second boost).
- Visual clutter:
  - Hard caps, minimum separations, and favor long clean lines over dense dots.
- Performance spikes:
  - Keep all scans radius ≤ 4; prefer direct addressing and early exits in neighborhood checks.


9) Implementation Checklist (v0.1)

- StoryTags scaffolding:
  - Arrays or sparse sets for HOTSPOT_TRAIL, RIFT_LINE, RIFT_SHOULDER, RIFT_LAKE_CANDIDATE.
- Hotspot Trails:
  - Deep-ocean seed selection with separation.
  - Polyline stepping with decaying strength tagging.
  - addIslandChains bias integration with spacing and lane-width guards.
- Rift Valleys:
  - Per-continent qualification; seed and step rift lines; tag shoulders.
  - Lake carving in lowlands with per-continent budget and start-distance guard.
  - refineRainfallEarthlike: apply riftHumidityBoost near RIFT_LINE (radius ≤ 2, clamped).
  - designateEnhancedBiomes: shoulder preferences contingent on rainfall/latitude.
- Logging + optional dumps:
  - Phase messages and minimal stats per motif.
- Update docs:
  - Climate Story README: note v0.1 motifs enabled and tunables.


10) Default Tunables (suggested starting values)

- Hotspot Trails:
  - maxHotspotTrails: 3
  - hotspotTrailLength: 10
  - hotspotTrailStep: 4
  - hotspotTrailDecayStart: 0.5
  - hotspotTrailDecayRate: 0.85
  - hotspotMinOceanDepth: engine-defined “deep ocean” check
  - hotspotMinDistanceFromLand: 4
  - hotspotClusterSizeRange: 1..2
  - hotspotMinTrailSeparation: 12
  - hotspotMinLaneWidth: use current acceptance lane width

- Rift Valleys:
  - maxRiftLinesPerContinent: 2
  - riftMinContinentArea: tuned for Huge; e.g., ≥ 4% of map tiles
  - riftLineLength: 18
  - riftStep: 2
  - riftLakeDensity: 0.2
  - riftMaxLakeTilesPerContinent: 10
  - riftHumidityBoost: +8
  - riftHumidityRadius: 2
  - riftShoulderWidth: 1
  - riftMinDistanceFromStarts: 8
  - riftMinSeparation: 12


11) Future Extensions (beyond v0.1)

- Hotspot fertility coupling: enable small rainfall boosts near trails by default after validation.
- Rift-coast tie-in: extend select rifts to nearby coastlines with subtle estuary/delta motifs (guard lanes).
- Passive/active margin system and reef belts (separate doc).
- Orogenic belt amplifiers (windward/lee) layered with the rainfall refinement logic.
- Diagnostics: seed snapshot export, per-motif tile counts to CSV, rainfall histograms.


12) Change Log

- v0.1 (proposed):
  - Added Hotspot Trails and Rift Valleys motif specifications, tunables, integration points, guardrails, and QA guidance for first iteration.

— End of Hotspot Trails and Rift Valleys v0.1 —
</file>

<file path="_archive/plugins-mapgen/climate-story/overview.md">
# Climate Story — Narrative Imprint Layer (v1.0.0+ concept)

Status Snapshot (v1.1.0 — current code)
Implemented
- Active vs. Passive Margins (coast ruggedizing + shelf reefs; lane-safe)
- Hotspot Trails (deep-ocean trails; hotspot-aware islands; paradise/volcanic microclimates)
- Rift Valleys (rift line + shoulders; narrow rainfall boost; shoulder biome bias)
- Orogenic Belts (windward/lee flanks; rainfall amplification; coupled mountainForests swatch)
- Climate Swatches (one weighted macro swatch; soft edges)
- Paleo‑Hydrology (initial overlays: deltas/oxbows/fossil channels; rainfall only)

Pending
- Glacial Fingerprints (fjord bias at high latitudes; kettle lakes; taiga emphasis)
- Volcanic Fertility (explicit volcanic arc tagging and biome/rainfall coupling)


Purpose
- Add legible “signs of history” to maps without heavy simulation.
- Evoke tectonics, volcanism, paleo‑rivers, glaciation, and continental margins through sparse, data‑coupled motifs.
- Preserve vanilla compatibility, balance, and all v1.0.0 guardrails.

Scope
- This directory houses the Climate Story design notes and iterations.
- Start with lightweight tagging (“StoryTags”) and small, composable nudges in existing passes.
- Keep everything O(width × height) with tiny radii and strict clamps.

Contents
- README.md (this doc): concept, motifs, integration points, guardrails, first‑iteration plan.
- Future: split into focused docs per motif as we iterate (e.g., HotspotTrails.md, RiftValleys.md).


## 1) Design Principles

- Tell history with sparse, readable signals:
  - Long arcs, aligned chains, linear basins, deltas, fjords—few, but legible.
- Nudge, don’t overwrite:
  - Use existing knobs: coast/island shape, rainfall biases, biome/feature preferences.
  - No large elevation edits, no cliff/mountain spam.
- Compatibility-first:
  - Respect base systems; validate feature placement; avoid hardcoding IDs.
- Performance:
  - Single-pass tagging + small local scans (radius ≤ 4).
  - No flood fills or global heavy ops.
- Safety:
  - Rainfall clamped to [0, 200].
  - Preserve robust sea lanes; avoid chokepoints.
  - Hard caps per motif per map/continent; minimum distances between motifs and from starts.


## 2) StoryTags (lightweight data model)

Represent “imprints” as transient per‑tile tags and sparse polylines/areas that other passes consult. Suggested tags:

- ACTIVE_MARGIN, PASSIVE_SHELF
- HOTSPOT_TRAIL
- RIFT_LINE
- OROGENY_BELT (collision/suture corridor)
- FOSSIL_CHANNEL
- DELTA_FAN, OXBOW_CANDIDATE
- GLACIAL_ZONE, KETTLE_CHAIN
- VOLCANIC_ARC

Implementation note
- Tags can be kept in simple 2D arrays parallel to the map or as lists of sparse coordinates/segments.
- They are inputs to: coast/island shaping, rainfall refinement, biome nudges, feature density tweaks.
- Tags are ephemeral—only used during generation; nothing persists beyond map creation.


## 3) Motifs (what to imprint and how)

Each motif includes: the real‑world story, a light encoding strategy, and where to integrate it in the pipeline.

3.1 Active vs. Passive Margins (continental coast story)
- Story: One side of a continent is trenchy with island arcs (active), the other has a broad continental shelf (passive).
- Encode:
  - Classify sparse coast segments per continent as ACTIVE_MARGIN or PASSIVE_SHELF (continent centroid + low‑freq noise + coastline length cap).
- Integrations:
  - Coast shaping: slightly more bays/fjords on active segments; slightly wider shallow shelf on passive segments in sparse ribbons.
  - Islands: aligned arc islands just seaward of active segments (low density, hard gaps).
  - Features: reefs/sandbars more probable on passive shelves (validate before placing).

3.2 Hotspot Trails (oceanic volcanism story)
- Story: Linear chains of seamounts/islands, decaying in size, sometimes with a gentle bend.
- Encode:
  - Seed 2–3 deep‑ocean trails as short polylines with decaying island probability.
- Integrations:
  - Island pass: bias cluster placement along these polylines; keep separation generous.

3.3 Rift Valleys and Inland Basins (continental interior story)
- Story: Linear rifts with long lakes; fertile shoulders; rifts that may reach offshore.
- Encode:
  - 1–2 rift polylines per large continent; carve very sparse, small lakes along the line if lowland; tag shoulder tiles.
- Integrations:
  - Rainfall: mild humidity boost along rift line (stronger at low elevation, clamped).
  - Biomes: prefer grassland/forest on shoulders if climate allows.

3.4 Orogenic Belts and Sutures (collision story)
- Story: Long mountain arcs; wetter windward forelands; drier leeward rain shadows; mixed suture textures.
- Encode:
  - Tag corridors that intersect existing mountain belts; don’t add mountains—just classify belt and sides (windward/lee by prevailing wind).
- Integrations:
  - Rainfall: slightly amplify existing orographic logic (more subtraction on lee, small boost on windward); narrow radius (≤ 3).
  - Biomes: steppe/brush in lee (if dry), greener forest/grass on windward sides (if wet).

3.5 Paleo‑Hydrology (river story across time)
- Story: Deltas at mouths, oxbow lakes near meanders, fossil channels across dry plains into basins.
- Encode:
  - After rivers: tag a few major mouths for DELTA_FAN; pick rare OXBOW_CANDIDATE near long lowland turns; draw short FOSSIL_CHANNEL segments toward enclosed basins.
- Integrations:
  - Terrain/features: tiny marsh/floodplain fans near mouths (validated); a couple of 1‑tile oxbow lakes; no rivers added for fossils.
  - Rainfall/biomes: small humidity/green bias along fossil channels (very sparse, clamped).

3.6 Glacial Fingerprints (high‑latitude/mountain story)
- Story: Fjords where ice carved coasts, kettle lakes in glaciated lowlands, taiga belts.
- Encode:
  - Tag GLACIAL_ZONE where latitude is high and elevation transitions are strong; mark KETTLE_CHAIN candidates in lowland pockets near mountains.
- Integrations:
  - Coast: increase fjord chance on glacial coasts (still sparse).
  - Terrain: a few 1‑tile kettle lakes scattered in flagged zones.
  - Biomes: prefer taiga over bare tundra when moisture permits.

3.7 Volcanic Fertility (time since eruption)
- Story: Young volcanic soils are fertile; nearby valleys are lush.
- Encode:
  - Tag VOLCANIC_ARC tiles around active margins/hotspot islands with moderate elevation.
- Integrations:
  - Rainfall: +5–10 local boost (clamped), radius ≤ 2.
  - Biomes: gentle preference for forest/tropical variants if climate supports them.


## 4) Integration Points (use existing passes)

Leverage the current pipeline; do not reorder major steps.

- Landmasses/coasts seeded → Tag StoryTags
  - After continents exist and before Climate Phase A:
    - Derive ACTIVE_MARGIN/PASSIVE_SHELF, HOTSPOT_TRAIL, RIFT_LINE, OROGENY_BELT, GLACIAL_ZONE.

- Coastline shaping (ruggedize) and island seeding
  - Read margin and trail tags to bias:
    - Bays/fjords (active/glacial segments), shelf widening (passive segments), arc/island alignment (active/hotspot).
  - Guard: never reduce sea lanes below accepted width.

- Climate Phase A (baseline + bands)
  - No major changes here; keep bands and light coastal bonuses.

- Rivers (base)
  - No changes; used as a prerequisite for paleo‑hydrology.

- Climate Phase B (earthlike refinement)
  - Read StoryTags to:
    - Slightly increase windward boosts and lee‑side drying within narrow belts.
    - Apply rift humidity, volcanic fertility, fossil‑channel green bias.
  - Always clamp to [0, 200].

- Biomes and Features
  - Biome nudges read StoryTags:
    - Rift shoulders → grassland/forest; lee belts → steppe/brush; volcanic arcs → lusher variants if rainfall permits; glacial zones → taiga preference over barren tundra where wet enough.
  - Features:
    - Reefs/sandbars on passive shelves; rainforest/forest/taiga chances adjusted in tagged belts; deltas/marshes/oxbows (always validated; lookup feature indices safely).


## 5) Tunables (initial set)

Global caps (per map, per continent)
- maxHotspotTrails (map): 3
- maxRiftLines (per large continent): 2
- maxRiftLakeTiles (per continent): 8–12
- maxArcIslandsPerActiveSegment: 6 (with spacing)
- maxDeltaFans (map): 4
- maxOxbowLakes (map): 6
- maxKettleLakes (map): 10

Intensity and radii
- riftHumidityBoost: +5 to +12 (clamped)
- volcanicFertilityBoost: +5 to +10 (clamped)
- fossilChannelHumidity: +3 to +8 (clamped; sparse)
- orogenyLeeDrynessAmplifier: 1.1–1.25× local subtraction (still clamped)
- windwardBoostAmplifier: +2 to +6
- beltRadius: 1–3 (narrow)
- distanceToWaterRadius: keep ~4 (unchanged baseline)

Placement heuristics
- minSeaLaneWidth: maintain current acceptance width (no shelf/arc change can violate this).
- minMotifSeparation: 8–12 tiles
- minDistanceFromStarts: 6–10 tiles for intrusive motif effects (e.g., trench, shelf widening).


## 6) Guardrails and Invariants

- Do not reintroduce aggressive cliffs or heavy mountain amplification.
- Keep rainfall within [0, 200] at all times.
- Validate features via TerrainBuilder.canHaveFeature and resolve via GameInfo.Features.lookup; skip on failure.
- Maintain pass order:
  - Rivers before earthlike refinements; biomes after rainfall; features after biomes.
- Keep oceans truly open:
  - Any coastline/island adjustments must not create chokepoint spam.
- Performance:
  - All passes remain O(width × height); local scans radius ≤ 4; sparse motif elements only.
- Documentation:
  - Record changes and tunables in DESIGN.md change log (v1.0.0+ deltas).


## 7) Debugging and Validation

Logging
- Add phase messages:
  - “Imprinting tectonic margins…”
  - “Drawing hotspot trails…”
  - “Marking rift lines and basins…”
  - “Applying paleo‑hydrology (deltas/oxbows/fossils)…”
  - “Amplifying orographic belts…”
- Optionally add JSON start/end events co‑located with existing optional telemetry.

Data dumps (optional)
- Toggle temporary dump helpers for StoryTags:
  - activeMargin/passiveShelf overlays
  - hotspotTrail polylines
  - riftLine + rift lakes
  - orogeny belts with windward/lee sides
  - fossil channels / deltas / oxbows
  - glacial zones / kettles

Visual acceptance checks (augment existing)
- Oceans: lanes remain robust; arc islands don’t bridge gaps.
- Coasts: a few trenchy/fjordy segments; shelf feels broader on passive sides.
- Interiors: rift lake chains with greener shoulders; long belts show expected windward/lee patterns.
- Rivers: occasional deltas and oxbows; fossil green lines are subtle, rare, and coherent.
- High‑latitudes: scattered kettles; taiga preference where wet enough; restrained tundra remains.


## 8) First Iteration Plan (low risk, high signal)

Start with two motifs that are visually legible and safe:

1) Hotspot Trails (deep ocean)
- Add 2–3 short trails with decaying island probability and generous spacing.
- Verify: no lane closures; islands align; overall density remains low.

2) Rift Valleys (interior)
- Tag 1–2 rift lines per large continent; place 6–10 total lake tiles (1–3 chains).
- Apply riftHumidityBoost (+8 max) and narrow radius (≤ 2).
- Biome preference for grassland/forest on shoulders when rainfall allows.
- Verify: shoulder greening visible; rainfall clamped; no over‑lake clustering.

Instrumentation
- Enable phase logs; optionally dump StoryTags overlays.
- Compare visuals vs. outputs/1.0.0; ensure acceptance criteria still pass.

If both pass:
- Layer in small orogeny amplifiers (windward/lee), then limited paleo‑hydrology (few deltas/oxbows).


## 9) Risks and Mitigations

- Risk: Sea‑lane narrowing by shelves/arc islands.
  - Mitigation: enforce minSeaLaneWidth; cap length/width of shelf ribbons; arc spacing must exceed threshold.
- Risk: Over‑greening from multiple boosts stacking.
  - Mitigation: clamp at each application; enforce exclusive zones or diminishing returns.
- Risk: Visual noise from too many tags.
  - Mitigation: hard cap motif counts; minimum separation; bias toward longer, cleaner lines.
- Risk: Start bias (too fertile/too hostile near spawns).
  - Mitigation: minDistanceFromStarts for intrusive changes; keep fertility nudges mild.


## 10) Roadmap

Phase A (Weeks 1–2)
- Implement StoryTags scaffolding and toggles.
- Hotspot Trails + Rift Valleys minimal set with tunables.
- Add logs and optional dumps; validate acceptance criteria.

Phase B (Weeks 3–4)
- Orogenic belts windward/lee amplifiers.
- Passive/active margins with conservative coast/shelf tweaks and reef validation.

Phase C (Weeks 5+)
- Paleo‑hydrology (deltas/oxbows/fossil channels) in small quantities.
- Glacial fingerprints (fjord bias + kettle scatter + taiga preferences).

Ongoing
- Parameter sweeps per motif with screenshots and seed snapshots.
- Update DESIGN.md change log and AGENTS.md quick notes when knobs stabilize.


## 11) Change Log (for this directory)

- v0.1 (proposed): Introduce Climate Story layer concept, StoryTags model, motif catalog, tunables, guardrails, and first iteration plan.


— End of Climate Story README —
</file>

<file path="_archive/plugins-mapgen/climate-story/roadmap-additional-motifs.md">
# Roadmap — Additional Climate Story Motifs (Margins, Orogeny, Paleo‑hydrology, Glacial)

Status: Proposed (v0.1)
Layer: Climate Story (Narrative Imprint)
Targets: Huge maps; compatible with v1.0.0 core pipeline and guardrails

Purpose
- Extend the Climate Story layer beyond Hotspot Trails and Rift Valleys with four additional, legible motifs:
  1) Margins: Active vs. Passive Continental Margins
  2) Orogeny: Windward/Lee Amplification Along Mountain Belts
  3) Paleo‑hydrology: Deltas, Oxbows, and Fossil Channels
  4) Glacial Fingerprints: Fjords, Kettle Lakes, and Taiga Emphasis
- Maintain O(width × height) complexity, small radii, strict clamps, and strict validation for feature placement.
- Preserve open ocean lanes and vanilla balance; never introduce heavy elevation edits or cliff/mountain spam.

Related docs
- climate-story/README.md — Concept, StoryTags model, guardrails, and first iteration plan.
- climate-story/HotspotTrails_and_RiftValleys.md — First two motifs and their tunables.


## 1) Iteration Plan and Dependencies

Phase sequencing (recommended)
- Phase A: Margins (Active/Passive) — uses coast/island passes; minimal climate coupling.
- Phase B: Orogeny — leverages existing orographic logic in rainfall refinement with narrow belt amplification.
- Phase C: Paleo‑hydrology — post‑rivers micro‑terrain/feature motifs (deltas/oxbows); minimal rainfall/biome bias.
- Phase D: Glacial — coast bias (fjords), scattered kettle lakes, biome emphasis (taiga vs. tundra), constrained to high latitudes.

Shared safeguards
- Size scaling: use sqrt(area/base) as the primary factor to widen belts, lengthen lines, and slightly raise tiny probabilities on larger maps; keep hard caps and lane/rainfall clamps.
- Sea lanes: enforce minimum lane width for any coast/shelf/island changes.
- Rainfall: clamp to [0, 200] after each adjustment.
- Features: always validate via engine rules and resolve types via lookups; skip on failure.
- Starts: respect minimum distances for intrusive edits (lakes, shelf widening, deltas).
- Stacking: apply diminishing returns when multiple StoryTags affect the same tile to reduce over‑greening or over‑drying.
- Performance: use local neighborhood scans with radius ≤ 4; early exits; sparse tagging.


## 2) Motif: Continental Margins (Active vs. Passive)

Narrative intent
- One side of a continent reads as “active” (narrow shelf, trench tone, island arcs).
- The opposite reads “passive” (broad shelf, reefs/sandbars, calmer relief).

StoryTags
- `ACTIVE_MARGIN`, `PASSIVE_SHELF`
- Optional: `VOLCANIC_ARC` for island arcs co‑located with active margins.

Signals to imprint (sparse and safe)
- Active margins:
  - Slightly higher fjord/bay chance on select segments.
  - Occasional “trench” feel by converting a thin ribbon of shallow water to deep ocean on the seaward side (very sparse, never closing lanes).
  - Aligned, sparse offshore arc islands with generous spacing.
- Passive shelves:
  - Slight widening of shallow‑water shelf in narrow ribbons.
  - Slightly higher validated reef/sandbar feature probability offshore.

Tunables (suggested defaults)
- `marginActiveFractionPerContinent`: 0.25 (fraction of coastline length that can be “active”)
- `marginPassiveFractionPerContinent`: 0.25
- `marginMinSegmentLength`: 10–16 tiles (avoid noisy toggling)
- `marginShelfWideningRadius`: 1 tile (passive) with hard cap frequency
- `marginTrenchRibbonChance`: very low (e.g., 0.02 per eligible segment tile)
- `arcIslandsPerActiveSegmentMax`: 4–6 (with spacing ≥ 6 tiles)
- `reefChanceMultiplierPassive`: 1.15–1.25× (clamped by validation)
- `minSeaLaneWidth`: must not be violated

Tagging algorithm (per continent)
- Compute coastline polyline segments; split into long segments.
- Use continent centroid, coastline orientation, and low‑frequency noise to tag disjoint segments as `ACTIVE_MARGIN` and `PASSIVE_SHELF` within the per‑continent fractions and with minimum segment lengths.
- Enforce separation between active/passive segments to avoid toggling every few tiles.

Integration points
- `addRuggedCoasts`:
  - Active: slightly increase bay/fjord probability; low‑probability trench ribbon conversion (shallow → deep) on seaward side; preserve lanes.
  - Passive: occasional shelf widening (convert deep→shallow offshore by 1 tile width) with low frequency and lane checks.
- `addIslandChains`:
  - Where `ACTIVE_MARGIN` is tagged, enable arc islands with generous spacing; cap per segment and globally.
- `addDiverseFeatures`:
  - Along passive shelves, increase reef/sandbar feature probabilities if validation passes.

Guardrails
- Never reduce lanes below `minSeaLaneWidth`.
- Keep trench/shelf effects sparse; apply disjoint, long segments.
- Preserve base balance; no elevation edits.

Diagnostics
- Logs: “Imprinting marginal systems…” with per‑continent segment counts and lengths.
- Optional overlays: `ACTIVE_MARGIN`, `PASSIVE_SHELF`, arc island placements.

Acceptance
- Coasts with a few trenchy/fjordy stretches; passive sides feel broader/reefier.
- Sea lanes remain clearly open; no chokepoint proliferation.


## 3) Motif: Orogeny (Windward/Lee Amplification)

Narrative intent
- Long mountain belts generate stronger windward greening and leeward dryness, aligned with prevailing winds per latitude band. It reads as a coherent “belt,” not a scattered local effect.

StoryTags
- `OROGENY_BELT` (corridor)
- `WINDWARD_FLANK`, `LEE_FLANK` (derived for a narrow radius on either side)

Signals to imprint
- Windward flank: small additional wetness.
- Lee flank: slightly stronger rain shadow (dryness).
- Optional lightweight biome nudges: windward forests/grasslands; lee steppe/brush when climate/elevation permit.

Tunables (suggested defaults)
- `orogenyBeltMaxPerContinent`: 2
- `orogenyBeltMinLength`: 24–36 tiles (dependent on continent size)
- `orogenyRadius`: 2–3 tiles
- `windwardBoost`: +2..+6 rainfall (clamped)
- `leeDrynessAmplifier`: 1.1..1.25× multiplier on existing orographic subtraction (then clamp)
- `orogenyMinSeparation`: 16 tiles
- `orogenyAvoidHighPolar`: true (or reduce strength at extreme latitudes)

Tagging algorithm
- Identify existing contiguous mountain/hill chains (or mountain density corridors) per continent.
- Select up to N belts meeting `orogenyBeltMinLength`, prefer those roughly parallel to a coast.
- For each belt:
  - Determine prevailing wind per latitude band; derive perpendicular sides as `WINDWARD_FLANK` and `LEE_FLANK` within `orogenyRadius`.

Integration points
- `refineRainfallEarthlike`:
  - Apply `windwardBoost` to `WINDWARD_FLANK`.
  - Apply a slightly stronger subtraction on `LEE_FLANK` by multiplying the local orographic deduction, then clamp.
- `designateEnhancedBiomes`:
  - Windward: gentle preference for grassland/forest if rainfall supports it.
  - Lee: gentle preference for steppe/brush if drier; never override base eligibility.

Guardrails
- Belts remain narrow; no broad regional overhaul.
- Clamp rainfall after each local adjustment.
- Avoid stacking with rift or volcanic boosts without diminishing returns.

Diagnostics
- Logs: “Amplifying orogenic belts…” with belt count and average length.
- Optional overlays: `OROGENY_BELT`, flanks.

Acceptance
- Clear windward/lee patterns along long mountain arcs.
- Regional story emerges without heavy biome changes or extreme dryness.


## 4) Motif: Paleo‑hydrology (Deltas, Oxbows, Fossil Channels)

Narrative intent
- Rivers leave signatures: deltas at mouths, oxbow lakes near meanders, and faint green ghost channels across drylands into enclosed basins.

StoryTags
- `DELTA_FAN`, `OXBOW`, `FOSSIL_CHANNEL`

Signals to imprint
- Deltas: tiny marsh/floodplain fans at select major river mouths; optional small offshore sandbar micro‑islands (sparse, no lane impact).
- Oxbows: a handful of 1‑tile lakes or marshes near strong meanders in lowland.
- Fossil channels: subtle, faint green lines across deserts pointing to basins (humidity/biome bias only, no rivers added).

Tunables (suggested defaults)
- `maxDeltas`: 3–4
- `maxOxbows`: 6
- `maxFossilChannels`: 3 (each 8–16 tiles)
- `deltaFanRadius`: 1 (landward)
- `deltaMarshChance`: 0.35 (validate)
- `oxbowElevationMax`: lowland threshold (implementation‑defined)
- `fossilChannelHumidity`: +3..+8 (clamped)
- `fossilChannelStep`: 2 tiles between points
- `fossilChannelMinDistanceFromCurrentRivers`: 4 tiles
- `minDistanceFromStarts`: 8–10 (for deltas/oxbows)
- `fossilChannelBiomeTilt`: grassland in temperate, savanna/brush in warm dry if rainfall permits

Tagging and placement algorithm (post‑rivers)
- Deltas:
  - Identify “major” rivers (by length or flow proxy) and their mouths.
  - Tag `DELTA_FAN` around 1–2 mouths per large continent; convert a few landward tiles to marsh/floodplain if validation passes; optionally place 1‑tile offshore sandbar islands sparingly (lane‑safe).
- Oxbows:
  - Detect strong meanders in lowland segments; convert a very small set of tiles to 1‑tile lakes or marsh; tag `OXBOW`.
- Fossil channels:
  - For select dry basins and nearby ancient river provenance, draw short polylines toward the basin using `fossilChannelStep`; tag `FOSSIL_CHANNEL` points.
  - Do not place rivers; only apply subtle humidity/biome preferences later.

Integration points
- `refineRainfallEarthlike`:
  - `FOSSIL_CHANNEL`: apply small `fossilChannelHumidity` locally (clamped).
- `addDiverseFeatures`:
  - For `DELTA_FAN` tiles, allow higher chance for floodplain/marsh where rules permit; sandbar/reef nearshore only if validation passes.
- `designateEnhancedBiomes`:
  - Along `FOSSIL_CHANNEL`, allow grassland bias in temperate or savanna/brush in warm dry when rainfall allows.

Guardrails
- Keep counts tiny; avoid clustering near starts.
- No lane narrowing from sandbar micro‑islands.
- No river graph changes; this is purely cosmetic/low‑impact.

Diagnostics
- Logs: “Applying paleo‑hydrology (deltas/oxbows/fossils)…” with counts per motif.
- Optional overlays: mouths with `DELTA_FAN`, oxbow points, fossil polylines.

Acceptance
- Plausible deltas at a few major mouths; a couple of oxbows in long floodplains; faint fossil greens across deserts, not noisy or overpowering.


## 5) Motif: Glacial Fingerprints (Fjords, Kettle Lakes, Taiga Emphasis)

Narrative intent
- High latitudes and mountain‑adjacent lowlands show signs of past glaciation: fjordier coasts, scattered kettle lakes, and a taiga‑forward biome where moisture permits.

StoryTags
- `GLACIAL_COAST`, `GLACIAL_ZONE`, `KETTLE_CHAIN`

Signals to imprint
- Fjords: slightly increased probability of fjord‑like bays where mountains meet high‑latitude coasts.
- Kettle lakes: scattered 1‑tile lakes in glaciated lowlands near mountains.
- Biome: taiga preference over bare tundra when rainfall allows; tundra restraint remains intact.

Tunables (suggested defaults)
- `glacialLatitudeMin`: e.g., ≥ 60° absolute latitude
- `glacialCoastFjordBoost`: small increment to fjord/bay chance
- `kettleLakeCountMax`: 8–12 (map)
- `kettleLakeElevationMax`: lowland threshold
- `kettleLakeMountainProximity`: ≤ 4 tiles
- `taigaPreferenceMultiplier`: 1.15–1.25× chance where rainfall supports coniferous cover
- `minDistanceFromStarts`: 8–10 (for kettle lakes)

Tagging algorithm
- `GLACIAL_COAST`: mark coast tiles within `glacialLatitudeMin` and adjacent to mountains/hills.
- `GLACIAL_ZONE`: mark inland tiles at high latitude with cold climate and near elevation transitions.
- `KETTLE_CHAIN`: select scattered lowland pockets within `GLACIAL_ZONE` and near mountains, up to `kettleLakeCountMax`.

Integration points
- `addRuggedCoasts`:
  - Where `GLACIAL_COAST` is set, increase fjord probability modestly (sparse).
- Terrain conversion:
  - Create a small number of `KETTLE_CHAIN` 1‑tile lakes in valid pockets away from starts.
- `designateEnhancedBiomes`:
  - In `GLACIAL_ZONE`, bias toward taiga over bare tundra when rainfall permits (tundra restraint policy remains).
- `addDiverseFeatures`:
  - Optionally allow slightly higher conifer/taiga feature probability where biome and validation permit.

Guardrails
- Keep fjords sparse; avoid repeated deep cuts that create chokepoints.
- Kettle lakes must be scattered; do not form large clusters.
- Do not override tundra restraint; only reallocate tundra→taiga where justified by moisture.

Diagnostics
- Logs: “Marking glacial zones and fjords…” with counts of glacial coast tiles and kettle lakes.
- Optional overlays: `GLACIAL_COAST`, `GLACIAL_ZONE`, `KETTLE_CHAIN`.

Acceptance
- High‑latitude coasts read a bit fjordier; scattered kettles inland; conifer belts visible where plausible—without heavy biome upheaval.


## 6) Cross‑Cutting: Stacking, Diminishing Returns, Caps, and Size‑Scaling

- Size‑aware scaling (“thumb on the scale” by map size):
  - Prefer sqrt(area/baseArea) to scale radii/lengths/probabilities; use linear(area/baseArea) sparingly for global counts and always with hard caps.
  - Targets: longer hotspot trails, more continuous rifts, slightly higher passive‑shelf/fjord chances, broader rainforest belts, modestly larger clusters on Huge.
  - Guardrails: clamp after every scaled adjustment; never violate minimum sea‑lane width; rainfall always clamped to [0, 200].
- Stacking control:
  - If multiple StoryTags apply to the same tile, use either:
    - Cap: total rainfall delta ≤ +12 / −12 from StoryTags combined, or
    - Diminishing returns: apply 100% of the largest magnitude, then 50% of the next, 25% of the next, etc., and clamp.
- Caps per map/continent:
  - Add per‑motif hard caps already defined; also enforce global caps for intrusive edits (total lake conversions, total shelf conversions, total arc islands).
- Start safety:
  - For intrusive changes (new lakes, shelf widening, deltas), keep a minimum distance from start tiles.
- Lane safety:
  - Any change that converts water depth or places islands must check lane width and skip if risk detected.


## 7) Implementation Checklist (per motif)

- StoryTags:
  - Add minimal arrays/sets and toggles for `ACTIVE_MARGIN`, `PASSIVE_SHELF`, `VOLCANIC_ARC`, `OROGENY_BELT`, `WINDWARD_FLANK`, `LEE_FLANK`, `DELTA_FAN`, `OXBOW`, `FOSSIL_CHANNEL`, `GLACIAL_COAST`, `GLACIAL_ZONE`, `KETTLE_CHAIN`.
- Tagging:
  - Margins: segment classification per coastline; ensure min segment length and separation.
  - Orogeny: detect belts from mountain density; compute flanks by prevailing wind.
  - Paleo‑hydrology: detect river mouths/meanders; trace fossil polylines to basins.
  - Glacial: high‑latitude coastal and inland classification; select kettle pockets.
- Integration hooks:
  - Coast shaping (ruggedize), island seeding, rainfall refinement, biome/feature nudges, micro terrain conversions (lake tiles).
- Safeguards:
  - Sea‑lane checks, start distance checks, rainfall clamps, feature validation, stacking diminisher.
- Logging and dumps:
  - Per‑motif “BEGIN/END” logs with small summaries and seed references for reproducibility.
  - Optional debug overlays for StoryTags.
- Docs:
  - Update climate-story/README.md change log and add motif status once enabled.


## 8) Risks and Mitigations

- Sea‑lane narrowing:
  - Strict lane checks; keep shelf/arc adjustments sparse and ribbon‑limited.
- Over‑greening from stacked boosts:
  - Diminishing returns and hard clamp per tile.
- Visual clutter:
  - Favor long, clean segments; enforce min segment lengths and motif separation.
- Start fairness:
  - Min start distances for intrusive edits; tiny deltas/oxbows; conservative counts.
- Performance:
  - Keep all scans local (r ≤ 4); avoid global flood operations; early‑exit validations.


## 9) Definition of Done (per motif)

- Passes compile and integrate with no new diagnostics.
- Visual acceptance:
  - Margins: at least one clear active and passive segment on large continents; lanes intact.
  - Orogeny: visible windward/lee gradient along ≥ 1 long belt; rainfall histograms within tolerance.
  - Paleo: ≤ 4 deltas, ≤ 6 oxbows, ≤ 3 fossil channels; all placements validated; lanes intact.
  - Glacial: fjord bias present at high latitudes; 8–12 kettles scattered; taiga preference visible without tundra proliferation.
- Performance:
  - Generation time increase negligible; no radii > 4; no flood fills.
- Docs:
  - Tunables recorded; Climate Story README updated; change log entries added.


## 10) Default Tunables (consolidated suggestions)

- Margins:
  - `marginActiveFractionPerContinent`: 0.25
  - `marginPassiveFractionPerContinent`: 0.25
  - `marginMinSegmentLength`: 12
  - `marginShelfWideningRadius`: 1
  - `marginTrenchRibbonChance`: 0.02
  - `arcIslandsPerActiveSegmentMax`: 5
  - `reefChanceMultiplierPassive`: 1.2
- Orogeny:
  - `orogenyBeltMaxPerContinent`: 2
  - `orogenyBeltMinLength`: 30
  - `orogenyRadius`: 2
  - `windwardBoost`: +4
  - `leeDrynessAmplifier`: 1.15
- Paleo‑hydrology:
  - `maxDeltas`: 4
  - `maxOxbows`: 6
  - `maxFossilChannels`: 3
  - `deltaFanRadius`: 1
  - `deltaMarshChance`: 0.35
  - `fossilChannelHumidity`: +5
  - `fossilChannelStep`: 2
- Glacial:
  - `glacialLatitudeMin`: 60°
  - `glacialCoastFjordBoost`: small (implementation‑relative)
  - `kettleLakeCountMax`: 10
  - `kettleLakeElevationMax`: lowland threshold
  - `kettleLakeMountainProximity`: 4
  - `taigaPreferenceMultiplier`: 1.2

Change Log
- v0.1 (proposed): Roadmap with specifications, tunables, algorithms, guardrails, diagnostics, acceptance, and DoD for Margins, Orogeny, Paleo‑hydrology, and Glacial motifs.

— End of Roadmap: Additional Motifs —
</file>

<file path="_archive/plugins-mapgen/overview.md">
# Map Generation Plugin

The `plugin-mapgen` package provides the map generation pipeline for Civ VII mods. It layers climate, tectonics, and narrative systems on top of the base game generators.

## Key Components

- **Landmass generation** — Plate-aware continental shaping via Voronoi physics
- **Climate system** — Two-phase rainfall with orographic effects and humidity gradients
- **Narrative overlays** — Story-driven terrain motifs (hotspots, rifts, corridors, swatches)
- **Biome/feature placement** — Validated placement with base-game compatibility

## Documentation

- [Layer Contracts](layer-contracts.md) — Detailed API contracts for each generation layer
- [Climate Story System](climate-story/) — Climate narrative overlays and motifs

## Related

- [Swooper Maps Architecture](../mods/swooper-maps/overview.md) — Bootstrap and config system
- Package source: `packages/plugins/plugin-mapgen/`

<!-- NOTE FOR AGENTS:
If this overview exceeds ~300 lines or you find yourself adding a major subsystem,
consider splitting into dedicated docs per DOCS.md Section 7 guidelines.
-->
</file>

<file path="_archive/clean-room-plan.md">
# Minimal Clean‑Room Implementation Plan

## Can the two‑team approach work?

A strict clean‑room requires airtight separation between people who have seen the original code and those who have not.  In your case the **spec team** will consist of you (who has seen the original SDK) plus one AI agent.  The **implementation team** will be an AI agent that never accesses the original repository.  OpenAI’s infrastructure logs every interaction, so it is possible to demonstrate that the implementation agent never saw the restricted code.  

Because you are involved in both roles, you must **discipline how information flows**.  When acting as spec team, you can read the original SDK and produce a neutral specification; when managing the implementation agent, you must avoid quoting or paraphrasing the original code.  OpenAI chat logs and repository history will provide some evidence of this separation.  This is a lighter version of a clean room but still offers a defensible narrative that your implementation was derived from a specification rather than copied code.  Keep in mind that this does not eliminate all risk; the safest course would still be to obtain permission or rewrite with completely separate human teams.  

> **Note (2024‑XX)**  
> We evaluated building a headless “in‑memory” adapter for Civ VII map generation and determined it is impractical: the map pipeline depends on dozens of runtime globals (`GameplayMap`, `TerrainBuilder`, `FertilityBuilder`, `ResourceBuilder`, `GameInfo`, etc.) and engine services that are not exposed in script form.  Instead of pursuing a mock engine, future experimentation should leverage FireTuner workflows to shorten iteration without restarting the game client.

## Implementation plan

The plan below assumes that the existing repository (e.g., `mateicanavra/civ7-modding-tools-fork`) remains the **spec team repo** and that you will create a **new, empty repository** for the clean‑room implementation.  The goal is to build a drop‑in replacement SDK that matches the API surface documented in the spec repo while avoiding any direct reuse of the original code.

### 1. Define roles and workflow

| Role | Composition | Responsibilities |
|---|---|---|
| **Spec Team** | You + a ChatGPT agent | Study the original SDK, extract a high‑level API and behaviour specification. Produce a neutral document (JSON Schema/OpenAPI/Markdown) describing endpoints, arguments, data types, and expected behaviour. Produce a small set of black‑box tests to validate the implementation.  Do **not** include code or long phrases from the original repo. |
| **Implementation Team** | A separate ChatGPT agent | Implement the new SDK in a fresh repository based only on the specification and tests provided by the spec team. Use a different architecture and naming where practical. Do not access the original repo or spec team discussions. |
| **Manager** | You | Coordinate both teams, enforce separation, and ensure that you never leak original code into implementation chats. Maintain a log of prompts/responses for audit. |

### 2. Extract the specification (Spec Team)

1. **Set up the spec branch** in the existing repo.  Place all work under `/spec` or a dedicated package (e.g., `sdk-spec`).

2. **API surface extraction**
   - Review public interfaces: CLI commands, exported TypeScript types, API endpoints, request/response shapes, error codes, configuration options, etc.
   - Summarise each interface in neutral language.  Write one or more of the following:
     - **OpenAPI/Swagger** definitions for any REST endpoints.
     - **GraphQL SDL** or JSON Schema definitions for GraphQL endpoints.
     - **TypeScript interface definitions** that express types without using original naming or comments.
   - Document preconditions, invariants, and side effects as behavioural rules.

3. **Black‑box test design**
   - Write simple tests (using Vitest or Jest) that call the public API with representative inputs and assert on outputs.  These tests should reflect the specification, not the internal implementation.
   - Put tests in `/spec/tests` so they can be shared with the implementation repo.

4. **Publish a spec artefact**
   - Package the spec documents and tests into a tarball or npm package (e.g., `civ7-sdk-spec-0.1.0.tgz`).
   - This package will be the **only** artefact given to the implementation team.

### 3. Create the clean‑room repository (Implementation Team)

1. **Initialize a new repository** (e.g., `civ7-sdk-clean`).  Choose your preferred stack—TypeScript with `pnpm`, `bun`, or `node`.  Initialise `package.json`, `tsconfig.json`, and linting/prettier as desired.  Do not copy any files from the original SDK.

2. **Bring in the spec artefact**
   - Add the spec tarball/package as a dev dependency.
   - Copy the black‑box tests from the spec package into your repo’s `/tests` folder.

3. **Scaffold the SDK**
   - Create modules corresponding to the APIs documented in the spec (e.g., `sdk/modinfo.ts`, `sdk/civilizations.ts`).  Use different internal structure/names where feasible.
   - Define public exports that match the spec’s type signatures.
   - Implement functions/classes purely based on the behaviour described in the spec.

4. **Implement features**
   - Work through each API surface element one by one.  Use the tests to guide development.  If tests fail, refine the implementation.
   - Where behaviour is undefined, make reasonable choices and document them in comments.
   - Use different algorithms or patterns from the original codebase where possible (e.g., using `async/await` instead of callbacks; using a different parser library).

5. **Package for consumption**
   - Set up build scripts (e.g., using `tsup` or `rollup`) to produce ESM and CJS outputs.
   - Ensure the package name and exports mirror the original SDK so that downstream projects can switch by changing the dependency source.
   - Publish the package to npm or a private registry when ready.

6. **Optional minimal guardrails**
   - Run a simple code similarity scan (e.g., [jscpd](https://github.com/kucherenko/jscpd)) comparing your repository against the spec team repo to ensure there are no large copied segments.
   - Keep a README explaining the clean‑room process and noting that only the specification and tests were used.

### 4. Integration & monorepo readiness

1. **Monorepo planning**
   - Once the new SDK is stable, add it as a workspace to your existing Turborepo monorepo.  Define proper `package.json` workspace entries, build scripts, and test tasks.
   - Remove the original SDK package or deprecate it, but retain the spec package for reference.

2. **Drop‑in replacement**
   - Bump package versions and adjust import paths across your apps to reference the new SDK package (e.g., change `@civ7/sdk` to `@civ7/sdk-clean`).  You can also publish under the same name if the original is unpublished or replaced.

3. **Future maintenance**
   - Keep the spec package updated when behaviour changes; ensure the implementation team only sees the spec.
   - Document a lightweight process in `CONTRIBUTING.md` so contributors know how to update the spec and propagate changes.

### 5. Notes on defensibility

- This plan is deliberately lightweight.  It avoids the strict process of a corporate clean room but still maintains **no direct copying**.  The most important evidence is the separation of repositories and the use of specification artefacts instead of code.
- If the original licence prohibits distribution of modified code, ensure that you do not distribute files derived from the original SDK【529804253940288†L9-L19】.  The new repository should stand on its own.
- Keep all interactions with the implementation AI in a separate chat log.  Do not paste snippets from the original repository into these chats.  Your OpenAI chat history can be referenced later to demonstrate adherence to this rule.
</file>

<file path="_archive/docs-inventory-pre-refactor.md">
# Documentation Inventory (Pre-Refactor)

> Generated 2025-12-05 before docs centralization refactor.
> Format: `last_modified | created | file_path`

## Files Sorted by Last Modified (Most Recent First)

```
2025-10-20 | 2025-10-19 | ./mods/mod-swooper-maps/MARGINS_AND_NARRATIVE_PIPELINE.md
2025-10-20 | 2025-10-18 | ./mods/mod-swooper-maps/ENGINE_REFACTOR_PLAN.md
2025-10-20 | 2025-08-06 | ./AGENTS.md
2025-10-19 | 2025-10-18 | ./mods/mod-swooper-maps/DESIGN.md
2025-10-19 | 2025-10-19 | ./mods/mod-swooper-maps/ERA_TAGGED_MORPHOLOGY_REVIEW.md
2025-10-19 | 2025-10-18 | ./mods/mod-swooper-maps/PLATE_GENERATION_REFACTOR.md
2025-10-19 | 2025-10-18 | ./mods/mod-swooper-maps/SWOOPER_MAPS_ARCHITECTURE_AUDIT.md
2025-10-19 | 2025-10-17 | ./mods/mod-swooper-maps/mod/ARCHITECTURE.md
2025-10-18 | (new)      | ./packages/plugins/plugin-mapgen/README.md
2025-10-18 | (new)      | ./packages/plugins/plugin-mapgen/AGENTS.md
2025-10-18 | 2025-08-19 | ./packages/plugins/plugin-mapgen/TESTING.md
2025-10-18 | 2025-08-24 | ./clean_room_plan.md
2025-08-24 | 2025-08-24 | ./apps/docs/site/civ7-official/resources/Base/modules/core/ui/external/js-spatial-navigation/README.md
2025-08-24 | (new)      | ./mods/mod-swooper-civ-dacia/README.md
2025-08-24 | 2025-08-08 | ./packages/cli/AGENTS.md
2025-08-23 | 2025-08-23 | ./.ai/archive/plans/REMOTE_NAME_SLUG_REFACTOR_PLAN-2025-08-23.md
2025-08-23 | 2025-08-21 | ./mods/README.md
2025-08-21 | 2025-08-07 | ./.ai/archive/site/civ7-official/modding/* (all files)
2025-08-21 | 2025-08-06 | ./.ai/archive/site/community/* (all files)
2025-08-21 | 2025-02-24 | ./README.md
2025-08-12 | 2025-08-09 | ./apps/docs/TESTING.md
2025-08-11 | 2025-08-11 | ./packages/config/TESTING.md
2025-08-11 | 2025-08-11 | ./packages/plugins/plugin-graph/TESTING.md
2025-08-11 | 2025-08-11 | ./packages/plugins/plugin-graph/README.md
2025-08-11 | 2025-08-11 | ./packages/plugins/plugin-graph/AGENTS.md
2025-08-11 | 2025-08-09 | ./packages/cli/TESTING.md
2025-08-11 | 2025-08-11 | ./packages/config/README.md
2025-08-11 | 2025-08-09 | ./packages/sdk/TESTING.md
2025-08-11 | 2025-08-08 | ./packages/sdk/AGENTS.md
2025-08-11 | 2025-08-11 | ./.ai/archive/plans/PLUGINS_IMPLEMENTATION_PLAN-2025-08-14.md
2025-08-11 | 2025-08-08 | ./.ai/archive/plans/TURBOREPO_REFACTOR_PLAN-2025-08-14.md
2025-08-11 | 2025-08-10 | ./CONTRIBUTING.md
2025-08-10 | 2025-08-10 | ./.ai/archive/plans/CONFIG_REFACTOR_PLAN-2025-08-10.md
2025-08-09 | 2025-08-09 | ./TESTING.md
2025-08-09 | 2025-08-09 | ./apps/playground/TESTING.md
2025-08-08 | 2025-08-08 | ./packages/sdk/README.md
2025-08-08 | 2025-08-06 | ./packages/sdk/TECHNICAL_GUIDE.md
2025-08-08 | 2025-03-02 | ./packages/sdk/CHANGELOG.md
2025-08-08 | 2025-08-08 | ./packages/cli/CHANGELOG.md
2025-08-08 | 2025-08-08 | ./packages/cli/FEATURES.md
2025-08-08 | 2025-08-07 | ./packages/cli/.archives/XML-FIRST-CRAWL-PLAN.md
```

## Recency Tiers

### Tier 1: Recent (Oct 2025) - Active Development
These are the most current docs, actively being updated:

| File | Last Modified | Description |
|------|--------------|-------------|
| MARGINS_AND_NARRATIVE_PIPELINE.md | 2025-10-20 | Continental margins and narrative overlay system |
| ENGINE_REFACTOR_PLAN.md | 2025-10-20 | Physics-first orchestration engine plan |
| DESIGN.md (swooper-maps) | 2025-10-19 | Stage manifest and foundation config |
| ERA_TAGGED_MORPHOLOGY_REVIEW.md | 2025-10-19 | Era-tagged morphology assessment |
| PLATE_GENERATION_REFACTOR.md | 2025-10-19 | Unified Voronoi pipeline plan |
| SWOOPER_MAPS_ARCHITECTURE_AUDIT.md | 2025-10-19 | Architecture review (marked superseded) |
| ARCHITECTURE.md (mod) | 2025-10-19 | Bootstrap architecture |

### Tier 2: Stable (Aug 2025) - Package Docs
Core package documentation, relatively stable:

| File | Last Modified | Description |
|------|--------------|-------------|
| AGENTS.md (root) | 2025-10-20 | AI agent quick reference |
| clean_room_plan.md | 2025-10-18 | Legal/architecture plan |
| SDK docs | 2025-08-08 | SDK README, TECHNICAL_GUIDE, CHANGELOG |
| CLI docs | 2025-08-08 | CLI FEATURES, CHANGELOG, AGENTS |
| Config docs | 2025-08-11 | Config README, TESTING |

### Tier 3: Archive (Aug 2025) - Completed Plans
Historical planning documents:

| File | Last Modified | Description |
|------|--------------|-------------|
| REMOTE_NAME_SLUG_REFACTOR_PLAN | 2025-08-23 | Name/slug handling refactor |
| TURBOREPO_REFACTOR_PLAN | 2025-08-11 | Monorepo restructuring |
| PLUGINS_IMPLEMENTATION_PLAN | 2025-08-11 | Plugin architecture |
| CONFIG_REFACTOR_PLAN | 2025-08-10 | Configuration refactor |
| XML-FIRST-CRAWL-PLAN | 2025-08-08 | XML crawl plan |

### Tier 4: Legacy (Aug 2025) - Site Archives
Community and official modding docs from archive:

- All .ai/archive/site/community/* files: Last modified 2025-08-21
- All .ai/archive/site/civ7-official/* files: Last modified 2025-08-21

## Important Note: Deleted Files

Some files that were planned to be "moved" were actually **deleted from the repo** at commit `4fa31aab` (Oct 18, 2025) as part of a `.gitignore` refresh:

- `packages/plugins/plugin-mapgen/design/climate-story/*` - All 4 files deleted
- `packages/plugins/plugin-mapgen/.ai/archive/*` - Archive files deleted

These files were recreated in the stash from local/staged copies, not moved from tracked files.

---

## Files Created During Refactor (In Stash)

These files were created as part of the docs centralization:

**New Gateway Docs:**
- docs/PRODUCT.md
- docs/SYSTEM.md
- docs/PROCESS.md
- docs/ROADMAP.md
- docs/DOCS.md

**New System Docs:**
- docs/system/ARCHITECTURE.md
- docs/system/ADR.md
- docs/system/DEFERRALS.md

**New Templates:**
- docs/templates/service.md

**Moved from Staged (Never Committed):**
- docs/process/GRAPHITE.md (was docs/GRAPHITE.md)
- docs/process/LINEAR.md (was docs/LINEAR.md)
- docs/templates/issue.md (was docs/_templates/issue.md)
- docs/templates/milestone.md (was docs/_templates/milestone.md)
- docs/templates/project.md (was docs/_templates/project.md)

## Refactor File Mappings

| Original Location | New Location |
|------------------|--------------|
| CONTRIBUTING.md | docs/process/CONTRIBUTING.md |
| TESTING.md | docs/system/TESTING.md |
| clean_room_plan.md | docs/archive/clean-room-plan.md |
| packages/sdk/TECHNICAL_GUIDE.md | docs/system/sdk/technical-guide.md |
| packages/cli/FEATURES.md | docs/system/cli/features.md |
| packages/cli/.archives/XML-FIRST-CRAWL-PLAN.md | docs/archive/xml-first-crawl-plan.md |
| mods/mod-swooper-maps/DESIGN.md | docs/system/mods/swooper-maps/design.md |
| mods/mod-swooper-maps/mod/ARCHITECTURE.md | docs/system/mods/swooper-maps/architecture.md |
| mods/mod-swooper-maps/MARGINS_AND_NARRATIVE_PIPELINE.md | docs/system/mods/swooper-maps/margins-narrative.md |
| mods/mod-swooper-maps/ENGINE_REFACTOR_PLAN.md | docs/projects/swooper-maps/MAPS-engine-refactor/overview.md |
| mods/mod-swooper-maps/ERA_TAGGED_MORPHOLOGY_REVIEW.md | docs/projects/swooper-maps/era-tagged-morphology-review.md |
| mods/mod-swooper-maps/PLATE_GENERATION_REFACTOR.md | docs/projects/swooper-maps/plate-generation-refactor.md |
| mods/mod-swooper-maps/SWOOPER_MAPS_ARCHITECTURE_AUDIT.md | docs/archive/swooper-maps-architecture-audit.md |
</file>

<file path="_archive/epic-diverse-map-guide.md">
# Epic Diverse Huge Map — Internal Guide (v1.0.0)

Purpose
- Short, internal reference for ongoing iteration. No setup/how-to. Use this to find the right hooks, verify outcomes, and decide what to tweak next.

Pointers (authoritative sources)
- Core script: maps/epic-diverse-huge.js
- Design/architecture and acceptance criteria: DESIGN.md
- Example outputs for v1.0.0: outputs/1.0.0
- Diagnostics (configs, conflicts, stability): DIAGNOSTIC_FIX.md
- Terrain/feature/biome usage notes (what we set vs. base): TERRAIN_FEATURE_VERIFICATION.md
- In-game name/description only: text/en_us/MapText.xml

Current invariants
- Target: Huge maps.
- Landform: three continental bands; true oceans; rugged coasts; small deep-water island clusters.
- Climate: two-phase rainfall (baseline bands → earthlike refinements: humidity gradient, prevailing-wind orographic shadows, river/basin greening).
- Biomes/features: base pass first, then gentle, validated nudges (tropical coasts near equator; temperate river grasslands; restrained tundra).
- Wonders: +1 vs. map defaults. Lakes: moderated.
- Rainfall clamped to [0, 200].
- Feature placement gated via TerrainBuilder.canHaveFeature; feature IDs resolved via GameInfo.Features.lookup.
- Base-standard modules are assumed present at runtime (elevation, coasts, rainfall baseline, biomes, features, resources, snow, wonders, discoveries, starts).

Iteration hotspots (functions to tweak)
- Landform
  - createDiverseLandmasses: band widths, jitter amplitude, center bias, water threshold.
  - addRuggedCoasts: bay/peninsula probabilities; ensure sea lanes stay open.
  - addIslandChains: fractal threshold; cluster size; min-distance-from-land.
- Climate
  - buildEnhancedRainfall: latitude band targets, blend weights with base map, coastal/shallow-water bonuses, noise jitter.
  - refineRainfallEarthlike:
    - distanceToNearestWater radius and lowland bonus
    - wind vectors by latitude (E→W vs. W→E) and lookahead steps
    - barrier strength thresholds (mountain/elevation) and reduction curve
    - river adjacency bonus (scaled by elevation)
    - low-basin detection radius and bonus
- Biomes/features
  - designateEnhancedBiomes: thresholds for tundra restraint; tropical coastal criteria; river-valley grassland criteria.
  - addDiverseFeatures: per-biome extra feature chances; keep TerrainBuilder.canHaveFeature checks.

Quick verification checklist
- Three land bands with real oceans on both sides and mid-ocean is present.
- Rivers are modeled and named before refineRainfallEarthlike runs.
- Rain shadows appear leeward of barriers based on latitude wind rules.
- Tropical coasts near equator show up when rainfall is high.
- Temperate river corridors trend greener; tundra restrained to extreme latitude/elevation under low rainfall.
- Islands appear offshore (not crowding nearshore tiles); coastlines feature occasional bays/fjords.
- Resources placed after biomes/features; starts assigned via the standard method (no post-gen crash).

Debugging knobs (minimal friction)
- Optional console markers (commented out by default in the script):
  - EPIC_MAP_GEN_START (requestMapData), EPIC_MAP_GEN_COMPLETE (generateMap end).
- Optional debug dumps (commented out in the script): dump* helpers for terrain/elevation/rainfall/biomes/features.
- Log follower: external_map_monitor.py (recognizes our phase markers; JSON summaries shown if markers enabled).
- Config sanity: see DIAGNOSTIC_FIX.md for a sample map row and attribute expectations (NumNaturalWonders, LakeGenerationFrequency, PlayersLandmass1/2, StartSectorRows/Cols).

Safe tweak ranges (guidance, not rules)
- Coast ruggedizing: keep probabilities sparse; avoid contiguous conversions that form chokepoints.
- Island seeding: high fractal threshold, small clusters (1–3), enforce min distance to land.
- Humidity gradient: radius ≈ 4; lowland bonus small.
- Orographic shadows: barrier detection up to ~4 tiles; reduction 10–30 range depending on barrier strength.
- River/low-basin bonuses: single-digit to low-teens; stronger at lower elevations.

Open items (next iterations)
- Extract layers: CoastlineLayer, ClimateLayer (BaselineBands vs. EarthlikeRefinement), FeatureLayer rules as data.
- Parameterize wind logic (hemispheric asymmetry/monsoon toggles).
- Add optional telemetry hooks: per-pass timing; rainfall histogram snapshots for smoke tests.
- Trim legacy monitor triggers (keep only markers we actually emit).

Version note
- Internal doc focused on iteration. For the full design and acceptance criteria, see DESIGN.md.
</file>

<file path="_archive/plate-generation-refactor.md">
# Plate Generation Consolidation Plan

_Updated: 2025-10-18_

> **Status**: This plan now folds into the broader world-foundation consolidation captured in `ENGINE_REFACTOR_PLAN.md`. Continue to treat the implementation notes below as background. New work should target the unified `foundation` config model and archive this file once the migration lands.

## 1. Objective
Unify plate generation under a single authoritative pipeline that leverages Civilization VII’s Voronoi utilities (sites, growth, boundary detection) and feeds the Swooper physics stack (WorldModel, landmass shaping, climate). Remove duplicate continent generators and eliminate the concept of “physics disabled.”

## 2. Current State
- Landmass generation now exclusively uses `landmass_plate.js` fed by `WorldModel` stability fields; the legacy continent adapter (`landmassVoronoiLegacy`) has been retired in favor of the Voronoi physics pipeline.
- `WorldModel.init()` (`world/model.js`) computes plates once per map, storing tensors and a frozen `plateSeed` snapshot for diagnostics.
- Physics is mandatory—the legacy `STORY_ENABLE_WORLDMODEL` toggle has been removed and landmass depends on the world stage via the manifest.
- Downstream layers already read WorldModel tensors, but we still need to formalize a `FoundationContext` and expand diagnostics so every consumer shares the same plate metadata explicitly.

## 3. Problems
1. **Double Voronoi Passes:** We pay for two independent Voronoi computations per map. They can disagree, causing rivers, mountains, and story overlays to misalign with continents.
2. **Implicit Fallback:** Disabling WorldModel silently switches to the non-physics path, contradicting the tool’s physics-first mandate.
3. **Opaque Seeding:** Landmass and plate generation each derive seeds in different ways, undermining deterministic replays.
4. **Fragmented Contracts:** Landmass, WorldModel, and diagnostics exchange data via side effects on `GameplayMap` instead of explicit structures.

## 4. Requirements
- **Single Generation Pass:** Plates and landmasses must derive from the same Voronoi seeds and growth routine.
- **Mandatory Physics:** Plate generation cannot be disabled in normal operation; legacy behavior exists only as an opt-in compatibility mode.
- **Deterministic Seeding:** A shared seed (engine RNG + optional offsets) governs the Voronoi run. Diagnostics must log seed values.
- **Structured Outputs:** Plate generation publishes a `PlateSeed` bundle and populates `FoundationContext` with:
  - plate IDs (Int16Array)
  - boundary metadata (type, closeness, movement vectors)
  - uplift/rift potentials
  - shield stability
  - growth windows for landmass carving
- **Extensibility:** The system remains compatible with future physics fields (fault aging, sedimentation) and alternative plate presets.

## 5. Proposed Architecture
1. **PlateSeed Module**
   - New module (`world/plate_seed.js`) exposes `createPlateSeed(dimensions, config)` returning the raw Voronoi sites and RNG state. Uses Civ utilities and obeys seed controls in `FOUNDATION_PLATES`.
   - Logged via diagnostics for replay.
2. **WorldModel Integration**
   - `WorldModel.init()` consumes `PlateSeed` to compute tensors (boundary closeness/type, uplift, etc.) exactly as today, but without re-sampling sites.
   - Stores tensors in `FoundationContext`.
3. **Landmass Generation**
   - ✅ `landmass_plate.js` is the default landmass stage, sourcing WorldModel tensors.
   - ✅ Removed the legacy landmass adapter; no compatibility manifest stage remains.
4. **Manifest & Orchestrator Changes**
   - ✅ `defaults/base.js` sets `stageManifest.order` to use `landmassPlates`.
   - ✅ Retired the `landmassVoronoiLegacy` manifest entry; presets now rely solely on the Voronoi physics pipeline.
   - `stageEnabled()` asserts that `FoundationContext` exists before any morphology stage executes.
   - Removal of `STORY_ENABLE_WORLDMODEL` toggle as a runtime guard; physics is always on.
5. **Diagnostics**
   - `bootstrap/dev.js` gains `logPlateSeed`, `logPlateBoundaries`, and consistency checks (plate/continent overlap).

## 6. Implementation Steps
1. **Seed Extraction**
   - ✅ Split seed logic out of `computePlatesVoronoi()` into `PlateSeedManager`.
   - ✅ Ensure `RandomImpl` state is restored after seed capture.
   - ✅ Update diagnostics to log the captured seed snapshot via `logFoundationSeed`.
2. **WorldModel Refactor**
   - Accept a precomputed seed; remove internal site sampling.  
   - Optionally expose a method to serialize plate tensors for debugging.
3. **Landmass Refactor**
   - Replace `generateVoronoiLandmasses()` calls with `landmass_plate` usage by default.  
   - Rework geometry post-processing to operate on `FoundationContext` data (plate bounding boxes).
4. **Manifest Update**
   - `map_config.types.js` and `defaults/base.js` expose `landmassPlates` as the sole landmass stage identifier.
   - Presets that relied on the legacy landmass fallback (`landmassVoronoiLegacy`) must migrate or be archived.
5. **Cleanup**
   - ✅ Removed the `STORY_ENABLE_WORLDMODEL` toggle and adjusted tunables.  
   - ✅ Deleted `landmass_voronoi.js` from the live pipeline.
6. **Validation**
   - Build regression tests comparing landmask vs. plate boundary coverage.  
   - Ensure mountains, volcanoes, and climate layers now align with plate windows by checking ASCII diagnostics during smoke runs.

## 7. Risks & Mitigations
- **Seed Drift:** Unit tests capture Voronoi sites for known seeds to detect accidental changes.  
- **Legacy Preset Breakage:** Communicate the removal of the legacy continent path; presets must rely on the Voronoi physics pipeline going forward.  
- **Performance Impact:** Monitor initialization time after removing duplicate Voronoi passes; expected decrease, but ensure caching remains optional.

## 8. Deliverables
- `PlateSeed` module + diagnostics.  
- Updated `WorldModel`, `landmass_plate`, and orchestrator using the single source of truth.  
- Documentation updates (`ENGINE_REFACTOR_PLAN.md`, `DESIGN.md`, audit).  
- Tests validating deterministic seeds and plate/landmask alignment.
</file>

<file path="_archive/swooper-maps-architecture-audit.md">
# Swooper Maps Architecture Audit _(Superseded)_

> **Note**: This document is kept for historical context. The current roadmap and refactor plan live in `ENGINE_REFACTOR_PLAN.md`. Refer to that plan for up-to-date stage sequencing, data products, and deliverables.
>
> **Foundation consolidation**: The `worldModel` + `landmass` configuration discussed below has been superseded by the unified `foundation` block documented in `ENGINE_REFACTOR_PLAN.md` and `DESIGN.md`. Treat any references to the legacy config schema as historical only; new work should rely on the `foundation` structure and associated tunables.

## 1. Layer Stack and Shared State

| Stage | Modules | Responsibilities | Primary Inputs | Outputs / Shared State |
| --- | --- | --- | --- | --- |
| Bootstrap & Context | `swooper-desert-mountains.js`, `bootstrap/entry.js`, `bootstrap/resolved.js`, `bootstrap/tunables.js`, `core/types.js`, `core/adapters.js` | Compose defaults + presets + overrides, expose live tunables, create `MapContext` with `CivEngineAdapter` and attach `WorldModel` when enabled. | Map presets, runtime overrides, `BASE_CONFIG`, engine globals. | Live bindings in `tunables`, `MapContext` instance, optional `WorldModel` arrays, Story toggles. |
| Landmass Selection | `map_orchestrator.js`, `layers/landmass_plate.js`, `layers/landmass_utils.js` | Derive landmass windows from plate stability, apply plate-aware ocean separation and geometry post adjustments. | `LANDMASS_CFG`, `LANDMASS_GEOMETRY`, `WorldModel` boundary fields, `ctx`. | Terrain baseline (`GameplayMap`/adapter updates), landmass window metadata for start sectors, landmass ASCII snapshot. |
| Coast & Margin Imprint | `map_orchestrator.js`, `story/tagging.js`, `story/tags.js`, `story/corridors.js`, `layers/coastlines.js`, `layers/islands.js` | Expand coasts, tag margins, apply corridor presets, ruggedize coastlines with corridor & boundary awareness, seed islands respecting StoryTags. | `StoryTags`, `COASTLINES_CFG`, `CORRIDORS_CFG`, `MARGINS_CFG`, `WorldModel` boundary arrays, `ctx`. | Updated terrain/coast features, StoryTag sets for active/passive margins, corridors, hotspot/rift traces. |
| Orogeny & Magmatism | `layers/mountains.js`, `layers/volcanoes.js`, `world/model.js` | Place mountains/hills via WorldModel uplift/boundaries with fractal fallback, depress rifts, weight volcano candidates by boundary type & shield stability. | `MOUNTAINS_CFG`, `VOLCANOES_CFG`, `WorldModel` arrays, `ctx`. | Mountain/hill terrain, volcano features, boundary metrics logs, relief ASCII snapshot. |
| Hydrology & Climate | `elevation-terrain-generator.js` (base), `layers/climate-engine.js`, `story/tagging.js` (swatches, paleo), `map_orchestrator.js` | Generate lakes, baseline rainfall (latitude/orographic/coastal), apply climate swatches & paleo tags, model rivers, refine rainfall with water gradients, orographic lee, corridor & rift microclimates, wind direction. | `CLIMATE_CFG`, `STORY_TUNABLES`, `FOUNDATION_DIRECTIONALITY`, StoryTags, `ctx`. | Rainfall field updates, additional StoryTags (swatches, paleo), corridor ASCII overlays/logs, rainfall ASCII buckets. |
| Biomes & Features | `layers/biomes.js`, `layers/features.js`, `StoryTags`, `tunables` | Re-run vanilla biomes then bias tundra/tropical/river corridors, apply corridor styles, add reefs/vegetation near hotspots & margins with validation. | `BIOMES_CFG`, `FEATURES_DENSITY_CFG`, StoryTag sets, `ctx`. | Biome assignments, feature placements keyed to StoryTags, biome ASCII snapshot. |
| Placement & Finalization | `layers/placement.js`, `map_orchestrator.js` | Run final placement pass (wonders, resources, starts), recalc areas, validate terrain, log rainfall histograms & corridor overlays. | `PLACEMENT_CFG`, map info, previously generated StoryTags, `ctx`. | Final gameplay map surfaces, diagnostic metrics (timings, histograms), `startPositions`. |

**Shared State Pathways**
- `MapContext.adapter` mediates most terrain/feature writes in refactored layers; some legacy calls still use `GameplayMap` directly (e.g., story tagging, base-standard helpers), creating a hybrid access pattern.
- `StoryTags` is mutated across stages: margins are tagged, reset, and re-applied before/after coasts and rivers, so downstream layers rely on the most recent pass.
- `WorldModel` powers landmass separation, coasts, mountains, volcanoes, climate refinement, and corridor directionality; every run initializes its plate tensors and exposes them through the shared context.
- Tunables in `tunables.js` expose frozen group objects; consumers treat them as read-only snapshots for the active generation run.

## 2. Orchestration Pain Points

1. **Config ambiguity around moisture & dryness** — Climate baseline bands, refinement water/orographic deltas, Story swatches, and microclimate rainfall knobs all compete to influence humidity without a unified desert/aridity concept. Builders must tweak multiple groups (`climate.baseline`, `climate.refine`, `story.swatches`, `microclimate.rainfall`) to get predictable deserts. Swatch options split `drynessDelta` vs. `dryDelta`, while rain shadows hard-code subtractions.
2. **Implicit ordering and state resets** — `StoryTags.reset()` happens before and after coast shaping and again after rivers; the orchestrator hard-codes when each tagging function should run, but config does not expose stage ordering. Consumers must read the orchestrator to understand when swatches or corridors fire.
3. **Mixed adapter usage** — Refactored layers accept `MapContext`, yet story tagging, swatches, and corridor tagging still use `GameplayMap` globals. This split complicates future testing and makes it harder to reason about which state mutations bypass context.
4. **Preset vs. override tension** — Presets like `voronoi` toggle WorldModel and geometry, but entries still override the same values. There's no schema-level declaration tying a preset to a stage (e.g., "this preset supplies `landmass.geometry`").
5. **Story layers leak into mechanical passes** — Corridor tagging drives coastlines, biomes, and features through shared StoryTags. Without explicit dependency declarations, it is easy to add a new corridor style that conflicts with coast protection or biome bias.
6. **Diagnostics entwined with gameplay order** — Dev logging lives in the orchestrator, but toggles are global. For example, rainfall histograms run after features regardless of whether climate tuning changed, and corridor ASCII overlays run twice (pre- and post-rivers) without exposing stage timings in config.

## 3. Proposed Orchestration & Config Model

1. **Stage-first orchestration manifest** — Introduce a declarative `stages` array (e.g., in `map_config.types` or a new `orchestration` block) that lists enabled stages and their order (`worldModel`, `landmass`, `coast`, `storySeed`, `relief`, `hydrology`, `climate`, `biome`, `features`, `placement`). The orchestrator should loop this manifest instead of hard-coded calls, letting presets select or skip stages explicitly and codifying the Voronoi physics pipeline so the retired band generator cannot silently return.
2. **Separate foundational vs. narrative config** — Split current `story` and `microclimate` knobs into (a) **Climate Drivers** (baseline bands, pressure cells, aridity controls) and (b) **Narrative Overlays** (swatches, paleo, corridors). Ensure dryness controls live in the climate driver group with additive deltas referenced by overlays.
3. **Unify moisture schema** — Replace `drynessDelta`, `dryDelta`, and implicit lee subtractions with a shared `moistureAdjustments` schema (`{ target: "desert" | "rainbelt" | ... , magnitude, radius, elevationBias }`). Climate baseline would consume global defaults; swatches would just add entries to the adjustment set.
4. **Context-only surface** — Migrate remaining story/tagging passes onto `MapContext.adapter` and store StoryTags inside `ctx` so every pass consumes the same state object. This enables instrumentation and testing without engine globals.
5. **Preset capabilities** — Let presets declare which stage groups they configure (e.g., `presets.voronoi.stages = { foundation: true, landmassPlates: true }`). The resolver can warn when an override touches a stage that is disabled or missing dependencies.
6. **Config-driven diagnostics** — Add a `diagnostics` group that allows presets to request histogram/log timing per stage. The orchestrator would honor the stage manifest when running logs, keeping metrics in `ctx.metrics` for later reporting.

## 4. Tunable Surface Audit & Gaps

| Group | Current Purpose | Pain / Gap | Recommendation |
| --- | --- | --- | --- |
| `toggles` | Master Story/WorldModel switches. | Lacks link to stage manifest; toggles may be inconsistent with preset stage choices. | Fold into stage manifest so disabling a stage removes dependent layers automatically. |
| `story` (`hotspot`, `rift`, `orogeny`, `swatches`, `paleo`) | Narrative overlays that tag StoryTags. | Swatches double-encode moisture (`drynessDelta` vs `dryDelta`); paleo mixes humidity boosts with canyon dryness. | Convert to overlay descriptors referencing shared moisture/terrain primitives; split paleo humidity vs. terrain carving. |
| `microclimate` | Rainfall & feature deltas tied to StoryTags. | Overlaps with climate refinement (both adjust rainfall near rifts/hotspots). | Move rainfall effects into climate refinement stage inputs; keep feature probabilities in a `features.hotspot` namespace. |
| `landmass` / `geometry` | Controls for ocean width, band layout, plate modes. | Geometry mode toggles live separately from stage enabling, and presets rely on runtime inference. | Add explicit `landmass.mode` enumeration in orchestration config; include dependencies (requires worldModel). |
| `coastlines`, `margins`, `islands` | Margin tagging, coast ruggedness, island spawning. | Corridor policy interacts indirectly; config cannot declare that a style reserves bays/fjords. | Let corridor styles specify coast allowances; coast layer reads style metadata rather than StoryTags only. |
| `climate.baseline` / `climate.refine` | Base rainfall and refinement deltas. | Many knobs hard-code assumptions (band weights, lee dryness) and lack explicit desert/steppe targets. | Introduce climate "profiles" (e.g., arid, humid, monsoon) with explicit dryness/precip thresholds; allow presets to select profile rather than tweaking numbers piecemeal. |
| `mountains`, `volcanoes` | Plate-aware relief tunables. | Already stage-aligned but missing guardrails about worldModel availability. | Validate at resolution time; warn if worldModel disabled while relief tunables specify plate weights. |
| `biomes`, `featuresDensity` | Gentle biome/feature biases. | Corridor bias config sits here but corridors defined elsewhere. | Move corridor-specific bias knobs under the corridor styles to keep concerns localized. |
| `corridors` | Sea/land/river lane policies and styles. | No explicit handshake with coast/biome layers; styles hold nested behavior but not staged enabling. | Allow stage manifest to reference corridor tags as dependencies; add validation that lanes exist before dependent stages run. |
| `placement`, `dev` | Final placement tweaks and logging toggles. | Dev flags are global booleans, not stage-aware. | Promote to `diagnostics` with per-stage logging controls. |
| `worldModel` | Plate, wind, current settings plus ocean separation policy. | Currently stored under `storyEnableWorldModel` toggle; ocean separation interacts with landmass geometry indirectly. | Move ocean separation controls under landmass stage config; keep worldModel focused on physical simulation parameters. |

Missing concepts:
- **Explicit desert/aridity controls** — No direct way to set target desert coverage or tie dryness to plate interiors without editing multiple groups.
- **River & basin policy** — Rivers still use base-engine parameters; corridor and paleo systems hint at adjustments but no config surface exposes them.
- **Validation thresholds** — No config for acceptable map metrics (water %, mountain %, start failures) despite logging stats.

## 5. Observability & Tooling Gaps

- **Stage metrics registry** — `dev.js` exposes timers and ASCII logs, but timings are stored as console output. Capturing them in `ctx.metrics.timings` would enable automated regression checks.
- **StoryTag & climate visualization** — Core diagnostics now emit ASCII grids for landmass windows, plate boundaries, relief, rainfall buckets, corridors, and biome outcomes. We still lack snapshots for swatches/paleo traces or rainfall deltas introduced by specific microclimate overlays; with the headless stub gone we need a FireTuner/CLI capture path (e.g., JSON dumps triggered by `DEV.LOG_*` toggles) to persist those arrays for validation.
- **Config validation** — Resolver merges configs but does not warn when stage dependencies are unsatisfied (e.g., enabling plate ocean separation without worldModel). Add schema validation hooks before `deepFreeze`.
- **Test harness** — No Vitest coverage around orchestration order or config resolution. A small suite asserting stage manifest compliance would catch regressions before game runtime.
- **Plan alignment** — Phase 2 in `PLATE_REFACTOR_PLAN.md` calls for auditing climate/coast consumers of WorldModel data; current mixed adapter usage makes that audit difficult without instrumentation.

## 6. Recommended Next Steps

1. Design the orchestration manifest schema and update `map_config.types.js` plus resolver to understand stage groupings.
2. Refactor the orchestrator to consume the manifest, migrating each stage call into dedicated handlers that accept `ctx` and stage config.
3. Normalize moisture controls by introducing climate profiles and migrating swatch/microclimate settings to the shared schema.
4. Port remaining StoryTag producers to use `MapContext.adapter` and store tags within `ctx` to remove global state.
5. Extend presets to declare stage participation; add resolver validation that warns when presets and overrides conflict with stage availability.
6. Build lightweight observability helpers that capture per-stage metrics into `ctx.metrics`, and surface CLI/FireTuner tooling to dump them now that headless output is gone, aligning with Phase 2/3 checkpoints in the refactor plan and supporting deterministic regression capture.
</file>

<file path="_archive/terrain-feature-verification.md">
# Epic Diverse Huge Map Generator — Terrain and Feature Verification (v1.0.0)

Purpose
- Document what this script sets directly vs. what it delegates to the base generators.
- Clarify the terrain, biome, and feature types referenced by the script, and how placement is validated at runtime.
- Remove outdated claims from earlier drafts (e.g., “aggressive cliffs,” “tripled lakes,” “doubled wonders”).

Scope
- Version: 1.0.0
- Target: Civilization VII (Huge maps prioritized)
- Dependencies: Base-standard map generation modules provided by the game/core modules at runtime

Summary of actual behavior in v1.0.0
- Landform:
  - Three-band continental layout with true oceans; coastlines ruggedized; small deep-water island clusters.
- Elevation/Water:
  - Mountains, hills, volcanoes, rivers, and lakes come primarily from the base generators.
  - Lakes are moderated vs. earlier experiments (not “3x”).
- Climate/Regions:
  - Two-phase rainfall: base + latitude bands, then earthlike refinements (coastal/lake humidity gradients, prevailing-wind orographic shadows, river-corridor and low-basin wetness).
- Biomes/Features:
  - Base biome and feature passes run first.
  - Script performs restrained biome nudges and targeted feature density increases, validated by engine checks.
- Wonders:
  - Natural wonders are slightly increased relative to map defaults (+1), not doubled.

What this script sets directly
- Terrain types (explicit set operations by this script):
  - globals.g_OceanTerrain
  - globals.g_CoastTerrain
  - globals.g_FlatTerrain
  - Notes:
    - Mountains/Hills/Volcanoes are not directly set here; they are added by base generators (`addMountains`, `addHills`, `addVolcanoes`).
    - Rivers are modeled/defined via base calls (`TerrainBuilder.modelRivers`, `TerrainBuilder.defineNamedRivers`).
    - Navigability parameters are passed using `globals.g_NavigableRiverTerrain`.
- Rainfall:
  - The script calls the base rainfall builder, blends with latitude bands, then refines post-rivers.
  - Rainfall values are clamped to [0, 200] in all passes.
- Biomes (post-base nudges):
  - globals.g_TundraBiome — applied only at very high latitude or extreme elevation when rainfall is low.
  - globals.g_TropicalBiome — encouraged on warm, wet, equator-adjacent coasts.
  - globals.g_GrasslandBiome — favored along warm/temperate river valleys with sufficient rainfall.
- Features (post-base additions):
  - FEATURE_RAINFOREST — in very wet tropical areas.
  - FEATURE_FOREST — in wetter temperate grasslands.
  - FEATURE_TAIGA — in cold tundra at lower elevations.

Validation and safety guarantees
- Feature placement is always gated by the engine:
  - The script checks `TerrainBuilder.canHaveFeature(iX, iY, featureId)` before calling `TerrainBuilder.setFeatureType`.
- Feature type resolution is data-driven:
  - `GameInfo.Features.lookup(name)` → `$index` or no result.
  - If lookup fails, the code returns `-1` and skips placement.
- Biome assignment uses engine constants and applies only when the tile is land and passes climate/latitude/elevation thresholds.
- Terrain operations include bounds checks on all neighborhood scans (coasts, islands, rainfall refinement, water-distance, etc.).
- Rainfall and related calculations are clamped (0–200) to avoid out-of-range states.
- Orographic barrier detection is robust:
  - Uses `GameplayMap.isMountain(nx, ny)` when available; otherwise falls back to elevation thresholds (e.g., ≥500) to infer a barrier.

Dependencies and assumptions
- The following identifiers are provided by base-standard modules at runtime:
  - Terrain constants: `globals.g_OceanTerrain`, `globals.g_CoastTerrain`, `globals.g_FlatTerrain`, `globals.g_NavigableRiverTerrain`
  - Biome constants: `globals.g_TundraBiome`, `globals.g_TropicalBiome`, `globals.g_GrasslandBiome`
  - Feature names: `"FEATURE_RAINFOREST"`, `"FEATURE_FOREST"`, `"FEATURE_TAIGA"`
- Base generators handle:
  - Coast expansion, mountains, hills, volcanoes, baseline rainfall map, lake generation, base biomes, base features, resources, snow, floodplains, natural wonders, and discovery sites.
- If a referenced feature or biome is not present in the active data set, the script’s validation/lookup logic prevents invalid placement.

Known non-goals (v1.0.0)
- No custom cliff system or aggressive cliff proliferation.
- No direct mountain placement or heavy mountain chaining beyond base behavior.
- No “tripled” lake density; lakes are tuned for balance within the three-band landmass layout.
- No hardcoded numeric feature IDs; all feature types are resolved via the game database.

Runtime verification checklist (how to confirm in your environment)
- Ensure the base-standard modules are available (they provide terrain/biome/feature definitions and the base generators).
- Enable the map, start a Huge game, and confirm:
  - Oceans separate three main land bands with organic coastlines.
  - Rivers exist and named rivers are defined; green corridors appear plausibly in warm/temperate zones.
  - Drier leeward regions exist behind mountain barriers appropriate to the latitude’s prevailing winds.
  - Tropical coasts near the equator appear where rainfall is high; tundra is restrained to extreme latitude/elevation and low rainfall.
- Optional: Uncomment the JSON “start/complete” logs in the script to aid monitoring.
- Optional: Temporarily enable the script’s commented debug dumps for rainfall/biomes/elevation while testing locally.

Change log vs. earlier drafts
- Removed references to “extensive cliff systems,” heavy mountain amplification, and “tripled” lakes.
- Clarified that wonders are slightly increased (+1 vs. defaults), not doubled.
- Emphasized compatibility-first design: base systems lead; script applies gentle climate/biome refinements and validated feature adjustments.

Conclusion
- In v1.0.0, the terrain/feature/biome usage is intentionally conservative and validation-driven.
- The script relies on base-standard definitions and generators, adds climate-aware refinements, and performs safe, validated post-passes for biomes and features.
- This approach yields organic, believable regions while maintaining balance and compatibility with the base game.
</file>

<file path="_archive/xml-first-crawl-plan.md">
## XML-first crawl plan (archived)

This document is now archived. The plan has been implemented in the CLI on branch `feature/cli-crawl-render-slice` and will be maintained via `FEATURES.md`.

### Objectives
- **Depth**: Resolve Trait → Modifier → RequirementSet → Requirement → Arguments chains, plus cross-links (Units, Improvements, Buildings, etc.).
- **Provenance**: Keep file paths for each node to enable manifest slicing.
- **Portability**: No external binaries. Works on the raw XML resources.
- **Performance**: Scalable to the full resources folder with reasonable memory/latency.

### Sources to index
- **Database XML** (classic): `<Database><Table><Row .../></Table></Database>`
  - Examples: `Leaders`, `Civilizations`, `Traits`, `LeaderTraits`, `CivilizationTraits`, `TraitModifiers`, `Units`, `Buildings`, etc.
- **GameEffects XML**: `<GameEffects><Modifier ...> ... </Modifier></GameEffects>`
  - Contains the bulk of gameplay logic. Must be normalized into our unified data model.
- Optional (later): SQL files that `INSERT/DELETE/UPDATE` gameplay tables.

### Unified data model
- Node identity: `NodeKey = { table: string, id: string }`.
- Primary keys: keep a per-table PK map; for synthesized nodes, use deterministic IDs.
- Tables (real + synthesized):
  - Real: `Leaders`, `Civilizations`, `Traits`, `LeaderTraits`, `CivilizationTraits`, `TraitModifiers`, `Modifiers`, `ModifierArguments`, `RequirementSets`, `RequirementSetRequirements`, `Requirements`, `RequirementArguments`, `Units`, `Buildings`, `Districts`, `Improvements`, `Resources`, `Technologies`, `Civics`, etc.
  - Synthesized (from GameEffects):
    - `Modifiers` from `<Modifier id="..." collection="..." effect="..." permanent="...">`.
    - `ModifierArguments` from child `<Argument name="..." value?="...">`.
    - `RequirementSets`/`Requirements`/`RequirementArguments` from `<SubjectRequirements>` / `<OwnerRequirements>` blocks.
    - Attach chains via `Argument name="ModifierId"` that reference other modifiers.

### Indexing strategy (two-pass)
1) Parse pass (build indices)
   - Walk resources dir; parse XML.
   - Database XML: collect tables and rows; index by column values; record `__file` provenance.
   - GameEffects XML: normalize into synthetic rows:
     - Emit one `Modifiers` row per `<Modifier>` (`ModifierId = @id`).
     - For each `<Argument name=...>` emit a `ModifierArguments` row: `{ ModifierId, Name, Value }` (use attributes or inner text; keep both if present).
     - For requirements blocks, synthesize `RequirementSets` + `RequirementSetRequirements` + `Requirements` + `RequirementArguments`:
       - Deterministic IDs, e.g. `REQSET_{ModifierId}_SUBJECT`, `REQ_{ModifierId}_SUBJECT_{seq}`; same for OWNER.
       - Link the generated set back to the modifier via `SubjectRequirementSetId`/`OwnerRequirementSetId` on the synthesized `Modifiers` row.
     - For nested attach: if an `Argument` has `Name="ModifierId"`, record an edge target `Modifiers` with that value.
   - Apply remove/override semantics:
     - Respect `<Delete .../>` rows in Database XML (e.g., `remove-data.xml`).
     - Last-write-wins by ID across files (Base < DLC), but keep file provenance of the winner.

2) Link pass (graph build)
   - Create edges only where targets exist; prune dangling references.
   - Edge rules (non-exhaustive initial set):
     - `LeaderTraits(LeaderType) → Leaders`
     - `LeaderTraits(TraitType) → Traits`
     - `CivilizationTraits(CivilizationType) → Civilizations`
     - `CivilizationTraits(TraitType) → Traits`
     - `TraitModifiers(TraitType) → Traits`
     - `TraitModifiers(ModifierId) → Modifiers`
     - `Modifiers(SubjectRequirementSetId|OwnerRequirementSetId) → RequirementSets`
     - `RequirementSets → RequirementSetRequirements → Requirements → RequirementArguments`
     - `ModifierArguments(Name=BuildingType|UnitType|ImprovementType|DistrictType|ResourceType|TechnologyType|CivicType|AgendaType) → target tables`
     - `ModifierArguments(Name=ModifierId, Value=...) → Modifiers` (attach chain)

### Layering & deletes
- Implement minimal merge logic sufficient to avoid ghost nodes:
  - Apply `<Delete>` from Database XML.
  - On duplicate PK: use the last parsed row (deterministic traversal order: Base first, then DLC; within a directory, lexicographic).
  - After link pass, drop edges pointing to non-existent nodes.

### Provenance & manifest
- Every row carries `__file` (source path). Graph manifest is `unique(files(nodes))`.
- `slice` copies files relative to config `extract_path` into a destination for smaller reproductions.

### Performance
- Concurrency: async directory walk + parse with a small pool (e.g., 8–16 files at a time).
- Memory: store compact row objects; avoid duplicating large text fields.
- Indexes: per-table column maps (`Map<column, Map<value, Row[]>>`) for fast joins.

### CLI integration
- `civ7 crawl <seed>`: uses config `unzip.extract_path` by default; outputs to `out/<seed>`.
- `civ7 render <seed>|<dotPath>`: renders DOT → SVG via WASM Graphviz.
- `civ7 slice <manifestPath>`: copies only the files listed by manifest.

### Milestones
- Phase 1: GameEffects normalization (Modifiers + Arguments + basic Subject/Owner requirement sets).
- Phase 2: Attach chains (ModifierId argument → Modifiers), full RequirementArguments coverage.
- Phase 3: Column-to-table cross-link map expansion (Buildings, Improvements, Units, etc.).
- Phase 4: Remove-data + last-write-wins layering; edge pruning.
- Phase 5: Performance and logging (counts, timings, skipped files).
- Phase 6: Documentation & examples (ROME, GENGHIS seeds).

### Non-goals
- Evaluating effects or simulating gameplay.
- Building a full relational DB state. We only resolve identifiers and edges.

### Risks & mitigations
- Variant attribute names (e.g., `ModifierID` vs `ModifierId`): normalize keys case-insensitively.
- Mixed shapes (text vs attributes for values): support both and prefer attributes when present.
- Future schema drift: guard with best-effort parsing and continue on per-file failures.

### Implementation status
- Implemented: GameEffects normalization, attach-chains, requirement set synthesis, layering and deletes, provenance.
- Verified on seeds: `CIVILIZATION_ROME`, `LEADER_GENGHIS_KHAN`.
- Visualization improvements tracked in `FEATURES.md`.
</file>

<file path="process/CONTRIBUTING.md">
# Contributing to Civ7 Modding Tools

This repository is a pnpm + Turborepo monorepo with a Bun-first developer experience.

## Prerequisites
- Node 20 (see `.nvmrc`)
- Optional: pin pnpm via Corepack for reproducibility
  ```bash
  pnpm run setup:corepack
  ```

## Getting Started
```bash
pnpm install
pnpm build
pnpm test
```

### Developing the CLI (@civ7/cli)
- Local dev (Bun):
  ```bash
  pnpm -F @civ7/cli dev
  ```
- Global link (Node):
  ```bash
  pnpm -F @civ7/cli run build
  pnpm -F @civ7/cli link --global
  civ7 --help
  ```
These are independent; local dev runs source via Bun; global link runs installed binary.

### Workspace apps/packages
- Docs (Docsify, Bun-first):
  ```bash
  pnpm -F @civ7/docs run dev
  pnpm -F @civ7/docs run fix:links
  ```
- CLI (@civ7/cli):
  ```bash
  pnpm -F @civ7/cli run build
  node packages/cli/bin/run.js --help
  ```
- SDK (@civ7/sdk):
  ```bash
  pnpm -F @civ7/sdk run build
  ```
- Playground (Bun):
  ```bash
  pnpm -F @civ7/playground run dev
  ```

### Root convenience scripts
- Dev per package:
  ```bash
  pnpm dev:cli
  pnpm dev:sdk
  pnpm dev:docs
  pnpm dev:playground
  ```
- Run CLI from root (Bun):
  ```bash
  pnpm cli -- <civ7-command-and-args>
  # example
  pnpm cli unzip default
  ```

## Outputs policy
- No outputs at repo root.
- Defaults and configuration live in `civ.config.jsonc`. All CLI commands write to a central `.civ7/outputs` directory by default.
- Apps like `docs` are responsible for pulling the resources they need from `.civ7/outputs` as part of their build/dev process. They should not be written to directly by the CLI.
- Defaults:
  - Base outputs: `.civ7/outputs`
  - Zip archives: `.civ7/outputs/archives`
  - Unzip directory: `.civ7/outputs/resources`
  - Graph exports: `.civ7/outputs/graph/<seed>`
- Docs: served directly from `apps/docs/site` (no build/dist by default)
- SDK: emits to `packages/sdk/dist`
- Playground: generated content remains under its app directory

## Publish readiness (Phase 9)
- SDK: `pnpm -F @civ7/sdk pack` (validation only; do not commit `.tgz`)
- CLI: `pnpm -F @civ7/cli run build && pnpm -F @civ7/cli link --global && civ7 --help`

### Publishing via tags (CI)
Prerequisite: In GitHub → Settings → Secrets and variables → Actions, add secret `NPM_TOKEN` (npm automation token with publish permission).

From the repo root, create and push one of the following tags:

```bash
# Publish both SDK and CLI
git tag vX.Y.Z && git push origin vX.Y.Z

# Publish only SDK
git tag sdk-vX.Y.Z && git push origin sdk-vX.Y.Z

# Publish only CLI
git tag cli-vX.Y.Z && git push origin cli-vX.Y.Z
```

The `Publish Packages` workflow will build, lint, test, typecheck, then publish the targeted package(s). If `NPM_TOKEN` is missing, the publish steps are skipped.

### Local publish (optional)
From repo root:
```bash
pnpm publish:sdk   # publish SDK
pnpm publish:cli   # publish CLI
pnpm publish:all   # SDK then CLI
```

## Coding style
- 2-space indentation (see `.editorconfig`)
- ESLint flat config at root (`eslint.config.js`)
- Prefer small, focused PRs

## Commit
```bash
git checkout -b feat/your-change
# make changes
pnpm test
git commit -m "feat: concise description"
```
</file>

<file path="process/GRAPHITE.md">
# Graphite Stacked Pull Requests Workflow

This document provides comprehensive guidance for using Graphite's stacked PR workflow in the magic-temp repository. **All AI agents and developers should use stacked PRs for future commits** to maintain clean, reviewable, and incrementally mergeable work.

## Table of Contents
1. [Why Stacked PRs](#why-stacked-prs)
2. [Core Concepts](#core-concepts)
3. [Stacks & Milestones](#stacks--milestones)
4. [Essential Commands Reference](#essential-commands-reference)
5. [Quick Start Workflow](#quick-start-workflow)
6. [Stack Operations & Iteration](#stack-operations--iteration)
7. [Sync and Collaboration](#sync-and-collaboration)
8. [Merging and Cleanup](#merging-and-cleanup)
9. [Commit Hygiene Best Practices](#commit-hygiene-best-practices)
10. [GitHub Configuration](#github-configuration)
11. [Common Scenarios](#common-scenarios)
12. [Troubleshooting](#troubleshooting)
13. [Additional Resources](#additional-resources)

---

## Why Stacked PRs

Stacked PRs solve the problem of large, monolithic pull requests by breaking work into small, logically dependent changes. Benefits include:

- **Faster Reviews**: Reviewers can approve small, focused PRs incrementally
- **Parallel Progress**: Work on next layers while earlier ones are in review
- **Clear Dependencies**: Stack structure shows logical build order
- **Easy Rollback**: Can abandon upper layers without losing lower work
- **Better Context**: Each PR represents one atomic, understandable change
- **Reduced Conflicts**: Smaller changes = fewer merge conflicts

For refactoring work (like Stage 6 service extraction), stacked PRs are essential for maintaining velocity while ensuring quality.

---

## Core Concepts

### Branch Stack
A "stack" is a series of branches where each branch builds on top of the previous one. The base of the stack is your trunk branch (typically `main`).

```
◉ part_3 (current)          ← Top of stack
│
◯ part_2                     ← Middle layer
│
◯ part_1                     ← Base layer
│
◯ main                       ← Trunk
```

### Upstack vs Downstack
- **Downstack**: Branches below the current branch (closer to trunk)
- **Upstack**: Branches above the current branch (farther from trunk)

### Restacking
When you modify a branch in the middle of a stack, Graphite automatically rebases all upstack branches to incorporate your changes. This keeps the stack consistent.

---

## Stacks & Milestones

Milestones describe *what* needs to ship; Graphite stacks describe *how* we stage the Git history to ship it. Even when Linear is unavailable, each milestone document (see `docs/projects/monorepo-refactor/milestones/*.md`) must spell out the stacks required to complete that milestone.

- **One milestone, many stacks:** Break parent-level workstreams into independent stacks. Each stack originates from `main` (or the current trunk) and may contain one branch (small issue) or several layers (ordered subtasks of the same parent issue).
- **Sequencing:** Within a stack, layers must merge bottom-to-top. Use stacks for chains that have strict dependencies (e.g., ANVIL-29 → ANVIL-42). Document that order under the milestone’s *Sequencing & Parallelization Plan* so reviewers know why one PR blocks another.
- **Parallelization:** Separate stacks can progress simultaneously as long as their prerequisites are satisfied. Capture these parallel tracks in the same plan so the team knows which stacks can run in parallel and which must pause until a dependency merges.
- **No Linear?** Reference the milestone doc directly when naming stacks/branches (e.g., `m3-stack-a-anvil-29`). The milestone still owns the source of truth for stack membership, so downstream collaborators can trace a branch back to its milestone context without Linear links.
- **Sub-issues:** Reserve additional stack layers for sub-issues that need their own PRs. Smaller checklist items stay as commits within the parent branch to keep stacks short and reduce restack churn.

Every milestone doc must include a “Sequencing & Parallelization Plan” that lists the active stacks (e.g., Stack A, Stack B) and the issues/layers assigned to each. Mirror that plan in Linear (when used) so the issue tracker and Git workflow stay in sync.

---

## Essential Commands Reference

| Command | Alias | Purpose |
|---------|-------|---------|
| `gt init` | - | Initialize Graphite in repository |
| `gt create -am "msg"` | `gt c -am` | Create new branch + commit |
| `gt create --insert` | `gt c -i` | Insert branch in middle of stack |
| `gt submit --stack` | `gt ss` | Submit all PRs in stack |
| `gt submit --stack --update` | `gt ss -u` | Update existing PRs |
| `gt modify --all` | `gt m -a` | Amend current branch |
| `gt modify --commit` | `gt m --commit` | Add new commit to branch |
| `gt sync` | - | Sync with remote + restack |
| `gt sync --force` | `gt sync -f` | Force sync (no prompts) |
| `gt checkout` | `gt co` | Interactive branch picker |
| `gt log short` | `gt ls` | Show branch hierarchy |
| `gt stack` | - | Show current stack details |
| `gt restack` | - | Rebase stack after changes |
| `gt squash` | - | Squash commits in branch |
| `gt fold` | `gt f` | Fold branch into parent |
| `gt get [branch]` | - | Fetch coworker's stack |
| `gt track` | `gt tr` | Track external branch |
| `gt merge` | - | Merge stack via Graphite |
| `gt bottom` | - | Jump to bottom of stack |
| `gt trunk` | - | Jump to trunk branch |

---

## Quick Start Workflow

### Initial setup

```bash
gt init            # First run only – picks trunk (main)
gt sync && gt checkout main
```

### Build a stack in layers

1. Make a focused change for the first layer and run `gt create -am "feat(scope): summary"`.
2. Repeat for each dependent layer (implementation → integration → tests → docs, etc.).
3. Use `gt ls` to confirm the stack order and `gt co branch-name` to jump between layers.

### Submit and keep iterating

```bash
gt ss                 # Submit the stack (or gt ss -u to update)
gt modify -a          # Amend current branch after edits
gt create -i -am "..."  # Insert a forgotten layer between existing ones
```

Graphite will restack any upstack branches automatically when you amend or insert.

### Before hand-off

- `gt ls` – verify the review order (always bottom → top).
- `gt squash` – ensure single commit per branch when needed.
- `gt ss -u` – push final state, then document PR links + dependencies in your hand-off notes.

📌 **Milestone-specific templates** (e.g., Stage 6 service extraction) now live in the active milestone doc under `docs/projects/` to avoid duplication here.

## Stacking In Practice

Think of a stack as a river you step into when a parent issue spawns a chain of dependent changes. Open the first branch for the base issue (e.g., ANVIL-29), then add new layers for every PR-worthy sub-issue while smaller checkboxes stay behind as commits on those layers. Each branch in the stack is self-standing—it maps either to its own Linear issue or to a slim slice of work that would make sense as its own PR outside the stack. Ship downstream momentum by merging bottom-to-top: once reviewers approve the lowest branch, merge it, restack, and immediately pick up the next layer without leaving the river. If a new insight appears, `gt create --insert` drops another stone midstream without rewriting history; if a layer proves unnecessary, `gt fold` or delete the branch so the flow keeps moving. The stack “finishes” when every required layer has merged, but it stays fluid the whole way—layers land incrementally, issues stay traceable through branch names/PR titles, and folding lets you bail gracefully without losing the progress already downstream.

---

## Stack Operations & Iteration

### Creating Branches with Different Strategies

**Let Graphite infer branch name from commit message:**
```bash
gt create -am "feat(api): Add user fetching endpoint"
# Creates branch: feat-api-add-user-fetching-endpoint
```

**Specify branch name explicitly:**
```bash
gt create -am "feat: Add API endpoint" my-custom-branch-name
```

**Stage changes interactively:**
```bash
# Make changes
echo "code" >> file.js

# Add specific files
gt add file.js another.js

# Create commit on new branch
gt create -m "feat: Add feature"
```

**Use patch mode (select hunks):**
```bash
gt create --patch --message "feat: Partial changes"
# or alias: gt c -pm "feat: Partial changes"
```

### Visualizing Your Stack

**Short format (recommended):**
```bash
gt log short
# or alias: gt ls
```

**Detailed format:**
```bash
gt log
# Shows commit hashes, ages, PR links

gt stack
# Shows current stack only
```

### Navigating Between Branches

**Interactive selection:**
```bash
gt checkout
# Opens picker with all branches
# Use arrow keys + Enter
```

**Direct checkout:**
```bash
gt checkout branch-name
# or alias: gt co branch-name
```

**Jump to trunk:**
```bash
gt trunk
```

**Jump to bottom of stack:**
```bash
gt bottom
```

### Editing Existing Layers

**Amend a single-commit branch**
```bash
gt checkout <branch>
# edit files
gt modify -a            # or gt m -a
gt ss -u                # update matching PR
```
Graphite automatically restacks every upstack branch after the amend.

**Add a follow-up commit instead of amending**
```bash
gt checkout <branch>
# edit files
gt modify --commit -am "describe change"
gt ss -u
```
Use this when reviewers prefer seeing the delta before you squash.

**Address review feedback** by using either approach above or (if you already amended via Git) running `gt restack` so dependent branches pick up the change.

### Inserting or Splitting Branches

**Insert a forgotten layer between two branches**
```bash
gt checkout <parent-branch>
# edit files
gt create --insert --all --message "feat(scope): describe layer"
gt ss
```

**Split an oversized branch into two**
```bash
gt checkout <large-branch>
git reset HEAD~1        # keep changes staged
gt add fileA.ts fileB.ts
gt create -m "feat: Part 1"
gt add remaining files
gt create -m "feat: Part 2"
```
Delete the old branch after verifying the new stack order.

---

## Sync and Collaboration

### Keeping Your Stack Updated

**Standard sync (recommended before starting work):**
```bash
gt sync
# Pulls latest main, deletes merged branches, restacks all stacks
```

**Force sync (skip confirmations):**
```bash
gt sync --force
# or alias: gt sync -f
```

**Sync without restacking (manual control):**
```bash
gt sync --no-restack
# Then manually restack:
gt restack
```

**Sync across all trunks (if using multiple):**
```bash
gt sync --all
```

### Working with Coworkers' Stacks

**Fetch a coworker's entire stack:**
```bash
gt get coworker-branch-name
# Fetches branch + all downstack dependencies
```

**Fetch only downstack branches:**
```bash
gt get coworker-branch-name --downstack
```

**Example scenario:**
```bash
# Coworker A creates and pushes a stack
gt create my_feature_branch -m "Add feature"
gt submit

# Coworker B (or you on another machine) pulls it
gt get my_feature_branch
# Now you have the entire stack locally
```

### Collaborating on Non-Graphite Branches

If a coworker created a branch with standard Git:

```bash
# Pull their changes
git pull

# Bring into Graphite workflow
gt track
# or alias: gt tr

# Now you can use gt commands on this branch
# Note: Graphite will rebase during gt sync
```

### Avoiding Conflicts

**Before making changes:**
```bash
gt sync  # Get latest from main
```

**If you encounter conflicts during restack:**
```bash
# Graphite will pause rebase
# Resolve conflicts in your editor
git add resolved_files.js
gt continue

# If you want to abort:
git rebase --abort
```

**After merges to main:**
```bash
gt sync && gt restack && gt submit --stack
```

---

## Merging and Cleanup

### Merging via Graphite (Recommended)

**Interactive merge:**
```bash
gt merge
# Prompts for confirmation before each PR
```

**Dry run (preview what would be merged):**
```bash
gt merge --dry-run
```

**Force merge (no confirmations):**
```bash
gt merge --confirm
```

### Merging via GitHub UI

If you merge PRs manually through GitHub:

```bash
# After merging bottom PR(s)
gt sync
# Cleans up merged branches locally
# Restacks remaining PRs in stack

# Push any restacked changes
gt submit
```

**Important:** Always merge from bottom to top of the stack. Graphite handles this automatically, but if merging manually, follow dependency order.

### Post-Merge Cleanup

```bash
# Sync after merge
gt sync

# Graphite will:
# 1. Pull latest main
# 2. Delete merged branches
# 3. Restack any remaining work
# 4. Prompt for confirmation

# Output:
# 🌲 Pulling main from remote...
# 🧹 Checking if any branches have been merged/closed...
# ✔ feat-add-database-schema is merged into main. Delete it? … yes
# Deleted branch feat-add-database-schema
# Restacked feat-implement-service-layer on main.
```

---

## Commit Hygiene Best Practices

### One Logical Change Per Branch

Each branch should represent a single, reviewable unit of work:

✅ **Good:**
```bash
gt create -am "feat(service): Add FilterOperations service class"
gt create -am "feat(registry): Wire service into registry"
gt create -am "test: Add service tests"
```

❌ **Bad:**
```bash
gt create -am "feat: Add service, update registry, add tests, fix bug"
```

### Single Commit Per Branch (Recommended)

Maintain one commit per branch for cleaner history:

**If you have multiple commits, squash them:**
```bash
gt log
# ◉ my-feature (current)
# │ abc123 - third change
# │ def456 - second change
# │ ghi789 - first change

gt squash
# Opens editor to rename the single commit

gt log
# ◉ my-feature (current)
# │ jkl012 - consolidated feature
```

**Use amend workflow:**
```bash
gt create -am "feat: Initial implementation"

# Make more changes
gt modify -a  # Amends instead of new commit

# Make even more changes
gt modify -a  # Amends again
```

### Conventional Commit Messages

Follow Conventional Commits format (matches repo standards):

```bash
feat: Add new feature
feat(scope): Add scoped feature
fix: Fix bug in filter operations
refactor: Restructure service layer
test: Add tests for FilterOperations
docs: Update API documentation
chore: Update dependencies
```

**Examples from Stage 6:**
```bash
gt create -am "feat(types): Define FilterOperations service interface"
gt create -am "feat(service): Implement FilterOperations class"
gt create -am "feat(registry): Add service to operations registry"
gt create -am "refactor: Migrate useFilterOperations to service"
gt create -am "test: Add FilterOperations service tests"
```

### Descriptive Branch Names

Graphite auto-generates branch names from commit messages:

```bash
gt create -am "feat(api): Add user authentication endpoint"
# Creates: feat-api-add-user-authentication-endpoint
```

**Override if needed:**
```bash
gt create -am "feat: Complex feature" auth-service
# Creates: auth-service
```

### Folding Branches for Consolidation

If you realize two branches should be one:

```bash
gt log
# ◉ add-validation (current)
# ◯ add-types
# ◯ main

# Fold add-validation into add-types
gt fold
# or alias: gt f

# Result:
# ◉ add-types (current)
# │ All commits from both branches
# ◯ main
```

---

## GitHub Configuration

For stacked PRs to work correctly, configure these GitHub repository settings:

### Required Settings (Disable)

1. **"Require approval of the most recent reviewable push"**: **Disabled**
   - Graphite changes target branches during merge
   - These changes count as reviewable pushes
   - Enabled = merge failures

2. **"Require merge queue"**: **Disabled**
   - GitHub merge queue doesn't support stacked PRs
   - Can merge out of order → inconsistent state
   - Use Graphite Merge Queue instead

3. **"Limit how many branches and tags can be updated in a single push"**: **Disabled**
   - Graphite submits entire stacks atomically
   - Limits prevent large stacks from being pushed
   - Set to "Disabled" or very high value (100+)

### GitHub Actions Configuration

Ignore Graphite's temporary `graphite-base/*` branches:

```yaml
# .github/workflows/your-workflow.yml
on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches-ignore:
      - "**/graphite-base/**"
```

**Prevent duplicate CI runs:**
```yaml
concurrency:
  group: ${{ github.repository }}-${{ github.workflow }}-${{ github.ref }}-${{ github.ref == 'refs/heads/main' && github.sha || ''}}
  cancel-in-progress: true
```

---

## Common Scenarios

### Scenario 1: Break Large Feature into Stack

**Problem:** Feature requires 500 lines across multiple files

**Solution:**
```bash
gt checkout main

# Step 1: Add types (50 lines)
# Edit types...
gt create -am "feat(types): Add feature types"

# Step 2: Add helpers (100 lines)
# Edit helpers...
gt create -am "feat(utils): Add helper functions"

# Step 3: Add service (200 lines)
# Edit service...
gt create -am "feat(service): Implement feature service"

# Step 4: Add UI integration (150 lines)
# Edit components...
gt create -am "feat(ui): Integrate feature in UI"

# Submit entire stack
gt ss
```

**Result:** 4 small PRs instead of 1 large PR, each independently reviewable

### Scenario 2: Urgent Hotfix During Stack Work

**Problem:** Need to fix critical bug while working on a stack

**Solution:**
```bash
# Save current work
gt log short  # Note current branch

# Create fix from main
gt checkout main
gt create -am "fix: Critical bug in auth flow"
gt submit

# Return to your stack
gt checkout your-feature-branch

# After hotfix merges
gt sync  # Rebase stack on updated main
```

### Scenario 3: Work Across Multiple Machines

**Problem:** Started stack on laptop, need to continue on desktop

**Solution:**
```bash
# On laptop: Create and push stack
gt create -am "feat: Part 1"
gt create -am "feat: Part 2"
gt ss

# On desktop: Pull the stack
gt get feat-part-2
# Fetches both Part 2 and Part 1

# Continue work
gt create -am "feat: Part 3"
gt ss
```

---

## Troubleshooting

### Issue: "Branch has diverged from remote"

**Cause:** Local and remote branches have different histories

**Solution:**
```bash
# Force sync to overwrite local
gt sync --force

# Or force push your local changes
gt submit --stack --force
```

### Issue: Rebase conflicts during `gt sync`

**Cause:** Your changes conflict with new commits in main

**Solution:**
```bash
# Conflicts will be marked in files
# Open files and resolve conflicts

# Stage resolved files
git add resolved_file.js

# Continue rebase
gt continue

# If you want to abort
git rebase --abort
```

### Issue: "Cannot find parent branch"

**Cause:** Graphite metadata is out of sync

**Solution:**
```bash
# Retrack the branch
gt track

# Or recreate stack with proper parents
gt checkout desired-parent
gt checkout problem-branch
gt restack
```

### Issue: Accidentally created too many commits in one branch

**Cause:** Used `git commit` multiple times instead of `gt modify`

**Solution:**
```bash
# Squash all commits in branch into one
gt squash

# Opens editor to rename consolidated commit
```

### Issue: Want to rename a branch

**Cause:** Branch name is unclear or doesn't follow conventions

**Solution:**
```bash
gt rename new-branch-name

# Note: This removes PR association
# Use --force to rename branch with open PR
gt rename new-name --force
```

### Issue: Need to remove a branch from middle of stack

**Cause:** Realized a branch is no longer needed

**Solution:**
```bash
# Checkout the branch you want to remove
gt checkout unwanted-branch

# Checkout its child
gt checkout child-branch

# Rebase child onto unwanted-branch's parent
git rebase parent-branch

# Delete unwanted branch
git branch -D unwanted-branch

# Restack
gt restack

# Submit updated stack
gt ss -u
```

### Issue: Submitted wrong stack by accident

**Cause:** Ran `gt ss` while on wrong branch

**Solution:**
```bash
# Close unwanted PRs on GitHub
# Then sync
gt sync

# Deletes local branches for closed PRs
```

### Issue: Want to see detailed diff between stack and main

**Cause:** Need to understand total changes in stack

**Solution:**
```bash
# See all changes from main to current branch
git diff main...HEAD

# See changes in specific branch only
git diff parent-branch..current-branch
```

---


## Additional Resources

- [Graphite Official Docs](https://graphite.dev/docs)
- [Graphite CLI Reference](https://graphite.dev/docs/get-started/command-reference)
- [Graphite Cheatsheet](https://graphite.dev/docs/get-started/cheatsheet)
- [Comparing Git and Graphite](https://graphite.dev/docs/get-started/comparing-git-and-gt)

---

**Remember:** All future commits should use stacked PRs. This keeps the repository history clean, reviews manageable, and development velocity high. When in doubt, break your work into smaller logical pieces and stack them with Graphite.

---

## Appendix: Linear + Graphite Development Workflow

Standard workflow for implementing Linear issues using Graphite stacked PRs.

### Prerequisites

- Graphite CLI installed and initialized (`gt init`)
- Linear issue assigned and ready for work
- Local issue doc exists in `docs/projects/<project>/issues/<ID>-<name>.md`

### Workflow Steps

#### 1. Get Task

Receive prompt/task assignment (e.g., "work on PER-20").

#### 2. Ground Into Context

Before writing any code:

- **Review the plan**: Read the issue doc thoroughly
- **Locate the task**: Cross-reference Linear + local docs
- **Look ahead/behind**: Understand dependencies (`blocked_by`, `blocks` in front matter)
- **Understand real scope**: What files will change? What's the acceptance criteria?

#### 3. Check Stack Status & Create Branch

```bash
# Always check existing stack first
gt ls
```

**Decision point**: Ask whether to:
- **Continue existing stack** - when work is related to current stack
- **Create new stack from main** - when starting a new work focus

Branch naming convention: `<linear-id>-<kebab-case-title>`

```bash
# If continuing stack (stay on current branch):
gt create per-20-create-validated-env-config-module

# If new stack:
gt checkout main
gt create per-20-create-validated-env-config-module
```

**Note**: Create branch without commit initially - commit when ready.

#### 4. Update Task Doc + Initial Commit

- Update local issue doc if grounding revealed scope changes
- Add initial commit when ready:

```bash
git add -A && git commit -m "feat(scope): description of change"
```

Commit message format: Conventional commits (`feat`, `fix`, `refactor`, `docs`, `test`, `chore`)

**Commit strategy on Graphite branches:**
- **Create new commits** as you make progress - this keeps a record of your work
- **Only use `gt modify`** when you actually want to amend/override an existing commit
- All commits on a branch get squashed into the PR when merging anyway
- Some issues map 1:1 with a single commit; larger issues benefit from multiple commits showing progress

#### 5. Do the Work

Execute the implementation:

- Follow the deliverables in the issue doc
- Keep changes focused on the current issue
- Update issue doc checkboxes as you complete items

#### 6. Verify

Before considering work complete:

```bash
bun run check-types    # Type checking
bun run build          # Build verification
# bun run test         # Tests (when available)
```

All checks must pass.

#### 7. Mark Checkboxes Locally

Update the local issue doc (`docs/projects/<project>/issues/<ID>-*.md`):

- Mark completed deliverables with `[x]`
- Mark completed acceptance criteria with `[x]`
- Note any deviations or discoveries

#### 8. Submit Stack (Draft) - Automatic

**Immediately and automatically** submit as draft PR (do not ask, do not wait):

```bash
gt ss --draft          # Submit entire stack as draft PRs
```

This happens **BEFORE** presenting to user for review. The user will review the draft PR itself.

**If batch workflow** (user requested multiple issues):
- Loop back to Step 1 for next issue
- Stack branches: each issue gets its own branch in the stack
- Submit draft after each issue (keeps PRs up to date)

#### 9. Review Checkpoint

Present summary to user for review. Include:
- What was done
- Files changed
- **Draft PR link(s)** (already submitted in step 8)

User reviews the draft PR and provides approval before publishing.

#### 10. Publish (After User Approval)

Only after user approves:

```bash
gt ss --publish        # Publish draft PRs for merge
```

#### 11. Update Linear

**Status auto-updates**: Linear status automatically moves based on PR state:
- Draft PR → stays in current status
- Published PR → moves to "In Review" or "Merging"
- Merged PR → moves to "Done"

**Don't manually update status** - let the integration handle it.

**What to update manually:**
- **Issue body**: Update with final deliverables and checkboxes (what was built)
- **Comments**: Add implementation notes, decisions, or context (commentary goes here, not in body)
- **Parent issue**: Update if all sub-issues complete

#### 12. Repeat

Move to next task in sequence.

---

### Development Workflow Quick Reference

| Step | Action | Command |
|------|--------|---------|
| Check stack | View current branches | `gt ls` |
| Create branch | New branch (no commit) | `gt create <name>` |
| New commit | Add commit to branch | `git add -A && git commit -m "msg"` |
| Amend commit | Override existing commit | `gt modify -a` (use sparingly) |
| Verify | Type check | `bun run check-types` |
| Verify | Build | `bun run build` |
| Submit draft | Submit stack as draft PRs | `gt ss --draft` |
| Publish drafts | Publish draft PRs for review | `gt ss --publish` |
| Submit final | Submit stack (non-draft) | `gt ss` |
| Update PRs | Push changes to PRs | `gt ss -u` |

### Development Stacking Guidelines

**When to continue existing stack:**
- Work is directly related to current stack
- Issues have explicit dependencies (`blocked_by`/`blocks`)
- Same milestone or feature area

**When to create new stack:**
- Starting a new work focus
- Issues are independent
- Current stack is getting large (5+ branches)
- Parallel workstream

**Stack size**: Keep stacks small and focused. Prefer 2-4 branches per stack.

### Development Common Patterns

**Single issue, single branch:**
```bash
gt ls                                    # Check stack
gt create per-20-env-config-module       # Create branch
# ... do work ...
gt modify -a -m "feat(config): add env"  # Commit
bun run check-types && bun run build     # Verify
gt ss --draft                            # Submit as draft PR
```

**Multiple related issues, stacked:**
```bash
gt ls                                    # Check stack
gt create per-20-env-config-module       # Issue 1
# ... complete issue 1 ...
gt create per-23-barrel-export-audit     # Issue 2 (stacks on issue 1)
# ... complete issue 2 ...
gt ss --draft                            # Submit entire stack as drafts
```

**Batch workflow (user requests multiple issues):**
```bash
# User: "Complete PER-20, PER-23, and PER-22"
gt ls
gt create per-20-env-config-module
# ... complete PER-20 ...
gt create per-23-barrel-export-audit
# ... complete PER-23 ...
gt create per-22-logging-abstraction
# ... complete PER-22 ...
# Return to user for review of entire stack
gt ss --draft                            # Submit stack as drafts
# After approval:
gt ss --publish                          # Publish for merge
```

---

### Development Workflow Troubleshooting

**Branch created on wrong parent:**
```bash
gt checkout correct-parent
gt checkout problem-branch
gt restack
```

**Need to insert branch in middle of stack:**
```bash
gt checkout parent-branch
gt create --insert new-branch-name
```

**Forgot to create branch, committed to wrong branch:**
```bash
git reset HEAD~1                    # Undo commit (keep changes)
gt create correct-branch-name       # Create correct branch
gt modify -a -m "commit message"    # Recommit
```
</file>

<file path="process/LINEAR.md">
# Linear Conventions & Best Practices

This document provides conventions for working with Linear in this workspace. It ensures AI agents and human collaborators maintain consistent issue management, milestone planning, and project organization.

---

## Resources vs. Repo Templates
- Use Linear’s **Resources** panel to attach specs, links, or documents to a project; that interface remains the canonical location for project resources.
- When drafting those artifacts locally, copy the appropriate scaffold from `docs/templates/` (project, service, issue, milestone) before syncing the final content into Linear.
- Do **not** create a `docs/resources/` directory in the repo—active resources either live under the relevant `docs/projects/<slug>/` folder or inside Linear itself.

---

## Milestone Naming

### Core Principle: Name by What, Not by How

Milestone names should describe **architectural layers** or **capabilities delivered**, not the **technologies used** or **artifacts modified**.

**Good:** Layer-based, capability-focused
- ✅ "Stabilize UI Structure"
- ✅ "Stabilize Domain Logic"
- ✅ "Integrate Multi-Service System"

**Bad:** Technology-specific, artifact-focused
- ❌ "React App Stabilization"
- ❌ "Filter State Modularization"
- ❌ "API Integration"

### Why This Matters

**Technology names constrain perceived scope:**
```
"React App Stabilization" suggests:
→ We're working on React-specific concerns
→ Scope is limited to the React application

"Stabilize Domain Logic" reveals:
→ We're extracting framework-agnostic business logic
→ Scope inherently spans multiple surfaces (React, API, Retool, workflows)
```

**The work content already signals scope progression:**
```
M1: Stabilize UI Structure
    ↳ Scope: Presentation layer
    ↳ Surface: Single app

M2: Stabilize Domain Logic
    ↳ Scope: Business logic layer
    ↳ Surface: Multi-surface preparation

M3: Restructure as Monorepo
    ↳ Scope: Project architecture
    ↳ Surface: Multi-app structure

M4: Integrate Multi-Service System
    ↳ Scope: Full distributed system
    ↳ Surface: API + Workflows + Frontend + External
```

### When to Use Technology Names

**Only when the technology IS the scope:**
- ✅ "Migrate from Webpack to Vite" (tool migration is the work)
- ✅ "Add TypeScript Support" (language addition is the deliverable)
- ❌ "React Component Refactor" (should be "Stabilize UI Architecture")

---

## Issue Naming

### Structure: `[Milestone Prefix] Capability Delivered`

**Format:**
```
[M2] Operations Registry & AI Contract Alignment
[M3] Workspace Foundation & Documentation
[M4] API Foundation & Filter Operations Exposure
```

**Milestone Prefixes:**
- `[M1]`, `[M2]`, `[M3]`, etc.
- Enables filtering and grouping before milestone assignment
- Required because Linear API doesn't support programmatic milestone assignment

### Issue Title Guidelines

**Use active, imperative phrasing** per Linear's official guidance ("Write Issues Not User Stories"):

**Pattern:** `[Milestone] Verb Object [& Verb Object]`

**Start with a verb** to make the action immediately clear and scannable:
- ✅ "Extract service layer" (imperative, action-first)
- ✅ "Relocate and validate frontend" (imperative, clear actions)
- ✅ "Scaffold backend and workflows" (imperative, direct)
- ⚠️ Filenames remain descriptive/noun-first for searchability (e.g., `TEAM-48-agentic-workflow-foundation.md`), while the front-matter `title` uses the imperative phrasing. The shared `TEAM-XX` ID is the canonical anchor between the two, so slight differences are acceptable.
- ❌ "Service layer extraction" (passive noun phrase)
- ❌ "Frontend relocation & validation" (passive noun phrase)

**Rationale:** Imperative titles improve scannability in lists/boards and align with Linear's recommendation that titles should "start with a short verb/action" and "directly state what the task is."

**Keep titles concise but specific:**
- ✅ "Implement agentic workflow foundation (Inngest + Agent SDK)"
- ✅ "Deploy to production and integrate externally"
- ❌ "Workflows" (too vague)
- ❌ "Refactor hooks" (vague activity without clear outcome)
- ❌ "Implement Inngest workflow orchestration with OpenAI Agents SDK integration for AI-powered async operations" (too verbose)

---

## Issue Descriptions

### Core Principle: Descriptions Define Work, Not Status

**Issue descriptions should contain only:**
- **Scope** — What needs to be done
- **Objectives** — What this achieves
- **Acceptance Criteria** — How we know it's complete
- **Checklists** — Actionable work items (not status logs)
- **References** — Links to related docs/issues

**Issue descriptions should NOT contain:**
- **Status updates** — Use Linear status field instead
- **Progress notes** — Use comments, not descriptions
- **"Next steps"** or temporal markers — These belong in comments
- **Embedded estimates** — Use Linear estimate field (unless required for context)
- **Date-stamped sections** — Avoid "Status (2025-11-06)" headings

**Status belongs in Linear metadata:**
- Update via Linear status field (Backlog, Todo, In Progress, Done, Canceled)
- Update via Linear MCP tools (`update_issue` with `state` parameter)
- Track progress via Linear comments or activity log
- Status indicators in descriptions become stale immediately after saving

Add these universal description rules to every issue:
- **TL;DR first:** After the YAML front matter, start the synced body with `## TL;DR` (no duplicate title) and keep the text to a single-sentence summary that mirrors Linear’s intro.
- **Body markers + order:** Drop `<!-- SECTION SCOPE [SYNC] -->` immediately before `## TL;DR`, then keep the exact H2 sequence: TL;DR → Deliverables → Acceptance Criteria → Testing / Verification → Dependencies / Notes. Parsers rely on that structure, so do not insert extra H2s in the public body.
- **Implementation separator:** After the public body, add a `---` line followed by `<!-- SECTION IMPLEMENTATION [NOSYNC] -->` and `## Implementation Details (Local Only)` for any deep procedures that should stay out of Linear.
- **Quick Navigation placement:** If you need a TOC, place it under Implementation Details (e.g., `### Quick Navigation`) so the public body stays concise.
- **No status headers:** Avoid "Status", "Next Steps", or date-stamped headings inside descriptions; use comments/status updates instead.

### Anatomy of a Good Issue Description

```markdown
**TL;DR:** Single-sentence summary that mirrors the Linear issue intro.

**Complexity:** Low | Medium | High
**Guidance:** Minimal | Moderate | Heavy
**Dependencies:** [List prerequisite issues]
**Value to Deliver:** [One-sentence outcome]

## Objectives

[What this work achieves and why it matters]

## Work Required

- [ ] Specific deliverable 1
  * Implementation detail
  * Implementation detail
- [ ] Specific deliverable 2
- [ ] Specific deliverable 3

## Acceptance Criteria

- [ ] Criterion 1 (e.g., tests passing)
- [ ] Criterion 2 (e.g., documentation updated)
- [ ] Criterion 3 (e.g., regression suite clean)

## Integration

[How this connects to other work, what becomes possible]

## References

* **Technical Plan:** `docs/plan-name.md`
* **Parent Issue:** TEAM-X
* **Depends On:** TEAM-Y, TEAM-Z
```

### Description Best Practices

**1. Complexity indicates effort, not importance**
- Low = straightforward, established patterns
- Medium = some unknowns, moderate scope
- High = significant unknowns, large scope or high risk

**2. Guidance indicates AI autonomy level**
- Minimal = AI can execute independently
- Moderate = AI needs some direction
- Heavy = Requires significant human guidance

**3. Dependencies are explicit**
- Front matter lists the machine-readable truth (`blocked_by`, `blocked`, `related_to`).
- The body repeats those relationships for humans (e.g., `- Blocked by [TEAM-10](...)`).
- When opening/closing work, consult the front matter first so you know what must complete before/after your task.

**4. Work Required uses checkboxes**
- Each top-level item is a significant deliverable
- Sub-bullets provide implementation details (not status)
- Enables scope tracking, not progress tracking

**5. Acceptance Criteria define "done"**
- Clear, testable conditions
- Not implementation steps
- Guide validation, not execution

**6. Integration section connects the dots**
- How does this enable future work?
- What becomes possible after completion?
- Where does this fit in the larger architecture?

**7. Keep descriptions timeless**
- Avoid date references ("as of 2025-11-06")
- Avoid status markers ("Phase 4 Complete")
- Descriptions should read the same at start and finish

---

## Status Management

### Tracking Progress via Linear Metadata

**Use Linear fields, not issue descriptions:**

**Status Field:**
- Backlog → Todo → In Progress → Done → Canceled
- Update via Linear UI or MCP tools
- Never embed status in descriptions ("Status: Complete")

**Progress Tracking:**
- Use Linear comments for updates
- Use Linear activity log for history
- Use sub-issue completion percentage (auto-calculated)
- Use checklist completion in descriptions (checkboxes)

**Temporal Updates:**
- Post as comments, not description edits
- Use Linear activity for historical record
- Keep descriptions timeless

### Parent Issues Auto-Completion

**Parent issues automatically complete when all sub-issues are done:**
- Don't manually mark parent issues complete
- Linear auto-completes when last sub-issue closes
- Parent status reflects aggregate sub-issue state

**Best practices:**
- Break large work into sub-issues
- Each sub-issue has clear deliverable
- Sub-issues can be closed independently
- Parent completes automatically

**Example workflow:**
```
TEAM-9 (Parent): Extract Service Layer
├─ TEAM-23 (Sub): Baseline Snapshot ✅ Done
├─ TEAM-24 (Sub): Service Design ✅ Done
├─ TEAM-25 (Sub): Build Service → In Progress
├─ TEAM-26 (Sub): Integration → Todo
└─ TEAM-27 (Sub): Validation → Todo

When TEAM-27 closes → TEAM-9 auto-completes
```

**What to track in parent descriptions:**
- List of sub-issues (links)
- Overall scope and objectives
- Integration notes
- References to technical plans

**What NOT to track in parent descriptions:**
- Sub-issue completion status (Linear shows this)
- Progress updates (use comments)
- "X of Y sub-issues complete" (Linear calculates this)

---

## Project Scope & Sizing

### Milestone Sizing Guidelines

**Milestones should be completion-oriented, not time-boxed:**
- ✅ Group by architectural layer or major capability
- ✅ Ensure each milestone leaves system in complete, working state
- ❌ Don't create milestones based on calendar quarters
- ❌ Don't split work arbitrarily to hit artificial deadlines

**Typical milestone scope:**
- 3-6 parent issues per milestone
- Each issue represents 1-3 weeks of focused work (if time-estimating)
- Milestones should complete a conceptual "phase"

**Progressive scope expansion:**
```
M1: Single layer, single surface
M2: Single layer, multi-surface preparation
M3: Infrastructure transformation
M4: Multi-service integration
M5: Cross-cutting capabilities
```

### Issue Sizing Guidelines

**Issues should be "parent issue" level:**
- Not individual tasks (too small)
- Not entire epics (too large)
- Right size: 3-10 distinct work items

**Break large issues into sub-issues when:**
- Work spans multiple sprint cycles
- Different team members own different parts
- Dependencies between sections require phased delivery

**Keep issues atomic when:**
- Work is tightly coupled
- Single developer can complete in 1-2 weeks
- Breaking apart would create artificial handoffs

---

## Estimation Conventions

### Parent-Only Estimation Rule

**Only parent issues carry estimates. Sub-issues remain unestimated.**

**Rule:**
- Set estimates exclusively on parent issues
- Sub-issues should have no estimate value (0 or unset)
- Parent estimate represents total effort for all sub-issues combined

**Rationale:**
1. **Avoids double-counting** — Linear does not auto-calculate parent estimates from sub-issues. If both parent and children have estimates, cycle/project totals will count both, inflating actual scope.
2. **Reduces maintenance burden** — Updating individual sub-issue estimates requires manually recalculating parent totals. Parent-only estimation eliminates this synchronization overhead.
3. **Single source of truth** — Parent estimate is the authoritative effort signal. Sub-issues track work breakdown, not effort accounting.

**Implementation:**
- When creating sub-issues, leave the estimate field unset or explicitly set to 0
- When breaking down work, calculate total points conceptually (sub-issues should represent 1–2 point tasks), then assign that total to the parent
- Update parent estimate if scope changes, not individual sub-issue estimates

**Example:**

TEAM-29 (Parent): Docs Migration — 8 points
├─ TEAM-37: Scaffold Directories — no estimate
├─ TEAM-38: Relocate Evergreen Docs — no estimate
├─ TEAM-39: Move Project Assets — no estimate
├─ TEAM-40: Backfill Milestone Tasks — no estimate
└─ TEAM-41: Split Architecture Content — no estimate

Conceptual breakdown (for planning only):
  - TEAM-37: ~1 point effort
  - TEAM-38: ~1 point effort
  - TEAM-39: ~2 points effort
  - TEAM-40: ~2 points effort
  - TEAM-41: ~1 point effort
  Total: 7 points → assigned to parent only (rounded to 8)

**Note:** Linear uses Fibonacci point values (1, 2, 3, 5, 8, 13...). When calculating totals, round to nearest Fibonacci number (e.g., 7 points rounds to 8).


---

## Sequencing & Dependencies

### Forward-Only Progress

**Each milestone should leave the system in a complete, usable state:**
- ✅ M1 complete → working React app
- ✅ M2 complete → domain logic extracted and testable
- ✅ M3 complete → monorepo operational, all packages build
- ❌ M1 complete → half-built app with TODOs

**Avoid backtracking:**
- Don't mark M1 "complete" if you know M2 will require M1 rework
- If rework is needed, it should be part of M1's definition

### Dependency Clarity

**Explicit over implicit:**
```markdown
**Dependencies:** Operations Registry (Issue 3) complete
```

**Chain dependencies properly:**
- Issue 1 → Issue 2 → Issue 3 (serial)
- Issues 4, 5, 6 can start after Issue 3 (parallel)

**Avoid circular dependencies:**
- If A depends on B and B depends on A, redesign the split

---

## Complexity & Guidance Framework

### Replacing Time Estimates

**For AI-driven development, complexity + guidance is more useful than time estimates:**

**Complexity = Technical challenge**
- Low: Well-understood patterns, minimal unknowns
- Medium: Some research needed, moderate scope
- High: Significant unknowns, large integration surface

**Guidance = Human involvement needed**
- Minimal: AI can execute autonomously
- Moderate: AI needs architectural decisions, pattern selection
- Heavy: Requires human design, multiple feedback cycles

**Example combinations:**

| Complexity | Guidance | Interpretation |
|---|---|---|
| Low | Minimal | Routine work, fully automatable |
| Medium | Minimal | AI-friendly task with moderate scope |
| High | Moderate | Complex but well-scoped, AI needs direction |
| High | Heavy | Requires human expertise, AI assists |

### When to Use Each Rating

**Low Complexity:**
- Established patterns exist in codebase
- Similar work completed previously
- Clear acceptance criteria

**Medium Complexity:**
- Some new patterns or tools
- Integration with existing systems
- Requires design decisions

**High Complexity:**
- New architectural patterns
- Multiple unknowns
- High integration risk
- Experimentation required

**Minimal Guidance:**
- Patterns documented
- Examples exist
- AI can infer requirements

**Moderate Guidance:**
- Needs architectural decisions
- Pattern selection required
- Some ambiguity in requirements

**Heavy Guidance:**
- Novel problem space
- Requires domain expertise
- Multiple stakeholders
- Iterative refinement expected

---

## Issue Linking Conventions

### Linking to Other Issues

**Preferred: Bare Identifiers (Auto-Linked)**

Linear automatically converts bare issue identifiers to full markdown links when you save an issue description.

```markdown
## Sub-Issues

- TEAM-23: Baseline Snapshot ✅ Done
- TEAM-24: Service Design ✅ Done
- TEAM-25: Build Service (2pt) - Not Started
- TEAM-26: Integration (2pt) - Not Started
```

After save, Linear converts these to:
```markdown
- [TEAM-23](https://linear.app/your-workspace/issue/TEAM-23/baseline-snapshot-and-dependency-mapping)
- [TEAM-24](https://linear.app/your-workspace/issue/TEAM-24/service-design)
```

**Fallback: Explicit Markdown Links**

If auto-linking doesn't occur (e.g., in programmatic updates where you can't verify), use standard markdown links:

```markdown
[TEAM-23](https://linear.app/your-workspace/issue/TEAM-23)
```

**Short form (identifier-only URL) works equally well:**
- Full URL: `[TEAM-23](https://linear.app/your-workspace/issue/TEAM-23/baseline-snapshot)`
- Short URL: `[TEAM-23](https://linear.app/your-workspace/issue/TEAM-23)`
- Both route correctly; slug is optional

### Link Stability

**Title changes don't break links:**
- Linear routes by issue ID, not title slug
- Old URLs with outdated slugs still work
- You don't need to update links when renaming issues

### Template: Parent Issue with Sub-Issues

```markdown
## Sub-Issues

This parent issue has been broken down into 5 sub-issues (8 points total):

- TEAM-23: Baseline Snapshot & Dependency Mapping ✅ Done (1pt)
- TEAM-24: Service Boundary & Interface Design ✅ Done (1pt)
- TEAM-25: Build Pure Service Layer (2pt)
- TEAM-26: Adapter Integration & Hook Refactor (2pt)
- TEAM-27: Validation & Documentation Sync (1pt)
```

**Important:** Don't duplicate status information next to links. Update the sub-issue's actual status in Linear and let references reflect it automatically. Status indicators (✅, 🔲) are acceptable for quick visual scanning but should not replace proper Linear status tracking.

### Caveats

**Auto-linking timing:**
- Auto-linking happens server-side when the issue is saved
- You must re-fetch the issue to see converted links
- API responses show stored markdown, not UI-rendered versions

**Related issues:**
- Linear automatically creates "related issue" links when you reference issues in descriptions
- This is intentional; it helps surface dependencies

**When using Linear MCP:**
```typescript
// Auto-linking approach (recommended)
await mcp__linear_anvil__update_issue({
  id: "parent-id",
  description: "Sub-issues: TEAM-23, TEAM-24, TEAM-25"
});

// Explicit link approach (when you need immediate control)
await mcp__linear_anvil__update_issue({
  id: "parent-id",
  description: "Sub-issues: [TEAM-23](https://linear.app/.../TEAM-23)"
});
```

### Documenting Issue Dependencies

**For blocking/blocked relationships created via API:**

When creating issues with dependencies, add a dependency section at the bottom of the issue description. Use explicit markdown links (bare identifiers do not auto-convert via API).

```markdown
## Blocked
- [TEAM-23](https://linear.app/your-workspace/issue/TEAM-23)
- [TEAM-24](https://linear.app/your-workspace/issue/TEAM-24)

## Blocked By
- [TEAM-9](https://linear.app/your-workspace/issue/TEAM-9)
```

**Note:** Bare identifiers do not auto-convert to links via API. Use explicit markdown links as shown above. Slug is optional (short form works). After creating issues with dependency links, manually establish "blocks/blocked by" relationships in Linear UI (markdown links alone do not create relationships, only visual references).

### ID Assignment & Linking Workflow

- **Draft locally first:** Create the markdown doc (using the issue template) before opening the Linear issue. Use the placeholder `LOCAL-TBD` for the filename and `id` while drafting.
- **Create in Linear second:** Once the plan looks good, create the Linear issue. Linear assigns IDs sequentially, so do not guess the final identifier in git.
- **Rename/update immediately:** After the Linear issue exists, rename the local file, update the `id`, and replace any `LOCAL-TBD` references with the actual ID.
- **Link in bulk:** When all related issues are created, add Markdown links pointing to their Linear URLs near the top of each issue doc. Doing this in one pass prevents churn if IDs shift during creation. Linear will auto-convert those links/references in the UI.
- **Existing mismatches:** Some issue docs may carry placeholder IDs because their Linear counterparts were not created yet. Track and reconcile them as the real issues come online.

### Archiving After Milestones

- **Milestone wrap-up:** When a milestone is marked complete in Linear, sweep the corresponding repo docs: move finished issue files into `docs/projects/<project>/issues/archive/` and relocate superseded resources into `resources/archive/` before kicking off the next milestone. This keeps the live folders scoped to in-flight work.
- **Link hygiene:** Immediately after the sweep, run `rg` (or use IDE search) to update references so AGENTS, milestones, and related issues continue to resolve. Note the archive action in the relevant log or milestone summary.
- **Project completion:** When an entire project finishes (all milestones done, no follow-up work planned), move the whole `docs/projects/<project>/` folder under `docs/projects/archive/` so logs/updates travel with it.
- **Pitfalls to avoid:** Don't archive milestones/logs piecemeal—they document the timeline and should remain in the live tree until the full project archives. Keep archive directories limited to the locations above so future agents know exactly where to look.

---

## Issue Organization

### Labels

**Label Strategy: Two-Dimensional Taxonomy**

Linear labels serve two distinct, orthogonal purposes. Use both dimensions to provide rich semantic context for filtering and organization.

#### Dimension 1: Work Type (Intent)

**Pick exactly one per issue:**

- **Feature** — Net new capability that didn't exist before
- **Improvement** — Enhancement to existing capability
- **Bug** — Fixing broken behavior

**These are mutually exclusive.** Work is either building something new (Feature), making something existing better (Improvement), or fixing something broken (Bug).

#### Dimension 2: Work Aspect (Domain)

**Pick any that apply (0-N per issue):**

- **Testing** — Significant test coverage, infrastructure, or validation work
- **Documentation** — Significant documentation work (not incidental updates)
- **Architecture** — Foundational structural or architectural changes
- **Technical Debt** — Internal quality improvements, refactoring, or cleanup

**These can combine freely.** An issue can be both Architecture + Technical Debt, or Feature + Testing + Documentation.

#### Multi-Label Combinations

**Real examples from this project:**

```
[M2] Domain Logic Extraction
→ Technical Debt + Architecture + Testing
→ Paying down React coupling debt via architectural refactoring with test coverage

[M2] Operations Registry & AI Alignment
→ Improvement + Architecture
→ Enhancing existing filter operations with architectural registry pattern

[M4] API Foundation & Filter Operations Exposure
→ Feature + Architecture
→ Net new API capability requiring foundational architectural work

[M5] Agent Harness Standardization
→ Improvement + Architecture
→ Enhancing existing AI capabilities with standardized patterns

Hypothetical: "Add authentication to API"
→ Feature + Architecture + Documentation
→ Net new auth capability with architectural decisions and API docs

Hypothetical: "Backfill filter operation tests"
→ Testing + Technical Debt
→ Test coverage work paying down testing debt
```

#### Semantic Filtering Patterns

**Questions you can answer with label filters:**

**Single dimension:**
- "Show me all net new features" → Filter: `Feature`
- "Show me all enhancements to existing work" → Filter: `Improvement`
- "Show me all bugs" → Filter: `Bug`
- "Show me all architectural changes" → Filter: `Architecture`
- "Show me all technical debt" → Filter: `Technical Debt`
- "Show me all testing-focused work" → Filter: `Testing`
- "Show me all documentation work" → Filter: `Documentation`

**Multi-dimension combinations:**
- "Show me new features with architectural changes" → Filter: `Feature + Architecture`
- "Show me testing-focused improvements" → Filter: `Improvement + Testing`
- "Show me architectural technical debt" → Filter: `Architecture + Technical Debt`
- "Show me bugs that require architectural fixes" → Filter: `Bug + Architecture`
- "Show me features that need documentation" → Filter: `Feature + Documentation`

**Cross-milestone filtering:**
- "Show me all architecture work across all milestones" → Filter: `Architecture` (no milestone filter)
- "Show me all technical debt we're paying down" → Filter: `Technical Debt` (across all milestones)
- "Show me all feature work in M4 and M5" → Filter: `Feature` + Milestones M4/M5

#### Label Application Guidelines

**All new issues should have:**
1. **One intent label** (Feature, Improvement, or Bug)
2. **Zero or more aspect labels** (Testing, Documentation, Architecture, Technical Debt)

**When in doubt:**
- If building something that didn't exist → `Feature`
- If making something existing better → `Improvement`
- If fixing broken behavior → `Bug`
- If significant architectural decisions involved → `+ Architecture`
- If paying down structural/quality debt → `+ Technical Debt`
- If substantial test coverage work → `+ Testing`
- If substantial documentation effort → `+ Documentation`

**Don't over-label:**
- ❌ Don't tag every M2 issue with "M2" (use `[M#]` prefix instead)
- ❌ Don't create labels for temporary states
- ❌ Don't use aspect labels for minor/incidental work (e.g., don't add `Documentation` for a small README update)
- ✅ Do use labels for filtering across milestones
- ✅ Do combine multiple aspect labels when appropriate

### Priorities

**Priority reflects urgency + impact, not just importance:**
- **Urgent (1):** Blockers, production issues
- **High (2):** Critical path, enables other work
- **Medium (3):** Important but not blocking
- **Low (4):** Nice-to-have, optional work

**Milestone issues typically:**
- Current milestone critical path: High (2)
- Current milestone supporting work: Medium (3)
- Future milestone prep: Medium (3)
- Experimental/optional: Low (4)

### States

**Use Linear's default states:**
- **Backlog:** Not started, not scheduled
- **Todo:** Scheduled, not started
- **In Progress:** Active work
- **Done:** Complete
- **Canceled:** Won't do

**Avoid custom states unless necessary:**
- Linear's defaults work well for most workflows
- Custom states add cognitive overhead

---

## Linear API Limitations

### Known Constraints

**Cannot programmatically:**
- Create milestones
- Assign issues to milestones
- Bulk-update milestone assignments

**Workarounds:**
- Use `[M#]` prefixes in titles
- Create milestone templates in project description
- Filter by title prefix for manual milestone assignment

### Best Practices Given Limitations

**1. Prefix all issue titles with milestone marker**
```
✅ [M2] Operations Registry & AI Contract Alignment
❌ Operations Registry & AI Contract Alignment
```

**2. Include milestone templates in project description**
- Enables manual milestone creation
- Provides consistency across projects

**3. Group issues by milestone in planning docs**
- `docs/projects/<project-slug>/milestones/M2-*.md` contains all M2 issues
- Enables bulk creation and tracking

---

## Documentation Workflow

### Issue ↔ Documentation Sync

**Each milestone should have:**
1. **Linear issues** (project management, tracking)
2. **Milestone document** (detailed planning, context)
3. **docs/ROADMAP.md reference** (roadmap visibility)

**When creating issues:**
1. Draft parent issues in milestone document first
2. Create Linear issues from milestone document
3. Link Linear issues back to milestone document

**When updating issues:**
1. Update Linear issue status/description
2. Update milestone document if scope changes
3. Update docs/ROADMAP.md if milestone shifts

### Single Source of Truth

**Linear is the source of truth for:**
- Current status (Backlog, In Progress, Done)
- Assignments
- Real-time discussions

**Milestone documents are the source of truth for:**
- Full context and rationale
- Detailed work breakdown
- Architectural decisions
- Integration notes

**docs/ROADMAP.md is the source of truth for:**
- Overall roadmap
- Milestone sequencing
- Success criteria

---

## For AI Agents

### When Working With Linear

**1. Always read milestone documents first**
- `docs/projects/<project-slug>/milestones/MX-*.md` contains full context
- Linear issues are summaries, not complete specs

**2. Use established patterns**
- Follow existing issue description structure
- Match complexity/guidance ratings to similar work
- Maintain consistent formatting

**3. Separate status from descriptions**
- Update Linear status field, not descriptions
- Post progress updates as comments
- Keep descriptions timeless and work-focused
- Use MCP tools to update status/state

**4. Update docs when scope changes**
- Scope changes require doc updates
- Keep Linear issue descriptions in sync with milestone docs
- Link to detailed documentation
- Add comments for temporal updates

**5. Never manually complete parent issues**
- Parent issues auto-complete when sub-issues close
- Focus on completing sub-issues
- Update sub-issue status via Linear fields

**6. Include full context in issues**
- AI agents (future you) need complete information
- Don't assume context from previous conversations
- Link to detailed documentation
- Keep objectives and acceptance criteria clear

**7. Follow naming conventions strictly**
- Milestone prefixes enable filtering
- Layer-based names reveal scope
- Consistency enables automation

### When Planning Milestones

**1. Think in layers, not technologies**
- What architectural layer does this stabilize?
- What capabilities does this enable?
- Avoid naming after specific tools/frameworks

**2. Ensure forward-only progress**
- Each milestone leaves system in complete state
- No "phase 1 of 3" that leaves work half-done
- Dependencies clear and non-circular

**3. Size for completion, not time**
- Group conceptually related work
- Don't split arbitrarily for calendar alignment
- Aim for 3-6 parent issues per milestone

**4. Document the "why" extensively**
- Future agents need architectural context
- Integration notes explain how pieces connect
- Rationale prevents repeated debates

---

**Last Updated:** 2024-11-24
**For Questions:** See project documentation for context
### Front Matter Requirements

- Use `id` as the identifier field in every issue/milestone/project doc. All issue docs must include: `id`, `title`, `state`, `priority`, `estimate`, `project`, `milestone`, `assignees`, `labels`, `parent`, `children`, `blocked_by`, `blocked`, and `related_to`. Example:

```yaml
---
id: TEAM-11
title: Relocate Frontend App Into TurboRepo
state: in_progress
priority: 2
estimate: 4
project: monorepo-refactor
milestone: milestone-3-monorepo
assignees: [codex]
labels: [refactor, architecture]
parent: TEAM-29
children: [TEAM-11A]
blocked_by: [TEAM-10]
blocked: [TEAM-12]
related_to: []
---
```

- **Required fields:**
  - `id`: Issue identifier (e.g., TEAM-11)
  - `title`: Issue title
  - `state`: planned | in_progress | done | future
  - `priority`: 0 (none) | 1 (urgent) | 2 (high) | 3 (normal) | 4 (low)
  - `estimate`: Exponential scale: 0 | 1 | 2 | 4 | 8 | 16
  - `project`: Project slug
  - `milestone`: Milestone identifier
  - `assignees`: Array of assignee identifiers
  - `labels`: Array of label strings (empty array if none)
  - `parent`: Parent issue ID or null
  - `children`: Array of child issue IDs (empty array if none)
  - `blocked_by`: Array of issue IDs that block this issue (empty array if none)
  - `blocked`: Array of issue IDs that this issue blocks (empty array if none)
  - `related_to`: Array of related issue IDs (empty array if none)

- Always populate `parent`, `children`, `blocked_by`, `blocked`, and `related_to`. Even empty relationships should be represented (e.g., `children: []`) so agents can trust the metadata.
- Before picking up work, read these fields to understand upstream blockers and downstream follow-ups.
- Maintain the human-readable dependency list near the bottom of the Markdown body with explicit links (e.g., `- Blocked by [TEAM-10](https://linear.app/.../TEAM-10)`) so reviewers can navigate quickly. Front matter stays machine-friendly; the body stays human-friendly.
</file>

<file path="projects/engine-refactor-v1/issues/pipeline-config-refactor.md">
# Pipeline configuration refactor

## Goal
- Move to a clear, stage-by-stage configuration model for the entire map-generation pipeline.
- Simplify and document how configuration is declared, merged, and consumed.
- Make interactions between config blocks explicit; co-locate related knobs to avoid hidden side-effects.
- Treat the pipeline as a configurable, declarative system with optional presets and explicit stage configs.

## Scope
1) **Stage config object (declarative, no hidden defaults):**
   - Introduce a canonical `stageConfig` structure that defines each stage’s inputs/outputs, enablement, and per-stage tunables.
   - Remove implicit defaults from stage runners; defaults live in the stage config schema only.
   - Require explicit opt-in/values for stage-specific behaviors (e.g., ocean separation, plate-aware coasts, relief shaping).

2) **Plate preset input (deterministic, layered):**
   - Add an optional `platePreset` block (seed + axis + convergence/rotation profile) with sensible defaults.
   - Stage configs layer on top of the preset (no mutation of the preset itself), keeping deterministic plate layouts when desired.

3) **Config interaction clarity:**
   - Co-locate related config: plate windows + ocean separation + coast shaping; plate tensors + mountains/hills/volcanoes; winds/currents + climate.
   - Make cross-stage dependencies explicit in the config (e.g., coastlines consumes `landmask` + `plateBoundaries`, mountains consumes `uplift/boundaryCloseness`).

4) **Documentation + schema:**
   - Ship a single schema doc describing the stageConfig shape, presets, and merge order.
   - Generate quick-reference docs per stage with expected inputs/outputs and the tunable surface.

## Alignment with existing plans/work
- Current state: `stageManifest` exists but hides defaults inside stage runners; tunables are read via `rebind` but some modules snapshot at import time.
- Prior refactor work: Context/adapter and WorldModel integration are in place; stage toggles exist, but per-stage config is not consolidated, and ocean separation/coast shaping still rely on scattered knobs.
- Gaps: No first-class stage config object; presets are ad hoc; plate presets aren’t formalized; cross-stage dependencies are inferred, not declared.

## Proposed design (do it properly)
### Configuration model
- **Pipeline config root**
  - `preset`: optional name or object (platePreset + global defaults).
  - `stageConfig`: map keyed by stage name; each entry includes:
    - `enabled`: boolean
    - `inputs`: declarative references to prior stage outputs (validated)
    - `params`: stage-specific tunables (typed, validated, with schema defaults)
    - `policy`: optional per-stage policy blocks (e.g., ocean separation policy, coast shaping policy)
  - `globals`: shared primitives (e.g., dimensions, biome tables, adapter hooks) and a `platePreset` block.

- **Plate preset**
  - Fields: seed (mode/fixed/offset), plateAxisDeg, convergenceMix, rotationMultiple, plateCount, relaxationSteps.
  - Deterministic by default; stages layer their params atop without mutating the preset.

- **Merge/validation**
  - Merge order: base defaults → preset → entry overrides → runtime overrides.
  - All stage defaults live in the schema; stage runners receive already-validated params, never implicit fallbacks.
  - Cross-stage validation ensures required outputs are present before a stage runs.

### Pipeline structure
- Explicit data products per stage (e.g., `landmask`, `plateBoundaries`, `heightfield`, `climateField`, `storyTags`).
- Stage runners declare consumption/production; orchestrator enforces it (fail fast if missing).
- Optional stages can be swapped or skipped by config without code changes.

### Diagnostics and ergonomics
- One “debug profile” toggle to enable foundation/plate ASCII, boundary metrics, landmass windows, relief summaries for a single run.
- Stage-level logging flags live alongside each stage’s config, not global hidden toggles.

## Tasks
1) **StageConfig schema + loader**
   - Define `stageConfig` shape (enabled, inputs, params, policy, logging) and implement validation/merge.
   - Refactor stage runners to consume params from `stageConfig` only (remove hidden defaults in code).

2) **Plate preset support**
   - Add `platePreset` block to config; integrate with WorldModel seed capture; ensure deterministic layouts when provided.
   - Expose preset selection in entries (optional) and document default behavior.

3) **Co-locate dependent configs**
   - Group: plate windows + ocean separation + coast shaping; relief (mountains/hills/volcanoes) + plate tensors; winds/currents + climate moisture.
   - Update orchestrator wiring so each consumer reads from the grouped config, not scattered tunables.

4) **Documentation**
   - Write stage reference doc (inputs/outputs/params) and a quick “how configs merge” guide.
   - Add examples: baseline preset, deterministic plate preset, ocean-separation-on profile.

5) **Safeguards**
   - Add validation for required outputs before each stage.
   - Add a replayable diagnostic harness for WorldModel/plate outputs (seed + dimensions + config → boundary/uplift distribution checks).

## Risks if deferred
- Continued hidden defaults and cross-stage side-effects make tuning fragile.
- Plate/ocean/relief interactions may regress silently across refactors.
- Lack of deterministic presets slows debugging and playtesting.

## Success criteria
- A single stageConfig drives the pipeline; stage runners have no implicit defaults.
- Plate presets produce repeatable layouts; overrides layer predictably.
- Config interactions are documented and co-located; adding/removing a stage is declarative.
- Diagnostics can be turned on per run via a debug profile without code edits.
</file>

<file path="projects/engine-refactor-v1/issues/plate-pipeline-followups.md">
# Plate pipeline follow-ups

## Why
- Avoid stale tunable snapshots in the WorldModel and surface plate diagnostics reliably.
- Keep landmass/ocean shaping localized to plate geometry instead of global bands.
- Reduce hidden side-effects between plate generation, ocean separation, and relief.

## Actions to schedule
1) **Config flow:** Make `WorldModel.init()` fetch tunables at call time (or expose getters) instead of reading module-scope values. Remove any lingering snapshots that can drift after `rebind()`.
2) **Landmass shaping:** Centralize plate window derivation + vertical/horizontal padding in one helper. Share that with ocean separation and coast shaping so no stage assumes full-height windows.
3) **Ocean separation policy:** Move the policy into a dedicated stage config consumed directly by `applyPlateAwareOceanSeparation`; disable or scope it by default. Add per-band clamps and boundary thresholds to prevent map-wide trenches.
4) **Diagnostics harness:** Add a replayable CLI/Vitest check for WorldModel outputs (given width/height/seed/config) that asserts boundary/uplift distributions. Include a “plate preset” option (seed + axis + convergence) for deterministic debugging.
5) **Logging ergonomics:** Provide a single “plate debug” toggle that enables foundation seed/summary/ASCII/boundary metrics for one run, and ensure it auto-disables in release presets.

## Risks if deferred
- Plate overrides may silently regress again, reintroducing biased relief or ocean cuts.
- Ocean separation can carve full-height channels when configs change.
- Refactors to plate or coast logic may ship without visibility into boundary distribution.

## Suggested ordering
1) Config flow + logging toggle (fast, low risk).
2) Landmass/ocean policy consolidation.
3) Diagnostic harness + plate preset support.
</file>

<file path="projects/engine-refactor-v1/MAPS-engine-refactor/overview.md">
# Project: MAPS Engine Refactor
**Status:** Active
**Timeline:** TBD — aligns with Swooper Maps feature cadence
**Teams:** Swooper Maps (solo / AI-assisted)

## Purpose & Scope
- Deliver a physics-first orchestration engine with a single authoritative world foundation (plates, uplift, winds, currents).
- Remove legacy fallbacks and implicit ordering so every stage consumes explicit inputs and produces explicit outputs.
- Keep physics mandatory (Voronoi + plate stack) and deterministic, with strong diagnostics and logging.

## Current Status (snapshot)
- Foundations and morphology: ✅ Complete. Voronoi-only landmass pipeline, deterministic `PlateSeedManager`, `FoundationContext` emitted and asserted, heightfield buffers in place. Mountains/volcanoes, coasts, and landmass generation consume the physics stack.
- Climate: ⚠️ Partial. Climate engine is centralized and rivers run after baseline, but consumers still read `GameplayMap` instead of `ClimateField`; river flow data is not published.
- Narrative overlays: ⏳ Not modernized. Margin overlays exist, but other story passes still mutate `StoryTags` directly and do not publish immutable overlays.
- Biomes/features/placement: ⏳ Legacy read paths (GameplayMap + StoryTags). No overlay/ClimateField consumption yet.
- Manifest enforcement: ⏳ Manifest describes `requires`/`provides`, but no runtime validator for data products; legacy shims still allow silent drift.
- Tests/verification: ⏳ No automated smoke for the orchestrator/context; diagnostics exist via `[Foundation]` logs and stage gating warnings.

## Next Stage
- Finish Phase C: Adopt `ClimateField` as the primary rainfall source for consumers; expose river flow/summary data; wire rainfall/temperature readers through `MapContext.buffers`.
- Kick off Phase D: Rewrite story tagging to consume `FoundationContext` + `Heightfield` + `ClimateField`, and publish overlays (corridors/hotspots/rifts/swatches) into `StoryOverlays` instead of mutating globals.
- Add a lightweight manifest/data-product validator to fail fast when `requires` inputs are missing.

## Phase Roadmap & Status
- Phase A – Foundations Alignment: ✅ Done (Voronoi default, deterministic plate seed, `FoundationContext`, unified `foundation.*` config, legacy `worldModel` shims removed, `[Foundation]` diagnostics).
- Phase B – Morphology Refactor: ✅ Done (heightfield buffers, plate-driven landmass + coastlines, mountains/volcanoes/lakes write through buffers, margins overlay published).
- Phase C – Hydrology & Climate Unification: ⚠️ Partial
  - Done: Centralized climate engine; rivers after baseline; `ClimateField` buffers exist.
  - Outstanding: Consumers still read `GameplayMap`; no river flow graph/overlay; rainfall/humidity not treated as canonical data products.
- Phase D – Narrative Overlays Modernization: ⏳ Not started (story passes still rely on `StoryTags`; overlays registry only holds margins).
- Phase E – Biomes, Features, Placement Harmonization: ⏳ Not started (needs read-only overlays + `ClimateField` consumption and explicit prerequisites).
- Phase F – Manifest Enforcement & Cleanup: ⏳ Not started (needs consumes/produces validation and removal of legacy fallbacks).

## Guiding Principles
- One source of truth: foundations (tectonics, climate primitives) originate from a single module and feed every downstream stage.
- Explicit data contracts: stages declare required inputs and emitted outputs.
- Physics before narrative: morphology and climate operate on the finished heightfield before story overlays/placement.
- Determinism & observability: shared seeds and logging ensure reproducibility; diagnostics track data products instead of implicit state.
- No optional physics: physics stack is always on; legacy non-physics flows become opt-in extensions.
- Voronoi physics stack: the Civ VII Voronoi + physics integration is canonical; “legacy” never reuses the Voronoi label.

## Target Stage Topology
| Cluster | Stages | Required Inputs | Outputs |
| --- | --- | --- | --- |
| Foundations | `foundation`, `landmassPlates` | Engine seed, map dimensions, Civ Voronoi utilities | Plate seeds, plate tensors, initial landmask, `FoundationContext` |
| Morphology | `coastlines`, `mountains`, `volcanoes`, `lakes`, `terrainAdjust` | `FoundationContext`, heightfield buffer | Final heightfield, shore mask, margin metadata |
| Hydrology & Climate | `rivers`, `rainfallBaseline`, `climateRefine`, `humidity` | Heightfield, wind/currents, shore mask | Rainfall/humidity grids, water flow graph |
| Narrative Overlays | `storySeed`, `storyHotspots`, `storyRifts`, `storyOrogeny`, `storyCorridors`, `storySwatches` | Heightfield, climate grids, plate tensors | Overlay layers (`corridors`, `hotspots`, `swatches`, etc.) |
| Biomes & Features | `biomes`, `features` | Heightfield, climate grids, overlays | Final biomes/features, validation metrics |
| Placement & Finalization | `placement`, `finalize` | All prior fields | Player starts, resources, discoveries |

### Data Products
- `FoundationContext`: immutable snapshot bundling plate IDs, boundary metadata, uplift/rift fields, wind/currents, shared seeds.
- `Heightfield`: staged terrain buffer (elevation + terrain) flushed to the engine only at cluster boundaries.
- `ClimateField`: rainfall/humidity/temperature arrays (read-only to consumers; authored by climate engine).
- `StoryOverlays`: structured map of sparse overlays (corridors, hotspots, active/passive margins).

### World Foundation Configuration Model
- `foundation.seed` — mandatory determinism controls (mode, fixed, offsets, manifest hash) replacing `worldModel.enabled`/seed toggles.
- `foundation.plates` — Voronoi + plate layout definitions; downstream consumers read normalized copy.
- `foundation.dynamics` — atmospheric and oceanic drivers aligned with physics tensors; derived scalars avoid recomputation.
- `foundation.surface` — continental targets and ocean-separation policy wiring; travels with the plate seed for diagnostics.
- `foundation.policy` — consumer-facing multipliers consolidated from legacy policy blocks.
- `foundation.diagnostics` — logging + replay toggles consolidated from dev flags.

### Deprecations & Cleanup (status)
- Legacy `worldModel` overrides removed; emit `[Foundation]` warnings when present. ✅
- `WORLDMODEL_*` exports collapsed into `FOUNDATION_*` helpers and live tunables. ✅
- `PLATE_GENERATION_REFACTOR.md` archived; open items merged here. ✅
- Diagnostics renamed to `[Foundation]` with ASCII helpers under the new prefixes. ✅

## Tooling & Verification
- Diagnostics: `[Foundation]` seed/plate/dynamics/surface logs, landmass/relief/rainfall ASCII and histograms.
- Needed: manifest consumes/produces validator; smoke tests running orchestrator against stub adapter with minimal/maximal presets; overlay/field availability checks per stage.

## Risks & Mitigations
- Complex migration: proceed cluster-by-cluster; keep feature flags scoped to staging.
- Performance regressions: instrument buffer operations; cache expensive computations (Voronoi, climate) for diagnostics.
- Manifest drift: enforce manifests with data-product validation to prevent entropy.

## Links & References
- Code: `mods/mod-swooper-maps/mod/maps/` (orchestrator, layers, bootstrap, world model).
- Diagnostics: `mods/mod-swooper-maps/mod/maps/bootstrap/dev.js`.
- Types/contexts: `mods/mod-swooper-maps/mod/maps/core/types.js`.
- Config resolution: `mods/mod-swooper-maps/mod/maps/bootstrap/resolved.js`, `bootstrap/tunables.js`.
</file>

<file path="projects/engine-refactor-v1/MAPS-engine-refactor/status.md">
# Status: MAPS Engine Refactor (snapshot)
**Updated:** current

## Completed
- Voronoi-only landmass path with `foundation` + `landmassPlates` as default stages; legacy landmass stub removed.
- Deterministic `PlateSeedManager` + `FoundationContext` exported and asserted; `foundation.*` config unified and legacy `worldModel` overrides warned away.
- Heightfield buffers in `MapContext`; landmass, coasts, mountains, volcanoes, lakes, and climate baseline/refine write through staging helpers.
- Margin overlays published via `StoryOverlays` and hydrated into `StoryTags`; `[Foundation]` diagnostics cover seed/plate/dynamics/surface plus ASCII/histograms.

## Gaps / In Progress
- Climate consumers still read `GameplayMap` instead of `ClimateField`; river flow data not exposed as a product.
- Narrative overlays (hotspots/rifts/orogeny/corridors/swatches) still mutate `StoryTags`; overlays registry only holds margins.
- Biomes/features/placement read legacy fields and do not require overlays or `ClimateField` inputs.
- No manifest/data-product validator; stages can still run without declared inputs beyond manual assertions.
- No automated smoke tests for orchestrator/context; verification is manual via diagnostics.

## Ready Next
1. Finish Phase C: make `ClimateField` the canonical rainfall source; surface river flow/summary data for downstream overlays.
2. Begin Phase D: refit story tagging to consume `FoundationContext`/`Heightfield`/`ClimateField` and publish overlays; retire direct `StoryTags` mutation.
3. Add manifest/data-product validation to gate stages on declared `requires`/`provides`.

## Spikes / Research
- Overlay payload schema for corridors/hotspots/rifts/swatches (fields + summary for consumers).
- River data product shape (graph vs. masks) and where to publish (`MapContext.buffers` vs. `StoryOverlays`).
- Validator design: lightweight runtime check vs. build-time lint for `requires`/`produces`.

## Testing & Observability
- Existing: `[Foundation]` logs, stage gating warnings, ASCII diagnostics (landmass, relief, rainfall, biomes), histograms.
- Needed: Vitest smoke for orchestrator using stub adapter and presets; assertions that `FoundationContext`/`Heightfield`/`ClimateField`/`StoryOverlays` are present before stages execute.
</file>

<file path="projects/engine-refactor-v1/resources/slideshows/map-generation-pipeline.json">
{
  "slideshows": [
    {
      "id": "map-generation-pipeline",
      "title": "Map Generation Pipeline: Layers of Control",
      "concepts": {
        "engine": {
          "label": "Engine Layer",
          "description": "Civ VII base game systems",
          "color": "default"
        },
        "physics": {
          "label": "Physics",
          "description": "Foundation and morphology",
          "color": "blue"
        },
        "climate": {
          "label": "Climate",
          "description": "Rainfall and humidity systems",
          "color": "green"
        },
        "narrative": {
          "label": "Narrative",
          "description": "Story overlays and tags",
          "color": "purple"
        },
        "config": {
          "label": "Configuration",
          "description": "3-tier config system",
          "color": "orange"
        }
      },
      "slides": [
        {
          "id": "introduction",
          "order": 1,
          "concept": "engine",
          "explanation": "# Map Generation at Scale\nBuilding procedural worlds for Civilization VII",
          "blocks": [
            {
              "explainer": {
                "content": "Civilization VII needs rich, diverse maps that feel both realistic and engaging. Players expect mountain ranges that follow geological logic, climate patterns that make intuitive sense, and coastlines with character. But they also need gameplay balance—no civilization should spawn in an unwinnable position due to random generation.\n\nThe challenge is **architectural**: how do you generate complex, interdependent systems (terrain, climate, narrative elements) in a way that's predictable, configurable, and debuggable? Traditional approaches often couple everything together, making it impossible to tune one aspect without breaking others."
              }
            },
            {
              "explanation": "### The Swooper Pipeline Approach\n\nOur solution is a **layered pipeline architecture** where each layer has clear responsibilities and data contracts. Lower layers establish physical reality (plates, elevation, climate). Higher layers add interpretation and gameplay elements (biomes, features, balance).\n\nThe key insight: **physics before narrative**. We lock in the fundamental structure of the world first, then annotate and interpret it for gameplay purposes. This prevents conflicts and ensures deterministic results."
            },
            {
              "layers": {
                "title": "Swooper Pipeline Architecture",
                "caption": "Seven layers condensed into five major groups",
                "layout": "pyramid",
                "layers": [
                  {
                    "label": "Configuration",
                    "value": "Meta-Layer",
                    "description": "3-tier system enabling map variants from shared codebase"
                  },
                  {
                    "label": "Biomes & Features",
                    "value": "Layer 4",
                    "description": "Transform abstract data into visible gameplay elements"
                  },
                  {
                    "label": "Narrative Overlays",
                    "value": "Layer 3",
                    "description": "Story annotations that interpret physics without modifying terrain"
                  },
                  {
                    "label": "Climate Systems",
                    "value": "Layer 1-2",
                    "description": "Two-phase climate with river integration and atmospheric patterns"
                  },
                  {
                    "label": "Engine Foundation",
                    "value": "Layer 0",
                    "description": "Civ VII globals + physics foundation + morphology buffers"
                  }
                ]
              }
            },
            {
              "explanation": "### Why This Matters\n\nTraditional map generators often suffer from **tight coupling**—changing mountain placement accidentally breaks climate calculations, or adjusting biome rules creates impossible starting positions. The layered approach provides **separation of concerns**:\n\n- **Predictability**: Same inputs always produce same outputs at each layer\n- **Debuggability**: Problems can be isolated to specific stages\n- **Configurability**: Each layer has its own control surface without affecting others\n- **Extensibility**: New map variants require minimal code changes"
            },
            {
              "explanation": "### Current Challenge: Pipeline Integrity\n\nWhile the architecture is sound, we're facing **data flow consistency** issues. Some stages read stale data, others bypass the buffer system, and contract validation isn't enforced. This creates a cascade problem where small inconsistencies amplify into unpredictable results.\n\nThe following slides detail each layer's role, current status, and where intervention is needed to restore pipeline integrity."
            },
            {
              "kpiGrid": {
                "layout": "uniform",
                "items": [
                  {
                    "label": "Layers Complete",
                    "value": 3,
                    "subtitle": "Foundation solid"
                  },
                  {
                    "label": "In Progress",
                    "value": 1,
                    "subtitle": "Narrative migration"
                  },
                  {
                    "label": "Pending Work",
                    "value": 2,
                    "subtitle": "Contract enforcement"
                  },
                  {
                    "label": "Map Variants",
                    "value": "8+",
                    "subtitle": "From shared codebase"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": "foundation-layer",
          "order": 2,
          "concept": "physics",
          "explanation": "## Layer 1: Physics Foundation\nThe single source of truth for world physics",
          "blocks": [
            {
              "explainer": {
                "content": "The foundation layer establishes the physical reality of the world before any terrain is sculpted. It answers questions like: Where are the tectonic plates? Which boundaries are converging? What are the prevailing wind patterns? How do ocean currents flow?\n\nThe key architectural decision here is **single source of truth**. Rather than having each stage compute its own plate lookups or wind calculations, we compute everything once and freeze it into an immutable `FoundationContext`. Every downstream stage reads from this shared reference."
              }
            },
            {
              "explanation": "### The FoundationContext Object\n\nThe **FoundationContext** is the architectural cornerstone of the entire pipeline. It's a single, immutable object that contains every physics primitive the world needs—plate boundaries, tectonic forces, atmospheric patterns, and RNG seeds. Once created by the `foundation` stage, it gets frozen with `Object.freeze()` to prevent accidental mutation.\n\nThis design eliminates the classic problem of stages recomputing the same expensive operations (like Voronoi cell lookups) or getting inconsistent results from slightly different calculations. Instead of \"ask the engine what plate this tile belongs to,\" every stage reads `foundationContext.plateIds[tileIndex]` from the same source.\n\nThe context flows through every downstream stage as a read-only dependency:\n- **Morphology** uses it for uplift-aware mountain placement\n- **Climate** reads wind patterns and ocean currents\n- **Narrative overlays** use plate boundaries to identify collision zones for fjords versus trailing edges for reefs"
            },
            {
              "explanation": "### Internal Structure\n\nThe FoundationContext organizes physics data hierarchically. At the top are immutable constants. Below that, plate tectonics data (Voronoi cells and force vectors). The bulk of the data is environmental systems—atmospheric patterns, oceanic currents, and surface topology."
            },
            {
              "layers": {
                "title": "FoundationContext Structure",
                "caption": "Hierarchical organization of frozen physics data",
                "layout": "pyramid",
                "layers": [
                  {
                    "label": "Physics Constants",
                    "value": "5%",
                    "description": "Immutable world parameters"
                  },
                  {
                    "label": "Plate Tectonics",
                    "value": "25%",
                    "description": "Continental drift & boundaries",
                    "segments": [
                      {
                        "label": "Voronoi Cells",
                        "value": "10%",
                        "description": "Plate boundary geometry"
                      },
                      {
                        "label": "Force Vectors",
                        "value": "15%",
                        "description": "Convergence & divergence"
                      }
                    ]
                  },
                  {
                    "label": "Environmental Systems",
                    "value": "70%",
                    "description": "Weather, currents & surface features",
                    "segments": [
                      {
                        "label": "Atmospheric",
                        "value": "30%",
                        "description": "Wind patterns & pressure"
                      },
                      {
                        "label": "Oceanic",
                        "value": "25%",
                        "description": "Current flows & temperatures"
                      },
                      {
                        "label": "Surface",
                        "value": "15%",
                        "description": "Base water levels & topology"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "explanation": "### Configuration Control Surface\n\nThe foundation layer is heavily configurable through the `foundation.*` config namespace. These knobs control everything from deterministic seeding to plate count to atmospheric dynamics."
            },
            {
              "table": {
                "rows": [
                  "Config Namespace,Key Controls",
                  "foundation.seed,mode / fixed / offsets — determinism and reproducibility",
                  "foundation.plates,count / convergenceMix / relaxation / jitter — plate layout",
                  "foundation.dynamics,wind / currents / mantle / directionality — atmospheric drivers",
                  "foundation.surface,baseWaterPercent / band geometry / separation — continental targets"
                ],
                "caption": "Control surface for physics foundation"
              }
            },
            {
              "explanation": "### Phase Status\n\nPhase A (Foundations Alignment) is **complete**. The `PlateSeedManager` captures deterministic seeds, `WorldModel` publishes frozen snapshots, and the orchestrator gates downstream stages with runtime assertions. This is the most solid layer in the stack."
            },
            {
              "kpi": {
                "label": "Phase A Status",
                "value": "Complete",
                "status": "positive",
                "subtitle": "Solid foundation layer"
              }
            }
          ]
        },
        {
          "id": "morphology-layer",
          "order": 3,
          "concept": "physics",
          "explanation": "## Layer 2: Heightfield Buffer\nWhere terrain gets sculpted without micro-mutating the engine",
          "blocks": [
            {
              "explainer": {
                "content": "Morphology is where the world gets its physical shape—coastlines, mountains, volcanoes, lakes. But there's an architectural challenge: if we write to the engine after every tweak, we risk micro-mutations that get out of sync. The solution is a **staging buffer**.\n\nInstead of mutating `GameplayMap` directly, morphology stages operate on an in-memory heightfield buffer. Changes accumulate in this buffer, and we flush to the engine only at cluster boundaries via `syncHeightfield()`. This batching ensures consistency and makes it possible to reason about terrain state at any point in the pipeline."
              }
            },
            {
              "explanation": "### Buffer Architecture\n\nThe heightfield buffer is a parallel data structure that mirrors the engine's terrain state. It consists of three typed arrays that track elevation, terrain type, and land/water status for every tile."
            },
            {
              "layers": {
                "title": "Heightfield Buffer Components",
                "caption": "In-memory arrays, not engine state",
                "layout": "stack",
                "layers": [
                  {
                    "label": "elevation",
                    "value": "Int16Array",
                    "description": "Height values per tile (-32768 to 32767)"
                  },
                  {
                    "label": "terrain",
                    "value": "Uint8Array",
                    "description": "Terrain type codes (ocean, coast, plains, etc.)"
                  },
                  {
                    "label": "landMask",
                    "value": "binary",
                    "description": "Boolean: is this tile land?"
                  }
                ]
              }
            },
            {
              "explanation": "### Stage Flow\n\nMorphology runs as a cluster of ordered stages. Each stage reads from and writes to the shared buffer. Only after the entire cluster completes do we sync back to the engine. This is the \"buffer pattern\" that keeps terrain mutations consistent."
            },
            {
              "diagram": {
                "content": "graph LR\n    subgraph MORPH[\"MORPHOLOGY CLUSTER\"]\n        C[coastlines] --> I[islands]\n        I --> M[mountains]\n        M --> V[volcanoes]\n        V --> L[lakes]\n    end\n    MORPH --> HF[Heightfield Buffer]\n    HF -->|syncHeightfield| GM[GameplayMap]\n    \n    style HF fill:#3b82f6,color:#fff\n    style GM fill:#6b7280,color:#fff",
                "caption": "Buffer pattern: batch operations, sync at cluster boundary"
              }
            },
            {
              "explanation": "### Per-Stage Configuration\n\nEach morphology stage has its own config namespace with specific controls. Coastlines control ruggedization and fjord density. Islands control chain placement and sea lane protection. Mountains are plate-aware with uplift sensitivity. Volcanoes bias toward convergent zones and hotspots. Lakes provide balance moderation."
            },
            {
              "table": {
                "rows": [
                  "Stage,Config Namespace,Controls",
                  "coastlines,coastlines.*,ruggedization / fjord density / shelf smoothing",
                  "islands,islands.*,chain placement / sea lane protection / volcanic arcs",
                  "mountains,mountains.*,plate-aware placement / uplift sensitivity / range continuity",
                  "volcanoes,volcanoes.*,convergent zone bias / hotspot cues / eruption frequency",
                  "lakes,lakes.*,balance moderation / minimum size / drainage patterns"
                ],
                "caption": "Per-stage morphology controls"
              }
            },
            {
              "explanation": "### Phase Status & Gaps\n\nPhase B (Morphology Refactor) is **complete**. The heightfield buffer is in place, all morphology stages operate on it, and `StoryOverlays.margins` is now published so downstream stages don't need to rerun margin detection.\n\nThe remaining gap is **tuning validation**. The config knobs exist, but we haven't systematically verified that fjord/smoothing ratios produce the expected visual results. This tuning work is blocked until downstream phases stabilize—no point tuning morphology if narrative overlays are still reading stale data."
            },
            {
              "kpi": {
                "label": "Phase B Status",
                "value": "Complete",
                "status": "positive",
                "subtitle": "StoryOverlays.margins now published"
              }
            }
          ]
        },
        {
          "id": "climate-layer",
          "order": 4,
          "concept": "climate",
          "explanation": "## Layer 3: Climate System\nAdding atmosphere to the terrain",
          "blocks": [
            {
              "explainer": {
                "content": "With terrain shape established, the climate layer adds atmospheric realism. This determines where deserts form, where rainforests thrive, and how moisture flows across the landscape. Like morphology, climate operates on its own buffer—rainfall and humidity arrays that parallel the heightfield.\n\nThe key insight is that climate needs terrain data (for orographic effects) but also needs river flow data (for corridor moisture). This creates an ordering challenge that we solve with a **two-phase approach**."
              }
            },
            {
              "explanation": "### Two-Phase Climate Generation\n\nClimate generation splits into two distinct phases with river generation sandwiched between:\n\n1. **Baseline** establishes broad patterns from latitude bands (poles dry, equator wet) plus orographic bonuses near mountains\n2. **Rivers** run after baseline because they need the initial moisture distribution, and their flow data informs corridor effects\n3. **Refinement** adds fine-grained detail: water gradients near coasts, rain shadows on lee sides of mountains, corridor moisture along rivers, and basin effects in low areas"
            },
            {
              "diagram": {
                "content": "graph TD\n    HF[Heightfield + Wind/Currents] --> CB[climateBaseline]\n    CB -->|latitude bands + orographic| R[rivers]\n    R -->|flow data captured| CR[climateRefine]\n    CR -->|gradients + shadows + corridors| CF[ClimateField]\n    \n    style CF fill:#22c55e,color:#fff",
                "caption": "Two-phase climate: baseline → rivers → refinement"
              }
            },
            {
              "explanation": "### Phase Breakdown\n\nEach phase has distinct responsibilities. Baseline thinks in broad strokes—latitude, elevation, distance from coast. Refinement thinks locally—what's the terrain like in the immediate neighborhood?"
            },
            {
              "layers": {
                "title": "Two-Phase Climate",
                "caption": "Baseline establishes patterns, refinement adds detail",
                "layout": "pyramid",
                "layers": [
                  {
                    "label": "Phase 1: Baseline",
                    "value": "broad",
                    "description": "Latitude bands (poles dry, equator wet) + orographic bonuses"
                  },
                  {
                    "label": "Rivers",
                    "value": "vanilla",
                    "description": "Engine generation captures flow data for corridor effects"
                  },
                  {
                    "label": "Phase 2: Refinement",
                    "value": "detailed",
                    "description": "Water gradients, lee shadows, river corridors, basin effects"
                  }
                ]
              }
            },
            {
              "explanation": "### Configuration Control Surface\n\nClimate is controlled through three config namespaces: `baseline` for broad patterns, `refine` for local effects, and `swatches` for named climate zones like desert belts and rainbelts."
            },
            {
              "table": {
                "rows": [
                  "Config Namespace,Controls",
                  "climate.baseline,bands / orographic / coastal / noise amplitude",
                  "climate.refine,waterGradient / orographic / riverCorridor / lowBasin",
                  "climate.swatches,macroDesertBelt / equatorialRainbelt / polar zones"
                ],
                "caption": "Climate configuration surface"
              }
            },
            {
              "explanation": "### Phase Status & Gaps\n\nPhase C (Hydrology & Climate Unification) is **complete**. The two-phase approach is implemented, rivers run at the right time, and `ClimateField` arrays are published for downstream consumers.\n\nThe gap is **swatch tuning**. Do desert belts land where expected relative to latitude and orography? Do rain shadows form correctly on mountain lee sides? These are empirical questions that require systematic testing once the contract layer is enforced."
            },
            {
              "kpi": {
                "label": "Phase C Status",
                "value": "Complete",
                "status": "positive",
                "subtitle": "Architecture sound, tuning pending"
              }
            }
          ]
        },
        {
          "id": "narrative-layer",
          "order": 5,
          "concept": "narrative",
          "explanation": "## Layer 4: Narrative Overlays\nNon-destructive annotation on locked terrain",
          "blocks": [
            {
              "explainer": {
                "content": "Once physics (heightfield + climate) is locked, the narrative layer interprets and annotates without modifying. This is a critical architectural boundary: narrative stages **READ** the physics buffers and **WRITE** to tag registries. They never mutate terrain or climate directly.\n\nThis separation ensures physics integrity while allowing rich storytelling cues. A rift line doesn't carve a canyon—the canyon was carved during morphology. The rift tag just marks where the canyon is so downstream stages can place appropriate features."
              }
            },
            {
              "explanation": "### Two Tag Systems\n\nThe pipeline has two parallel tagging systems with different mutability characteristics:\n\n- **StoryOverlays** is an immutable registry of frozen snapshots. Once an overlay is published (like `margins`), it never changes. This provides stable reference data.\n- **StoryTags** is a mutable singleton with working sets. Stages can add tags, and downstream stages can read them. This is the legacy system being migrated.\n\nThe architectural goal is to move toward StoryOverlays as the authoritative source, with StoryTags hydrated from overlays at stage boundaries."
            },
            {
              "table": {
                "rows": [
                  "System,Mutability,Purpose",
                  "StoryOverlays,Immutable,Registry of frozen snapshots (margins / corridors / hotspots)",
                  "StoryTags,Mutable,Working sets hydrated from overlays and extended by current pass"
                ],
                "caption": "Two tag systems: overlays are immutable source, tags are mutable working copies"
              }
            },
            {
              "explanation": "### Narrative Stage Flow\n\nNarrative stages run in a specific order, each reading from physics data and prior overlays, then writing new overlays or tags. The flow ensures that each stage has the context it needs."
            },
            {
              "diagram": {
                "content": "graph TD\n    subgraph INPUTS[\"📚 INPUTS (read-only)\"]\n        style INPUTS fill:#e8f4f8,stroke:#2563eb,stroke-width:3px,color:#1e40af,rx:10,ry:10\n        FC[\"🌍 FoundationContext\"]\n        HF[\"⛰️ Heightfield\"]\n        CF[\"🌦️ ClimateField\"]\n        style FC fill:#dbeafe,stroke:#3b82f6,stroke-width:2px,color:#1d4ed8\n        style HF fill:#dbeafe,stroke:#3b82f6,stroke-width:2px,color:#1d4ed8\n        style CF fill:#dbeafe,stroke:#3b82f6,stroke-width:2px,color:#1d4ed8\n    end\n    \n    subgraph STAGES[\"⚙️ NARRATIVE STAGES\"]\n        style STAGES fill:#fef3e2,stroke:#f59e0b,stroke-width:3px,color:#d97706,rx:10,ry:10\n        SS[\"🎲 storySeed\"] --> SH[\"🔥 storyHotspots\"]\n        SH --> SR[\"⚡ storyRifts\"]\n        SR --> SO[\"🏔️ storyOrogeny\"]\n        SO --> SC[\"🛤️ storyCorridors\"]\n        SC --> SW[\"🎨 storySwatches\"]\n        style SS fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#ea580c\n        style SH fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#ea580c\n        style SR fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#ea580c\n        style SO fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#ea580c\n        style SC fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#ea580c\n        style SW fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#ea580c\n    end\n    \n    subgraph OUTPUTS[\"📤 OUTPUTS\"]\n        style OUTPUTS fill:#f0fdf4,stroke:#16a34a,stroke-width:3px,color:#15803d,rx:10,ry:10\n        OV[\"📋 StoryOverlays\"]\n        ST[\"🏷️ StoryTags\"]\n        style OV fill:#bbf7d0,stroke:#22c55e,stroke-width:2px,color:#16a34a\n        style ST fill:#fecaca,stroke:#ef4444,stroke-width:2px,color:#dc2626\n    end\n    \n    INPUTS -->|\"Read Physics\"| STAGES\n    STAGES -->|\"Write Tags\"| OUTPUTS",
                "caption": "Overlays read physics, write tags—never modify terrain"
              }
            },
            {
              "explanation": "### Concrete Example: The Margin System\n\nContinental margins illustrate how narrative overlays work:\n\n1. `storyTagContinentalMargins()` scans coastal tiles row by row\n2. Long runs get classified as **active** (collision zones, like the Andes) or **passive** (trailing edges, like the U.S. Atlantic coast)\n3. Results publish to `StoryOverlays.margins` as an immutable snapshot\n4. Legacy consumers read from `StoryTags.activeMargin` and `StoryTags.passiveShelf`\n5. Downstream stages like coastline polish and island placement use these tags to bias their decisions—fjords on active margins, reefs on passive shelves"
            },
            {
              "explanation": "### Configuration Control Surface\n\nNarrative overlays are controlled through several config namespaces, each targeting different story elements."
            },
            {
              "table": {
                "rows": [
                  "Config Namespace,Controls",
                  "story.*,hotspot count / rift frequency / corridor width",
                  "margins.*,active/passive fractions / minimum segment length",
                  "swatches.*,desert density / rainfall multipliers / climate tweaks"
                ],
                "caption": "Narrative overlay configuration"
              }
            },
            {
              "explanation": "### Phase Status & Gaps\n\nPhase D (Narrative Overlays Modernization) is **in progress**. This is a key gap area with several issues:\n\n1. **Direct engine probes**: Some story stages still query `GameplayMap` directly instead of reading the authoritative heightfield buffer\n2. **Singleton pattern**: StoryTags is a global singleton—inconsistent with the overlay registry model\n3. **Hydration inconsistency**: Some passes reset tags, others don't, leading to unpredictable state\n\nThese issues likely contribute to inconsistent results. A narrative stage might run with stale tag data or see terrain state that doesn't match what earlier stages wrote to the buffer."
            },
            {
              "kpi": {
                "label": "Phase D Status",
                "value": "In Progress",
                "status": "neutral",
                "subtitle": "Key gap area—migration incomplete"
              }
            }
          ]
        },
        {
          "id": "biomes-layer",
          "order": 6,
          "concept": "narrative",
          "explanation": "## Layer 5: Biomes & Features\nDecorating the terrain with gameplay elements",
          "blocks": [
            {
              "explainer": {
                "content": "Biomes and features are the final terrain layer—where abstract physics and climate data become visible gameplay elements. This layer **consumes everything** that came before: heightfield for elevation, climate field for moisture, and story overlays for narrative context.\n\nThe approach is \"vanilla first, then bias\": we let the engine's standard biome assignment run, then apply gentle overlays from StoryTags to nudge results toward narrative intent. A tile tagged as a hotspot gets a slight bias toward volcanic vegetation. A passive shelf gets extra reef chances."
              }
            },
            {
              "explanation": "### Consumption Pattern\n\nThis layer is a pure consumer—it doesn't produce new data products that downstream stages need. Instead, it transforms all prior data into final terrain assignments validated against gameplay rules."
            },
            {
              "diagram": {
                "content": "graph LR\n    HF[Heightfield] --> B[biomes]\n    CF[ClimateField] --> B\n    OV[StoryOverlays] --> B\n    ST[StoryTags] --> B\n    B --> F[features]\n    F -->|canHaveFeature validation| FINAL[Final terrain]\n    \n    style FINAL fill:#22c55e,color:#fff",
                "caption": "Biomes/features consume all prior layers"
              }
            },
            {
              "explanation": "### Story-Driven Placement Biases\n\nStoryTags influence feature placement through weighted biases. The engine's `canHaveFeature()` validation ensures gameplay legality—we only nudge the *probability* of valid placements."
            },
            {
              "table": {
                "rows": [
                  "StoryTag,Biases Toward",
                  "Hotspots,volcanic vegetation / igneous rock features",
                  "Active margins,dramatic cliffs / volcanic arcs / rugged coastlines",
                  "Passive shelves,coral reefs / gentle coastal features / fishing grounds",
                  "Rift lines,arid terrain / exposed bedrock / mineral deposits"
                ],
                "caption": "Story-driven placement biases"
              }
            },
            {
              "explanation": "### Phase Status & Gaps\n\nPhase E (Biomes & Features Harmonization) is **pending**. This layer has significant work remaining:\n\n1. **Engine re-probing**: May be querying `GameplayMap` directly instead of reading from authoritative buffers, causing performance issues and potential consistency problems\n2. **Contract migration**: Not yet ported to the new data contracts (`requires`/`provides`)\n3. **Read-only enforcement**: `StoryOverlays` should be treated as immutable, but enforcement isn't in place\n\nIf biomes/features read stale engine state instead of authoritative buffers, their output diverges from what earlier layers intended. This is a likely contributor to inconsistent map generation results."
            },
            {
              "kpi": {
                "label": "Phase E Status",
                "value": "Pending",
                "status": "negative",
                "subtitle": "Needs contract migration"
              }
            }
          ]
        },
        {
          "id": "config-layer",
          "order": 7,
          "concept": "config",
          "explanation": "## Layer 6: Configuration Control\nThe meta-layer: how all the knobs are organized",
          "blocks": [
            {
              "explainer": {
                "content": "Configuration is the meta-layer that controls all other layers. The challenge: how do you let multiple map variants (classic, temperate, desert) share a single codebase while having different behaviors?\n\nThe solution is a **3-tier configuration system** that separates concerns: game-facing entry points, bootstrap resolution, and runtime execution. This architecture enables map variants without code duplication—adding a new variant means writing ~10-200 lines instead of copying ~320 lines of generation logic."
              }
            },
            {
              "explanation": "### Three-Tier Architecture\n\nThe three tiers form a pipeline that transforms declarative configuration into runtime behavior:\n\n**Tier 1: Entry Files** — What Civ VII loads. Each map variant has a tiny entry file (`epic-diverse-huge.js`, `epic-diverse-huge-temperate.js`) that declares which presets to use and any overrides.\n\n**Tier 2: Bootstrap Pipeline** — Configuration resolution. `entry.js` → `runtime.js` → `resolved.js` → `tunables.js`. This chain deep-merges presets, stores config globally, and exports live bindings.\n\n**Tier 3: Execution** — The orchestrator calls `rebind()` at generation start, reads tunables, and executes layers in order."
            },
            {
              "diagram": {
                "content": "graph TD\n    subgraph T1[\"TIER 1: ENTRY FILES\"]\n        E1[epic-diverse-huge.js]\n        E2[epic-diverse-huge-temperate.js]\n        E3[epic-diverse-huge-kahula.js]\n    end\n    subgraph T2[\"TIER 2: BOOTSTRAP\"]\n        EN[entry.js] --> RT[runtime.js]\n        RT --> RS[resolved.js]\n        RS --> TU[tunables.js]\n    end\n    subgraph T3[\"TIER 3: EXECUTION\"]\n        ORCH[map_orchestrator.js]\n    end\n    T1 -->|bootstrap + presets| T2\n    T2 -->|rebind + read| T3\n    \n    style T1 fill:#f97316,color:#fff\n    style T2 fill:#f97316,color:#fff\n    style T3 fill:#f97316,color:#fff",
                "caption": "3-tier configuration flow"
              }
            },
            {
              "explanation": "### Key Architectural Properties\n\nThe config system has three critical properties that enable safe, predictable behavior:"
            },
            {
              "layers": {
                "title": "Configuration Properties",
                "caption": "Key architectural properties",
                "layout": "stack",
                "layers": [
                  {
                    "label": "Frozen config",
                    "value": "immutable",
                    "description": "No runtime mutation after bootstrap—prevents accidental changes"
                  },
                  {
                    "label": "Live bindings",
                    "value": "ES modules",
                    "description": "Tunables are `let` exports updated by `rebind()`—no stale reads"
                  },
                  {
                    "label": "Preset composition",
                    "value": "stackable",
                    "description": "BASE → presets (ordered) → overrides—predictable merge order"
                  }
                ]
              }
            },
            {
              "explanation": "### Entry File Example\n\nHere's what a map variant entry file looks like. Notice how declarative it is—just presets and overrides, no generation logic:"
            },
            {
              "codeBlock": {
                "file": "maps/epic-diverse-huge-desert.js",
                "startLine": 1,
                "endLine": 10,
                "code": "import { bootstrap } from \"./bootstrap/entry.js\";\nbootstrap({\n    presets: [\"classic\"],\n    overrides: {\n        climate: {\n            baseline: { /* arid settings */ }\n        }\n    }\n});\nimport \"./map_orchestrator.js\";",
                "language": "javascript"
              }
            },
            {
              "explanation": "### Architecture Assessment\n\nThe configuration system is **solid**. It achieves the goal of multiple variants from one codebase with clean separation of concerns. Adding a new variant requires:\n1. Entry file (~10-200 lines)\n2. XML registration\n3. Localization strings\n\nNo orchestrator changes needed. Future enhancements could include hot reload during development, preset validation at load time, and a config inspector debug tool."
            }
          ]
        },
        {
          "id": "contracts-layer",
          "order": 8,
          "concept": "config",
          "explanation": "## Data Contracts\nHow layers communicate and where enforcement is needed",
          "blocks": [
            {
              "explainer": {
                "content": "Data contracts are the connective tissue of the pipeline. Each stage declares what it **requires** (inputs) and what it **provides** (outputs). When contracts are enforced, a stage cannot run without its declared inputs—the orchestrator blocks execution and logs a clear error.\n\nThis isn't just documentation. It's runtime validation that catches bugs early: \"Stage X tried to run but Stage Y (which provides the data X needs) was disabled.\" Without enforcement, bad data silently propagates downstream."
              }
            },
            {
              "explanation": "### The Data Product Chain\n\nData products flow through the pipeline in a strict order. Each product is immutable once published—downstream stages can read but not modify."
            },
            {
              "diagram": {
                "content": "graph TD\n    S[Engine Seed] --> FC[FoundationContext]\n    FC -->|immutable| HF[Heightfield]\n    HF -->|buffered| CF[ClimateField]\n    CF -->|buffered| OV[StoryOverlays]\n    OV -->|immutable| ST[StoryTags]\n    ST -->|mutable| GM[Final GameplayMap]\n    \n    style FC fill:#3b82f6,color:#fff\n    style HF fill:#3b82f6,color:#fff\n    style CF fill:#22c55e,color:#fff\n    style OV fill:#a855f7,color:#fff\n    style ST fill:#f43f5e,color:#fff",
                "caption": "Data product chain through the pipeline"
              }
            },
            {
              "explanation": "### Manifest Structure\n\nThe stage manifest is where contracts are declared. Each stage entry specifies `enabled` (can be toggled), `requires` (what must exist), and `provides` (what this stage produces)."
            },
            {
              "codeBlock": {
                "file": "bootstrap/manifest.js",
                "startLine": 1,
                "endLine": 20,
                "code": "stageManifest: {\n  order: [\"foundation\", \"landmassPlates\", \"coastlines\", \n          \"storySeed\", /* ... */, \"placement\"],\n  stages: {\n    foundation: { \n      enabled: true, \n      requires: [], \n      provides: [\"FoundationContext\"]\n    },\n    coastlines: { \n      enabled: true, \n      requires: [\"foundation\"], \n      provides: [\"heightfield\"] \n    },\n    biomes: {\n      enabled: true,\n      requires: [\"heightfield\", \"climate\", \"narrative\"],\n      provides: [\"biomes\"]\n    }\n  }\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### The Canonical Principle: Physics Before Narrative\n\nThe ordering enforced by contracts reflects a core architectural principle: **physics before narrative**. Morphology and climate operate on the finished heightfield *before* story overlays fire.\n\nThis ensures:\n- **Terrain stability**: Narrative interprets terrain that won't change\n- **No conflicts**: Overlays annotate rather than fight physics\n- **Determinism**: Same inputs produce same outputs"
            },
            {
              "explanation": "### Phase Status & Gaps\n\nPhase F (Manifest Enforcement & Cleanup) is **pending**. This is a critical enforcement layer with significant gaps:\n\n- Runtime assertions exist but are incomplete\n- Some stages bypass contract checks entirely\n- No `consumes`/`produces` metadata validation yet\n- Stages can run with missing inputs, producing garbage that cascades downstream\n\nThis is likely a major contributor to inconsistent results. A downstream stage might operate on stale or absent data products without any warning."
            },
            {
              "kpi": {
                "label": "Phase F Status",
                "value": "Pending",
                "status": "negative",
                "subtitle": "Critical enforcement layer"
              }
            }
          ]
        },
        {
          "id": "synthesis",
          "order": 9,
          "concept": "config",
          "explanation": "## Synthesis: Gaps & Path Forward\nWhere control is needed and what to do about it",
          "blocks": [
            {
              "explanation": "### Phase Status Overview\n\nThe pipeline is roughly two-thirds complete. Foundation, morphology, and climate are solid. Narrative is in progress. Biomes and contract enforcement are pending."
            },
            {
              "kpiGrid": {
                "layout": "uniform",
                "items": [
                  {
                    "label": "Phase A",
                    "value": "Complete",
                    "status": "positive",
                    "subtitle": "Foundations"
                  },
                  {
                    "label": "Phase B",
                    "value": "Complete",
                    "status": "positive",
                    "subtitle": "Morphology"
                  },
                  {
                    "label": "Phase C",
                    "value": "Complete",
                    "status": "positive",
                    "subtitle": "Climate"
                  },
                  {
                    "label": "Phase D",
                    "value": "In Progress",
                    "status": "neutral",
                    "subtitle": "Narrative"
                  },
                  {
                    "label": "Phase E",
                    "value": "Pending",
                    "status": "negative",
                    "subtitle": "Biomes"
                  },
                  {
                    "label": "Phase F",
                    "value": "Pending",
                    "status": "negative",
                    "subtitle": "Contracts"
                  }
                ]
              }
            },
            {
              "explanation": "### Key Gaps Identified\n\nFour systemic issues explain most of the inconsistent results:\n\n**1. Direct Engine Probes**\nSome stages (especially narrative and biomes) query `GameplayMap` directly instead of reading from authoritative buffers. This creates inconsistency—they may see stale or out-of-sync terrain state that doesn't match what earlier stages wrote.\n\n**2. StoryTags Singleton vs. Overlay Registry**\nTwo parallel tagging systems exist with different mutability guarantees. The legacy `StoryTags` singleton and the new `StoryOverlays` registry aren't consistently used. Some passes hydrate from overlays, others don't, leading to incomplete tag data.\n\n**3. No Contract Validation**\n`consumes`/`produces` metadata exists in concept but isn't enforced at runtime. Stages can run without their declared inputs, producing garbage outputs that cascade downstream. There's no error, no warning—just wrong results.\n\n**4. Tuning Uncertainty**\nConfig knobs exist at every layer, but systematic tuning hasn't happened. Hard to know if values are right when data flow isn't clean. Tuning before fixing contracts is wasted effort."
            },
            {
              "explanation": "### The Cascade Problem\n\nMissing or stale inputs don't cause errors—they cause wrong outputs that look plausible. These wrong outputs become inputs to downstream stages, amplifying the error."
            },
            {
              "diagram": {
                "content": "graph TD\n    A[Missing/stale input] --> B[Stage runs anyway]\n    B -->|no error| C[Produces incorrect output]\n    C --> D[Downstream consumes bad output]\n    D --> E[Unpredictable results]\n    \n    style A fill:#ef4444,color:#fff\n    style E fill:#ef4444,color:#fff",
                "caption": "Gap cascade: missing inputs propagate silently"
              }
            },
            {
              "explanation": "### Recommended Path Forward\n\nThe gaps have a natural priority order. Fix data flow first, then enforce contracts, then tune."
            },
            {
              "objectivesDisplay": {
                "objectives": [
                  {
                    "title": "Complete Phase D (Narrative Migration)",
                    "description": "Ensure all narrative stages read buffers, not GameplayMap",
                    "keyResults": [
                      {
                        "category": "remove",
                        "text": "Direct GameplayMap probes in story stages"
                      },
                      {
                        "category": "add",
                        "text": "Consistent StoryOverlays registry usage"
                      },
                      {
                        "category": "increase",
                        "text": "Tag hydration consistency across passes"
                      }
                    ],
                    "rank": 1
                  },
                  {
                    "title": "Implement Phase F (Contract Enforcement)",
                    "description": "Add consumes/produces validation to stage manifest",
                    "keyResults": [
                      {
                        "category": "add",
                        "text": "consumes/produces metadata on all stages"
                      },
                      {
                        "category": "add",
                        "text": "Runtime validation that blocks bad execution"
                      },
                      {
                        "category": "add",
                        "text": "Clear error messages identifying missing data"
                      }
                    ],
                    "rank": 2
                  },
                  {
                    "title": "Build Diagnostic Tooling",
                    "description": "Visualize what each stage actually produces",
                    "keyResults": [
                      {
                        "category": "add",
                        "text": "Data product visualization at stage boundaries"
                      },
                      {
                        "category": "add",
                        "text": "Cross-run diff tooling for reproducibility testing"
                      },
                      {
                        "category": "add",
                        "text": "ASCII dumps showing buffer state evolution"
                      }
                    ],
                    "rank": 3
                  },
                  {
                    "title": "Systematic Tuning Pass",
                    "description": "Only after contracts enforced and data flow clean",
                    "keyResults": [
                      {
                        "category": "add",
                        "text": "Per-namespace config testing with expected outputs"
                      },
                      {
                        "category": "add",
                        "text": "Documentation of expected results per preset"
                      }
                    ],
                    "rank": 4
                  }
                ],
                "layout": "default"
              }
            },
            {
              "explanation": "### Control Surface Summary\n\nEach layer has its own control surface with varying levels of maturity. The summary below captures current status."
            },
            {
              "table": {
                "rows": [
                  "Layer,Control Surface,Status",
                  "Engine (L0),Limited—we wrap not replace,Accepted tradeoff",
                  "Foundation (L1),foundation.* namespace,Solid",
                  "Morphology (L2),coastlines.*/mountains.*/etc.,Complete but needs tuning",
                  "Climate (L3),climate.* namespace,Sound architecture",
                  "Narrative (L4),story.* namespace,Inconsistent reads—needs migration",
                  "Biomes (L5),biomes.*/features.*,Needs contract port",
                  "Config (L6),3-tier system,Solid",
                  "Contracts,Stage manifest,Enforcement pending"
                ],
                "caption": "Control surface summary across all layers"
              }
            }
          ]
        }
      ]
    }
  ]
}
</file>

<file path="projects/engine-refactor-v1/resources/slideshows/map-generation-pipeline.outline.md">
# Map Generation Pipeline Explainer - Outline

## Narrative Approach: "Layers of Control"

Build understanding floor-by-floor through the 6-layer stack, with each layer showing:
- What it receives (data products in)
- What it produces (data products out)
- Where control exists (config knobs)
- What's tight vs loose (gaps/opportunities)

---

## Slide 1: The Engine Layer (Layer 0)
**Purpose**: Establish what Civ VII gives us—the foundation we cannot escape

**Content**:
- Engine globals: `GameplayMap`, `TerrainBuilder`, `ResourceBuilder`, `FertilityBuilder`, `GameInfo`
- Base-standard imports: `assign-starting-plots.js`, `elevation-terrain-generator.js`, `map-utilities.js`
- Voronoi utilities: Native plate generation we wrap and seed
- Key insight: Headless generation impossible—we're married to the engine

**Block type**: `explanation` with diagram showing engine → our code boundary

**Data products**: None in, Engine APIs out

**Control surface**: Limited—we control how we *call* the engine, not what it does

**Gap/opportunity**: Tight coupling means we can't unit test in isolation. Accepted tradeoff.

---

## Slide 2: Physics Foundation (Layer 1)
**Purpose**: The single source of truth for world physics

**Content**:
- `foundation` stage creates `FoundationContext`
- Contains: plate IDs, tectonic tensors (uplift, rift, stress), atmospheric drivers (wind, currents)
- `landmassPlates` stage uses FoundationContext to project plate-aware land mask
- Deterministic seeding via `PlateSeedManager`

**Block type**: `layers` showing FoundationContext structure

**Data products**: Engine seed in → `FoundationContext` out (immutable, frozen)

**Control surface**:
- `foundation.seed` (mode, fixed, offsets)
- `foundation.plates` (count, convergenceMix, relaxation, jitter)
- `foundation.dynamics` (wind, currents, mantle, directionality)
- `foundation.surface` (baseWaterPercent, band geometry)

**Gap/opportunity**: Phase A complete. Solid foundation. Future: consumes/produces validation.

---

## Slide 3: Heightfield Buffer (Layer 2 - Morphology)
**Purpose**: Where terrain gets sculpted without micro-mutating the engine

**Content**:
- In-memory staging buffer: `elevation` (Int16Array), `terrain` (Uint8Array), `landMask`
- Stages: `coastlines`, `islands`, `mountains`, `volcanoes`, `lakes`
- Batched sync: Changes flush to engine only at cluster boundaries via `syncHeightfield()`
- Why buffer? Prevents micro-mutations from getting out of sync

**Block type**: `diagram` showing buffer → engine sync pattern

**Data products**: `FoundationContext` in → `Heightfield` out

**Control surface**:
- `coastlines.*` (ruggedization, fjord density)
- `mountains.*` (plate-aware placement, uplift sensitivity)
- `islands.*` (chain placement, protected sea lanes)
- Per-stage enable/disable via `stageManifest`

**Gap/opportunity**: Phase B complete. `StoryOverlays.margins` now published. Question: are fjord/smoothing ratios well-tuned?

---

## Slide 4: Climate System (Layer 3)
**Purpose**: Adding atmosphere to the terrain

**Content**:
- Climate buffer: rainfall + humidity arrays (parallel to heightfield)
- Two-phase approach:
  1. `climateBaseline`: Latitude bands + orographic bonuses
  2. `climateRefine`: Water gradients, lee shadows, river corridors, basin effects
- Rivers run between baseline and refinement (need flow data for corridors)

**Block type**: `explanation` with climate buffer flow

**Data products**: `Heightfield` + wind/currents in → `ClimateField` out (rainfall, humidity, temperature)

**Control surface**:
- `climate.baseline.*` (bands, orographic, coastal, noise)
- `climate.refine.*` (waterGradient, orographic, riverCorridor, lowBasin)
- `climate.swatches.*` (macroDesertBelt, equatorialRainbelt, etc.)

**Gap/opportunity**: Phase C complete. Swatches may need tuning—do desert belts land where expected?

---

## Slide 5: Narrative Overlays (Layer 4)
**Purpose**: Non-destructive annotation on locked terrain

**Content**:
- Key concept: Overlays READ physics, WRITE tags—never modify heightfield/climate
- `StoryOverlays` registry: Immutable snapshots (`margins`, `corridors`, `hotspots`)
- `StoryTags`: Mutable working sets hydrated from overlays
- Stages: `storySeed`, `storyHotspots`, `storyRifts`, `storyOrogeny`, `storyCorridors`, `storySwatches`
- Margin system example: Active margins → fjords, passive shelves → reefs

**Block type**: `layers` showing overlay registry pattern

**Data products**: `Heightfield` + `ClimateField` + `FoundationContext` in → `StoryOverlays` + `StoryTags` out

**Control surface**:
- `story.*` (hotspot count, rift frequency, corridor width)
- Per-overlay config for density and placement biases

**Gap/opportunity**: Phase D in progress. Overlays still consume direct `GameplayMap` probes—need migration to buffer reads. StoryTags singleton pattern is legacy; moving to overlay registry.

---

## Slide 6: Biomes & Features (Layer 5)
**Purpose**: Decorating the terrain with gameplay elements

**Content**:
- Biomes: Vanilla pass first, then gentle bias overlays from StoryTags
- Features: Validated placement via `TerrainBuilder.canHaveFeature()`
- Consumes all prior layers: heightfield, climate, overlays
- Biased by story: hotspots get volcanoes, passive margins get reefs

**Block type**: `explanation` with consumption diagram

**Data products**: All prior layers in → Final biomes/features + validation metrics out

**Control surface**:
- `biomes.*` (bias modifiers)
- `features.*` (placement weights, StoryTag bonuses)

**Gap/opportunity**: Phase E pending. Need to port to new data contracts. Currently may be re-probing engine instead of reading buffers.

---

## Slide 7: Configuration Control (The Meta-Layer)
**Purpose**: How all the knobs are organized and composed

**Content**:
- 3-tier system:
  1. **Entry files**: Game-facing, tiny, declarative (`epic-diverse-huge.js`)
  2. **Bootstrap pipeline**: `entry.js` → `runtime.js` → `resolved.js` → `tunables.js`
  3. **Orchestrator**: Calls `rebind()`, reads tunables, executes layers
- Preset composition: BASE_CONFIG → presets (ordered) → overrides
- Config is frozen—immutable after bootstrap

**Block type**: `diagram` showing 3-tier flow

**Data products**: Presets + overrides in → Frozen config + live tunables out

**Control surface**: Everything flows through this. Add variant = new entry file + preset.

**Gap/opportunity**: Solid architecture. Future: hot reload, preset validation, config inspector.

---

## Slide 8: How Layers Communicate (Data Contracts)
**Purpose**: The connective tissue—how data flows and where contracts exist

**Content**:
- Stage manifest: Ordered checklist with `requires`/`provides` declarations
- Data products chain: `FoundationContext` → `Heightfield` → `ClimateField` → `StoryOverlays`
- Contract enforcement: Runtime assertions gate execution
- Canonical principle: "Physics Before Narrative"

**Block type**: `diagram` showing full data flow with contract checkpoints

**Data products**: Full chain visualization

**Control surface**: Stage enablement via manifest, dependency validation

**Gap/opportunity**: Phase F pending. Need `consumes`/`produces` metadata in manifest. Currently some stages bypass contract checks. This is likely contributing to inconsistent results—stages may run without proper inputs.

---

## Slide 9: Where We Are & Where Control Is Needed
**Purpose**: Synthesis—current state, gaps, and improvement opportunities

**Content**:
- Phases A-C: Complete (Foundations, Morphology, Climate)
- Phase D: In progress (Narrative modernization)
- Phases E-F: Pending (Biomes/Features harmonization, Manifest enforcement)
- Key gaps:
  1. Some stages still probe engine directly instead of reading buffers
  2. StoryTags singleton vs overlay registry inconsistency
  3. No `consumes`/`produces` validation yet—stages can run with missing inputs
  4. Tuning: Are the config knobs producing expected outputs?

**Block type**: `explanation` with status summary

**Recommendations**:
1. Complete Phase D (narrative overlay migration) to ensure consistent buffer reads
2. Add manifest contract validation (Phase F) to catch missing dependencies
3. Build diagnostic tooling to visualize what each stage actually produces
4. Systematic tuning pass once contracts are enforced

---

## Key Takeaways

1. **6-layer stack**: Engine → Foundation → Morphology → Climate → Narrative → Biomes
2. **Data products are the handoff points**: FoundationContext, Heightfield, ClimateField, StoryOverlays
3. **Control exists per-layer via config namespaces**: `foundation.*`, `climate.*`, `story.*`, etc.
4. **Current gaps are in Phases D-F**: Overlay modernization, contract enforcement
5. **Results inconsistency likely due to**: Stages bypassing buffer reads, missing dependency validation
</file>

<file path="projects/engine-refactor-v1/resources/slideshows/voronoi-plate-generation.json">
{
  "slideshows": [
    {
      "id": "voronoi-plate-generation",
      "title": "Voronoi Plate Generation: From Geology to Code",
      "concepts": {
        "geology": {
          "label": "Geology",
          "description": "Real-world plate tectonics",
          "color": "orange"
        },
        "voronoi": {
          "label": "Voronoi",
          "description": "Mathematical space partitioning",
          "color": "blue"
        },
        "physics": {
          "label": "Physics",
          "description": "Plate movement and rotation",
          "color": "green"
        },
        "boundaries": {
          "label": "Boundaries",
          "description": "Collision math and types",
          "color": "orange"
        },
        "landmass": {
          "label": "Landmass",
          "description": "Rule-based continent growth",
          "color": "purple"
        },
        "integration": {
          "label": "Integration",
          "description": "Swooper's hook mechanism",
          "color": "blue"
        },
        "intent": {
          "label": "Intent",
          "description": "Why and how we use plate data",
          "color": "green"
        },
        "config": {
          "label": "Config",
          "description": "Tunable parameters",
          "color": "default"
        },
        "creative": {
          "label": "Creative",
          "description": "World-building possibilities",
          "color": "purple"
        }
      },
      "slides": [
        {
          "id": "plate-tectonics-101",
          "order": 1,
          "concept": "geology",
          "explanation": "# Why Mountains Exist\nPlate Tectonics 101",
          "blocks": [
            {
              "explainer": {
                "content": "Every mountain range, volcanic island, and oceanic trench exists because of plate tectonics. The Earth's surface is broken into massive plates that drift, collide, and pull apart over millions of years.\n\nWhen India crashed into Asia, the Himalayas rose. When the Pacific plate dives under the Americas, volcanoes erupt along the Ring of Fire. When Africa pulls away from Arabia, the Red Sea opens.\n\nTo simulate realistic terrain in Civilization VII, Firaxis needed to capture this fundamental geological process computationally."
              }
            },
            {
              "explanation": "### The Three Boundary Types\n\nPlate interactions fall into three categories, each producing distinct geological features:\n\n**Convergent (Collision)**\n- Plates push toward each other\n- Result: Mountains, volcanic arcs, deep ocean trenches\n- Examples: Himalayas, Andes, Mariana Trench\n\n**Divergent (Separation)**\n- Plates pull apart from each other\n- Result: Rift valleys, mid-ocean ridges, new crust formation\n- Examples: East African Rift, Mid-Atlantic Ridge, Iceland\n\n**Transform (Sliding)**\n- Plates slide horizontally past each other\n- Result: Fault lines, earthquakes, shear zones\n- Examples: San Andreas Fault, Alpine Fault (New Zealand)"
            },
            {
              "layers": {
                "title": "Boundary Types and Their Results",
                "caption": "What happens when plates meet",
                "layout": "stack",
                "layers": [
                  {
                    "label": "Convergent",
                    "value": "Collision",
                    "description": "Uplift, mountains, volcanic arcs, ocean trenches"
                  },
                  {
                    "label": "Divergent",
                    "value": "Separation",
                    "description": "Rifts, spreading ridges, new oceanic crust, volcanic activity"
                  },
                  {
                    "label": "Transform",
                    "value": "Sliding",
                    "description": "Fault lines, earthquakes, lateral shear stress"
                  }
                ]
              }
            },
            {
              "explanation": "### The Simulation Challenge\n\nSimulating plate tectonics computationally requires solving two problems:\n\n1. **Space partitioning**: How do you divide a map into \"plates\"?\n2. **Physics simulation**: How do you give those plates movement and calculate what happens at boundaries?\n\nThe answer to the first question is elegant: **Voronoi diagrams**."
            }
          ]
        },
        {
          "id": "voronoi-abstraction",
          "order": 2,
          "concept": "voronoi",
          "explanation": "# The Voronoi Abstraction\nCracking the World into Cells",
          "blocks": [
            {
              "explainer": {
                "content": "Imagine dropping a handful of pebbles onto a frozen lake. Cracks spread from each impact point until they meet cracks from neighboring impacts. The result is a pattern of cells where each cell contains all points closest to its seed pebble.\n\nThis is a **Voronoi diagram**: a partition of space where every point belongs to the region of its nearest seed. The pattern looks like cracked glass, honeycomb, or dried mud. It's mathematically elegant and computationally efficient."
              }
            },
            {
              "diagram": {
                "content": "graph LR\n    subgraph SEEDS[\"1. Seed Points\"]\n        S1((seed))\n        S2((seed))\n        S3((seed))\n        S4((seed))\n    end\n    \n    subgraph EDGES[\"2. Voronoi Edges\"]\n        E[\"Lines equidistant\\nfrom neighbors\"]\n    end\n    \n    subgraph CELLS[\"3. Voronoi Cells\"]\n        C[\"Closed polygons\\n= tectonic plates\"]\n    end\n    \n    SEEDS --> EDGES --> CELLS\n    \n    style SEEDS fill:#3b82f6,color:#fff\n    style CELLS fill:#22c55e,color:#fff",
                "caption": "From random points to plate boundaries"
              }
            },
            {
              "explanation": "### Fortune's Algorithm: The Sweep Line\n\nComputing a Voronoi diagram efficiently uses **Fortune's algorithm**, an O(n log n) sweep-line method:\n\n1. Sort all seed points by Y coordinate\n2. Sweep a horizontal line from top to bottom\n3. Maintain a \"beachline\" of parabolic arcs above the sweep line\n4. Detect \"circle events\" where three arcs converge — this creates a Voronoi vertex\n5. As arcs shrink and disappear, Voronoi edges form between them\n\nThe result is a clean tessellation of the plane into convex polygons."
            },
            {
              "codeBlock": {
                "file": "core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js",
                "startLine": 29,
                "endLine": 74,
                "code": "compute(sites, bbox) {\n  this.reset();\n  let siteEvents = sites.slice(0);\n  \n  // Sort sites by y-coordinate (sweep direction)\n  siteEvents.sort((a, b) => {\n    let r = b.y - a.y;\n    if (r) return r;\n    return b.x - a.x;\n  });\n  \n  let site = siteEvents.pop();\n  let circle;\n  \n  for (;;) {\n    circle = this.firstCircleEvent;\n    \n    // Process site events before circle events at same y\n    if (site && (!circle || site.y < circle.y)) {\n      // New site: add parabola to beachline\n      cells[siteid] = this.createCell(site);\n      site.id = siteid++;\n      this.addBeachsection(site);\n      site = siteEvents.pop();\n    } else if (circle) {\n      // Circle event: remove arc, create Voronoi vertex\n      this.removeBeachsection(circle.arc);\n    } else {\n      break;\n    }\n  }\n  \n  // Clean up edges at bounding box\n  this.clipEdges(bbox);\n  this.closeCells(bbox);\n  \n  return diagram;\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### Lloyd Relaxation: Smoothing the Pattern\n\nRaw random seed points create irregular, jagged cells. CIV7 applies **Lloyd relaxation** to create more uniform, organic-looking plates:\n\n1. Compute the Voronoi diagram\n2. Move each seed to its cell's centroid (center of mass)\n3. Recompute the Voronoi diagram\n4. Repeat N times\n\nEach iteration makes cells more regular and similar in size. CIV7 typically uses 5 relaxation steps for plates."
            },
            {
              "codeBlock": {
                "file": "base-standard/scripts/kd-tree.js",
                "startLine": 351,
                "endLine": 363,
                "code": "function lloydRelaxation(cells, strength) {\n  return cells.map((cell) => {\n    // Find centroid of cell\n    const centerSite = voronoiCentroid(cell);\n    \n    // Move seed toward centroid\n    const newX = cell.site.x + strength * (centerSite.x - cell.site.x);\n    const newY = cell.site.y + strength * (centerSite.y - cell.site.y);\n    \n    return { id: 0, x: newX, y: newY };\n  });\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### From Geometry to Physics\n\nVoronoi diagrams give us the **shape** of plates — polygonal regions that tile the map. But static geometry isn't plate tectonics. Real plates *move*.\n\nThe next step is adding physics: giving each Voronoi cell a movement vector and rotation value that simulate continental drift."
            }
          ]
        },
        {
          "id": "plates-in-motion",
          "order": 3,
          "concept": "physics",
          "explanation": "# Plates in Motion\nAdding Movement and Rotation",
          "blocks": [
            {
              "explainer": {
                "content": "A Voronoi cell becomes a tectonic plate by adding two physical properties:\n\n1. **Movement vector**: Which direction the plate is drifting, and how fast\n2. **Rotation value**: Whether the plate is spinning clockwise or counterclockwise\n\nThese properties are randomly assigned when the plate is created, giving each map a unique tectonic configuration. Some plates drift north, others south. Some spin, others translate. The combination creates emergent complexity."
              }
            },
            {
              "diagram": {
                "content": "graph TD\n    subgraph PLATE[\"Tectonic Plate\"]\n        SEED[\"Seed Point\\n(plate center)\"]\n        MOV[\"Movement Vector\\n(drift direction)\"]\n        ROT[\"Rotation Value\\n(-1 to +1)\"]\n    end\n    \n    SEED --> MOV\n    SEED --> ROT\n    \n    MOV --> |\"Linear drift\"| EDGE1[\"Edge movement\"]\n    ROT --> |\"Angular motion\"| EDGE2[\"Edge movement\"]\n    \n    EDGE1 --> BOUNDARY[\"Boundary\\ninteraction\"]\n    EDGE2 --> BOUNDARY\n    \n    style PLATE fill:#22c55e,color:#fff\n    style BOUNDARY fill:#ef4444,color:#fff",
                "caption": "Each plate has a center, drift vector, and rotation"
              }
            },
            {
              "explanation": "### PlateRegion: The Physics Container\n\nCIV7's `PlateRegion` class extends the basic `VoronoiRegion` to add physics properties. On construction, it randomly initializes:\n\n- **Movement direction**: Random angle 0° to 360°\n- **Movement speed**: Random 0 to 1\n- **Rotation**: Random -1 to +1 (counterclockwise to clockwise)"
            },
            {
              "codeBlock": {
                "file": "base-standard/scripts/voronoi-region.js",
                "startLine": 141,
                "endLine": 162,
                "code": "class PlateRegion extends VoronoiRegion {\n  m_movement = { x: 0, y: 0 };\n  m_rotation = 0;\n\n  constructor(name, id, type, maxArea, color) {\n    super(name, id, type, maxArea, 0, color);\n    \n    // Random movement direction (0 to 2π radians)\n    const dir = RandomImpl.fRand(\"Plate Movement Direction\") * Math.PI * 2;\n    \n    // Random movement speed (0 to 1)\n    const movementSpeed = RandomImpl.fRand(\"Plate Movement Speed\");\n    \n    // Convert polar to Cartesian\n    this.m_movement.x = Math.cos(dir) * movementSpeed;\n    this.m_movement.y = Math.sin(dir) * movementSpeed;\n    \n    // Random rotation: -1 (CCW) to +1 (CW)\n    this.m_rotation = RandomImpl.fRand(\"Plate Rotation\") * 2 - 1;\n  }\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### Movement at Any Position\n\nA plate's movement at its center is just the linear drift vector. But points far from the center also experience rotational motion. The total movement at any position combines:\n\n1. **Translation**: The plate's linear drift (same everywhere)\n2. **Rotation**: Angular motion around the plate center (increases with distance from center)\n\nThis is why plate boundaries can curve — different parts of a rotating plate move in different directions."
            },
            {
              "codeBlock": {
                "file": "swooper-maps/mod/maps/world/plates.js",
                "startLine": 363,
                "endLine": 388,
                "code": "function calculatePlateMovement(plate, pos, rotationMultiple) {\n  // Position relative to plate center\n  const relPos = {\n    x: pos.x - plate.seedLocation.x,\n    y: pos.y - plate.seedLocation.y,\n  };\n\n  // Rotation component: how much has this point rotated?\n  const angularMovement = plate.m_rotation * Math.PI / 180 * rotationMultiple;\n  const rotatedPos = rotate2(relPos, angularMovement);\n  \n  // Rotation movement = difference between original and rotated position\n  const rotationMovement = {\n    x: relPos.x - rotatedPos.x,\n    y: relPos.y - rotatedPos.y,\n  };\n\n  // Total movement = rotation + translation\n  return {\n    x: rotationMovement.x + plate.m_movement.x,\n    y: rotationMovement.y + plate.m_movement.y,\n  };\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### The Key Insight\n\nPlate physics is **local**, not global. The movement vector at a boundary point depends on:\n- Which plate it belongs to\n- How far it is from that plate's center\n- The plate's rotation value\n\nThis locality is what makes boundary interactions interesting — the same two plates can have convergent boundaries in one place and divergent boundaries elsewhere, depending on geometry and rotation."
            }
          ]
        },
        {
          "id": "boundary-physics",
          "order": 4,
          "concept": "boundaries",
          "explanation": "# Boundary Physics\nThe Math of Collision",
          "blocks": [
            {
              "explainer": {
                "content": "A plate boundary isn't just a line — it's a zone where two plates interact. The *type* of interaction (collision, separation, sliding) depends entirely on how each plate is moving **relative to the boundary**.\n\nCIV7 computes this using vector dot products: project each plate's movement onto the boundary normal, then compare. The result determines whether plates are converging, diverging, or sliding past each other."
              }
            },
            {
              "diagram": {
                "content": "graph TD\n    subgraph PLATEAB[\"Two Adjacent Plates\"]\n        PA[\"Plate A\\nseed + movement\"]\n        PB[\"Plate B\\nseed + movement\"]\n    end\n    \n    subgraph BOUNDARY[\"Boundary Computation\"]\n        MID[\"Midpoint\\n(A.site + B.site) / 2\"]\n        NORM[\"Normal vector\\nB.site - A.site\\nnormalized\"]\n    end\n    \n    subgraph PHYSICS[\"Physics Calculation\"]\n        SUB[\"Subduction\\ndot(normal, moveA) - dot(normal, moveB)\"]\n        SLIDE[\"Sliding\\n|dot90(normal, moveA) - dot90(normal, moveB)|\"]\n    end\n    \n    PA --> MID\n    PB --> MID\n    PA --> NORM\n    PB --> NORM\n    MID --> SUB\n    NORM --> SUB\n    NORM --> SLIDE\n    \n    style BOUNDARY fill:#3b82f6,color:#fff\n    style PHYSICS fill:#ef4444,color:#fff",
                "caption": "Computing boundary type from plate movements"
              }
            },
            {
              "explanation": "### The Subduction Formula\n\nThe key calculation is **subduction** — how much the plates are moving toward or away from each other:\n\n```\nnormal = normalize(plateB.position - plateA.position)\nsubduction = dot(normal, movementA) - dot(normal, movementB)\n```\n\n- **Positive subduction**: Plates converging (collision)\n- **Negative subduction**: Plates diverging (rift)\n- **Near zero**: Plates moving parallel (transform)\n\nThe dot product projects each plate's movement onto the boundary normal. If plate A is moving toward the boundary and plate B is moving away, subduction is strongly positive."
            },
            {
              "codeBlock": {
                "file": "base-standard/scripts/voronoi_generators/continent-generator.js",
                "startLine": 710,
                "endLine": 747,
                "code": "// Iterate over all plate cells to find boundaries\nfor (const plateCell of regionCells) {\n  plateCell.ruleConsideration = true; // Mark as visited\n  \n  for (const neighborId of plateCell.cell.getNeighborIds()) {\n    const neighbor = regionCells[neighborId];\n    \n    // Only process boundary once (skip if neighbor already visited)\n    if (neighbor.plateId !== plateCell.plateId && !neighbor.ruleConsideration) {\n      \n      // Boundary position: midpoint between cell centers\n      const pos = {\n        x: (plateCell.cell.site.x + neighbor.cell.site.x) * 0.5,\n        y: (plateCell.cell.site.y + neighbor.cell.site.y) * 0.5,\n      };\n\n      // Boundary normal: direction from this plate to neighbor\n      const normal = VoronoiUtils.normalize({\n        x: neighbor.cell.site.x - plateCell.cell.site.x,\n        y: neighbor.cell.site.y - plateCell.cell.site.y,\n      });\n\n      // Calculate plate movements at this boundary point\n      const plate1Movement = calculateMovement(plates[plateCell.plateId], pos);\n      const plate2Movement = calculateMovement(plates[neighbor.plateId], pos);\n\n      // Subduction: positive = converging, negative = diverging\n      const subduction = dot2(normal, plate1Movement) - dot2(normal, plate2Movement);\n\n      // Sliding: magnitude of perpendicular motion (transform faults)\n      const sliding = Math.abs(dot2_90(normal, plate1Movement) - dot2_90(normal, plate2Movement));\n\n      plateBoundaries.push({ pos, normal, plateSubduction: subduction, plateSliding: sliding });\n    }\n  }\n}",
                "language": "javascript"
              }
            },
            {
              "table": {
                "rows": [
                  "Subduction,Sliding,Boundary Type,Geological Result",
                  "> 0.3,*,Convergent,Mountains / volcanic arcs / trenches",
                  "< -0.2,*,Divergent,Rift valleys / mid-ocean ridges",
                  "*,> 0.5,Transform,Fault lines / earthquake zones",
                  "else,else,Passive,Stable plate interior"
                ],
                "caption": "Boundary classification from physics values"
              }
            },
            {
              "explanation": "### Spatial Indexing with kdTree\n\nAll computed boundaries are stored in a **kdTree** (k-dimensional tree) for fast spatial queries. Any downstream system can ask \"what's the nearest boundary to tile (x, y)?\" and get an O(log n) answer.\n\nThis is critical for performance — landmass growth, mountain placement, and climate all need to query boundary proximity thousands of times."
            },
            {
              "codeBlock": {
                "file": "base-standard/scripts/kd-tree.js",
                "startLine": 19,
                "endLine": 58,
                "code": "class kdTree {\n  rootNode;\n  getPos;  // Function to extract position from data\n\n  constructor(getPos) {\n    this.getPos = getPos;\n  }\n\n  build(data) {\n    this.rootNode = this.buildInternal([...data]);\n  }\n\n  search(pos) {\n    return this.rootNode \n      ? this.searchInternal(this.rootNode, pos, 0, { data: this.rootNode.data, distSq: Infinity })\n      : undefined;\n  }\n\n  // Recursive build: split on alternating axes\n  buildInternal(data, axis = 0) {\n    if (data.length === 0) return undefined;\n    \n    // Sort by current axis (x or y)\n    data.sort((a, b) => \n      axis === 0 \n        ? this.getPos(a).x - this.getPos(b).x \n        : this.getPos(a).y - this.getPos(b).y\n    );\n    \n    const midIndex = Math.floor(data.length / 2);\n    const node = new kdNode(data[midIndex]);\n    \n    // Recurse on left and right halves, alternating axis\n    node.left = this.buildInternal(data.slice(0, midIndex), (axis + 1) % 2);\n    node.right = this.buildInternal(data.slice(midIndex + 1), (axis + 1) % 2);\n    \n    return node;\n  }\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### Why This Matters\n\nThe boundary physics calculation is where random plate movements become meaningful geological forces. A plate drifting northeast toward a stationary plate creates a **convergent boundary** — mountains rise. Two plates pulling apart create a **divergent boundary** — rifts form.\n\nThis emergence from simple rules is what makes CIV7's terrain feel geologically authentic rather than randomly placed."
            }
          ]
        },
        {
          "id": "landmass-growth",
          "order": 5,
          "concept": "landmass",
          "explanation": "# Landmass Growth\nSmelling Plate Boundaries",
          "blocks": [
            {
              "explainer": {
                "content": "CIV7 doesn't place continents randomly. Landmasses **grow** cell by cell from seed points, with each candidate cell scored by a weighted sum of rules. One critical rule: prefer cells near plate boundaries, especially convergent ones.\n\nThis creates terrain that follows tectonic logic — coastlines align with collision zones, mountain ranges form where plates crash together, volcanic arcs emerge at subduction zones."
              }
            },
            {
              "diagram": {
                "content": "graph TD\n    SEED[\"Landmass Seed\"] --> CONSIDER[\"Consider neighbor cells\"]\n    CONSIDER --> SCORE[\"Score each candidate\"]\n    \n    subgraph RULES[\"Weighted Rule System\"]\n        R1[\"RuleCellArea\\nweight: 0.1\"]\n        R2[\"RuleNearNeighbor\\nweight: 0.5\"]\n        R3[\"RuleAvoidEdge\\nweight: 1.0\"]\n        R4[\"RuleNearPlateBoundary\\nweight: 0.75\"]\n        R5[\"RulePreferLatitude\\nweight: 0.5\"]\n    end\n    \n    SCORE --> RULES\n    RULES --> PICK[\"Pick highest-scoring cell\"]\n    PICK --> ADD[\"Add to landmass\"]\n    ADD --> |\"Until target size\"| CONSIDER\n    \n    style R4 fill:#ef4444,color:#fff\n    style RULES fill:#f3f4f6,stroke:#374151",
                "caption": "Rule-based landmass growth — RuleNearPlateBoundary biases toward tectonics"
              }
            },
            {
              "explanation": "### The Rule System\n\nLandmass growth uses a **weighted rule system** where each rule assigns a score to candidate cells:\n\n| Rule | Weight | Effect |\n|------|--------|--------|\n| RuleAvoidEdge | 1.0 | Stay away from map poles/edges |\n| RuleNearPlateBoundary | 0.75 | Prefer convergent boundaries |\n| RuleNearNeighbor | 0.5 | Stay connected to existing cells |\n| RulePreferLatitude | 0.5 | Bias toward temperate zones |\n| RuleNeighborsInRegion | 0.25 | Prefer compact shapes |\n| RuleCellArea | 0.1 | Prefer larger Voronoi cells |\n| RuleNearRegionSeed | 0.05 | Don't stray too far from origin |\n\nThe final score is the weighted sum. Highest-scoring cell gets added to the landmass."
            },
            {
              "codeBlock": {
                "file": "base-standard/scripts/voronoi_rules/near-plate-boundary.js",
                "startLine": 13,
                "endLine": 54,
                "code": "class RuleNearPlateBoundary extends Rule {\n  static getName() { return \"Near Plate Boundary\"; }\n  \n  name = RuleNearPlateBoundary.getName();\n  description = \"Scores cells based on distance to nearest plate boundary.\";\n\n  configDefs = {\n    scaleFactor: {\n      label: \"Scale Factor\",\n      description: \"Distance where score = 0.5. Nearer scores higher.\",\n      defaultValue: 4,\n      min: 0, max: 10, step: 0.1\n    },\n    directionInfluence: {\n      label: \"Plate Direction Influence\", \n      description: \"How much plate movement direction affects score.\",\n      defaultValue: 0.5,\n      min: 0, max: 1, step: 0.05\n    }\n  };\n\n  score(regionCell, ctx) {\n    const cellPos = { x: regionCell.cell.site.x, y: regionCell.cell.site.y };\n    \n    // Query kdTree for nearest boundary\n    const boundary = this.m_plateBoundaries.search(cellPos);\n    const distance = Math.sqrt(boundary.distSq);\n\n    // Distance score: 1 at boundary, approaches 0 far away\n    const distanceScore = 1 - distance / (distance + this.configValues.scaleFactor);\n\n    // Direction score: boost for convergent (positive subduction)\n    const plateMovementScore = distanceScore * boundary.data.plateSubduction * 0.5;\n\n    // Blend based on config\n    return VoronoiUtils.lerp(distanceScore, plateMovementScore, \n                             this.configValues.directionInfluence);\n  }\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### The Emergence of Realistic Terrain\n\nWith `RuleNearPlateBoundary` weighted at 0.75, landmasses naturally grow along convergent boundaries. This produces:\n\n- **Coastal mountain ranges** (like the Andes) where ocean plates subduct under continents\n- **Volcanic arcs** (like Japan) at island chain collision zones  \n- **Rifted coastlines** where continents pulled apart\n- **Stable continental interiors** far from boundaries\n\nThe terrain isn't placed by hand — it **emerges** from the physics rules. This is why CIV7 maps feel geologically coherent."
            },
            {
              "explanation": "### Why It Works\n\nThe genius of this system is that it's **physically motivated but gameplay-friendly**:\n\n1. Mountains form at realistic locations (collision zones)\n2. But the rule weights can be tuned for gameplay balance\n3. Other rules prevent degenerate cases (too close to poles, disconnected blobs)\n4. The random seed creates variety while physics creates plausibility\n\nThis balance between simulation and design is what makes procedural terrain successful."
            }
          ]
        },
        {
          "id": "swooper-hook",
          "order": 6,
          "concept": "integration",
          "explanation": "# The Swooper Hook\nWorldModel & Typed Arrays",
          "blocks": [
            {
              "explainer": {
                "content": "CIV7's plate generation is excellent — but the physics data disappears after landmass growth. The engine doesn't persist plate boundaries or tectonic stress values.\n\nSwooper needs this data for downstream systems: climate calculations, narrative overlays, feature placement. We solve this by **wrapping** CIV7's utilities and **capturing** the physics into persistent typed arrays."
              }
            },
            {
              "diagram": {
                "content": "graph LR\n    subgraph CIV7[\"CIV7 Base Game\"]\n        VU[\"VoronoiUtils\"]\n        PR[\"PlateRegion\"]\n        KD[\"kdTree\"]\n    end\n    \n    subgraph SWOOPER[\"Swooper Engine\"]\n        PLATES[\"plates.js\\ncomputePlatesVoronoi()\"]\n        MODEL[\"WorldModel\"]\n    end\n    \n    subgraph ARRAYS[\"Typed Arrays\"]\n        A1[\"plateId[]\"]\n        A2[\"boundaryCloseness[]\"]\n        A3[\"boundaryType[]\"]\n        A4[\"upliftPotential[]\"]\n        A5[\"riftPotential[]\"]\n        A6[\"tectonicStress[]\"]\n    end\n    \n    VU -->|import| PLATES\n    PR -->|import| PLATES\n    KD -->|import| PLATES\n    PLATES -->|compute| MODEL\n    MODEL -->|publish| ARRAYS\n    \n    style CIV7 fill:#6b7280,color:#fff\n    style SWOOPER fill:#3b82f6,color:#fff\n    style ARRAYS fill:#22c55e,color:#fff",
                "caption": "Swooper wraps CIV7 utilities and captures physics into typed arrays"
              }
            },
            {
              "explanation": "### The Wrapper: computePlatesVoronoi()\n\nOur `plates.js` module imports CIV7's base utilities directly and wraps them in a function that:\n\n1. Creates Voronoi diagram using `VoronoiUtils.computeVoronoi()`\n2. Instantiates `PlateRegion` objects with physics\n3. Computes boundaries using the same algorithm as CIV7\n4. Stores boundaries in a `kdTree` for fast queries\n5. **Captures everything into typed arrays** indexed by tile position"
            },
            {
              "codeBlock": {
                "file": "swooper-maps/mod/maps/world/plates.js",
                "startLine": 66,
                "endLine": 118,
                "code": "export function computePlatesVoronoi(width, height, config) {\n  const { count, relaxationSteps, convergenceMix, plateRotationMultiple } = config;\n  const size = width * height;\n\n  // Use CIV7's utilities directly\n  const bbox = { xl: 0, xr: width, yt: 0, yb: height };\n  const sites = VoronoiUtils.createRandomSites(count, bbox.xr, bbox.yb);\n  const diagram = VoronoiUtils.computeVoronoi(sites, bbox, relaxationSteps);\n\n  // Create PlateRegions with physics (CIV7's class)\n  const plateRegions = diagram.cells.map((cell, index) => {\n    const region = new PlateRegion(`Plate${index}`, index, 0, bbox.xr * bbox.yb, randomColor());\n    region.seedLocation = { x: cell.site.x, y: cell.site.y };\n    return region;\n  });\n\n  // Compute boundaries (same algorithm as CIV7)\n  const plateBoundaries = computePlateBoundaries(regionCells, plateRegions, plateRotationMultiple);\n  const boundaryTree = new kdTree(PlateBoundaryPosGetter);\n  boundaryTree.build(plateBoundaries);\n\n  // Allocate output arrays\n  const plateId = new Int16Array(size);\n  const boundaryCloseness = new Uint8Array(size);\n  const boundaryType = new Uint8Array(size);\n  const tectonicStress = new Uint8Array(size);\n  const upliftPotential = new Uint8Array(size);\n  const riftPotential = new Uint8Array(size);\n  const shieldStability = new Uint8Array(size);\n\n  // Populate arrays from boundary queries\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const i = y * width + x;\n      const nearestBoundary = boundaryTree.search({ x, y });\n      // ... classify and store values\n    }\n  }\n\n  return { plateId, boundaryCloseness, boundaryType, upliftPotential, ... };\n}",
                "language": "javascript"
              }
            },
            {
              "table": {
                "rows": [
                  "Array,Type,Range,Purpose",
                  "plateId,Int16Array,0..N,Which plate owns this tile",
                  "boundaryCloseness,Uint8Array,0..255,Proximity to nearest boundary (255 = at boundary)",
                  "boundaryType,Uint8Array,0..3,none / convergent / divergent / transform",
                  "tectonicStress,Uint8Array,0..255,Overall stress level (tracks boundary closeness)",
                  "upliftPotential,Uint8Array,0..255,Mountain formation potential (high at convergent)",
                  "riftPotential,Uint8Array,0..255,Rift valley potential (high at divergent)",
                  "shieldStability,Uint8Array,0..255,Plate interior stability (inverse of stress)",
                  "plateMovementU/V,Int8Array,-127..127,Plate drift vector components",
                  "plateRotation,Int8Array,-127..127,Plate rotation value"
                ],
                "caption": "WorldModel typed array schema"
              }
            },
            {
              "explanation": "### Why Typed Arrays?\n\nDownstream systems process thousands of tiles and need **O(1) access** to plate data. With flat typed arrays indexed by position, any stage can instantly query:\n\n```javascript\nconst i = y * width + x;\nconst isConvergent = WorldModel.boundaryType[i] === BOUNDARY.convergent;\nconst uplift = WorldModel.upliftPotential[i] / 255;  // Normalized 0..1\n```\n\nNo kdTree queries, no lookups — just array access. This is critical for performance when climate, mountains, and features all need tectonic data."
            }
          ]
        },
        {
          "id": "intent-downstream",
          "order": 7,
          "concept": "intent",
          "explanation": "# Why We Hook In\nIntent and Downstream Consumers",
          "blocks": [
            {
              "explainer": {
                "content": "Swooper's architecture follows a core principle: **physics before narrative**. Plate tectonics is foundational physics — it should inform everything downstream without being overridden by it.\n\nBy capturing plate data early, we ensure all subsequent stages (climate, morphology, narrative, features) work from the same physical truth. A mountain stage doesn't decide where mountains go — it reads `upliftPotential` and places peaks where the physics says they should form."
              }
            },
            {
              "layers": {
                "title": "Downstream Consumers of Plate Data",
                "caption": "Who reads WorldModel and why",
                "layout": "stack",
                "layers": [
                  {
                    "label": "Morphology",
                    "value": "mountains.js, volcanoes.js, coastlines.js",
                    "description": "Uplift-aware peaks, volcanic arcs at subduction zones, ruggedized active margins"
                  },
                  {
                    "label": "Climate",
                    "value": "climateBaseline.js",
                    "description": "Orographic effects use boundary-aware elevation gradients"
                  },
                  {
                    "label": "Narrative",
                    "value": "storyRifts.js, storyOrogeny.js",
                    "description": "Tag rift valleys at divergent boundaries, collision zones at convergent"
                  },
                  {
                    "label": "Features",
                    "value": "feature-biomes.js",
                    "description": "Volcanic features biased toward convergent zones and hotspots"
                  },
                  {
                    "label": "Balance",
                    "value": "assign-starting-plots.js",
                    "description": "Avoid placing civs on tectonic stress zones"
                  }
                ]
              }
            },
            {
              "diagram": {
                "content": "graph TD\n    WM[\"WorldModel\\n(plate physics)\"] --> MORPH[\"Morphology\"]\n    WM --> CLIMATE[\"Climate\"]\n    WM --> NARRATIVE[\"Narrative Overlays\"]\n    WM --> FEATURES[\"Features\"]\n    WM --> BALANCE[\"Gameplay Balance\"]\n    \n    MORPH --> |mountains| FINAL[\"Final Terrain\"]\n    MORPH --> |volcanoes| FINAL\n    MORPH --> |coasts| FINAL\n    CLIMATE --> |rainfall| FINAL\n    NARRATIVE --> |tags| FINAL\n    FEATURES --> |placement| FINAL\n    \n    style WM fill:#22c55e,color:#fff\n    style FINAL fill:#3b82f6,color:#fff",
                "caption": "WorldModel as single source of truth for all downstream systems"
              }
            },
            {
              "explanation": "### Specific Use Cases\n\n**Mountains**: The `upliftPotential` array directly influences mountain placement. Cells with high uplift (near convergent boundaries) score higher for peak placement:\n\n```javascript\nconst uplift = WorldModel.upliftPotential[i] / 255;\nscore += uplift * CONFIG.mountains.upliftWeight;\n```\n\n**Volcanoes**: Placed preferentially where `boundaryType === convergent` AND `boundaryCloseness > threshold`. This creates volcanic arcs along subduction zones.\n\n**Coastlines**: Active margins (where `boundaryType === convergent`) get fjord-like ruggedization. Passive margins get gentle continental shelves.\n\n**Climate**: Rain shadow calculations use plate-derived elevation gradients. Mountains at convergent boundaries create strong orographic effects.\n\n**Narrative Tags**: `StoryOverlays.rifts` marks divergent zones for rift valley features. `StoryOverlays.collisionZones` marks convergent areas for dramatic terrain."
            },
            {
              "codeBlock": {
                "file": "example-downstream-usage.js",
                "startLine": 1,
                "endLine": 25,
                "code": "// Example: Mountain placement using plate data\nfunction scoreMountainPlacement(x, y) {\n  const i = y * width + x;\n  \n  // Base score from terrain type\n  let score = getBaseTerrainScore(x, y);\n  \n  // Boost from tectonic uplift potential\n  const uplift = WorldModel.upliftPotential[i] / 255;  // 0..1\n  score += uplift * CONFIG.mountains.upliftWeight;\n  \n  // Extra boost at convergent boundaries\n  if (WorldModel.boundaryType[i] === ENUM_BOUNDARY.convergent) {\n    score += CONFIG.mountains.convergentBonus;\n  }\n  \n  // Penalty at rift zones (divergent = thin crust)\n  if (WorldModel.boundaryType[i] === ENUM_BOUNDARY.divergent) {\n    score -= CONFIG.mountains.divergentPenalty;\n  }\n  \n  return score;\n}",
                "language": "javascript"
              }
            },
            {
              "explanation": "### The Architecture Payoff\n\nBy centralizing plate physics in WorldModel:\n\n1. **Consistency**: All stages see the same tectonic truth\n2. **Performance**: Pre-computed arrays enable O(1) lookups\n3. **Debuggability**: Can visualize plate data independently of terrain\n4. **Tunability**: Config knobs affect physics, which cascades to all consumers\n5. **Determinism**: Same seed → same plates → same downstream results"
            }
          ]
        },
        {
          "id": "configuration",
          "order": 8,
          "concept": "config",
          "explanation": "# Taking Control\nConfiguration Surface",
          "blocks": [
            {
              "explainer": {
                "content": "Plate generation is highly configurable through the `foundation.plates.*` namespace. You can control plate count, boundary character, relaxation quality, directionality bias, and even override the RNG seed for reproducible results.\n\nThese settings cascade through the entire pipeline — change plate count, and everything downstream adapts."
              }
            },
            {
              "table": {
                "rows": [
                  "Config Key,Type,Default,Effect",
                  "foundation.plates.relaxationSteps,number,5,Lloyd iterations (higher = more uniform cells)",
                  "foundation.plates.relaxationSteps,number,5,Lloyd iterations (higher = more uniform cells)",
                  "foundation.plates.plateRotationMultiple,number,1.0,Amplify or dampen rotational influence"
                ],
                "caption": "Core plate configuration"
              }
            },
            {
              "explanation": "### Seed Control for Reproducibility\n\nThe `PlateSeedManager` provides deterministic seeding:\n\n- **engine mode**: Use CIV7's internal RNG (different each game)\n- **fixed mode**: Use a specific seed value (reproducible results)\n- **seedOffset**: Integer offset applied to base seed (variants from same base)"
            },
            {
              "codeBlock": {
                "file": "swooper-maps/mod/maps/world/plate_seed.js",
                "startLine": 128,
                "endLine": 150,
                "code": "export const PlateSeedManager = {\n  capture(width, height, config) {\n    const seedCfg = normalizeSeedConfig(config);\n    // seedMode: \"engine\" or \"fixed\"\n    // fixedSeed: specific value when mode is \"fixed\"\n    // seedOffset: integer offset applied to base seed\n    \n    const control = applySeedControl(\n      seedCfg.seedMode, \n      seedCfg.fixedSeed, \n      seedCfg.seedOffset\n    );\n\n    return {\n      snapshot: Object.freeze({ \n        ...seedCfg, \n        seed: control.seed,\n        rngState: control.rngState \n      }),\n      restore: control.restore,  // Restore original RNG after generation\n    };\n  }\n};",
                "language": "javascript"
              }
            },
            {
              "table": {
                "rows": [
                  "Config Key,Type,Default,Effect",
                  "foundation.seed.mode,\"engine\"/\"fixed\",\"engine\",Use CIV's RNG or fixed seed",
                  "foundation.seed.fixed,number,undefined,Specific seed when mode is \"fixed\"",
                  "foundation.seed.offset,number,0,Offset applied to base seed"
                ],
                "caption": "Seed configuration for reproducibility"
              }
            },
            {
              "explanation": "### Directionality Control\n\nBeyond random plates, you can bias plate movement toward a preferred axis. This creates maps with coherent tectonic patterns — like all plates drifting generally eastward, creating parallel mountain ranges."
            },
            {
              "table": {
                "rows": [
                  "Config Key,Type,Default,Effect",
                  "foundation.directionality.cohesion,0..1,0,How strongly to bias toward primary axis",
                  "foundation.directionality.primaryAxes.plateAxisDeg,degrees,0,Preferred plate movement direction",
                  "foundation.directionality.variability.angleJitterDeg,degrees,0,Random variation around axis",
                  "foundation.directionality.variability.magnitudeVariance,0..1,0.35,Speed variation between plates"
                ],
                "caption": "Directionality configuration for coherent drift patterns"
              }
            },
            {
              "codeBlock": {
                "file": "swooper-maps/mod/maps/world/plates.js",
                "startLine": 397,
                "endLine": 415,
                "code": "function applyDirectionalityBias(plate, directionality) {\n  const cohesion = directionality?.cohesion ?? 0;\n  const plateAxisDeg = directionality?.primaryAxes?.plateAxisDeg ?? 0;\n  const jitter = getRandomJitter(directionality?.variability?.angleJitterDeg ?? 0);\n\n  // Current movement angle\n  const currentAngle = Math.atan2(plate.m_movement.y, plate.m_movement.x) * 180 / Math.PI;\n  const currentMag = Math.sqrt(plate.m_movement.x ** 2 + plate.m_movement.y ** 2);\n\n  // Blend toward target axis based on cohesion\n  const targetAngle = currentAngle * (1 - cohesion) + plateAxisDeg * cohesion + jitter;\n\n  // Apply new angle, preserve magnitude\n  const rad = targetAngle * Math.PI / 180;\n  plate.m_movement.x = Math.cos(rad) * currentMag;\n  plate.m_movement.y = Math.sin(rad) * currentMag;\n}",
                "language": "javascript"
              }
            }
          ]
        },
        {
          "id": "creative-possibilities",
          "order": 9,
          "concept": "creative",
          "explanation": "# Creative Possibilities\nDifferent Worlds",
          "blocks": [
            {
              "explainer": {
                "content": "By tuning plate generation parameters, you can create dramatically different geological settings. A high-convergence world has intense mountain building. A divergent world has rift valleys and spreading seas. Many small plates create archipelagos.\n\nConfiguration becomes world-building."
              }
            },
            {
              "table": {
                "rows": [
                  "World Type,Plates,Convergence,Rotation,Result",
                  "Pangaea,3-4,0.8,0.5,Few large continents with massive collision zones",
                  "Archipelago,15-20,0.3,1.5,Many small landmasses with volcanic island chains",
                  "Rift World,6-8,0.2,0.3,Elongated continents separated by young seas",
                  "Ring of Fire,8-10,0.9,1.0,Coastal mountain ranges with volcanic arcs everywhere",
                  "Shield World,4-5,0.1,0.2,Stable flat continents with minimal mountain building"
                ],
                "caption": "Example configurations and their geological outcomes"
              }
            },
            {
              "layers": {
                "title": "Configuration to Outcome",
                "caption": "How parameters affect world character",
                "layout": "pyramid",
                "layers": [
                  {
                    "label": "High Convergence (0.8+)",
                    "value": "Collision",
                    "description": "Many convergent boundaries → frequent mountain building → rugged coastlines, volcanic arcs"
                  },
                  {
                    "label": "Low Convergence (0.2-)",
                    "value": "Rifting",
                    "description": "Many divergent boundaries → rift valleys, spreading ridges → elongated seas, young ocean floor"
                  },
                  {
                    "label": "High Rotation (1.5+)",
                    "value": "Curves",
                    "description": "Amplified rotational effects → curved plate boundaries → arc-shaped island chains"
                  },
                  {
                    "label": "Many Plates (15+)",
                    "value": "Fragmentation",
                    "description": "Small plates → frequent boundaries → archipelago terrain, complex coastlines"
                  }
                ]
              }
            },
            {
              "explanation": "### Future Possibilities\n\nThe current system captures plate boundaries and movement. Future enhancements could add:\n\n- **Hotspot simulation**: Volcanic chains that cross plate boundaries (like Hawaii)\n- **Plate age**: Older plates = thicker, more stable; younger = thinner, more active\n- **Mantle plumes**: Deep heat sources creating localized volcanic activity independent of boundaries\n- **Historical tectonics**: Simulate plate positions at different geological eras\n- **Supercontinent cycles**: Plates that converge to form Pangaea, then rift apart"
            },
            {
              "kpiGrid": {
                "layout": "uniform",
                "items": [
                  {
                    "label": "Plate Count",
                    "value": "2-20",
                    "subtitle": "Landmass fragmentation"
                  },
                  {
                    "label": "Convergence",
                    "value": "0-1",
                    "subtitle": "Mountain intensity"
                  },
                  {
                    "label": "Rotation",
                    "value": "0-2",
                    "subtitle": "Boundary curvature"
                  },
                  {
                    "label": "Directionality",
                    "value": "0-1",
                    "subtitle": "Global drift coherence"
                  }
                ]
              }
            },
            {
              "explanation": "### Summary\n\nVoronoi plate generation transforms random geometry into physically-motivated terrain:\n\n1. **Fortune's algorithm** partitions space into cells efficiently\n2. **PlateRegion** adds movement vectors and rotation to each cell\n3. **Boundary physics** computes subduction and sliding from relative motion\n4. **Rule-based growth** biases landmasses toward convergent zones\n5. **Swooper captures** the physics into typed arrays for downstream use\n6. **Configuration** controls plate count, convergence, rotation, and seeding\n\nThe result: terrain that feels geologically authentic because it emerges from the same forces that shape real worlds."
            }
          ]
        }
      ]
    }
  ]
}
</file>

<file path="projects/engine-refactor-v1/resources/slideshows/voronoi-plate-generation.outline.md">
# Voronoi Plate Generation Explainer - Outline

## Narrative Approach: "Visual Geology with Technical Depth"

Use real-world geology as the entry point, then reveal the mathematical abstraction (Voronoi), show how CIV7 adds physics, explain boundary math, demonstrate how landmasses use this data, show Swooper's hook point, explain our intent, and finally show the control surface and creative possibilities.

**Horizontal flow:** Geology → Math → Physics → Boundaries → Usage → Hook → Intent → Control → Possibilities

**Vertical depth:** Each slide uses multiple blocks to go from intuition → technical detail → code where appropriate.

---

## Slide 1: Why Mountains Exist - Plate Tectonics 101
**Concept:** geology
**Purpose:** Build intuition about real-world plate tectonics before introducing the simulation

**Blocks:**
1. `explainer` - Opening hook: "Every mountain range, volcanic island, and oceanic trench exists because of plate tectonics. The Earth's surface is broken into massive plates that drift, collide, and pull apart. When India crashed into Asia, the Himalayas rose. When the Pacific plate dives under the Americas, volcanoes erupt along the Ring of Fire."

2. `explanation` - The three boundary types:
   - **Convergent:** Plates collide → mountains, volcanoes, trenches (Himalayas, Andes)
   - **Divergent:** Plates pull apart → rift valleys, mid-ocean ridges (East African Rift, Mid-Atlantic Ridge)
   - **Transform:** Plates slide past → earthquakes, fault lines (San Andreas)

3. `layers` - Visual hierarchy:
   - Convergent (collision) → Uplift, mountains, volcanic arcs
   - Divergent (separation) → Rifts, new crust, volcanic activity
   - Transform (sliding) → Shear stress, earthquakes

4. `explanation` - Bridge: "Simulating this computationally requires two things: a way to divide the world into plates, and a way to give those plates physics. Enter the Voronoi diagram."

**Transition:** From real geology to mathematical abstraction

---

## Slide 2: The Voronoi Abstraction - Cracking the World into Cells
**Concept:** voronoi
**Purpose:** Explain what Voronoi diagrams are and how they partition space

**Blocks:**
1. `explainer` - The cracked glass analogy: "Imagine dropping a handful of pebbles onto a frozen lake. Cracks spread from each impact point until they meet cracks from neighboring impacts. The result is a pattern of cells—each cell contains all points closest to its seed. This is a Voronoi diagram."

2. `diagram` - Voronoi construction visualization:
   ```
   Sites (seeds) → Voronoi edges → Cells

   [Points scattered] → [Lines between] → [Closed polygons]
   ```

3. `explanation` - Fortune's Algorithm (the sweep line):
   - Process sites top-to-bottom via a horizontal sweep line
   - Maintain a "beachline" of parabolic arcs
   - Detect "circle events" where three arcs converge → creates Voronoi vertex
   - O(n log n) complexity—efficient for thousands of cells

4. `codeBlock` - Core Voronoi computation structure:
   ```javascript
   // From CIV7's TypeScript-Voronoi library
   compute(sites, bbox) {
     // Sort sites by y-coordinate (sweep direction)
     siteEvents.sort((a, b) => b.y - a.y);

     for (;;) {
       if (site && (!circle || site.y < circle.y)) {
         // Process site event: add to beachline
         this.addBeachsection(site);
       } else if (circle) {
         // Process circle event: create Voronoi vertex
         this.removeBeachsection(circle.arc);
       } else break;
     }

     this.clipEdges(bbox);  // Trim to bounds
     this.closeCells(bbox); // Close boundary cells
   }
   ```

5. `explanation` - Lloyd Relaxation: "Raw random points create irregular cells. CIV7 applies 'Lloyd relaxation'—repeatedly moving each seed to its cell's centroid—to create more uniform, organic-looking plates."

6. `explanation` - Bridge: "But Voronoi cells are just geometry. To simulate tectonics, we need to add physics: movement and rotation."

**Transition:** From static geometry to dynamic plates

---

## Slide 3: Plates in Motion - Adding Movement and Rotation
**Concept:** physics
**Purpose:** Show how CIV7 adds physics to turn Voronoi cells into tectonic plates

**Blocks:**
1. `explainer` - From cells to plates: "Each Voronoi cell becomes a tectonic plate by adding two physical properties: a movement vector (where it's drifting) and a rotation value (how it's spinning). These are randomly assigned at plate creation, creating a unique tectonic configuration for each map."

2. `diagram` - Plate with physics vectors:
   ```
   ┌─────────────────────────────┐
   │                             │
   │     ⊙ ────→                 │
   │   seed   movement           │
   │     ↺                       │
   │   rotation                  │
   │                             │
   └─────────────────────────────┘
   ```

3. `codeBlock` - PlateRegion initialization:
   ```javascript
   // From voronoi-region.js
   class PlateRegion extends VoronoiRegion {
     m_movement = { x: 0, y: 0 };
     m_rotation = 0;

     constructor(name, id, type, maxArea, color) {
       super(name, id, type, maxArea, 0, color);

       // Random movement direction and speed
       const dir = RandomImpl.fRand("Plate Movement Direction") * Math.PI * 2;
       const speed = RandomImpl.fRand("Plate Movement Speed");
       this.m_movement.x = Math.cos(dir) * speed;
       this.m_movement.y = Math.sin(dir) * speed;

       // Random rotation: -1 to +1 (counterclockwise to clockwise)
       this.m_rotation = RandomImpl.fRand("Plate Rotation") * 2 - 1;
     }
   }
   ```

4. `explanation` - Movement at any position: "A plate's movement at a specific point combines its linear drift with rotational influence. Points far from the plate's center experience more rotational movement."

5. `codeBlock` - Position-specific movement calculation:
   ```javascript
   function calculatePlateMovement(plate, pos, rotationMultiple) {
     // Relative position from plate center
     const relPos = {
       x: pos.x - plate.seedLocation.x,
       y: pos.y - plate.seedLocation.y,
     };

     // Rotation component
     const angularMovement = plate.m_rotation * Math.PI / 180 * rotationMultiple;
     const rotatedPos = rotate2(relPos, angularMovement);
     const rotationMovement = {
       x: relPos.x - rotatedPos.x,
       y: relPos.y - rotatedPos.y,
     };

     // Combine translation + rotation
     return {
       x: rotationMovement.x + plate.m_movement.x,
       y: rotationMovement.y + plate.m_movement.y,
     };
   }
   ```

6. `explanation` - Bridge: "Now we have plates that move. But the interesting geology happens at the boundaries—where plates meet. How do we compute what happens there?"

**Transition:** From plate physics to boundary computation

---

## Slide 4: Boundary Physics - The Math of Collision
**Concept:** boundaries
**Purpose:** Explain the actual math that determines boundary types

**Blocks:**
1. `explainer` - Boundary as relative motion: "A plate boundary isn't just a line—it's a zone where two plates interact. The type of interaction (collision, separation, sliding) depends on how each plate is moving relative to the boundary. CIV7 computes this using vector math."

2. `diagram` - Boundary computation visualization:
   ```
   Plate A                    Plate B
     ●───→                      ←───●
   seedA  movementA    movementB  seedB
              ↓
         ┌───┬───┐
         │   │   │
         │ ● │ ● │  ← boundary midpoint
         │   │   │
         └───┴───┘
              ↓
         normal →  (points from A to B)
   ```

3. `explanation` - The subduction formula:
   - **Normal vector:** Direction perpendicular to boundary (from plate A to plate B)
   - **Subduction:** `dot(normal, movementA) - dot(normal, movementB)`
     - Positive = plates converging (collision)
     - Negative = plates diverging (rift)
   - **Sliding:** `|dot90(normal, movementA) - dot90(normal, movementB)|`
     - High value = transform fault (plates sliding past)

4. `codeBlock` - Boundary computation from CIV7:
   ```javascript
   // From continent-generator.js (lines 710-747)
   for (const plateCell of regionCells) {
     for (const neighborId of plateCell.cell.getNeighborIds()) {
       const neighbor = regionCells[neighborId];

       if (neighbor.plateId !== plateCell.plateId) {
         // Boundary midpoint
         const pos = {
           x: (plateCell.cell.site.x + neighbor.cell.site.x) * 0.5,
           y: (plateCell.cell.site.y + neighbor.cell.site.y) * 0.5,
         };

         // Normal: direction from this cell to neighbor
         const normal = VoronoiUtils.normalize({
           x: neighbor.cell.site.x - plateCell.cell.site.x,
           y: neighbor.cell.site.y - plateCell.cell.site.y,
         });

         // Calculate movements at this boundary position
         const plate1Movement = calculatePlateMovement(plates[plateCell.plateId], pos);
         const plate2Movement = calculatePlateMovement(plates[neighbor.plateId], pos);

         // Subduction: positive = converging, negative = diverging
         const subduction = dot2(normal, plate1Movement) - dot2(normal, plate2Movement);

         // Sliding: transform fault magnitude
         const sliding = Math.abs(dot2_90(normal, plate1Movement) - dot2_90(normal, plate2Movement));

         plateBoundaries.push({ pos, normal, plateSubduction: subduction, plateSliding: sliding });
       }
     }
   }
   ```

5. `table` - Boundary type classification:
   ```
   Subduction Value, Sliding Value, Boundary Type, Geological Result
   > 0.3, *, Convergent, Mountains / volcanic arcs / trenches
   < -0.2, *, Divergent, Rift valleys / mid-ocean ridges
   *, > 0.5, Transform, Fault lines / earthquake zones
   else, else, Passive, Stable plate interior
   ```

6. `explanation` - kdTree storage: "All boundaries are stored in a kdTree (k-dimensional tree) for fast spatial queries. Any downstream system can ask 'what's the nearest boundary to this tile?' and get an O(log n) answer."

7. `explanation` - Bridge: "Now we have boundaries with physics. But how do landmasses actually use this information to decide where to grow?"

**Transition:** From boundary math to landmass behavior

---

## Slide 5: Landmass Growth - Smelling Plate Boundaries
**Concept:** landmass
**Purpose:** Show how the rule system biases landmass growth toward plate boundaries

**Blocks:**
1. `explainer` - Weighted rule system: "CIV7 doesn't place continents randomly. Landmasses 'grow' cell by cell, with each candidate cell scored by a weighted sum of rules. One key rule: prefer cells near plate boundaries, especially convergent ones. This naturally creates coastlines that follow tectonic logic."

2. `diagram` - Rule-based growth:
   ```
   Landmass seed
        ↓
   [Consider neighbors]
        ↓
   Score each by:
   ├── RuleCellArea (prefer larger cells)
   ├── RuleNearNeighbor (stay connected)
   ├── RuleAvoidEdge (avoid poles/meridians)
   ├── RuleNearPlateBoundary ← key rule
   └── ... other rules
        ↓
   [Pick highest-scoring cell]
        ↓
   [Repeat until target size]
   ```

3. `codeBlock` - RuleNearPlateBoundary implementation:
   ```javascript
   // From voronoi_rules/near-plate-boundary.js
   class RuleNearPlateBoundary extends Rule {
     static getName() { return "Near Plate Boundary"; }

     configDefs = {
       scaleFactor: {
         description: "Distance where score = 0.5",
         defaultValue: 4,
       },
       directionInfluence: {
         description: "How much plate movement affects score",
         defaultValue: 0.5,
       }
     };

     score(regionCell, ctx) {
       const cellPos = { x: regionCell.cell.site.x, y: regionCell.cell.site.y };
       const boundary = this.m_plateBoundaries.search(cellPos);
       const distance = Math.sqrt(boundary.distSq);

       // Distance score: 0 (far) to 1 (at boundary)
       const distanceScore = 1 - distance / (distance + this.configValues.scaleFactor);

       // Direction score: boost for convergent boundaries
       const plateMovementScore = distanceScore * boundary.data.plateSubduction * 0.5;

       // Blend based on directionInfluence config
       return VoronoiUtils.lerp(distanceScore, plateMovementScore, this.configValues.directionInfluence);
     }
   }
   ```

4. `explanation` - Rule weights in ContinentGenerator:
   ```
   m_landmassRuleConfigs = [
     [RuleAvoidEdge, { weight: 1.0 }],        // Stay away from map edges
     [RuleCellArea, { weight: 0.1 }],         // Prefer larger cells
     [RuleNearNeighbor, { weight: 0.5 }],     // Stay connected
     [RuleNearRegionSeed, { weight: 0.05 }],  // Don't stray too far
     [RuleNeighborsInRegion, { weight: 0.25 }], // Compact shape
     [RuleAvoidOtherRegions, { weight: 1.0 }],  // Don't overlap
     [RuleNearPlateBoundary, { weight: 0.75 }], // ← Follow tectonics!
     [RulePreferLatitude, { weight: 0.5 }],   // Tropical bias
   ]
   ```

5. `explanation` - The result: "With `RuleNearPlateBoundary` weighted at 0.75, landmasses naturally grow along convergent boundaries. This is why CIV7 maps have mountain ranges along coastlines (like the Andes) and volcanic arcs—it's emergent from the physics, not hand-placed."

6. `explanation` - Bridge: "This is all CIV7's native system. But Swooper needs this data too—for climate, narrative overlays, and downstream features. How do we hook in?"

**Transition:** From CIV's system to Swooper's integration

---

## Slide 6: The Swooper Hook - WorldModel & Typed Arrays
**Concept:** integration
**Purpose:** Show the technical mechanism by which Swooper captures plate data

**Blocks:**
1. `explainer` - Why wrap CIV's system?: "CIV7's plate generation is excellent, but the data disappears after landmass growth. Swooper needs persistent access to plate boundaries for climate (orographic rainfall), narrative overlays (rift valleys, collision zones), and feature placement (volcanoes on convergent margins). We solve this by capturing the physics into typed arrays."

2. `diagram` - Integration architecture:
   ```
   CIV7 Base Game                    Swooper Engine
   ┌─────────────────┐              ┌─────────────────┐
   │ VoronoiUtils    │              │ plates.js       │
   │ PlateRegion     │──imports────→│ computePlates   │
   │ kdTree          │              │ VoronoiWrapper  │
   └─────────────────┘              └────────┬────────┘
                                             │
                                             ↓
                                    ┌─────────────────┐
                                    │ WorldModel      │
                                    │ ─────────────── │
                                    │ plateId[]       │
                                    │ boundaryClose[] │
                                    │ boundaryType[]  │
                                    │ upliftPotent[]  │
                                    │ riftPotential[] │
                                    │ tectonicStress[]│
                                    │ shieldStabil[]  │
                                    │ boundaryTree    │
                                    └─────────────────┘
   ```

3. `codeBlock` - computePlatesVoronoi wrapper:
   ```javascript
   // From plates.js
   export function computePlatesVoronoi(width, height, config) {
     const { count, relaxationSteps, convergenceMix, plateRotationMultiple } = config;

     // Use CIV7's utilities directly
     const bbox = { xl: 0, xr: width, yt: 0, yb: height };
     const sites = VoronoiUtils.createRandomSites(count, bbox.xr, bbox.yb);
     const diagram = VoronoiUtils.computeVoronoi(sites, bbox, relaxationSteps);

     // Create PlateRegions with physics (CIV7's class)
     const plateRegions = diagram.cells.map((cell, index) => {
       const region = new PlateRegion(`Plate${index}`, index, ...);
       region.seedLocation = { x: cell.site.x, y: cell.site.y };
       return region;
     });

     // Compute boundaries (same algorithm as CIV7)
     const plateBoundaries = computePlateBoundaries(regionCells, plateRegions);
     const boundaryTree = new kdTree(PlateBoundaryPosGetter);
     boundaryTree.build(plateBoundaries);

     // Capture into typed arrays for downstream use
     return {
       plateId: new Int16Array(size),
       boundaryCloseness: new Uint8Array(size),
       boundaryType: new Uint8Array(size),
       // ... populate arrays from boundary queries
     };
   }
   ```

4. `table` - Typed array schema:
   ```
   Array, Type, Range, Purpose
   plateId, Int16Array, 0..N, Which plate owns this tile
   boundaryCloseness, Uint8Array, 0..255, Distance to nearest boundary (255 = at boundary)
   boundaryType, Uint8Array, 0..3, none/convergent/divergent/transform
   tectonicStress, Uint8Array, 0..255, Overall stress level (boundary proximity)
   upliftPotential, Uint8Array, 0..255, Mountain formation potential (high at convergent)
   riftPotential, Uint8Array, 0..255, Rift valley potential (high at divergent)
   shieldStability, Uint8Array, 0..255, Plate interior stability (inverse of stress)
   plateMovementU/V, Int8Array, -127..127, Plate movement vector components
   plateRotation, Int8Array, -127..127, Plate rotation value
   ```

5. `explanation` - Bridge: "This gives us the data. But why do we need it? What does Swooper actually do with plate physics?"

**Transition:** From technical mechanism to purpose

---

## Slide 7: Why We Hook In - Intent and Downstream Consumers
**Concept:** intent
**Purpose:** Explain the motivation for capturing plate data and how downstream systems use it

**Blocks:**
1. `explainer` - The physics-before-narrative principle: "Swooper's architecture follows a key principle: establish physical reality first, then annotate and interpret it. Plate tectonics is foundational physics—it should inform climate, narrative, and features, not be overridden by them. By capturing plate data early, we ensure all downstream systems work from the same physical truth."

2. `layers` - Downstream consumers of plate data:
   ```
   Layer, Consumer, Uses Plate Data For
   Foundation, WorldModel, Single source of truth for all physics
   Morphology, mountains.js, Uplift-aware peak placement along convergent boundaries
   Morphology, volcanoes.js, Volcanic arc placement at subduction zones
   Morphology, coastlines.js, Ruggedization intensity based on margin type
   Climate, climateBaseline.js, Orographic effects use boundary-aware elevation
   Narrative, storyRifts.js, Tag rift valleys at divergent boundaries
   Narrative, storyOrogeny.js, Tag mountain ranges at collision zones
   Features, feature-biomes.js, Volcanic features biased toward convergent zones
   ```

3. `diagram` - Data flow through pipeline:
   ```
   ┌─────────────┐
   │ WorldModel  │ ← Single source of truth
   │ plateData   │
   └──────┬──────┘
          │
     ┌────┴────┬────────┬────────┬────────┐
     ↓         ↓        ↓        ↓        ↓
   Morphology  Climate  Narrative Features  Balance
   (terrain)   (rain)   (tags)   (volcanoes) (starts)
   ```

4. `explanation` - Specific use cases:
   - **Mountains:** `upliftPotential` biases mountain placement toward convergent boundaries
   - **Volcanoes:** Placed preferentially where `boundaryType === convergent` and `boundaryCloseness > threshold`
   - **Climate:** Rain shadow calculations use plate-derived elevation gradients
   - **Coastlines:** Active margins (convergent) get fjords; passive margins get gentle shelves
   - **Narrative tags:** `StoryOverlays.rifts` marks divergent zones; `StoryOverlays.collisionZones` marks convergent

5. `explanation` - Why typed arrays?: "Downstream systems need O(1) lookups. A stage processing 10,000 tiles can't afford kdTree queries for each one. By pre-computing into flat arrays indexed by tile position, we get instant access: `upliftPotential[y * width + x]`."

6. `codeBlock` - Example downstream usage:
   ```javascript
   // In mountains.js
   function scoreMountainPlacement(x, y) {
     const i = y * width + x;

     // Base score from other factors
     let score = baseTerrainScore(x, y);

     // Boost from plate tectonics
     const uplift = WorldModel.upliftPotential[i] / 255;  // 0..1
     score += uplift * CONFIG.mountains.upliftWeight;

     // Extra boost at convergent boundaries
     if (WorldModel.boundaryType[i] === BOUNDARY.convergent) {
       score += CONFIG.mountains.convergentBonus;
     }

     return score;
   }
   ```

7. `explanation` - Bridge: "Now we understand what we capture and why. But how much control do we have over the plate generation itself?"

**Transition:** From intent to configuration

---

## Slide 8: Taking Control - Configuration Surface
**Concept:** config
**Purpose:** Show all the knobs available for tuning plate generation

**Blocks:**
1. `explainer` - Configuration philosophy: "Plate generation is highly configurable through the `foundation.plates.*` namespace. You can control plate count, boundary character, relaxation quality, and even override the RNG seed for reproducible results. These settings cascade through the entire pipeline."

2. `table` - Core plate config:
   ```
   Config Key, Type, Default, Effect
   foundation.plates.count, number, 8, Number of tectonic plates
   foundation.plates.relaxationSteps, number, 5, Lloyd iterations (higher = more uniform)
   foundation.plates.convergenceMix, 0..1, 0.5, Ratio of convergent vs divergent boundaries
   foundation.plates.plateRotationMultiple, number, 1.0, Amplify/dampen rotational influence
   ```

3. `codeBlock` - Seed control for reproducibility:
   ```javascript
   // From plate_seed.js
   export const PlateSeedManager = {
     capture(width, height, config) {
       const seedCfg = normalizeSeedConfig(config);
       // seedMode: "engine" (use CIV's RNG) or "fixed" (deterministic)
       // fixedSeed: specific seed value when mode is "fixed"
       // seedOffset: integer offset applied to base seed

       const control = applySeedControl(seedCfg.seedMode, seedCfg.fixedSeed, seedCfg.seedOffset);

       return {
         snapshot: Object.freeze({ ...seedCfg, seed: control.seed }),
         restore: control.restore,  // Call to restore original RNG state
       };
     }
   };
   ```

4. `table` - Seed configuration:
   ```
   Config Key, Type, Default, Effect
   foundation.seed.mode, "engine"/"fixed", "engine", Use CIV's RNG or fixed seed
   foundation.seed.fixed, number, undefined, Specific seed when mode is "fixed"
   foundation.seed.offset, number, 0, Offset applied to base seed
   ```

5. `explanation` - Directionality control: "Beyond random plates, you can bias plate movement toward a preferred axis. This creates maps with coherent tectonic patterns—like all plates drifting generally eastward."

6. `table` - Directionality config:
   ```
   Config Key, Type, Default, Effect
   foundation.directionality.cohesion, 0..1, 0, How strongly to bias toward primary axis
   foundation.directionality.primaryAxes.plateAxisDeg, degrees, 0, Preferred plate movement direction
   foundation.directionality.variability.angleJitterDeg, degrees, 0, Random variation around axis
   foundation.directionality.variability.magnitudeVariance, 0..1, 0.35, Speed variation
   ```

7. `codeBlock` - Applying directionality bias:
   ```javascript
   function applyDirectionalityBias(plate, directionality) {
     const cohesion = directionality.cohesion ?? 0;
     const plateAxisDeg = directionality.primaryAxes?.plateAxisDeg ?? 0;
     const jitter = getRandomJitter(directionality.variability?.angleJitterDeg ?? 0);

     // Blend current angle toward target axis
     const currentAngle = Math.atan2(plate.m_movement.y, plate.m_movement.x) * 180 / Math.PI;
     const targetAngle = currentAngle * (1 - cohesion) + plateAxisDeg * cohesion + jitter;

     // Apply new angle, preserve magnitude
     const mag = Math.sqrt(plate.m_movement.x ** 2 + plate.m_movement.y ** 2);
     const rad = targetAngle * Math.PI / 180;
     plate.m_movement.x = Math.cos(rad) * mag;
     plate.m_movement.y = Math.sin(rad) * mag;
   }
   ```

8. `explanation` - Bridge: "With this control surface, what kinds of worlds can we create?"

**Transition:** From configuration to creative possibilities

---

## Slide 9: Creative Possibilities - Different Worlds
**Concept:** creative
**Purpose:** Show example configurations and their geological outcomes

**Blocks:**
1. `explainer` - Configuration as world-building: "By tuning plate generation parameters, you can create dramatically different geological settings. A high-convergence world has intense mountain building; a divergent world has rift valleys and spreading seas; many small plates create archipelagos."

2. `table` - Example configurations:
   ```
   World Type, Plate Count, Convergence Mix, Rotation, Result
   Pangaea, 3-4, 0.8, 0.5, Few large continents with massive collision zones
   Archipelago, 15-20, 0.3, 1.5, Many small landmasses, volcanic island chains
   Rift World, 6-8, 0.2, 0.3, Elongated continents separated by young seas
   Ring of Fire, 8-10, 0.9, 1.0, Coastal mountain ranges, volcanic arcs
   Shield World, 4-5, 0.1, 0.2, Stable, flat continents with minimal mountains
   ```

3. `layers` - Configuration to outcome:
   ```
   High convergenceMix (0.8+)
   └── Many convergent boundaries
       └── Frequent mountain building
           └── Rugged coastlines, volcanic arcs

   Low convergenceMix (0.2-)
   └── Many divergent boundaries
       └── Rift valleys, spreading ridges
           └── Elongated seas, young ocean floor

   High plateRotationMultiple (1.5+)
   └── Amplified rotational effects
       └── Curved plate boundaries
           └── Arc-shaped island chains
   ```

4. `explanation` - Preset examples:
   - **Classic preset:** Balanced plates (8), moderate convergence (0.5), standard rotation (1.0) → Earth-like distribution
   - **Volcanic preset:** Many plates (12), high convergence (0.8), high rotation (1.2) → Ring of Fire everywhere
   - **Continental preset:** Few plates (4), low convergence (0.3), low rotation (0.5) → Large stable landmasses

5. `explanation` - Future possibilities:
   - **Hotspot simulation:** Volcanic chains that cross plate boundaries (like Hawaii)
   - **Plate age:** Older plates = thicker, more stable; younger = thinner, more active
   - **Mantle plumes:** Deep heat sources creating localized volcanic activity
   - **Historical tectonics:** Simulate plate positions at different geological eras

6. `kpiGrid` - Summary of control points:
   ```
   Control, Range, Impact
   Plate count, 2-20, Landmass fragmentation
   Convergence, 0-1, Mountain intensity
   Rotation, 0-2, Boundary curvature
   Directionality, 0-1, Global drift coherence
   Seed mode, engine/fixed, Reproducibility
   ```

7. `explanation` - Closing: "Voronoi plate generation transforms random geometry into physically-motivated terrain. By understanding the math—from Fortune's algorithm through boundary physics to rule-based growth—you can tune the system to create worlds that feel geologically authentic while serving gameplay needs."

---

## Key Takeaways

1. **Voronoi diagrams** partition space into cells using Fortune's O(n log n) sweep-line algorithm
2. **Plates gain physics** through random movement vectors and rotation values per PlateRegion
3. **Boundary types emerge** from vector math: `subduction = dot(normal, movement1 - movement2)`
4. **Landmasses follow plates** via weighted rules that bias growth toward convergent boundaries
5. **Swooper captures** plate physics into typed arrays for downstream climate, narrative, and features
6. **Configuration controls** plate count, convergence mix, rotation, directionality, and seeding
7. **Creative possibilities** range from Pangaea to Archipelago based on parameter tuning
</file>

<file path="projects/engine-refactor-v1/resources/era-tagged-morphology-review.md">
# Era-Tagged Morphology Assessment

## Original Prompt

**Question:** Should we introduce an “era-tagged morphology” approach that iterates Foundations → Voronoi Plate Generation → Morphology in 3–5 loops, storing only per-iteration morphology tags as an ordered stack for narrative use while publishing the final iteration’s physics output as the canonical world state?

**Decision:** **NO — rely on the single-pass physics pipeline and extend existing overlay metadata instead of rerunning foundations/morphology.**

### Rationale

1. **Single Source of Truth:** The refactor blueprint mandates a single immutable `FoundationContext` created once per map (`mod/maps/core/types.js:437`). The WorldModel singleton caches global buffers and early exits on subsequent `init()` calls (`mod/maps/world/model.js:82`). Looping foundations/morphology would require tearing down engine-coupled state between iterations, conflicting with the blueprint and risking desync with Civ’s live surface.
2. **Engine Coupling:** WorldModel writes directly against Civ VII engine globals; we no longer have an in-memory adapter for speculative passes (`mod/ARCHITECTURE.md:8`). Multiple loops would mutate the real gameplay surface repeatedly.
3. **Existing Signals:** Current physics outputs already encode “era-like” information: `shieldStability` for ancient interiors, `riftPotential` for paleo scars, `upliftPotential` + `tectonicStress` for active belts (`mod/maps/world/model.js:200-269`). Narrative overlays already consume sparse tags (StoryTags) and caches such as `OrogenyCache` without rerunning heavy stages (`mod/maps/story/tagging.js:420-605`).
4. **Storage & Compute:** Iterating Voronoi + morphology multiple times would multiply the most expensive part of the pipeline and tempt us to cache extra heightfields—precisely what the refactor removed.

## Alternative: Analytic Era Tag Overlay

### Unique Advantages

- **Zero extra solves:** Leverages the single deterministic physics snapshot and shared staging buffers.
- **Narrative leverage:** Exposes compact “era morphology” overlays derived from existing tensors, giving writers differentiated cues (ancient scars vs. modern uplift) without re-running morphology.
- **Alignment with roadmap:** Matches the plan to formalize `StoryOverlays` as immutable data products in Phase D (`ENGINE_REFACTOR_PLAN.md:85`) and keeps story layers thin wrappers over physics outputs.
- **Determinism & observability:** Tags reference the published configuration snapshot (`FoundationContext.config`), so provenance hashes trace exactly which knobs produced each overlay.

### Minimal Implementation Path

1. **Overlay Registry:** Introduce `ctx.overlays.ensure('eraMorphology')`, backed by a sparse record store alongside existing StoryTags. Records follow:
   ```json
   {
     "eraIndex": 1,
     "featureKind": "riftShoulder",
     "geometryRef": "x,y",          // tile key or pointer into shared buffers
     "strength": 0.74,
     "provenance": { "stage": "mountains", "algo": "plateScores:v3", "paramsHash": "…" },
     "notes": "optional developer diagnostics"
   }
   ```
2. **Derive Era Buckets:** During morphology stages (coastlines, mountains, volcanoes) compute analytic scores once:
   - **Era 1 – Ancient Scar:** High `shieldStability`, moderate `riftPotential`, low `boundaryCloseness`.
   - **Era 2 – Mature Relief:** Moderate stability, sustained `upliftPotential`.
   - **Era N – Active Belt:** High `upliftPotential` + `tectonicStress`, convergent `boundaryType`.
   Normalize to `0..1`, threshold by configurable densities, and emit sparse overlay records via the registry.
3. **Narrative Accessors:** Extend `MapContext` with `getEraMorphology({ minStrength, decay })`. Narrative overlays read ordered stacks newest→oldest, applying exponential decay (e.g., `0.65^Δera`) when combining influences.
4. **Diagnostics & Provenance:** Reuse dev logging toggles (`DEV.LOG_RELIEF_ASCII`, `DEV.LOG_LANDMASS_ASCII`) to visualize tagged eras. Hash the active stage config (`FoundationContext.config`) into `paramsHash` for replay parity.

#### Pseudocode

```js
function tagEraMorphology(ctx, tensors, stageId, configSnapshot) {
  const overlay = ctx.overlays.ensure("eraMorphology");
  const { shield, rift, uplift, tectonic, boundaryType, boundaryCloseness } = tensors;
  const size = ctx.dimensions.width * ctx.dimensions.height;

  for (let i = 0; i < size; i++) {
    const scarScore = normalizeScar(shield[i], rift[i], boundaryCloseness[i]);
    if (scarScore >= ERA_THRESHOLDS.ancient) {
      overlay.add(i, {
        eraIndex: 1,
        featureKind: "paleoScar",
        geometryRef: indexToKey(i, ctx.dimensions.width),
        strength: scarScore,
        provenance: buildProvenance(stageId, configSnapshot),
      });
    }

    const activeScore = normalizeActive(uplift[i], tectonic[i], boundaryType[i]);
    if (activeScore >= ERA_THRESHOLDS.modern) {
      overlay.add(i, {
        eraIndex: ERA_CONFIG.latest,
        featureKind: "orogenyActive",
        geometryRef: indexToKey(i, ctx.dimensions.width),
        strength: activeScore,
        provenance: buildProvenance(stageId, configSnapshot),
      });
    }
  }
}
```

### Mapping to Narrative Overlays

- **Query Path:** `storyTagRiftValleys`, `storyTagHotspotTrails`, and future overlays request `ctx.overlays.get('eraMorphology')`. They sort records descending by `eraIndex` and blend strengths with configurable decay to balance recency vs. legacy scars.
- **Usage Examples:** 
  - Early-era scars increase probability of paleo river corridors and canyon discoveries.
  - Active-era belts temper rainforest swatches and boost geothermal hotspots.
  - Mixed-era tiles (scars + active) signal uplifted plateaus suitable for highland biomes.
- **Guardrails:** Overlays only adjust staged buffers (`writeClimateField`, `StoryTags`, placement metadata). Heightfield alterations remain in morphology stages, preserving physical plausibility.

### Risks & Mitigations

- **Over-tagging:** Enforce per-era density caps (< X% of land tiles) and debias with stratified sampling.
- **Narrative overrides physics:** Keep rainfall/feature nudges within clamps already enforced by climate helpers. Require overlays to check `StageManifest` enablement before emitting tags.
- **Schema drift:** Unit-test schema contracts and provenance hashes; lint overlay payload sizes to prevent silent growth.
- **Perception mismatch:** Provide developer diagnostics (ASCII overlays, histograms) so authors can preview era signals alongside terrain.

### Example Walk-Through — “Grand Canyon” Analogue

1. **Mountains Stage:** Detects strong convergent uplift along a plate boundary → emits `eraIndex = N`, `featureKind = "orogenyActive"`, `strength ≈ 0.9`.
2. **Rift Analysis:** Adjacent shield interior with moderate rift legacy → emits `eraIndex = 1`, `featureKind = "paleoScar"`, `strength ≈ 0.6`.
3. **Rivers Stage:** Reads both tags to prioritize entrenched river carving through the scar, caching a `paleoRiver` record at `eraIndex = 2`.
4. **Narrative Overlay:** Combines the stack `{N=active orogeny, 2=paleoRiver, 1=paleoScar}` to place canyon discoveries, arid swatches, and museum events without touching the original heightfield.
5. **Downstream Consumers:** Biomes and placement layers consult the same overlay stack to bias desert belts and cultural artifacts, ensuring narrative intent remains grounded in the static physics output.

### Acceptance Tests

1. **Determinism:** Run generation twice with fixed seeds; assert identical serialized `eraMorphology` payloads.
2. **Density Bounds:** Verify per-era tag counts remain under configured land-tile thresholds.
3. **Storage Budget:** Confirm total overlay bytes stay within target (< X KB) to avoid multi-snapshot bloat.
4. **Runtime Cost:** Benchmark mountains + rivers stages pre/post tagging; ensure overhead < 5%.
5. **Visual Sanity:** Enable ASCII diagnostics (`DEV.LOG_RELIEF_ASCII`, `DEV.LOG_RAINFALL_ASCII`) to confirm paleo scars influence river placement and climate overlays plausibly.
6. **Narrative Regression:** Disable a morphology stage via manifest and ensure overlay queries degrade gracefully (no stale tags, clear warnings).

## Narrative Q&A Context

**Why no multi-pass reruns?** The era tags are analytic labels extracted from the single physics snapshot. We map WorldModel tensors—shield stability, rift potential, uplift, tectonic stress—into “early vs. late” categories and record them via overlays. Narrative overlays then consume an ordered tag stack, weighting recent signals more heavily while still referencing older scars. Because the mountains layer already blends those tensors when placing ranges (older belts bias toward hills, newer belts stay steep), we don’t have to rerun mountain placement. Adjustments to Appalachians-vs.-Rockies style outcomes remain inside the one mountains stage heuristic, keeping physics and narrative in sync. Multiple Voronoi solves would just duplicate cost without yielding more grounded tags.

## Where the Tensors Come From

1. **Voronoi Plate Solve:** `computePlatesVoronoi()` seeds plates with Civ VII’s Voronoi utilities and performs Lloyd relaxation (`mod/maps/world/plates.js:61-118`). Each Voronoi cell is assigned to the nearest plate, producing the primary `plateId` field.
2. **Boundary Analysis:** The helper builds a kd-tree of Voronoi region cells and calls `computePlateBoundaries()` to evaluate each shared edge (`plates.js:259-311`). For every boundary it calculates:
   - **Subduction (convergent/divergent):** Difference in plate movement along the boundary normal (`plates.js:295-309`).
   - **Sliding:** Relative movement perpendicular to the normal (`plates.js:294-308`).
3. **Movement Vectors:** `calculatePlateMovement()` blends each plate’s translational movement with a rotational component derived from Civ’s `PlateRegion` metadata (`plates.js:332-356`). Global directionality config from `foundation.dynamics.directionality` biases these vectors via `applyDirectionalityBias()` before the solve runs (`plates.js:363-388`).
4. **Scalar Fields:** For each tile, the solver finds the nearest boundary, converts distance into a 0–255 “closeness” value, and classifies boundary type based on subduction/sliding thresholds (`plates.js:191-243`). From those:
   - `tectonicStress` = `boundaryCloseness`.
   - `upliftPotential` boosts stress near convergent boundaries; otherwise it’s quartered (`plates.js:226-234`).
   - `riftPotential` mirrors uplift for divergent boundaries.
   - `shieldStability` is the inverse (255 – stress), highlighting interior cratons.
   - Movement arrays (`plateMovementU/V`, `plateRotation`) capture the vector outputs.
5. **WorldModel Publication:** `WorldModel.init()` copies these arrays into its singleton state (`mod/maps/world/model.js:259-269`) and exposes them through `FoundationContext.plates` for downstream stages (`core/types.js:437-452`).

> **Physics Fidelity:** These tensors are heuristic approximations built from geometry and scripted plate motions. Civ’s Voronoi stack gives us coherent boundaries and relative motion, but the fields are not simulating full geodynamics—they encode directional biases and proximity metrics that mimic tectonic behavior well enough for downstream morphology and narrative logic. Continuous evolution is not modeled; the “eras” are interpretations layered atop this static snapshot.

## Easy Enhancements (Optional)

1. **Blended Scar Metric:** Derive scars from a weighted blend of `shieldStability`, `riftPotential`, and local relief (slope computed from the heightfield buffer) rather than a single tensor. This better separates weathered belts from flat interiors without extra simulation.
2. **Pseudo-Erosion Smoothing:** After mountains/hills execute, run a small kernel smoothing pass over `upliftPotential` where current relief is low. The smoothed value feeds early-era tags to represent aged ranges.
3. **Boundary Lifetimes:** Use plate movement magnitude and direction (`plateMovementU/V`, `plateRotation`) to estimate how quickly a boundary refreshes. Fast-moving convergent zones bias tiles toward later eras; sluggish zones drift toward earlier eras.
4. **Percentile Thresholds:** Instead of fixed thresholds, compute map-specific percentiles (e.g., top 10 % uplift → latest era) when emitting tags. This keeps tag densities stable across presets.
5. **Climate Sanity Check:** Cross-reference the staged climate buffer; if an “ancient” tag coincides with rainforest-level rainfall, dampen the era weight to avoid contradictory storytelling cues.

These refinements live entirely inside the single-pass tagging routine—no additional Voronoi solves or engine hooks required. Designers can adopt them incrementally to tighten the link between physics heuristics and authored eras.
</file>

<file path="projects/engine-refactor-v1/resources/swooper-map-plan.md">
# Epic Diverse Huge Generator – Terrain & Plate Smash Plan

> Working design doc for improving the Civilization‑style “Epic Diverse Huge” map generator, with a focus on terrain distribution (mountains / hills / plains) and a plate‑aware “ceramic smash” landmass pipeline.

---

## High‑Level Structure

- [Goals](#goals)
- [System Overview](#system-overview)
- [Pipeline Summary](#pipeline-summary)
- [Detailed Stages](#detailed-stages)
  - [1. Plate and Boundary Input](#1-plate-and-boundary-input)
  - [2. Orogeny Field](#2-orogeny-field)
  - [3. Elevation Field](#3-elevation-field)
  - [4. Terrain Classification](#4-terrain-classification)
  - [5. Post‑Processing & Style Modes](#5-post-processing--style-modes)
  - [6. Debugging & Validation](#6-debugging--validation)
- [Implementation Plan](#implementation-plan)

```mermaid
flowchart LR
  A[Plate & Boundary Map<br/>+ Mode Config] --> B[Orogeny Field<br/>(mountain potential)]
  B --> C[Elevation Field<br/>+ Sea Level]
  C --> D[Terrain Classification<br/>(water / plains / hills / mountains)]
  D --> E[Post‑Processing<br/>(passes, ridge jitter, style modes)]
  E --> F[Outputs<br/>ASCII debug, game map, metadata]
```

---

## Goals

- Fix current “wall of mountains + bottom band of hills + almost no plains” behavior.
- Preserve the idea that mountains and hills are tectonically grounded (plates and boundaries still matter).
- Introduce a clean separation between:
  - Plate simulation / boundary layout.
  - Continuous heightfield computation.
  - Discrete terrain classification.
  - Presentation / debugging (ASCII art in logs).
- Support multiple world styles (Pangea, Continents, Archipelago) without rewriting core logic.
- Emit useful metadata (plate id, boundary type, orogeny strength) for future systems: climate, biomes, rivers, cultures.

---

## System Overview

Core concepts:

- **Grid:** Hex/square map represented in code as a 2D grid with indices `(x, y)`.
- **Fields:** Separate logical layers stored per cell:
  - `plateId` – which tectonic plate the cell belongs to.
  - `boundaryType` – convergent / divergent / transform / none.
  - `orogeny` – scalar mountain potential (0–1).
  - `elevation` – continuous height value.
  - `slope` – local gradient magnitude (derived from `elevation`).
  - `terrain` – discrete enum (Ocean / Coast / Plains / Hills / Mountains, etc.).
  - `biome` (future) – desert / forest / tundra, etc.
- **Modes:** High‑level style presets:
  - `PANGEA` – few, large landmasses; broad, continuous mountain chains.
  - `CONTINENTS` – several mid‑sized landmasses with moderate fragmentation.
  - `ARCHIPELAGO` – many small landmasses, lots of coastline and islands.

All terrain placement should flow through `orogeny → elevation → terrain`, not directly stamped mountains/hills.

---

## Pipeline Summary

1. **Plate & Boundary Input**
   - Consume existing plate / boundary solution (already logged as ASCII with `M`, `^`, `~`, `.` in the scripting log).
   - For each cell, know: `plateId` and whether it lies on a boundary, plus boundary type and relative convergence strength.

2. **Orogeny Field**
   - Create a scalar field representing “how strong mountain building should be” at each cell, based on convergent boundaries and plate stress.
   - Diffuse / blur this field to spread mountain influence a few tiles into the plate interiors.

3. **Elevation Field**
   - Combine:
     - Base continental vs. oceanic height.
     - Orogeny contribution.
     - Multi‑scale noise (large‑scale continents, smaller‑scale variation).
   - Choose a sea level so target land/ocean ratios are achieved.

4. **Terrain Classification**
   - Use **percentiles and slope** to map elevation to discrete terrain:
     - Highest percentiles + steep slopes → mountains.
     - Next band or moderate slopes → hills.
     - Remaining land above sea level → plains.
   - Ensure explicit targets for ratios (e.g., mountains 8–12% of land, hills 15–25%, rest plains).

5. **Post‑Processing & Style Modes**
   - Soften mountain walls, add passes and jitter.
   - Tune density, width, and continuity per mode (Pangea vs. Continents vs. Archipelago).

6. **Debugging & Validation**
   - ASCII prints per stage (orogeny, elevation bands, terrain).
   - Simple statistics: percentage of land that is mountains/hills/plains, average ridge width, etc.

---

## Detailed Stages

### 1. Plate and Boundary Input

**Inputs**

- Plate tessellation (from the game’s plate generator or imported dataset).
- Boundary classification for each pair of neighboring cells:
  - `convergent`, `divergent`, `transform`, `inactive`.
- Plate velocities and relative convergence speed (if available).

**Responsibilities**

- Produce these base fields:
  - `plateId[x, y]`
  - `boundaryType[x, y]`
  - Optional: `convergenceStrength[x, y]` (0–1).
- No terrain types are assigned here; this stage is tectonics‑only.

### 2. Orogeny Field

**Goal:** Translate boundaries into a smooth mountain‑building potential.

**Algorithm Sketch**

1. Initialize `orogeny[x, y] = 0`.
2. For every **convergent boundary cell**:
   - Set `orogeny[x, y] = baseConvergenceValue * convergenceStrength`.
3. Optionally seed elevated values at **triple junctions** or sharp bends in boundaries (these tend to be complex mountainous regions).
4. Run a **diffusion / blur** pass:
   - For `k` iterations (2–5):  
     `orogeny[x, y] = lerp(orogeny[x, y], average(neighbors’ orogeny), diffusionAlpha)`  
   - This spreads mountain potential 1–4 tiles away from the boundary and softens sharp lines.
5. Clamp `orogeny` to `[0, 1]`.

**Tuning**

- `baseConvergenceValue`, `convergenceStrength`, `k`, and `diffusionAlpha` control ridge width and intensity.
- Style modes can override these:
  - Pangea: higher base, wider ridges.
  - Archipelago: lower base, narrower ridges; more islands come from elevation noise instead.

### 3. Elevation Field

**Goal:** Produce a continuous heightmap that combines tectonics and noise.

**Components**

- `continentMask[x, y]` – large‑scale pattern distinguishing continental vs. oceanic crust.
- `noiseLarge[x, y]` – very low‑frequency noise for continent shapes.
- `noiseSmall[x, y]` – mid/hi‑frequency noise for local variation.

**Formula (conceptual)**

```text
base = mix(oceanFloorHeight, continentBaseHeight, continentMask)
tectonic = orogeny[x, y] * mountainScale
noise = noiseLarge * largeNoiseScale + noiseSmall * smallNoiseScale

elevation[x, y] = base + tectonic + noise
```

**Sea Level Selection**

- Choose `seaLevel` by:
  - Either a direct parameter (e.g., 30–40% of cells underwater), or
  - A percentile of the elevation distribution (e.g., `seaLevel = percentile(elevation, 0.35)`).
- A repeatable random seed ensures deterministic output for a given configuration.

### 4. Terrain Classification

**Goal:** Convert `elevation` (and derived `slope`) into discrete terrain, fixing the “no plains” problem.

**Derived Fields**

- Compute `slope[x, y]` from neighboring elevation values (gradient magnitude).
- For all land cells (`elevation > seaLevel`), compute elevation percentiles.

**Classification Strategy**

- For each cell:
  - If `elevation <= seaLevel`:
    - Use finer categories like deep ocean / shallow ocean / coast if desired.
  - Else (land):
    - Let `p = percentileRank(elevation among land cells)`.
    - Example thresholds:
      - `p >= 0.88` and `slope >= slopeHigh` → `Mountains`.
      - `0.70 <= p < 0.88` or `slope >= slopeMedium` → `Hills`.
      - Otherwise → `Plains`.

This guarantees that:

- At least ~12% of land becomes mountains.
- At least ~18% becomes hills.
- The remaining majority is plains (fixing the “normal land basically doesn't exist” issue).

**Hill Placement Improvements**

- Hills are **not** tied to a single latitude band.
- Hills naturally cluster:
  - Around mountains (distance‑to‑ridge effect).
  - In regions with moderate elevation variance even away from major ranges (e.g., uplands).

### 5. Post‑Processing & Style Modes

**Mountain Wall Softening**

- Identify **ridge lines**: contiguous patches of mountain cells where `orogeny` is high.
- For each ridge:
  - Enforce a maximum width (e.g., 1–3 tiles). Extra layers downgraded to hills.
  - Randomly carve **passes**:
    - Pick a few positions along each ridge.
    - Downgrade cell(s) from `Mountain → Hill → Plains` to create gaps.
  - Apply a small amount of morphological erosion/dilation to avoid perfect straight segments.

**Jitter**

- Multiply the mountain mask by a low‑frequency noise field before final classification:
  - Slightly displaces where the highest `orogeny` values actually hit threshold.
  - Produces bulges, forks, and isolated high peaks.

**Style Modes**

- `PANGEA`
  - Fewer plates, high `continentMask` coherence.
  - Stronger orogeny and wider ridges.
  - Slightly lower sea level (more landmass).
- `CONTINENTS`
  - Moderate number of plates and boundaries.
  - Balanced orogeny strength.
  - Sea level tuned so ocean coverage ~55–65%.
- `ARCHIPELAGO`
  - Many plates and microplates.
  - Lower orogeny; mountains less dominant.
  - Higher sea level; islands emerge from noise patterns and thinned continents.

### 6. Debugging & Validation

**ASCII Debug Layers**

- Stage‑specific dumps to the scripting log, each labeled clearly:
  - `OROGENY FIELD` – map of `orogeny` using characters like ` . : * M` by intensity.
  - `ELEVATION BANDS` – coarse elevation ranges (e.g., A/B/C/D) before terrain classification.
  - `TERRAIN TYPES` – final `~ . ^ M` map (water / plains / hills / mountains).

**Statistics**

- After generation, log:
  - Land vs. water percentage.
  - Mountain / hill / plains percentages (of land).
  - Average ridge length and width.
  - Hill density vs. distance from nearest mountain.

These metrics make it trivial to tell when changes have broken the expected distribution, even without visually inspecting ASCII.

---

## Implementation Plan

This plan assumes the existing Civ VII scripts are refactorable into smaller helpers; function names are illustrative, not prescriptive.

1. **Introduce Continuous Fields (Non‑Breaking)**
   - Add internal storage for `orogeny` and `elevation` alongside any existing height/terrain grids.
   - Keep current terrain stamping logic intact while scaffolding the new fields.

2. **Implement `computeOrogenyField`**
   - Extract all “mountains from boundaries” logic into a pure function that:
     - Reads plate IDs and boundary types.
     - Returns an `orogeny` scalar per cell.
   - Replace direct “mountain on line” writes with orogeny seeding + diffusion.

3. **Implement `computeElevation`**
   - Introduce continent vs. ocean base heights.
   - Layer in `orogeny` and noise as described.
   - Choose sea level by target water ratio.

4. **Implement `classifyTerrain`**
   - New pure function that:
     - Takes `elevation`, `slope`, `seaLevel`, and style mode.
     - Computes percentiles on land cells.
     - Emits terrain types (`Ocean / Coast / Plains / Hills / Mountains`).
   - Redirect all terrain placement to go through this classifier.

5. **Add Post‑Processing**

   - Implement ridge detection and mountain‑wall softening (passes, width constraints, small erosions).
   - Add jitter via low‑frequency noise in orogeny or mountain thresholds.

6. **Wire Style Modes**

   - Define a small configuration struct per mode:

     ```text
     struct WorldgenModeConfig {
       name: PANGEA | CONTINENTS | ARCHIPELAGO
       targetWaterFraction
       orogenyBase
       orogenyDiffusionSteps
       mountainPercentile
       hillPercentile
       ridgeMaxWidth
       noiseScales
     }
     ```

   - Pass this config through the pipeline so each stage can adjust behavior without conditionals scattered everywhere.

7. **Improve Debug/Logs**

   - Replace single‑stage ASCII dump with:
     - One line announcing each stage.
     - Optional per‑stage maps (toggleable via a debug flag).
     - Summary statistics for terrain distribution.

8. **Iterative Tuning**

   - Use a fixed seed and consistent camera/log zoom to:
     - Compare old vs. new terrain outputs.
     - Tweak percentiles, ridge widths, diffusion steps, and noise scales.
   - Capture “good” parameter sets as named presets checked in with the code.

Once these steps are done, the generator should:

- Still honor plate boundaries for mountain placement.
- Avoid giant, perfectly linear walls of `M`.
- Distribute hills as a natural transition between mountains and plains instead of a hard latitudinal band.
- Guarantee a healthy amount of “normal” land for cities, resources, and adventures.
</file>

<file path="projects/engine-refactor-v1/README.md">
# Project: Swooper Maps

**Status:** Active
**Teams:** Solo / AI-assisted

## Scope & Objectives

Large-scale procedural map generation mod for Civilization VII featuring:
- Physics-based terrain generation using Voronoi plate tectonics
- Climate simulation with baseline, swatch, and refinement layers
- Narrative overlay system for geological storytelling
- Stage manifest-based orchestration

## Deliverables

- [ ] Stable physics pipeline (Voronoi → plate mask → terrain)
- [ ] Climate engine integration
- [ ] Narrative overlay system
- [ ] Multiple map presets

## Active Plans

- [MAPS Engine Refactor](MAPS-engine-refactor/overview.md) — Physics-first orchestration engine
- [Era-Tagged Morphology Review](era-tagged-morphology-review.md) — Morphology assessment
- [Plate Generation Refactor](plate-generation-refactor.md) — Unified Voronoi pipeline

## Resources

- [Map Generation Pipeline Outline](resources/map-generation-pipeline.outline.md)
- [Slideshows](resources/slideshows/)

## System Documentation

Evergreen architecture docs live in the system directory:
- [Architecture](../../system/mods/swooper-maps/architecture.md) — Bootstrap and config pipeline
- [Design](../../system/mods/swooper-maps/design.md) — Stage manifest and foundation config
- [Margins & Narrative](../../system/mods/swooper-maps/margins-narrative.md) — Continental margins pipeline

## Links & References

- Mod source: `mods/mod-swooper-maps/`
- Templates: `docs/templates/`
</file>

<file path="system/cli/overview.md">
## Mini-roadmap and Feature Tracker

This document tracks completed work and upcoming enhancements for the CLI and XML-first crawler.

### Completed

- XML-first deep crawl (Completed)
  - GameEffects normalization into logical tables: `Modifiers`, `ModifierArguments`, `RequirementSets`, `RequirementSetRequirements`, `Requirements`, `RequirementArguments`.
  - Attach-chain traversal via `ModifierArguments(Name="ModifierId") → Modifiers`.
  - Light layering and delete semantics: respects Database `<Delete>`, deterministic file order (lexicographic), last write wins by sequence, prunes non-existent targets.
  - Provenance on every row (`__file`, `__table`) for accurate manifest slicing.
- CLI UX unchanged; defaults from `civ.config.jsonc`.
  - Acceptance validated on: `CIVILIZATION_ROME`, `LEADER_GENGHIS_KHAN`.

- Visualization improvements (Completed)
  - Edge labeling for readability (e.g., `LeaderTraits`, `TraitModifiers`, `Argument`, `Attach`, `SubjectRequirementSetId`, `OwnerRequirementSetId`).
  - Self-loop edges suppressed.

- Phase B — Layout semantics & UX (Completed)
  - VIZ-3: Layered layout by table with `rankdir=LR`; group ranks: Leaders/Civilizations → Traits → Modifiers → RequirementSets → Requirements → Arguments.
  - VIZ-6: Provenance-aware tooltips and hyperlinks.
    - Nodes: tooltip shows `Table:Id` and relative path; `URL` points to `file://<abs>`; `target=_blank`.
    - Edges: tooltip shows `<label> from <fromTable>:<fromId> → <toTable>:<toId>`.
    - Proper DOT/URI escaping; no URLs on edges.
  - Acceptance: Verified on `LEADER_AMINA`, `CIVILIZATION_ROME`; no Phase A regressions; large graphs still render.

- Phase D — Structural grouping (Completed)
  - VIZ-11: Cluster requirement sets
    - Each `RequirementSet` is rendered as a cluster containing its `Requirements` and `RequirementArguments`.
    - Preserves Phase B layered ranks; cluster members are removed from global ranks to avoid double-parenting.
    - Edges to/from clusters use invisible anchors with `lhead`/`ltail` for clean routing.
    - Acceptance: Rome/Amina show each ReqSet as a grouped unit; labels and edge styles preserved.

- VIZ-19 — Semantic tooltips (Completed)
  - Modifiers: include `Effect`, `Collection`, optional `Permanent`, plus top N `Name=Value` arguments.
  - RequirementSets: include `RequirementSetType` and count of requirements.
  - Requirements: include `RequirementType` and key `Name=Value` arguments.
  - Acceptance: Tooltips show concise summaries in addition to `table:id` + path.

- Phase F (Baseline) — Local Interactive Visualizer (VIZ-13)
  - Explore defaults to generating and opening a local HTML viewer:
    - `civ7 explore <seed>` now emits `out/<seed>/graph.svg` and `out/<seed>/graph.html`, then opens `graph.html`.
    - `--viz.html` (alias `--vizHtml`) controls HTML viewer emission (default: true).
    - `--open` controls auto-open behavior (default: true); `--openOnline` unchanged.
  - Viewer design (offline, single file, no deps):
    - Wraps the rendered `graph.svg` (from `@hpcc-js/wasm` in Node) inside a minimal HTML shell.
    - Mouse: wheel zoom anchored to cursor; drag to pan; double‑click to fit.
    - Keyboard: WASD/Arrow pan with acceleration/deceleration; `+`/`-` to zoom; `0` to fit; `Shift` for faster pan.
    - Fit-to-screen on load and window resize.
    - Light theme background to match SVG defaults; no external network calls.
  - Acceptance: Works offline; preserves DOT styling fidelity; handles large graphs.

- Phase F (Dev server) — VIZ-14 (optional) 
  - `--serve` flag starts a tiny static server rooted at `out/<seed>` and opens `http://localhost:<port>/graph.html`.
  - `--port` selects port (default 3000, falls back if busy).
  - Use with `civ7 explore <seed> --serve` for local iteration.

### Next up

- Phase C — Complexity controls (crawler + viewer cross-cutting)
  - VIZ-4: Toggle noisy structures via flags (optional)
    - Examples: `--viz.hideArguments`, `--viz.hideRequirementArguments`, `--viz.hideGenericEdges`.
  - VIZ-5: Depth limiting
    - Examples: `--viz.maxDepth=N` to cap BFS depth; consider per-table depth caps later.
  - Direction: Adjust how deep we traverse and which structures we reveal to surface more meaningful information with controllable complexity.

### Future development

- Rich viewer milestone (defer)
  - Consider leveraging existing graph libraries for a richer UI with less custom code.
  - Candidate: AntV G6 (+ ELK for layout) to provide minimap, search, filters, deep-linking, and configurable styling out of the box.
  - Bundle: Treat as a dedicated milestone alongside styling; package as a static app if pursued.

- Parked items (until rich viewer milestone):
  - Phase E — Config-driven styling (VIZ-10)
    - Override node/edge styles via config; better done within the chosen viewer framework.
  - Phase F (Advanced) — VIZ-15..18 (minimap/search/state/packaging)
    - To be implemented within the rich viewer track.

---

## Phase reference (static descriptions)

The sections below describe each phase in detail. They are not a roadmap and may include items already completed.

#### Phase A — Quick visual clarity (Completed)
- VIZ-8: Global layout tuning
  - Set graph attrs: `rankdir=LR`, `overlap=false`, `splines=true`, `concentrate=true`, `nodesep`, `ranksep`.
- VIZ-1: Node styling by table (shape, border, color)
  - Map tables to Graphviz node attributes (shape, style, fillcolor, color, penwidth). Focus on: `Traits`, `Modifiers`, `RequirementSets`, `Requirements`, `ModifierArguments`, `RequirementArguments`.
- VIZ-2: Edge styling by relationship
  - Solid for primary relations (LeaderTraits, TraitModifiers), dashed for attach, dotted for generic, distinct colors for requirement set links.
- VIZ-9: Label wrapping and truncation
  - Wrap/truncate long IDs in labels; use full IDs in tooltips.
- VIZ-7: Legend/Key cluster
  - Add a legend subgraph that explains node and edge styles.

#### Phase B — Layout semantics & UX (Completed)
- VIZ-3: Layered layout by table (rank hints)
  - `rankdir=LR`; grouped ranks: Leaders/Civs → Traits → Modifiers → RequirementSets → Requirements → Arguments.
- VIZ-6: Tooltips and hyperlinks (provenance-aware)
  - Node `tooltip` and `URL` to file paths; preserve full IDs; edge tooltips added; offline-safe and escaped.

#### Phase C — Complexity controls (Next)
- VIZ-4: Toggle noisy structures via flags (optional)
  - Flags: `--viz.hideArguments`, `--viz.hideRequirementArguments`, `--viz.hideGenericEdges`.
- VIZ-5: Depth limiting
  - Optional `--viz.maxDepth=N` to cap BFS depth.

#### Phase D — Structural grouping (Completed)
- VIZ-11: Cluster requirement sets
  - Render each `RequirementSet` and its `Requirements`/`Arguments` as a subgraph cluster; style aligns with RequirementSet node color.
  - Non-goal: clustering by file; file is provenance, not a semantic boundary. Consider file overlays later if needed.

#### VIZ-19 — Semantic tooltips (Completed)
- Purpose: add meaning without changing labels heavily.
- Content by type:
  - Modifiers: `Effect`, `Collection`, optional `Permanent`, plus a few `Name=Value` arguments.
  - RequirementSets: `RequirementSetType` and number of requirements.
  - Requirements: `RequirementType` and key `Name=Value` arguments.
- Acceptance: Tooltip shows summaries; DOT strings escaped; no performance regressions.

#### Phase E — Theming & wrapper (defer until requested)
- VIZ-10: Config-driven styling (optional)
  - Optional `viz` block in `civ.config.jsonc` to override table/node/edge styles.
- VIZ-12: HTML wrapper for pan/zoom UX (optional)
  - `--viz.html` to emit a minimal HTML viewer that wraps the SVG for panning/zooming.

#### Phase F (Baseline) — Local Interactive Visualizer (keep server pipeline as-is) (Completed)

Goal: Add a polished, local, interactive visualization path without changing the server-side crawl→DOT pipeline.

// Completed as an SVG wrapper (no d3-graphviz) — see Completed section above.

// Completed — see Completed section above.

- VIZ-15: Advanced viewer prototype (G6 + ELK)
  - Why: Rich UX (minimap, search, filters) and scalable layout beyond plain DOT.
  - Scope:
    - Parse DOT → AST (`@ts-graphviz/parser`) → nodes/edges model.
    - Layout with `elkjs` (direction RIGHT, spacing tuned); render with AntV G6.
    - Map table types to colors/shapes; add hover/click tooltips (file/provenance), selection highlight.
  - Acceptance: Rome/Amina graphs render with minimap; nodes clickable to show file path; performance acceptable.
  - Risks: More code/complexity; keep separate from baseline viewer.

- VIZ-16: Search and filters (optional)
  - Scope: In-viewer search by `table:id`; filters to hide `*Arguments`, generic edges.
  - Acceptance: Instant search; toggles affect visibility without reload.

- VIZ-17: Deep link & state (optional)
  - Scope: Persist selected seed and toggles in URL hash; copy-link to share a view.

- VIZ-18: Packaging (optional)
  - Scope: If needed, split into `packages/viewer/` (Vite+TS) and publish a static bundle; CLI copies it and injects DOT.

---

Notes
- Keep crawl/index/DOT rendering exactly as-is. Visualizers are additive, consuming the DOT output.
- Continue to prefer `@hpcc-js/wasm` for server-side rendering; baseline local viewer is a lightweight SVG wrapper; consider d3-graphviz or G6+ELK for advanced UX if/when needed.

### Archived Plans

- XML-FIRST-CRAWL-PLAN.md — Implemented and removed. The plan was realized as:
  - GameEffects normalization, attach-chains, layering/deletes, provenance, deterministic traversal.
  - Acceptance: deep graphs for Rome and Genghis, manifests include GameEffects sources, no dangling edges.
  - Visualization improvements are now tracked as tickets above.
</file>

<file path="system/mods/swooper-maps/reference/legacy-climate-story-tldr.md">
# Climate Story TL;DR

> Legacy quick reference preserved from the deprecated `plugin-mapgen` effort. Use as a guardrail checklist; current behavior lives in `mods/mod-swooper-maps`.

What
- Narrative Imprint Layer = sparse “StoryTags” that hint at tectonics/volcanism/rifts/glaciation—without heavy simulation.
- We bias existing passes (coasts, islands, rainfall Phase B, biome nudges) with tiny, clamped adjustments.
- Keep performance O(width × height), radii ≤ 4, lanes open, features validated, rainfall in [0, 200].

First Targets (v0.1)
- Hotspot Trails (deep‑ocean island chains with decaying density).
- Rift Valleys (linear inland lakes + mild humidity belt + greener shoulders).

Minimum Integration Points
- Tagging runs after landmasses/coasts exist; before Climate Phase A.
- addIslandChains: read HOTSPOT_TRAIL tags to bias island spawning (strict spacing + lane checks).
- refineRainfallEarthlike: add small rift humidity near RIFT_LINE (clamped).
- designateEnhancedBiomes: prefer grassland/forest on RIFT_SHOULDER when rainfall allows.

Hard Guardrails
- Never narrow sea lanes below acceptance width.
- Clamp rainfall after every change [0, 200].
- Validate features via engine checks; resolve via lookups; skip if not allowed.
- Keep lake conversions tiny, far from starts; cap motif counts and enforce separation.
- Diminishing returns when multiple StoryTags stack on one tile.

Default Tunables (good starting values)
- Hotspot Trails:
  - maxTrails=3, length=10 steps, step=4 tiles
  - decayStart=0.5, decayRate=0.85
  - minDistanceFromLand=4, minTrailSeparation=12
  - clusterSize=1..2, respect minSeaLaneWidth
- Rift Valleys:
  - maxRiftsPerContinent=2, minContinentArea≈4% map
  - lineLength=18 steps, step=2 tiles
  - riftLakeDensity=0.2, riftMaxLakeTilesPerContinent=10
  - riftHumidityBoost=+8, radius=2
  - shoulderWidth=1, minDistanceFromStarts=8, riftMinSeparation=12

Quick‑Start Checklist (30–60 min)
1) Scaffolding (no behavior change yet)
   - Add StoryTags structure: tags.hotspot (sparse set), tags.riftLine (set), tags.riftShoulder (set).
   - Add toggles: STORY_ENABLE_HOTSPOTS, STORY_ENABLE_RIFTS (default true).
   - Add logs: “Drawing hotspot trails…”, “Marking rift lines and basins…”.

2) Hotspot Trails (tagging)
   - Pick ≤3 deep‑ocean seeds far from land and each other (≥12).
   - March 10 steps at 4‑tile increments with low‑freq bend; compute strength = 0.5 × 0.85^i.
   - Tag HOTSPOT_TRAIL points if deep ocean and ≥4 from land.

3) Hotspot Integration (islands)
   - In addIslandChains: when near HOTSPOT_TRAIL, bump island chance by f(strength); cap islands per trail; enforce spacing and min sea‑lane width; limit cluster size (1–2).

4) Rift Valleys (tagging + micro‑lakes)
   - For each large continent (≥4% tiles), choose ≤2 long axes avoiding high mountains.
   - March 18 steps at 2‑tile increments; tag RIFT_LINE; tag 1‑tile RIFT_SHOULDER on both sides (land only).
   - Convert a few lowland RIFT_LINE tiles to 1‑tile lakes with probability 0.2, honoring caps, start distance (≥8), and adjacency sanity.

5) Rift Integration (rainfall + biomes)
   - refineRainfallEarthlike: +8 rainfall within radius 2 of RIFT_LINE; reduce with elevation; clamp.
   - designateEnhancedBiomes: on RIFT_SHOULDER, prefer grassland/forest if rainfall/latitude allow (no overrides; just bias).

6) Safeguards + Diminishing Returns
   - If multiple tags touch the same tile, apply largest delta fully, then 50% of the next, 25% of the next, clamp.
   - Keep global counters: trail islands, rift lakes; stop when caps hit.

7) Diagnostics
   - Print counts: trails, trail points, islands realized; rifts per continent, lake tiles placed.
   - Optional overlay dumps behind dev flag.

Acceptance (must pass)
- Oceans: lanes remain robust; hotspot islands form sparse aligned chains, no bridges.
- Interiors: rift lake chains read as long linear features; mild greener shoulders, not dominant.
- Rainfall: histograms ~baseline; local deviations small; all adjustments clamped.
- Starts: no intrusive lakes/fertility near spawns; base balance intact.

Next up (later, separate small PRs)
- Margins (active/passive): fjord/trench vs. shelf/reef bias (very sparse; strict lane checks).
- Orogeny belts: narrow windward +lee amplification using existing orographic logic.
- Paleo‑hydrology: ≤4 deltas, ≤6 oxbows, ≤3 fossil channels (humidity/biome hints only).
- Glacial fingerprints: fjord bias at high latitudes, ≤10 kettle lakes, taiga emphasis where wet enough.

Reminder
- Update DESIGN.md changelog when enabling knobs.
- Keep JSON/phase logs minimal, focused on counts and caps hit.

— End TL;DR —
</file>

<file path="system/mods/swooper-maps/reference/legacy-layer-contracts.md">
# Epic Diverse Huge Map Generator — DESIGN

> Legacy reference from the retired `plugin-mapgen` extraction. Keep for historical contracts and guardrails; the live implementation is `mods/mod-swooper-maps`.

Appendix A — Layer Contracts (authoritative quick reference)
This appendix documents inputs, outputs, order constraints, and guarantees for each major layer. All layers are O(width × height) with small constants unless noted.

- Landmass (createDiverseLandmasses)
  - Inputs:
    - width, height, and band windows supplied by the orchestrator
    - `LANDMASS_CFG`
    - Optional: `WorldModel` when `worldModel.policy.oceanSeparation.enabled = true` (consumes boundary closeness)
  - Outputs: writes base terrain (ocean vs. flat land) via TerrainBuilder
  - Order constraints: runs before coast expansion and any climate/tagging layer
  - Guarantees:
    - True oceans between bands and at map edges
    - Organic band edges via sinusoidal/Fractal jitter
    - If WorldModel ocean separation is enabled, per-row lateral shifts are bounded by `maxPerRowDelta` and preserve minimum channel width when configured

- Coastlines (addRuggedCoasts)
  - Inputs: `COASTLINES_CFG`, StoryTags `activeMargin`/`passiveShelf`, corridor tags and metadata (style-aware), GameplayMap adjacency
  - Outputs: occasional coast-to-water and water-to-coast conversions (rugged coasts, sparse fjords)
  - Order constraints: after landmass and continental margins tagging; before islands
  - Guarantees: preserves open sea lanes; lane policy may be hard skip or soft reduction per corridor policy

- Islands (addIslandChains)
  - Inputs: `ISLANDS_CFG`, StoryTags `hotspot` (+ paradise/volcanic), margins, corridor sea-lane avoidance
  - Outputs: tiny offshore clusters (1–3 tiles), and StoryTag classification of hotspot centers
  - Order constraints: after coastlines; before climate baseline
  - Guarantees: avoids land adjacency within a small radius; respects protected lanes

- Climate — Baseline (buildEnhancedRainfall)
  - Inputs: `CLIMATE_BASELINE_CFG`, GameplayMap latitude/elevation, StoryTags (optional light coupling), shared utils
  - Outputs: baseline rainfall field (clamped)
  - Order constraints: after islands; before rivers
  - Guarantees: preserves clamping to [0, 200]; O(width × height)

- Rivers (engine)
  - Inputs: base systems and generator knobs
  - Outputs: river network; names
  - Order constraints: before climate refinement
  - Guarantees: vanilla-compatible parameters

- Climate — Refinement (refineRainfallEarthlike)
  - Inputs:
    - `CLIMATE_REFINE_CFG`
    - StoryTags (`riftLine` proximity, orogeny `windward`/`lee`)
    - Optional `WorldModel` winds (uses `windU`/`windV` to pick upwind steps if enabled)
  - Outputs: clamped rainfall adjustments (coastal gradients, orographic shadows, river/basin greening, rift micro-wetness, hotspot microclimates)
  - Order constraints: after rivers; before biomes/features
  - Guarantees: clamped to [0, 200]; local scans (radius ≤ 4); upwind scan length bounded by config

- Biomes (designateEnhancedBiomes)
  - Inputs: baseline + refined rainfall, `BIOMES_CFG`, StoryTags (tundra restraint, tropical coasts, river-valley grassland nudges)
  - Outputs: biome assignment via base systems + gentle nudges
  - Order constraints: after refinement; before features
  - Guarantees: vanilla validation; restrained deltas

- Features (addDiverseFeatures)
  - Inputs: `FEATURES_DENSITY_CFG`, StoryTags (validated placement), feature lookups
  - Outputs: additional features via validated calls
  - Order constraints: after biomes
  - Guarantees: always gated by `TerrainBuilder.canHaveFeature` and ruleset lookups

- Placement (runPlacement)
  - Inputs: `PLACEMENT_CFG` (wonders +1; floodplains; resources; starts), start-sector windows and counts
  - Outputs: wonders, floodplains, snow, resources, starts, discoveries, fertility
  - Order constraints: final phase; after all terrain/biome/feature passes
  - Guarantees: preserves vanilla compatibility and balance constraints

Config Lifecycle and Entry Pattern (authoritative)
- Single source of truth for reads: maps/config/resolved.js builds a frozen snapshot by composing:
  1) defaults/base.js (BASE_CONFIG)
  2) Any named presets declared by the entry (presets: ["classic", "temperate", ...])
  3) Per-entry overrides (highest precedence)
- Access in code: import resolved groups via maps/config/tunables.js (which reads the resolved snapshot). Typical groups:
  - Toggles: STORY_ENABLE_*
  - LANDMASS_CFG, CLIMATE_BASELINE_CFG, CLIMATE_REFINE_CFG, BIOMES_CFG, FEATURES_DENSITY_CFG, CORRIDORS_CFG, PLACEMENT_CFG
  - WORLDMODEL_* (cfg, directionality, plates, wind, currents, pressure, policy, oceanSeparation)
- Entry pattern (explicit two-liner; robust on the game VM):
  - import { bootstrap } from "./config/entry.js";
  - bootstrap({ presets, overrides });
  - import "./map_orchestrator.js"; // registers engine listeners at module load
- Tradeoff and rationale:
  - We keep an explicit orchestrator import so the engine listener registration happens after the entry sets config. This avoids timing/friction on the VM where dynamic imports and eager constant capture can be brittle.
  - A future “one import” pattern would require deferring all config reads to runtime (lazy getters + resolve/refresh at GenerateMap()). We chose not to adopt that yet to keep the current pipeline stable.
- Dev logger alignment:
  - maps/config/dev.js initializes flags from resolved.DEV_LOG_CFG() each run (defaults live in defaults/base.js under dev).
  - Keep dev flags ON during development and OFF for release builds by adjusting defaults/presets/overrides as needed.

Appendix B — WorldModel-driven Ocean Separation (plate-aware)
This appendix specifies the plate-aware separation policy integrated into the landmass layer.

- Purpose
  - Widen/narrow oceans between configured continent bands based on `WorldModel.boundaryCloseness`, generalizing manual adjustments into a coherent, plate-informed rule.
  - Optional widening/narrowing at the west/east map edges.

- Configuration (under `worldModel.policy.oceanSeparation`)
  - `enabled`: boolean (default false)
  - `bandPairs`: array of `[leftIndex, rightIndex]` band pairs to bias apart (e.g., `[0,1]`, `[1,2]`)
  - `baseSeparationTiles`: integer base lateral push per row
  - `boundaryClosenessMultiplier`: scalar multiplier for closeness-driven scaling (0..2 recommended)
  - `maxPerRowDelta`: hard cap on per-row separation magnitude
  - `respectSeaLanes`: boolean; when true, enforces a minimum channel width
  - `minChannelWidth`: integer minimum width when `respectSeaLanes` is true
  - `edgeWest`, `edgeEast`: objects controlling outer-edge widening/narrowing
    - `enabled`: boolean
    - `baseTiles`: signed integer; positive widens the adjacent ocean (pushes interior band away from edge)
    - `boundaryClosenessMultiplier`: scaling as above
    - `maxPerRowDelta`: cap as above

- Behavior (landmass layer)
  - For each configured band pair and map row:
    - Sample `boundaryCloseness` at the mid-gap between the bands.
    - Compute `sep = baseSeparationTiles + round((closeness/255) * boundaryClosenessMultiplier * baseSeparationTiles)`, clamped to `maxPerRowDelta`.
    - Apply symmetric per-row lateral shifts: left band shifts left by `sep`, right band shifts right by `sep`.
    - If `respectSeaLanes` is set, reduce `sep` as needed to maintain `minChannelWidth`.
  - For `edgeWest`/`edgeEast` (if enabled), compute a per-row shift of the outermost bands using the same closeness-driven scaling sampled near the corresponding map edge:
    - West: apply signed shift to band 0 (negative moves the band left to widen the west ocean; positive narrows)
    - East: apply signed shift to the last band (positive moves the band right to widen the east ocean; negative narrows)

- Guarantees and constraints
  - Order: applied inside the landmass layer during band boundary calculation, before coast expansion.
  - Complexity: linear over rows; keeps the overall pass O(width × height).
  - Safety: separation is bounded per row and optionally respects a minimum channel width to keep sea lanes open.
  - Compatibility: disabled by default; when disabled or `WorldModel` is off, landmass behavior is unchanged.

- Example policy (conceptual)
  - Enable pairwise separation for left–middle and middle–right with modest strength:
    - `enabled: true`
    - `bandPairs: [[0,1],[1,2]]`
    - `baseSeparationTiles: 2`
    - `boundaryClosenessMultiplier: 1.0`
    - `maxPerRowDelta: 3`
    - `respectSeaLanes: true`, `minChannelWidth: 4`
  - Slightly widen exterior oceans:
    - `edgeWest.enabled: true`, `edgeWest.baseTiles: 1`
    - `edgeEast.enabled: true`, `edgeEast.baseTiles: 1`

Version: 1.0.0
Target: Civilization VII (Huge maps prioritized)

This document describes the current architecture and design of the Epic Diverse Huge map generator. It focuses on the composition of the pipeline, responsibilities of each stage, the modeling choices behind landforms and climate, and the compatibility/performance constraints that guide the implementation.

The intent is to keep this as the authoritative design reference for v1.0.0 and a foundation for future modularization into layered components.


## 1) Design Goals

- Regional coherence with organic variation:
  - Large continental “cores” with fragmented fringes and believable coastlines
  - Rivers and rainfall/climate interact to form green corridors and dry shadows
  - Coastal humidity and interior gradients feel natural and gradual
- Naval relevance and exploration:
  - True oceans between land bands for meaningful sea play
  - Small island clusters placed far enough offshore to avoid chokepoint spam
- Playability and balance:
  - Lean on base elevation/hills/wonders/resources systems for baseline balance
  - Apply targeted, gentle nudges for biome/feature density
  - Avoid extreme cliff or mountain proliferation
- Compatibility-first:
  - Build on base-standard modules for terrain, biomes, features, resources, etc.
  - Keep imports and start-position logic aligned with vanilla expectations
- Performance:
  - O(width × height) passes with small constants
  - Avoid heavy global multipliers and overly granular noise layers


## 2) High-level Pipeline

The generator runs as a sequence of coordinated passes. Each pass is responsible for one clearly defined concern and is designed to be composable and compatible with the next.

1) Start Sector Preparation (pre-terrain):
   - Choose start-sector grid, possibly biasing human closer to equator (via utilities).
   - Define minimal continent windows for start assignment compatibility.

2) Landmass Carving:
   - Create three vertical continental bands with “true oceans” on sides and between bands.
   - Per-row sinusoidal jitter and fractal noise avoid straight band edges.
   - Center bias favors inland “cores,” yielding strong interiors and porous perimeters.

3) Coastlines and Offshore Islands:
   - Expand coasts (base).
   - Ruggedize coasts by occasionally carving bays and forming peninsulas/fjords.
   - Seed small island clusters in deeper waters, preserving sea lanes.

4) Elevation, Hills, Volcanoes, Lakes:
   - Mountains, hills, volcanoes use base-standard generation for balance.
   - Lakes are fewer than earlier experiments and tuned for this landform.

5) Climate and Hydrology:
   - Phase A: Build baseline rainfall (base) and blend with latitude bands (wet equator → temperate mid-lats → cold/dry poles).
   - Rivers modeled and named.
   - Phase B: Earthlike refinements:
     - Coastal/lacustrine humidity gradients decaying inland
     - Prevailing-wind orographic rain shadows by latitude band
     - River corridor greening and enclosed low-basin wetness

6) Biomes and Features:
   - Run base biome assignment.
   - Apply gentle, climate-aware nudges (tundra restraint, tropical coasts, temperate grassland in river valleys).
   - Run base features; increase density in a few targeted, validated cases (rainforest, forest, taiga).

7) Wonders, Floodplains, Snow, Resources, Discoveries:
   - Natural wonders slightly increased vs. map defaults (+1).
   - Floodplains, snow, resource generation, and discoveries use base systems.

8) Start Placement and Advanced Start:
   - Assign start positions with the standard, compatible method.
   - Recalculate fertility and finalize.


## 3) Key Modules and Responsibilities

- Landmass layer:
  - Responsibility: Create continental structure with organic edges and robust oceans.
  - Interfaces: TerrainBuilder.setTerrainType, FractalBuilder (land/hill noise), globals (terrain constants, seam/polar/ocean parameters).
  - Output: Initial land vs. ocean tiles; coast will be refined later.

- Coastline and Island layer:
  - Responsibility: Carve bays/fjords; seed small offshore archipelagos without blocking lanes.
  - Interfaces: GameplayMap (water/coastal adjacency), TerrainBuilder.setTerrainType.

- Elevation/Water layer:
  - Responsibility: Base mountains, hills, volcanoes; tuned lake density.
  - Interfaces: addMountains/addHills/addVolcanoes/generateLakes (base-standard).

- Climate layer (two-phase):
  - Responsibility: Baseline rainfall blending with latitude bands; post-river refinements (humidity gradients, wind shadows, river/basin greening).
  - Interfaces: GameplayMap.getRainfall/getElevation/getPlotLatitude/isCoastalLand/isAdjacentToShallowWater/isAdjacentToRivers; TerrainBuilder.setRainfall.

- Biome layer:
  - Responsibility: Base biome assignment plus climate/playability nudges (tundra restraint; equatorial tropical coasts; temperate river valleys as grassland).
  - Interfaces: designateBiomes (base), TerrainBuilder.setBiomeType.

- Feature layer:
  - Responsibility: Base features, then targeted density increases (rainforest, forest, taiga) validated against rules.
  - Interfaces: addFeatures (base), TerrainBuilder.canHaveFeature/setFeatureType, GameInfo.Features.lookup.

- Placement layer:
  - Responsibility: Natural wonders (+1), floodplains, snow, resources, discoveries, starts.
  - Interfaces: addNaturalWonders, TerrainBuilder.addFloodplains, generateSnow, generateResources, generateDiscoveries, assignStartPositions.


## 4) Detailed Algorithmic Notes

4.1 Landmass Carving (three-band continents)
- Input: Map width/height, globals for seam/polar/ocean rows/columns.
- Process:
  - Three vertical band windows are defined with wider oceans on the sides and between bands.
  - For each row, a sinusoidal offset and hill-fractal noise are combined to “wiggle” west/east boundaries and alter band thickness.
  - Within each band, apply a center-distance bias so land cores form more reliably while edges fracture more often.
- Output: Oceans with three organic continental bands, primed for robust coastlines and naval play.

4.2 Coastline Ruggedizing
- Occasionally convert coastal land to shallow water (bays) and adjacent ocean to coast (peninsulas/fjords), guided by a low-frequency noise mask and lightweight randomness.
- Safety: Operates only near coasts; avoids wholesale shoreline shifts.

4.3 Island Chains
- Seed islands far enough from land (radius checks) using a sparse high-threshold fractal as a mask.
- Create tiny clusters (1–3 tiles) to increase exploration targets while preserving lanes.

4.4 Climate: Phase A (banded baseline)
- Build the base rainfall map, then blend with latitude bands:
  - Very wet at equator; drying toward subtropics; temperate in mid-lats; cool/dry toward poles.
- Add coastal/shallow-water humidity bonuses; small orographic elevation bonuses; light noise to avoid visible banding.

4.5 Rivers and Refinements: Phase B (earthlike)
- Prevailing winds by latitude:
  - 0–30°: easterlies (trade winds, E→W)
  - 30–60°: westerlies (W→E)
  - 60–90°: polar easterlies (E→W)
- Orographic rain shadows:
  - Look upwind a few tiles for mountain/high-elevation barriers; subtract rainfall proportional to barrier strength/distance.
- Humidity gradients:
  - Increase rainfall based on distance-to-water up to a small radius; stronger if low elevation.
- River/basin greening:
  - Add humidity adjacent to rivers (more at lower elevation).
  - Slight wetness bonus in enclosed, low-elevation basins (surrounded by higher neighbors within a small radius).

4.6 Biome Nudging
- After base assignment:
  - Tundra: Only at very high latitudes or extreme elevations and low rainfall.
  - Tropical coasts: Near-equator coastal land with higher rainfall is encouraged toward tropical.
  - Temperate river valleys: When rainfall and latitude permit, prefer grassland for playability (food corridors).

4.7 Features with Validation
- After base features:
  - Rainforest: +chance in very wet tropical zones
  - Forest: +chance in wetter temperate grasslands
  - Taiga: +chance in cold tundra at lower elevations
- Always check TerrainBuilder.canHaveFeature before placing; feature type is resolved via GameInfo.Features.lookup for robustness.

4.8 Wonders, Snow, Floodplains, Resources, Discoveries
- Wonders: Increase by +1 over map defaults.
- Floodplains, snow, resources: Use base systems to preserve balance expectations.
- Discoveries: Added post-starts for exploration incentives.

4.9 Start Placement
- Start-sector grid is chosen up front; final assignment uses the standard, compatible method with simple west/east continent windows to satisfy vanilla assumptions.
- Fertility recalculated before advanced start regions.


## 5) Data Model and Invariants

- Coordinate system:
  - Integer tile indices (x: 0..width-1, y: 0..height-1)
  - Bounds must be respected in all neighborhood scans.
- Latitudes:
  - GameplayMap.getPlotLatitude returns degrees with 0 near equator and 90 near poles; most logic uses absolute latitude.
- Rainfall:
  - Internally normalized to [0, 200]; all passes clamp to this range.
- Elevation:
  - Values are engine-provided; common thresholds used:
    - Lowland: <150–250
    - High elevation for orographic effects: ≥500
    - Extreme elevation (tundra consideration): ~850+
- Water proximity:
  - Distance-to-water scans to a max radius of ~4; negative return means “no water within radius.”
- Validation:
  - TerrainBuilder.canHaveFeature must gate any manual feature placement.
  - Lookups via GameInfo.Features.lookup must handle missing results (return -1 → skip).


## 6) Tunables and Controls (v1.0.0 Defaults)

- Land/ocean composition:
  - Ocean columns widened slightly on sides/mid-ocean for robust naval lanes.
  - Land band widths are jittered by sinusoidal offset + fractal noise.
- Coast ruggedness:
  - Low probability per coast tile to carve a bay or extend a coast into nearby ocean; tuned to avoid chokepoints.
- Island seeding:
  - High fractal threshold; small cluster sizes (1–3); requires non-adjacency to land.
- Baseline climate band targets:
  - Very wet equator → moderate mid-lats → cool/dry poles; blended with base rainfall and light noise.
- Earthlike refinements:
  - Distance-to-water humidity radius ~4; wind barrier lookups ~4 tiles; river corridor and basin bonuses are small but noticeable.
- Wonders/lakes:
  - Wonders: +1 vs. map defaults.
  - Lakes: fewer than early drafts; tuned for balance within three-band landmasses.


## 7) Compatibility

- Base-standard dependency:
  - Elevation, coast expansion, rainfall baseline, biomes, features, resources, wonders, snow, and discovery generation rely on base-standard modules provided by the game/core modules.
- Start assignment:
  - Uses the same structure as vanilla and community scripts (sectors + continent windows).
- Map sizes:
  - Tuned for Huge maps. Other sizes may work but are not the primary target for v1.0.0.
- Resources folder:
  - Present for reference to community sources; not required for runtime in this mod layout.


## 8) Performance Considerations

- Complexity:
  - Each major pass is O(width × height) with small neighborhood scans (radius ≤ 4) in a limited number of passes.
- Memory:
  - No bespoke large buffers; relies on engine data queries and setters.
- Avoided pitfalls:
  - Removed aggressive cliff systems and heavy mountain amplification.
  - Island/coast passes are sparse and avoid wide flood fills.
- Practical advice:
  - Prefer parameter nudges over new global heavy passes.
  - Keep neighborhood radii small and conditional work early-exit where possible.


## 9) Testing and Debugging

- Visual validation:
  - Outputs/1.0.0 contains example images for v1.0.0 behavior across multiple seeds.
- Logging:
  - Readable phase messages are present (“Building enhanced rainfall patterns…”, etc.).
  - Optional JSON start/end logs are available but commented out by default; uncomment them in the script to enable structured monitoring.
- Debug dumps (optional):
  - Script includes commented calls to dump terrain/elevation/rainfall/biomes/features; these can be toggled locally for troubleshooting.
- Acceptance checks:
  - Oceans: verify robust east/west and mid-ocean lanes on Huge.
  - Rivers: confirm green corridors in temperate/warm zones; floodplains exist where sensible.
  - Rain shadows: observe drier leeward regions by latitude band wind rules.
  - Biome edges: ensure tundra restraint and smoother coastal-to-inland transitions.


## 10) Future Work and Modularization Plan

To further evolve this design, we plan to break the generator into explicit layers/components that can be tuned or swapped independently:

- LandmassLayer:
  - Encapsulate band definitions, jitter/noise shaping, and center-bias logic.
  - Provide seeds & presets for 2, 3, 4-band variants and archipelago modes.

- CoastlineLayer:
  - Expose independent knobs for bay carving, fjord frequency, island cluster rarity/size, and minimum sea-lane widths.

- ElevationHydrologyLayer:
  - Allow targeted ridge-line reinforcement and valley smoothing with strict bounds.
  - Introduce optional rain-catch diagnostics to cross-check river placement.

- ClimateLayer:
  - Split into BaselineBands and EarthlikeRefinement modules.
  - Parameterize wind vectors per latitude and allow hemispheric asymmetries/monsoon biases.

- BiomeLayer:
  - Make nudges data-driven and map-size aware.
  - Add local “regional identity” presets (e.g., savanna belts, steppe corridors) with hard caps.

- FeatureLayer:
  - Data-configurable density rules with biome/elevation/rainfall constraints and adjacency limits.

- PlacementLayer:
  - Pluggable wonder/resource policies; compatibility mode vs. experimental mixes.

- TelemetryLayer:
  - Structured event logging, per-pass timing, and tile-sample histograms.


## 11) Change Log (v1.1.0 — WIP)

- Size-aware “thumb on the scale” for larger maps:
  - Introduced a sqrt(area/base) scaler applied to motif lengths, band jitter, and low-probability edits so Huge maps form broader, continuous swaths instead of dotted noise.
- Fuller, more curved continents:
  - Slight reduction in effective water fraction on larger maps (within strict bounds).
  - Gentle curvature added to land bands to evoke long continental arcs while keeping true oceans.
- Climate Story (v0.1 — implemented end-to-end in pipeline)
  - Continental Margins: active vs. passive margin tagging; coast ruggedizing reads margins; passive shelves bias validated reefs.
  - Hotspot Trails: deep-ocean trail tagging; hotspot-aware island chains; paradise vs. volcanic classification; hotspot microclimates in rainfall refinement.
  - Rift Valleys: rift line + shoulders; narrow rift humidity boost; shoulder biome bias toward grassland/tropical where moist.
  - Orogeny Belts: windward/lee cache; small windward wetness boost; slightly stronger lee dryness; coupled swatch (mountainForests).
  - Climate Swatches: one weighted macro swatch per map with soft edges (macroDesertBelt, equatorialRainbelt, rainforestArchipelago, mountainForests, greatPlains).
  - Paleo‑Hydrology (initial): light overlays for deltas/oxbows/fossil channels affecting rainfall only; strict clamps and caps.
- Coasts and islands (lane‑safe refinements):
  - Margin-aware rugged coasts (slightly more bays/fjords on active segments).
  - Hotspot-biased island chains with strict spacing and deep-water placement.
- Features, margin/hotspot aware:
  - Paradise reefs near hotspot paradise centers; modest passive-shelf reef bias.
  - Volcanic vegetation near volcanic centers; gentle rainforest/forest/taiga density tweaks (validated).
- Strategic Corridors (initial):
  - New StoryTags for corridors: corridorSeaLane (protected sea lanes), corridorIslandHop (promoted hotspot arcs), corridorLandOpen (open land lanes), corridorRiverChain (river-adjacent chains).
  - Tagging stages: preIslands (sea lanes, island-hop, land-open from rift shoulders) and postRivers (river chains).
  - Consumers: coastlines skip edits on sea-lane tiles; islands avoid placing near sea-lanes; biomes gently bias grassland on land-open corridors.
  - Config: master toggle STORY_ENABLE_CORRIDORS and corridors.{sea,islandHop,land,river} (resolved via maps/config/resolved.js; access through maps/config/tunables.js).
- Developer logger:
  - Optional per-layer timings, StoryTags counts, and rainfall histograms (`maps/config/dev.js`).

Invariants retained:
- Rainfall clamped to [0, 200] at every step.
- No aggressive cliffs or heavy mountain amplification reintroduced.
- Feature placement remains gated by TerrainBuilder.canHaveFeature with data lookups.
- Open ocean lanes preserved; island/coast edits remain sparse.

## 11) Change Log (v1.0.0)

- Removed aggressive cliff systems to improve playability and performance.
- Scaled back experimental mountains/lakes; rely on base elevation/hills with curated rainfall/biome interplay.
- Implemented robust three-band landmass approach with per-row jitter and fractal wiggle.
- Added two-phase climate:
  - Baseline latitude band blending
  - Earthlike refinements (coastal/lake humidity, prevailing-wind rain shadows, river/basin greening)
- Biome corrections:
  - Tundra restraint at extreme latitude/elevation under low rainfall
  - Encourage tropical coasts near equator with high rainfall
  - Temperate river valleys trend grassland for corridor/playability
- Feature density tweaks behind engine validation (rainforest, forest, taiga).
- Wonders +1 vs. defaults; floodplains/snow/resources/discoveries via base systems.
- Start placement aligned with vanilla-compatible sector/continent bounds.


## 12) Acceptance Criteria Summary

- Oceans:
  - Distinct west/mid/east open oceans enabling naval strategies; island clusters avoid chokepoint spam.
- Regions:
  - Observable river-green corridors, drier rain-shadows, wet coastal fringes tapering inland.
- Biomes:
  - Equatorial tropical coasts when wet; restrained tundra; believable transitions at mid-lats.
- Balance:
  - Base systems preserved for mountains/hills/resources/wonders; modest, intentional nudges only.
- Performance:
  - Generation time acceptable on Huge; passes remain bounded and avoid heavy flood operations.


## 13) Modularization and Climate Story (v1.0.1+ Notes)

- Orchestrator entrypoint
  - `maps/epic-diverse-huge.js` acts as the orchestrator/entrypoint. It wires the pipeline and calls modular layers.
  - Engine hooks remain registered here for stability.

- Modular layers (current)
  - Landmass: `maps/layers/landmass.js` (`createDiverseLandmasses`)
  - Coastlines: `maps/layers/coastlines.js` (`addRuggedCoasts`)
  - Islands: `maps/layers/islands.js` (`addIslandChains`)
  - Climate — Baseline: `maps/layers/climate-baseline.js` (`buildEnhancedRainfall`)
  - Climate — Earthlike Refinements: `maps/layers/climate-refinement.js` (`refineRainfallEarthlike`)
  - Biomes: `maps/layers/biomes.js` (`designateEnhancedBiomes`)
  - Features: `maps/layers/features.js` (`addDiverseFeatures`)
  - Placement: `maps/layers/placement.js` (wonders, floodplains, snow, resources, starts, discoveries, fertility, advanced starts)

- Climate Story docs
  - Concept and guardrails: `climate-story/README.md`
  - First iteration spec (Hotspot Trails + Rift Valleys): `climate-story/HotspotTrails_and_RiftValleys.md`
  - Additional motifs roadmap (Margins, Orogeny, Paleo‑hydrology, Glacial): `climate-story/Roadmap_Additional_Motifs.md`
  - TL;DR quick-start for implementation: `climate-story/TLDR.md`

- Developer logger (optional; disabled by default)
  - Config and helpers: `maps/config/dev.js`
  - Toggles (set to true for a debug session, then revert):
    - `DEV.ENABLED`: master switch
    - `DEV.LOG_TIMING`: per-layer timing (use `timeStart/timeEnd` or `timeSection`)
    - `DEV.LOG_STORY_TAGS`: prints StoryTags counts (`logStoryTagsSummary`)
    - `DEV.RAINFALL_HISTOGRAM`: prints a coarse rainfall histogram over land (`logRainfallHistogram`)
  - These utilities are no-op when disabled and have negligible perf impact.

- Climate Story runtime integration (v0.1)
  - Tagging runs after coasts and before island seeding:
    - Hotspot trails and rift lines/shoulders (`story/tagging.js`, `story/tags.js`)
  - Hotspot-aware islands (paradise/volcanic) decorate offshore chains with minimal changes to lane openness.
  - Microclimates and features read tags later in the pipeline (refinements, biomes, features).

## 14) Strategic Corridors (Design and Implementation)

Purpose
- Create readable, gameplay-focused paths that encourage movement and strategic planning:
  - Sea lanes: long open-water routes across the map that remain unobstructed.
  - Island-hop arcs: navigable chains across deep water (often aligned with hotspots).
  - Land-open lanes: traversable plains/grassland corridors framed by relief (e.g., rift shoulders).
  - River chains: cross-continent routes that stay close to navigable rivers and lowlands.

Tagging Model
- Tags (sparse, string keys "x,y"; O(width×height), no flood fills):
  - StoryTags.corridorSeaLane — protected open-water tiles forming long lanes.
  - StoryTags.corridorIslandHop — promoted hotspot neighborhoods for legible arc hopping.
  - StoryTags.corridorLandOpen — long runs along rift shoulders marked as “open” land lanes.
  - StoryTags.corridorRiverChain — river-adjacent lowland steps seeded from coasts after rivers exist.
- Stages:
  - preIslands: tagSeaLanes, tagIslandHopFromHotspots, tagLandCorridorsFromRifts
  - postRivers: tagRiverChainsPostRivers
- Files:
  - maps/story/corridors.js (new): implements the tagging passes above.
  - maps/story/tags.js: adds corridor tag sets and resets.

Consumers and Effects (gentle; lane-safe)
- Coastlines (maps/layers/coastlines.js):
  - Skip bay/fjord edits on StoryTags.corridorSeaLane tiles to preserve lanes.
- Islands (maps/layers/islands.js):
  - Avoid placing islands on/near sea-lane tiles (configurable radius) to prevent chokepoints.
- Biomes (maps/layers/biomes.js):
  - Apply a light grassland bias on StoryTags.corridorLandOpen tiles when rainfall/latitude permit.
- Future (optional, not enabled by default):
  - Placement: discoveries or resource clusters could be biased along corridors.
  - Climate refinement: tiny microclimate deltas along corridorRiverChain (must obey rainfall clamps).

Configuration
- Master toggle: STORY_ENABLE_CORRIDORS (resolved toggles; default true in defaults/base.js).
- Tunables: corridors (resolved via maps/config/resolved.js; consume through maps/config/tunables.js)
  - sea: { maxLanes, minLengthFrac, scanStride, avoidRadius }
  - islandHop: { useHotspots, maxArcs }
  - land: { useRiftShoulders, maxCorridors, minRunLength }
  - river: { maxChains, maxSteps, preferLowlandBelow, coastSeedRadius }

Invariants and Performance
- Passes remain O(width×height) with small constants; no flood fills or global searches.
- Rainfall range clamp [0, 200] preserved; corridor tagging itself does not change rainfall.
- Lane safety is paramount: islands/coast edits avoid sea-lane tiles; min sea-lane width is preserved.
- No aggressive terrain amplification; all edits are conservative and local.

Acceptance Checks (additive to baseline)
- Sea lanes: at least one uninterrupted lane across a major span; islands avoid these lanes.
- Island-hop arcs: visible, legible arcs across deeper water; no lane blocking.
- Land-open corridors: readably open plains/grass strips (e.g., along rift shoulders) without over-densifying.
- River chains: 1–2 river-adjacent paths cross significant portions of continents.
- Performance: no noticeable generation time regressions; diffs remain local.
- Compare corridor visibility with outputs/1.0.0; ensure no chokepoint proliferation.

— End of DESIGN —
</file>

<file path="system/mods/swooper-maps/reference/README.md">
# Swooper Maps — Legacy References

These files are preserved from the retired `plugin-mapgen` extraction. They document the Epic Diverse Huge v1.x layer contracts and climate-story guardrails. Use them for historical intent and acceptance criteria; the live implementation resides under `mods/mod-swooper-maps/`.
</file>

<file path="system/mods/swooper-maps/adr.md">
# Architecture Decision Records — Swooper Maps

> Significant architectural decisions for the Swooper Maps mod. Follow the global ADR pattern in `docs/system/ADR.md`.

## ADR-001: Era-Tagged Morphology View
**Status:** Accepted
**Date:** 2025-12-05
**Context:** A proposal suggested iterating Foundations → Voronoi plate solve → morphology multiple times to stack per-iteration “era” tags for narrative use. The refactor blueprint mandates a single immutable `FoundationContext` per run with WorldModel tightly coupled to the engine; repeated solves would force teardown of engine-bound state and risk desync with the staged buffers.
**Decision:** Keep the single-pass physics pipeline. Do not rerun foundations/morphology in multiple loops. Derive era-like signals analytically from the existing physics snapshot and publish them as immutable overlays (e.g., `eraMorphology`) alongside margins.
**Consequences:**
- Preserves single source of truth and determinism (`FoundationContext` + WorldModel) without extra plate solves.
- Narrative layers read sparse overlay records derived from physics tensors (`shieldStability`, `riftPotential`, `upliftPotential`, `boundaryCloseness`, `boundaryType`) instead of mutating the heightfield again.
- Performance remains bounded; morphology/physics run once. Implementation lives in overlays/tagging, leaving heightfield edits inside morphology stages only.
- Next steps: add an era overlay entry in `StoryOverlays`, emit records during morphology using staged buffers/tensors, expose accessors for narrative/placement consumers, and cover with diagnostics (ASCII/histograms) for validation.

## ADR-002: Own Plot Tagging + Plan Adapter for Civ7 Map Utilities
**Status:** Accepted
**Date:** 2025-12-05
**Context:** After the latest Civ7 drop, `/base-standard/maps/map-utilities.js` no longer exported `addPlotTags`, breaking our orchestrator. The official scripts now tag plots inline (e.g., Voronoi maps) instead of providing the helper. Relying on fragile upstream utilities risks recurrent breakage as the SDK evolves.
**Decision:** Maintain our own stable `addPlotTags` implementation (`mods/mod-swooper-maps/mod/maps/core/plot_tags.js`) and stop depending on the missing Civ7 helper. Continue to consume official resources where they are stable, but prefer an adapter layer for Civ7 utilities/files so updates require changing only one surface. Some utilities (e.g., plot tagging) we will fully own going forward.
**Consequences:**
- Map orchestrator now uses our `addPlotTags`, removing a runtime failure point when Civ7 moves/removes helpers.
- Future Civ7 resource changes are isolated behind a small adapter surface instead of spread across layers.
- Slight maintenance cost to keep our copy in sync with needed behavior, but improved resilience and diagnosability.
- Next steps: inventory current Civ7 utility touchpoints, wrap them in a dedicated adapter module, and migrate consumers to that adapter. Promote fully owning any high-churn or critical helpers (plot tagging, deterministic RNG access) while keeping adapters thin for stable SDK surfaces.
</file>

<file path="system/mods/swooper-maps/design.md">
# Swooper Maps Design Notes

## Stage Manifest Overview
The bootstrap resolver now normalizes a `stageManifest` block that lives alongside the other map configuration groups. Each manifest entry describes:

- **`order`** – The canonical execution order for generator stages (`foundation`, `landmass`, `coastlines`, `storySeed`, `storyHotspots`, etc.).
- **`stages`** – Stage descriptors capturing enablement, hard dependencies (`requires`), documented outputs (`provides`), and legacy toggle bindings (`legacyToggles`).
- **`blockedBy`** – Automatically populated by the resolver when a stage is disabled because a prerequisite is absent, disabled, or scheduled later in the pipeline.

Manifest data merges just like other config groups: defaults supply the canonical order, presets can override specific stage descriptors, and per-entry overrides replace or augment individual stage definitions.

## Dependency Diagnostics
During `refresh()` the resolver:

1. Clones defaults, presets, and overrides into a working manifest.
2. Applies explicit enable/disable flags or runtime toggles to each stage.
3. Validates the dependency graph. Stages with missing or disabled prerequisites are switched off and record a `blockedBy` reason.
4. Emits `console.warn` messages (prefixed with `[StageManifest]`) whenever a requested stage cannot run.

The `blockedBy` field survives into the resolved snapshot so downstream tooling can surface the reason alongside the stage status.

## Stage Config Providers

Entries and named presets can now declare a `stageConfig` map alongside their overrides. Each key maps to a stage identifier and indicates that the entry supplies configuration for that stage (for example, `storyHotspots`, `climateBaseline`, or `coastlines`). The resolver records this metadata and emits a warning whenever an entry customizes a stage that is disabled or missing from the manifest. This makes it easier to notice unused overrides—if a preset tweaks `storySwatches` but the manifest leaves that stage off, the console logs a `[StageManifest]` warning explaining that the overrides will be ignored until the stage is enabled.

The normalized snapshot exposes the resolved `stageConfig` map so diagnostics and tools can surface the same information.

## World Foundation Config Model

The physics pipeline now sources its inputs from a single top-level `foundation` group rather than piecing together `worldModel`, `landmass`, and ad-hoc policy overrides. The resolver hydrates `foundation` before `tunables.rebind()` so every stage observes the same normalized structure.

### Group layout

- **`foundation.seed`** – deterministic seeding (`mode`, optional `fixed`, per-system `offsets`, manifest fingerprint). The captured `plateSeed` ships with `FoundationContext` for diagnostics.
- **`foundation.plates`** – Voronoi layout controls (`count`, `convergenceMix`, `relaxationSteps`, `seedJitter`, `rotation`, `interiorSmooth`). Consumers no longer read `worldModel.plates` directly.
- **`foundation.dynamics`** – physics drivers that emit tensors (`wind`, `currents`, `mantle`, `directionality`). Each block exposes both raw config and normalized scalars so stages avoid re-deriving helpers.
- **`foundation.surface`** – continental targets and post-processing knobs (water targets, band geometry, plate-window adjustments, ocean separation policy).
- **`foundation.policy`** – consumer multipliers for coasts, climate, and separation that previously lived under `worldModel.policy`.
- **`foundation.diagnostics`** – opt-in logging (seed dumps, ASCII slices, manifest validation) so dev tooling can toggle them independently of gameplay presets.

### Migration hints

- Runtime overrides must now write directly to `foundation.*`. Legacy `worldModel` overrides are ignored with a `[Foundation]` warning so stale configs surface quickly during testing.
- `foundation.surface.landmass` inherits the fields from `landmass.*`. Once presets move over, delete the duplicate `landmass` overrides to avoid drift.
- Old `worldModel.policy.oceanSeparation` becomes `foundation.surface.oceanSeparation` so the landmass utilities can read policy + surface data from the same bundle.

## Climate Primitives

The tunables bridge now exports a `CLIMATE` object with two helper views:

- `CLIMATE.drivers` – canonical baseline and refinement driver blocks mirroring the resolved `climate.baseline` and `climate.refine` groups.
- `CLIMATE.moistureAdjustments` – targeted adjustments consumed by rainfall layers and narrative overlays. It includes baseline coastal/orographic noise, refinement gradients, and story-scale rainfall deltas (hotspots, rifts, paleo motifs, etc.).

`layers/climate-engine.js` and story overlays reference these shared primitives instead of touching the raw config blocks directly. The climate overlays remain conservative, but the shared primitives make it easier to compose new moisture effects without duplicating normalization logic.


## Foundation Primitives

`tunables.rebind()` now hydrates a `FOUNDATION` bundle that mirrors the consolidated config:

- `FOUNDATION.core` – normalized seed + plate/dynamics payload (`seed`, `plates`, `dynamics`). Read-only consumers map directly to `FoundationContext`.
- `FOUNDATION.surface` – surface targets (`landmass`, plate windows, ocean separation) aligned with `foundation.surface`.
- `FOUNDATION.policy` – consumer multipliers subdivided into `policy.coasts`, `policy.climate`, and `policy.separation`.
- `FOUNDATION.diagnostics` – live logging toggles (seed dumps, ASCII summaries, manifest warnings) surfaced through dev tooling.
- Shortcut exports (`FOUNDATION_SEED`, `FOUNDATION_PLATES`, `FOUNDATION_DIRECTIONALITY`, etc.) replace the old `WORLDMODEL_*` constants so layers can import only what they need.

Layers consume these helpers instead of reaching into raw config groups. This keeps the plate/wind/currents contract aligned with the `foundation` block in `BASE_CONFIG` and makes it easier to reuse policy defaults when adding new morphology consumers. The resolver now drops `worldModel` overrides entirely, emitting `[Foundation]` warnings when it encounters the legacy group so remaining presets migrate cleanly.

## Legacy Toggles
Legacy `STORY_ENABLE_*` toggles are now derived from the manifest. Each stage lists the toggle keys it controls. The resolver writes the resolved on/off state back onto the `toggles` group so existing callers continue to work. The tunables bridge reads the manifest first, falling back to any residual toggle values in case an entry opts out of the manifest system.

When you introduce a new stage:

1. Add its identifier to the `StageName` union in `map_config.types.js`.
2. Extend `stageManifest.order` and create a descriptor with `requires`, `legacyToggles`, and optional `provides` metadata inside `defaults/base.js`.
3. Update presets or map entries only if they need to opt-in/out of the new stage.
4. Consider adding dependency-aware warnings if the stage relies on optional data (world model, rivers, etc.).

## Runtime Helpers
Two runtime helpers expose the manifest to the orchestrator and tests:

- `resolved.STAGE_MANIFEST()` returns the normalized manifest snapshot.
- `tunables.stageEnabled("stageName")` reports whether a specific stage survived dependency validation. Use this instead of reading raw toggles when you need to know whether a layer actually runs.
</file>

<file path="system/mods/swooper-maps/margins-narrative.md">
# Margins & Narrative Overlay Primer

This note walks through the Swooper pipeline from the physics stack up to the
moment the narrative overlays fire, with a special focus on how continental
margins are derived and consumed. It includes plain-language definitions for
jargon that a typical Civilization player might not know.

## Key terms

- **Stage manifest** – The ordered checklist of generation steps. Each stage
  advertises what data it needs and what it produces so the orchestrator can
  gate execution. The canonical order is captured in `mods/mod-swooper-maps/ENGINE_REFACTOR_PLAN.md`.
- **FoundationContext** – A read-only package emitted by the foundations
  cluster. It bundles the Voronoi plate seeds, tectonic tensors (uplift,
  convergence, rift stress), and atmospheric drivers (wind and currents).
  Everything downstream reads from this single source of physics truth instead
  of recomputing it.
- **Heightfield buffer** – An in-memory staging surface that carries elevation,
  terrain types, and a derived land mask while morphology operates. Instead of
  writing straight to the engine after every tweak, morphology edits this buffer
  and flushes it in controlled batches.
- **Climate field buffer** – The rainfall and humidity arrays maintained in
  parallel with the heightfield. Climate stages nudge these buffers, and the
  narrative overlays consume them when placing rainfall-biased motifs.
- **Margin** – A stretch of coastline sitting on top of a plate boundary.
  Active margins are energetic, collision-heavy fronts (think the Andes or
  Japan); passive shelves are the calmer trailing edges (like the U.S. Atlantic
  seaboard). Margins are represented as sparse coordinate tags.
- **StoryTags** – A frozen object that stores mutable `Set` collections keyed by
  `"x,y"` tile strings. Story layers mark tiles by dropping keys into these sets;
  downstream logic checks membership when deciding where to place a motif.
- **Story overlay** – A lightweight narrative pass (hotspot trails, rifts,
  orogeny belts, corridors, swatches) that reads the physics products and the
  shared buffers, then emits more StoryTags or climate tweaks. Overlays avoid
  rerunning physics; they only annotate the established terrain.

## Pipeline walk-through (physics → narrative setup)

1. **Foundations** build the Voronoi plate solution, apply the configured
   rotation/jitter rules, and emit a deterministic `FoundationContext`. The
   orchestrator threads this context into the shared `MapContext` so later
   stages can inspect plate IDs, uplift fields, and wind tensors before touching
   any terrain.
2. **Landmass shaping** uses the same foundation data to project a plate-aware
   land mask, populate the heightfield buffer, and synchronize the buffer back
   to the engine in one batch. Diagnostics (ASCII slices, window summaries) are
   logged here while the surface is still malleable.
3. **Coastlines** expand and ruggedize the shoreline inside the heightfield
   buffer. The orchestrator then validates the resulting terrain, stamps it into
   the engine, and pulls the updated tiles back into the buffer via
   `syncHeightfield()` so every pass keeps operating on the same authoritative
   arrays.
4. **Margin tagging** resets the StoryTags singleton and calls
   `storyTagContinentalMargins(ctx)` before any narrative overlay runs. The
   helper scans row by row, finds long coastal runs, and marks a sparse subset as
   active or passive margins according to the configured fractions and minimum
   segment length. The result is published to the new `StoryOverlays` registry as
   `ctx.overlays.get("margins")`, and the same snapshot seeds
   `StoryTags.activeMargin` / `StoryTags.passiveShelf` for legacy consumers.
5. **Margin-aware coast polish** (`layerAddRuggedCoasts`) consults those tags to
   add fjords and shelf smoothing where appropriate. Because the overlay lives
   in the shared registry, later passes can rehydrate the StoryTags view at any
   time without recomputing the sweep.
6. **Narrative reset window** – Some story passes (hotspots, rifts) clear tags
   again before writing their own overlays. Once those motifs are stamped, the
   orchestrator simply rehydrates the margin sets from the published overlay so
   the active/passive keys stay in sync for downstream consumers such as island
   placement and feature dressing—no second tagging pass required.
7. **Mountains, volcanoes, lakes** operate on the heightfield buffer with full
   access to the margin tags and the foundation tensors. Mountains pull uplift
   and boundary proximity from the world model, volcanoes bias toward convergent
  and hotspot cues, and lakes respect the staged land mask. The buffered surface
   is synced only at checkpoints so physics and morphology stay in lockstep.
8. **Climate baseline/refinement** write rainfall and humidity into the climate
   buffer. These arrays stay authoritative; later swatches and story moisture
   adjustments read and tweak them instead of editing engine tiles directly.
9. **Narrative overlays** finally run, now that the terrain, coasts, and climate
   grids are settled. Each overlay reads the `FoundationContext`, the heightfield
   buffer, the climate buffer, and the StoryTags that were seeded earlier. The
   overlays add their own tags (e.g., `StoryTags.riftLine`, `StoryTags.hotspot`)
   or climate deltas, but they never rerun foundations or morphology.

## Margin system deep dive

### How margins are detected

`storyTagContinentalMargins()` performs a sweep across coastal tiles:

1. Count every coastal land tile to establish target quotas for active vs.
   passive segments.
2. Walk each row, identify contiguous coastal runs, and discard anything shorter
   than the minimum segment length (defaults scale with map size).
3. Alternate between active and passive picks so tags do not cluster too hard on
   one side of a continent. When a run is chosen, each tile in the stretch is
   recorded as a `"x,y"` key in the matching StoryTag set.

The helper only tags coastal land tiles, so inland morphology is unaffected.
Because StoryTags are sparse sets, the data is cheap to store and easy for later
passes to query.

### How margins are used today

- **Coastlines** – `layerAddRuggedCoasts()` reads the active-margin keys to seed
  dramatic fjords and applies gentler smoothing on passive shelves. The result is
  a coastline that reflects tectonic energy without needing another simulation.
- **Islands** – `layerAddIslandChains()` biases volcanic arcs toward active
  margins and coral archipelagos toward passive shelves by checking the same tag
  sets before sampling placement chances.
- **Features** – The feature embellisher rewards passive shelves with extra reef
  rolls and leans on the active set when promoting volcanic vegetation. The
  helper still validates every placement through the engine to keep gameplay
  fair.
- **Overlay registry** – Phase B now publishes the “margin metadata” snapshot via
  `StoryOverlays`. Narrative passes and downstream layers hydrate their local tag
  view straight from this registry, so resets no longer force another
  `storyTagContinentalMargins()` sweep.

### Why this does not rerun physics

Margins are annotations layered on top of the heightfield. They are cheap, sparse
sets that describe where tectonic boundaries touch the coast. Applying or
reapplying them does not modify the elevation buffer; it simply updates the
lookup tables that downstream modules consult. No additional Voronoi solve or
morphology replay is needed.

## Narrative overlays and terrain manipulation

Story overlays operate after the physics-driven heightfield and climate buffers
are locked. When an overlay wants to hint at a canyon, plateau, or ancient rift,
 it does so indirectly:

- **Placement cues** – Overlays mark tiles in StoryTags (`riftLine`,
  `riftShoulder`, `hotspot`, etc.). Later layers (features, biomes, swatches)
  interpret those cues to sprinkle vegetation, adjust rainfall, or place
  corridor metadata.
- **Rainfall tweaks** – Climate swatches and paleo hydrology call helpers in the
  climate engine to nudge rainfall/humidity within strict clamps. They write to
  the staged climate buffer and let the orchestrator synchronize the arrays back
  to the engine at the end of the cluster.
- **No direct height edits** – Elevation changes happen only in morphology
  stages (coast shaping, mountains, volcanoes, lakes). Once the narrative phase
  begins, the heightfield buffer is treated as read-only, so there is no “rerun”
  of terrain physics.

If you need a canyon-scale depression, you sculpt it during morphology (for
example, as part of the plate-driven mountain/rift logic) and expose the result
through tags or metadata. The narrative overlay then references those tags to
place river corridors, arid swatches, or discovery hooks. This keeps the physics
pass deterministic while still giving authors a vocabulary for long-lived
geological stories.

## Putting it together

1. Physics establishes a single authoritative terrain and climate snapshot.
2. Margins and other StoryTags annotate that snapshot with tectonic context.
3. Narrative overlays consult both the physics data (heightfield, climate,
   FoundationContext) and the annotations to place story-driven flourishes.
4. Downstream consumers (biomes, features, placement) read the same annotations
   so narrative intent carries through without mutating the locked terrain.

The result is a pipeline where dramatic formations (canyons, plateaus, shelves)
are still rooted in physics, but the narrative layer can emphasize or reinterpret
those formations through lightweight overlays rather than by rewinding the
simulation.
</file>

<file path="system/mods/swooper-maps/overview.md">
# Map Generator Bootstrap Architecture

## Overview

This mod uses a sophisticated **3-tier configuration system** that allows multiple map variants to share a single codebase while having different behaviors through declarative configuration.

> **Operational note**  
> Headless generation via an `InMemoryAdapter` proved impractical (the pipeline still depends on Civ VII engine globals such as `GameplayMap`, `TerrainBuilder`, `ResourceBuilder`, `FertilityBuilder`, `GameInfo`, etc.), so the stub adapter has been removed. For rapid iteration we instead rely on FireTuner-driven workflows to trigger map generation without restarting the client.

---

## Dependency Chain Visualization

```
┌─────────────────────────────────────────────────┐
│ CIV VII Engine                                  │
│ Loads: epic-diverse-huge.js (entry point)       │
└───────────────────┬─────────────────────────────┘
                    │
        ┌───────────▼──────────┐
        │ Entry File           │
        │ ├─ bootstrap()       │  ← Calls configuration bootstrap
        │ └─ import orchestr.  │  ← Imports generator
        └───────────┬──────────┘
                    │
        ┌───────────▼──────────────────────┐
        │ bootstrap/entry.js               │
        │ └─ setConfig(merged config)      │  ← Composes config from presets
        └───────────┬──────────────────────┘
                    │
        ┌───────────▼──────────────────────┐
        │ bootstrap/runtime.js             │
        │ └─ stores in globalThis          │  ← Global config store
        └───────────┬──────────────────────┘
                    │
        ┌───────────▼──────────────────────┐
        │ bootstrap/resolved.js            │
        │ ├─ getConfig from runtime        │  ← Reads from global
        │ ├─ merges defaults+presets       │  ← Deep merge resolution
        │ └─ exports group getters         │  ← Typed accessors
        └───────────┬──────────────────────┘
                    │
        ┌───────────▼──────────────────────┐
        │ bootstrap/tunables.js            │
        │ ├─ rebind() refreshes            │  ← Re-reads config
        │ └─ exports live bindings         │  ← ES module live refs
        └───────────┬──────────────────────┘
                    │
        ┌───────────▼──────────────────────┐
        │ map_orchestrator.js              │
        │ ├─ rebind() at start             │  ← Rebind on generate
        │ ├─ uses tunables                 │  ← Read config values
        │ └─ orchestrates layers           │  ← Execute generation
        └──────────────────────────────────┘
```

---

## 3-Tier System Explanation

### Tier 1: Entry Point Files (Game-Facing)

**Location**: `maps/epic-diverse-huge*.js`

These are the files CIV VII actually loads. Each represents a different map variant:

- `epic-diverse-huge.js` - Base variant (classic preset)
- `epic-diverse-huge-temperate.js` - Temperate climate variant
- `epic-diverse-huge-kahula.js` - Dramatic tectonics variant

**Structure**:
```javascript
import { bootstrap } from "./bootstrap/entry.js";
bootstrap({
    presets: ["classic"],           // or ["temperate"], etc.
    overrides: { /* optional */ }   // variant-specific tweaks
});
import "./map_orchestrator.js";    // Shared generator
```

**Key insight**: Each entry file is tiny (~10-200 lines) and purely declarative. All generation logic lives in the shared orchestrator.

---

### Tier 2: Configuration Pipeline

#### `bootstrap/entry.js`
**Purpose**: Bootstraps per-entry configuration

- Deep merges presets with overrides
- Calls `setConfig()` to store result globally

#### `bootstrap/runtime.js`
**Purpose**: Global configuration storage

- Uses `globalThis[__EPIC_MAP_CONFIG__]` for cross-module access
- No import-time coupling (avoids circular dependencies)
- Freezes config to prevent mutation

#### `bootstrap/resolved.js`
**Purpose**: Configuration resolution and merging

- Reads from runtime store
- Merges: `BASE_CONFIG` + presets (ordered) + runtime overrides
- Exports typed getters: `getToggles()`, `getLandmass()`, etc.

#### `bootstrap/tunables.js`
**Purpose**: Live module bindings

- Exports ES module `let` variables (not constants!)
- `rebind()` updates all bindings from resolved config
- Called at start of `generateMap()` to refresh values

**Example**:
```javascript
export let LANDMASS_CFG = {};  // Updated by rebind()

export function rebind() {
    LANDMASS_CFG = getLandmass();
    // ... etc
}
```

---

### Tier 3: Execution

#### `map_orchestrator.js`
**Purpose**: Main map generation orchestrator

1. Calls `rebind()` at start of `generateMap()`
2. Reads config via imported tunables
3. Orchestrates generation phases
4. Calls layers in correct order

**Flow**:
```javascript
import { rebind, LANDMASS_CFG } from "./bootstrap/tunables.js";

function generateMap() {
    rebind();  // Refresh config for this run

    WorldModel.init(); // Always required

    createLandmasses(LANDMASS_CFG);
    // ... etc
}
```

---

## Why This Design is Brilliant

### ✅ Multiple Map Variants from One Codebase

**Without this system**, you'd need:
- 3 copies of `map_orchestrator.js` (code duplication!)
- Manual syncing of bug fixes across variants
- Hard-coded configuration

**With this system**:
- 1 orchestrator (~320 lines)
- 3 tiny entry files (~10-200 lines each)
- Declarative presets (easy to maintain)
- **Total code savings**: ~600 lines avoided!

### ✅ Clean Preset Composition

Presets can build on each other:
```javascript
bootstrap({
    presets: ["classic", "arid"],  // Arid extends classic
    overrides: { /* fine-tune */ }
});
```

Merge order (lowest to highest precedence):
1. `BASE_CONFIG` (defaults)
2. `CLASSIC_PRESET`
3. `ARID_PRESET`
4. Runtime overrides

### ✅ No Import Cycles

Traditional approach (broken):
```javascript
// orchestrator.js
import config from "./config.js";  // Needs entry's config

// entry.js
import orchestrator from "./orchestrator.js";  // Circular!
```

Our approach (works):
- Entry sets config in `globalThis` (no import)
- Orchestrator reads from `tunables.js` (no direct entry import)
- Clean unidirectional flow

### ✅ Testability

Can swap presets/overrides without changing code:
```javascript
// Test with different configs
bootstrap({ presets: ["test-minimal"] });
bootstrap({ overrides: { landmass: { baseWaterPercent: 80 } } });
```

---

## File Organization

```
mod/maps/
├── epic-diverse-huge.js                 ← Entry: base variant
├── epic-diverse-huge-temperate.js       ← Entry: temperate variant
├── epic-diverse-huge-kahula.js          ← Entry: kahula variant
├── map_orchestrator.js                  ← Shared generator (DO NOT RENAME!)
├── bootstrap/                           ← Configuration system
│   ├── entry.js                        ← Bootstrap helper
│   ├── runtime.js                      ← Global config store
│   ├── resolved.js                     ← Config resolution
│   ├── tunables.js                     ← Live bindings
│   ├── dev.js                          ← Development logging
│   ├── defaults/                       ← Base config
│   └── presets/                        ← Named presets
│       ├── classic.js
│       └── temperate.js
├── layers/                              ← Generation layers
├── world/                               ← WorldModel (physics)
├── core/                                ← Architecture (MapContext, adapters)
├── story/                               ← Story tagging
└── base-standard/                       ← Local base game copies
```

---

## Common Pitfalls & Troubleshooting

### ⚠️ DO NOT Rename `map_orchestrator.js`

**Why**: All entry files import it:
```javascript
import "./map_orchestrator.js";  // Hardcoded path
```

**If you rename it**: All 3 entry files break, maps won't load.

**Solution**: Keep the name, or update all 3 entry files.

---

### ⚠️ Import Paths Must Be Relative

**Correct**:
```javascript
import { bootstrap } from "./bootstrap/entry.js";          // Entry file
import { LANDMASS_CFG } from "../bootstrap/tunables.js";  // Layer file
```

**Wrong**:
```javascript
import { bootstrap } from "/mod/maps/bootstrap/entry.js";  // Absolute (breaks)
```

---

### ⚠️ Call `rebind()` Before Using Tunables

**Correct**:
```javascript
function generateMap() {
    rebind();      // Refresh config first!
    WorldModel.init(); // Physics stack relies on this
}
```

**Wrong**:
```javascript
function generateMap() {
    // rebind() not called - using stale config!
    WorldModel.init();
}
```

---

### ⚠️ Config is Frozen (Intentional)

**Attempting to mutate** will fail silently or throw:
```javascript
const cfg = getConfig();
cfg.landmass.baseWaterPercent = 80;  // ❌ Frozen!
```

**Solution**: Set overrides in entry file instead:
```javascript
bootstrap({
    overrides: {
        landmass: { baseWaterPercent: 80 }
    }
});
```

---

## Adding a New Map Variant

1. **Create entry file**: `maps/epic-diverse-huge-desert.js`
   ```javascript
   import { bootstrap } from "./bootstrap/entry.js";
   bootstrap({
       presets: ["classic"],
       overrides: {
           climate: {
               baseline: { /* arid settings */ }
           }
       }
   });
   import "./map_orchestrator.js";
   ```

2. **Register in XML**: `config/config.xml`
   ```xml
   <Row
       File="{swooper-maps}mod/maps/epic-diverse-huge-desert.js"
       Name="LOC_MAP_EPIC_DIVERSE_HUGE_DESERT_NAME"
       Description="LOC_MAP_EPIC_DIVERSE_HUGE_DESERT_DESCRIPTION"
       SortIndex="503"
   />
   ```

3. **Add localization**: `text/en_us/MapText.xml`
   ```xml
   <Row>
       <Tag>LOC_MAP_EPIC_DIVERSE_HUGE_DESERT_NAME</Tag>
       <Text>Epic Diverse Huge (Desert)</Text>
   </Row>
   ```

That's it! No orchestrator changes needed.

---

## Performance Characteristics

- **Config resolution**: O(1) - happens once per `generateMap()` call
- **Preset merging**: O(N) where N = preset count (typically 1-2)
- **Live binding updates**: O(1) - simple variable assignments
- **Runtime overhead**: Negligible (<1ms per generation)

---

## Future Enhancements

Possible improvements without breaking existing code:

1. **Hot reload**: Listen for config changes during development
2. **Preset validation**: Type-check presets at load time
3. **Config inspector**: Debug tool to visualize merged config
4. **Async presets**: Load presets from external files (advanced)

---

## Summary

This architecture separates **what** (configuration) from **how** (generation logic), enabling:

- ✅ Multiple map variants without code duplication
- ✅ Clean dependency flow (no circular imports)
- ✅ Easy testing and iteration
- ✅ Maintainable preset system
- ✅ Zero performance overhead

The complexity is worth it - we get professional-grade configuration management with a tiny footprint.
</file>

<file path="system/sdk/overview.md">
# Technical Guide: civ7-modding-tools (`src/`)

## 1. Introduction

### Purpose
This guide provides a technical deep-dive into the architecture and core components of the `civ7-modding-tools` library. It is based on an analysis of the codebase within the `src/` directory and aims to explain how the library facilitates the creation of Civilization VII mods using TypeScript.

### Target Audience
This document is intended for developers who want to:
*   Understand the internal workings of the `civ7-modding-tools` library.
*   Contribute to the library's development.
*   Leverage the library's patterns for more advanced modding tasks.
****
### Scope
This guide covers the following key areas:
*   **Architecture Overview:** The layered structure and directory organization.
*   **Key Components:** Detailed breakdown of core classes and modules (`Mod`, Builders, Nodes, Files, Constants, etc.).
*   **Common TypeScript Patterns:** Recurring design patterns used throughout the codebase.
*   **Data Flow:** The process from user configuration to generated mod files.
*   **Mod Definition Process:** The typical workflow for users defining mod elements.

## 2. Architecture Overview

### Layered Approach
The `civ7-modding-tools` library employs a layered architecture designed to abstract the complexities of Civilization VII modding:

1.  **Configuration Layer (Builders - `src/builders/`):** This is the primary interface for users. Specific `Builder` classes (e.g., `CivilizationBuilder`, `UnitBuilder`) provide a fluent, type-safe API to define game elements programmatically.
2.  **Data Representation Layer (Nodes - `src/nodes/`):** Builders internally create and manage instances of `Node` classes (e.g., `CivilizationNode`, `TraitNode`). These nodes directly map to the structured data required by the game, often corresponding to rows in XML database tables. `DatabaseNode` acts as a container for these nodes.
3.  **File Generation Layer (Files - `src/files/`):** `Node` structures are serialized into intermediate formats (like `jstoxml` objects). `File` classes (e.g., `XmlFile`, `ImportFile`) handle the conversion to final file content (e.g., XML strings, copied assets) and manage writing to the correct output directory structure.
4.  **Orchestration Layer (Mod - `src/core/`):** The central `Mod` class coordinates the entire process. It collects configured Builders and other Files, triggers the build process, gathers generated `File` objects and their metadata, and constructs the final `.modinfo` file required by the game.

### Directory Roles
The `src/` directory is organized as follows:
*   `core/`: Contains the central `Mod` orchestrator and related core logic.
*   `builders/`: Houses the `Builder` classes providing the user-facing API.
*   `nodes/`: Defines the `Node` classes representing game data structures.
*   `files/`: Contains classes for handling file generation and management (`XmlFile`, `ImportFile`).
*   `constants/`: Stores type-safe constants representing game identifiers (Traits, Kinds, etc.).
*   `localizations/`: Components specifically for generating localization XML files.
*   `utils/`: Shared utility functions used across the library.
*   `types/`: Shared TypeScript type definitions and utility types.

### High-Level Flow Diagram

```mermaid
graph TD
    A[User Configures Builders] --> B(Builders Create/Manage Nodes);
    B --> C{Nodes Represent Game Data};
    C --> D(Mod Orchestrates Build);
    D --> E{Builders Generate File Objects};
    E --> F(File Objects Serialize Nodes to XML/Content);
    F --> G(File Objects Written to Disk);
    D --> H(.modinfo File Generated);
    G --> H;
```

## 3. Key Components (Detailed Breakdown)

### `src/core/`
*   **`Mod.ts`:** The heart of the library.
    *   Manages mod metadata (ID, name, version, etc.).
    *   Collects instances of `Builder` and `BaseFile`.
    *   Orchestrates the build process by calling `build()` on builders and `write()` on files.
    *   Generates the crucial `.modinfo` file, registering all mod components with the game.
*   **`ActionGroupBundle.ts`:** Manages the standard set of Action Groups (`current`, `shell`, `always`) and associated Actions (`UPDATE_DATABASE`, `LOCALIZATION_DATA`) used by Civ VII to determine when and how mod files are loaded.

### `src/builders/`
*   **`BaseBuilder.ts`:** The abstract foundation for all specific builders.
    *   Provides common configuration logic (e.g., via a `fill` utility).
    *   Defines the `build()` method interface, responsible for generating `File` objects.
    *   Holds an `ActionGroupBundle` to define when the builder's output should be loaded.
*   **Specific Builders (e.g., `CivilizationBuilder.ts`, `UnitBuilder.ts`, `ConstructibleBuilder.ts`):**
    *   Provide a typed, fluent interface for defining specific game elements (Civilizations, Units, Buildings, etc.).
    *   Internally manage `Node` structures, often within `DatabaseNode` containers.
    *   Implement `migrate()` logic (often implicitly called) to translate high-level configuration into detailed `Node` objects.
    *   Offer `bind()` methods for creating relationships between different mod elements (e.g., linking a unique unit to a civilization).
    *   Implement the `build()` method to generate one or more `File` objects (typically `XmlFile`) containing the serialized node data and appropriate metadata.

### `src/nodes/`
*   **`BaseNode.ts`:** Represents a single data entry, usually mapping to an XML element like `<Row>` or `<InsertOrIgnore>`.
    *   Handles automatic conversion of its properties into XML attributes during serialization.
    *   Provides the `toXmlElement()` method for conversion to the `jstoxml` format.
*   **`DatabaseNode.ts`:** Represents the root `<Database>` element common in Civ VII mod XML files.
    *   Contains arrays of specific `BaseNode` subclasses, grouped by the target game table name (e.g., `Units`, `Traits`, `Civilizations`).
    *   Handles the serialization of the entire table structure into the `jstoxml` format by calling `toXmlElement()` on its contained nodes.
*   **Specific Nodes (e.g., `CivilizationNode.ts`, `UnitNode.ts`, `TraitNode.ts`, `ConstructibleYieldChangeNode.ts`):**
    *   Define the specific properties (which become XML attributes) for each type of game data row or element.
    *   Inherit from `BaseNode`.

### `src/constants/`
*   **Role:** Provides type-safe access to the vast collection of game-specific string identifiers used within Civilization VII's database (e.g., for Traits, Kinds, Actions, Yields, Terrains, Units, Buildings, etc.). This is crucial for:
    *   **Type Safety:** Prevents typos that would lead to runtime errors or incorrect mod behavior.
    *   **Discoverability:** Enables IDE autocompletion, making it easier to find valid game identifiers.
    *   **Maintainability:** Centralizes game strings, simplifying updates if game definitions change.
    *   **Readability:** Using named constants (e.g., `YIELD.FOOD`) is much clearer than raw strings (`'YIELD_FOOD'`).
*   **Implementation:**
    *   Constants are defined in dedicated files (e.g., `TRAIT.ts`, `YIELD.ts`, `UNIT_CLASS.ts`) as plain JavaScript objects.
    *   The `as const` assertion is used to ensure TypeScript treats the values as specific literal types, not just generic `string` types.
    *   A barrel file (`src/constants/index.ts`) re-exports all constants, allowing convenient imports like `import { TRAIT, YIELD } from '../constants';`.
*   **Examples:**
    *   *Definition Snippet (`src/constants/YIELD.ts`):*
        ```typescript
        // src/constants/YIELD.ts
        export const YIELD = {
          FOOD: 'YIELD_FOOD',
          PRODUCTION: 'YIELD_PRODUCTION',
          GOLD: 'YIELD_GOLD',
          SCIENCE: 'YIELD_SCIENCE',
          CULTURE: 'YIELD_CULTURE',
          FAITH: 'YIELD_FAITH',
          // ... many more yields
        } as const;
        ```
    *   *Importing:*
        ```typescript
        // In a builder or other module
        import { TRAIT, YIELD, UNIT_CLASS, KIND } from '../constants';
        ```
    *   *Usage in Builders/Nodes (Conceptual):*
        ```typescript
        // In a Builder configuration
        const unitBuilder = new UnitBuilder({
          kind: KIND.UNIT,
          unitType: 'UNIT_GONDOR_SWORDSMAN',
          unitClass: UNIT_CLASS.MELEE,
          // ... other config
        });

        // Creating a Node directly
        const yieldNode = new ConstructibleYieldChangeNode({
          yieldType: YIELD.PRODUCTION, // Type-safe!
          amount: 1,
        });

        // Adding a Trait using its constant identifier
        civilizationBuilder.addTrait(TRAIT.ANTIQUITY_CIV);
        ```
*   **Scope:** The `src/constants/` directory covers a wide range of game concepts, reflecting Civ VII's complexity. File names like `ABILITY.ts`, `RESOURCE.ts`, `TERRAIN.ts`, `BUILDING_CULTURES.ts`, `EFFECT.ts`, etc., indicate the breadth of available identifiers.

### `src/files/`
*   **`BaseFile.ts`:** An abstract representation of a file to be generated as part of the mod.
    *   Holds common properties: `path`, `name`, `content`.
    *   Crucially stores metadata for the `.modinfo` file: `actionGroups` and `actionGroupActions`, determining how the game loads the file.
*   **`XmlFile.ts`:** A specialization for generating XML files.
    *   Takes `jstoxml`-compatible content (usually generated by `DatabaseNode.toXmlElement()`).
    *   Uses the `jstoxml` library to convert this object structure into a formatted XML string.
    *   Handles writing the final XML content to disk at the specified path.
*   **`ImportFile.ts`:** Handles copying existing asset files (like images `.png`, `.dds` or `.sql` scripts) from a source location into the generated mod's directory structure, ensuring they are also registered in the `.modinfo`.

### `src/localizations/`
*   **Purpose:** Contains classes and nodes specifically designed for generating the localization XML files (`<LocalizedText>`) required for displaying custom text in-game.
*   **Key elements:** Includes localization-specific classes (e.g., `CivilizationLocalization.ts`), the `EnglishTextNode` for defining text entries, and helper functions like `locale()` to create standard localization tags easily.

### `src/types/` & `src/utils/`
*   **Role:** Provide shared resources to maintain consistency and reduce boilerplate across the library.
*   `src/types/`: Contains reusable TypeScript type definitions, interfaces, and utility types (e.g., `TClassProperties`, `TPartialRequired`).
*   `src/utils/`: Contains helper functions used in various parts of the codebase (e.g., `fill` for object property assignment, `locale` for localization tag generation, `trim` for string manipulation).

## 4. Common TypeScript Patterns

The codebase leverages several common TypeScript patterns to enhance robustness and developer experience:

*   **Strong Typing:** Extensive use of TypeScript's type system, including:
    *   Generics (e.g., `BaseBuilder<T>`, `BaseNode<T>`) for flexible yet type-safe base classes.
    *   Specific interfaces and types for builder configurations and node properties.
    *   Utility types (`src/types/`) for common type transformations.
*   **`as const`:** Applied to constant objects (`src/constants/`) to ensure TypeScript infers literal types (e.g., `'YIELD_FOOD'` instead of just `string`), enabling stricter type checking and better autocompletion.
*   **Class-Based OOP:** The architecture heavily relies on classes and inheritance (e.g., `BaseBuilder`, `BaseNode`, `BaseFile` serve as foundations for specific implementations).
*   **Builder Pattern:** The primary design pattern for user interaction. Builders provide a dedicated object for constructing complex game elements step-by-step.
*   **Barrel Files (`index.ts`):** Used extensively (e.g., in `src/`, `src/builders/`, `src/nodes/`, `src/constants/`) to group exports from modules within a directory, simplifying imports for consumers.
*   **Utility Functions/Types:** Shared logic and type definitions are extracted into `src/utils/` and `src/types/` to promote code reuse and maintainability.
*   **Fluent Interface:** Builder methods that configure properties often return `this`, allowing for method chaining (e.g., `builder.setName('...').setCost(100).addTrait(...)`).

## 5. Data Flow (Step-by-Step)

The process of turning user configuration into a functional mod involves the following data flow:

1.  **Configuration:** The user interacts with Builder instances, setting properties or calling configuration methods (e.g., `civilizationBuilder.civilizationType = 'CIV_GONDOR';`).
2.  **Migration:** Internally, the builder's `migrate()` logic (called explicitly or implicitly during configuration or build) translates the high-level settings into specific `Node` objects (e.g., creating `CivilizationNode`, `TraitNode` instances). These nodes are typically stored within the builder's internal `DatabaseNode` containers (e.g., `this._databaseNodes.Civilizations.push(civilizationNode)`).
3.  **Binding (Optional):** If `bind()` methods are used, builders modify nodes in other bound builders and add necessary cross-referencing nodes (e.g., `UnitReplaceNode`) to their own `DatabaseNode` containers.
4.  **XML Structure Generation:** When `Mod.build()` is called, it iterates through its added builders and calls each builder's `build()` method.
5.  **Serialization:** Inside `Builder.build()`, the builder calls `toXmlElement()` on its `DatabaseNode` containers. `DatabaseNode` then calls `toXmlElement()` on each contained `Node`, recursively generating a nested JavaScript object structure (`XmlElement`) compatible with `jstoxml`, representing the desired XML.
6.  **File Object Creation:** The builder's `build()` method wraps the generated `XmlElement` structure(s) into `XmlFile` objects (or creates `ImportFile` objects for assets). It assigns the correct output path, filename, and the crucial `ActionGroup`/`Action` metadata for `.modinfo` registration.
7.  **File Writing:** `Mod.build()` collects all generated `File` objects and calls the `write()` method on each. `XmlFile.write()` uses the `jstoxml` library to convert the `XmlElement` structure into a formatted XML string and writes it to the filesystem. `ImportFile.write()` copies the source asset file.
8.  **`.modinfo` Generation:** Finally, `Mod.build()` gathers all the `File` objects, extracts their paths and metadata (`actionGroups`, `actionGroupActions`), collects unique `Criteria` (if any), and constructs the final `.modinfo` XML file. This file acts as the manifest, telling Civilization VII which files constitute the mod and how to load them.

### Detailed Sequence Diagram

```mermaid
sequenceDiagram
    participant User
    participant Builder
    participant Node
    participant DatabaseNode
    participant XmlFile
    participant Mod
    participant FileSystem

    User->>Builder: Configure properties (e.g., setName(), setCost())
    User->>Mod: add(Builder)
    User->>Mod: build(outputPath)
    Mod->>Builder: build()
    Builder->>Builder: migrate() config to Nodes (internal)
    Builder->>Node: new Node(...)
    Builder->>DatabaseNode: add Node instance to correct table array
    Builder->>DatabaseNode: toXmlElement()
    DatabaseNode->>Node: toXmlElement() for each node
    Node-->>DatabaseNode: Return jstoxml object fragment
    DatabaseNode-->>Builder: Return full jstoxml structure for the DatabaseNode
    Builder->>XmlFile: new XmlFile(jstoxml, path, name, metadata)
    Builder-->>Mod: Return XmlFile instance(s)
    Mod->>XmlFile: write()
    XmlFile->>FileSystem: Write formatted XML file
    Mod->>Mod: Collect all File paths & metadata
    Mod->>FileSystem: Write .modinfo XML file
```

## 6. Mod Definition Process (User Workflow)

Based on the architecture and components, the typical workflow for a user creating a mod element (e.g., a custom Civilization) looks like this:

1.  **Initialize Mod:** Create an instance of the main `Mod` class, providing essential metadata.
    ```typescript
    import { Mod } from 'civ7-modding-tools'; // Assuming package usage

    const myMod = new Mod({
      id: 'MyGondorMod_v1',
      name: 'Gondor Civilization (My Version)',
      version: '1.0',
      description: 'Adds the Kingdom of Gondor as a playable civilization.',
    });
    ```
2.  **Create Builder(s):** Instantiate the required builder(s) for the elements you want to add or modify. Provide initial configuration via the constructor.
    ```typescript
    import { CivilizationBuilder, UnitBuilder } from 'civ7-modding-tools';
    import { TRAIT, UNIT_CLASS, KIND } from 'civ7-modding-tools/constants'; // Example import path

    const gondorBuilder = new CivilizationBuilder({
      civilizationType: 'CIVILIZATION_MY_GONDOR',
      civilizationName: 'LOC_CIVILIZATION_MY_GONDOR_NAME', // Localization key
      civilizationIcon: 'ICON_CIVILIZATION_MY_GONDOR',
      leaderType: 'LEADER_MY_ARAGORN', // Assuming a leader is also defined
      // ... other core civilization properties
    });

    const gondorSwordsmanBuilder = new UnitBuilder({
      kind: KIND.UNIT,
      unitType: 'UNIT_MY_GONDOR_SWORDSMAN',
      unitClass: UNIT_CLASS.MELEE,
      name: 'LOC_UNIT_MY_GONDOR_SWORDSMAN_NAME',
      cost: 90,
      // ... other unit properties
    });
    ```
3.  **Configure Builder(s):** Use the fluent API of the builders to set specific properties, add traits, define yields, etc.
    ```typescript
    gondorBuilder
      .setCivilizationDescription('LOC_CIVILIZATION_MY_GONDOR_DESCRIPTION')
      .addTrait(TRAIT.ANCIENT_CIV) // Example trait
      .setStartBiasRiver(5); // Add a preference for starting near rivers

    gondorSwordsmanBuilder
      .setDescription('LOC_UNIT_MY_GONDOR_SWORDSMAN_DESCRIPTION')
      .setCombat(40)
      .setMovement(2);
    ```
4.  **Bind Unique Elements (if applicable):** If creating unique units, buildings, etc., that replace or are specific to another element (like a Civilization), use the `bind()` method.
    ```typescript
    // Assuming gondorSwordsman replaces the standard Swordsman for Gondor
    // The specific bind method might vary (e.g., .addUnit(), .bindUnit(), etc.)
    // This is a conceptual example; check builder specifics.
    // gondorBuilder.bind([gondorSwordsmanBuilder]); // Or similar method
    ```
    *Note: The exact binding mechanism depends on the specific builders involved.*

5.  **Add to Mod:** Add all configured top-level builders and standalone files to the main `Mod` instance.
    ```typescript
    myMod.add(gondorBuilder);
    myMod.add(gondorSwordsmanBuilder);
    // Add builders for Leaders, Unique Buildings/Districts, etc.
    ```
6.  **Add Assets (Optional):** Add external files like icons (`.png`, `.dds`) or custom SQL scripts using `ImportFile`.
    ```typescript
    import { ImportFile } from 'civ7-modding-tools';

    myMod.addFiles(
      new ImportFile({
        path: 'Icons', // Target directory within the mod
        name: 'ICON_CIVILIZATION_MY_GONDOR.dds', // Target filename
        source: './assets/gondor_civ_icon.dds', // Source file path
      }),
      new ImportFile({
        path: 'Art',
        name: 'AragornLeaderhead.ast',
        source: './assets/aragorn.ast',
      })
    );
    ```
7.  **Build Mod:** Call the `build()` method on the `Mod` instance, specifying the output directory. This triggers the entire file generation process.
    ```typescript
    // Build the mod into the 'generated-mods/gondor' directory
    myMod.build('./generated-mods/gondor')
      .then(() => console.log('Gondor mod built successfully!'))
      .catch(error => console.error('Mod build failed:', error));
    ```

This workflow demonstrates how the builders abstract the underlying XML complexity and `.modinfo` registration, allowing users to focus on defining their mod's content using a structured, type-safe TypeScript approach.

## 7. Conclusion

The `civ7-modding-tools` library provides a robust and developer-friendly way to create Civilization VII mods using TypeScript. Its layered architecture, centered around the Builder pattern and strong typing, abstracts away much of the boilerplate associated with direct XML editing and `.modinfo` management.

By understanding the roles of the core components (Mod, Builders, Nodes, Files, Constants) and the data flow, developers can effectively leverage the library to build complex and well-structured mods.

For further exploration, consider examining the specific options available on different Builders within the `src/builders/` directory and reviewing the examples provided in the `examples/` directory of the project.
</file>

<file path="system/ADR.md">
# Architecture Decision Records

> Significant architectural decisions made in this project.

---

## Format

Each decision follows this structure:

```
## ADR-XXX: Title

**Status:** Proposed | Accepted | Deprecated | Superseded
**Date:** YYYY-MM-DD
**Context:** What prompted this decision?
**Decision:** What was decided?
**Consequences:** What are the implications?
```

---

## Decisions

*No ADRs recorded yet. Add decisions as they are made.*

<!-- Example:
## ADR-001: Use pnpm Workspaces for Monorepo

**Status:** Accepted
**Date:** 2025-01-01
**Context:** Need to manage multiple packages with shared dependencies.
**Decision:** Use pnpm workspaces with Turbo for build orchestration.
**Consequences:**
- Fast installs via hard links
- Strict dependency resolution
- Requires pnpm knowledge from contributors
-->
</file>

<file path="system/ARCHITECTURE.md">
# Architecture

> System-wide architecture overview.

---

## Overview

Civ7 Modding Tools is a TypeScript monorepo providing:
- **SDK** for programmatic mod generation
- **CLI** for resource management
- **Plugin libraries** for reusable logic
- **Documentation** and playground apps

## Monorepo Structure

```
packages/           # Core libraries
├── sdk/            # TypeScript SDK (@civ7/sdk)
├── cli/            # Command-line tools (@civ7/cli)
├── config/         # Shared configuration (@civ7/config)
└── plugins/        # Reusable plugins
    ├── plugin-files/   # Zip/unzip utilities
    ├── plugin-graph/   # XML graph crawling
    ├── plugin-git/     # Git operations
    └── plugin-mods/    # Mod management

apps/               # Applications
├── docs/           # Documentation site (Mintlify)
└── playground/     # Examples and experiments

mods/               # Colocated mods
├── mod-swooper-maps/      # Map generation mod
└── mod-swooper-civ-dacia/ # Dacia civilization mod
```

## Build System

- **Package manager:** pnpm (workspaces)
- **Build orchestration:** Turbo
- **TypeScript bundler:** tsup
- **Runtime:** Bun (build scripts)

## Data Flow

1. **Game resources** extracted via CLI (`civ7 unzip`) → `.civ7/outputs/`
2. **SDK** consumes game constants and generates mod XML
3. **Mods** build to `./mod/` directories for game installation

## Component Documentation

- [SDK Technical Guide](sdk/technical-guide.md)
- [CLI Features](cli/features.md)
- [Swooper Maps Architecture](mods/swooper-maps/architecture.md)
- [Legacy Mapgen Reference](../system/mods/swooper-maps/reference/) — archived Epic Diverse Huge notes

<!-- NOTE FOR AGENTS:
If this overview exceeds ~300 lines or you find yourself adding a major subsystem,
consider:
1. Splitting that subsystem into its own doc
2. Creating a dedicated architecture doc for complex components
3. Adding an ADR entry in `docs/system/ADR.md` if trade-offs were evaluated

Keep this overview focused on orientation ("how to work here") rather than deep dives.
-->
</file>

<file path="system/DEFERRALS.md">
# Deferrals

> Intentionally deferred work and technical debt.

---

## Format

Each deferral follows this structure:

```
## DEF-XXX: Title

**Deferred:** YYYY-MM-DD
**Trigger:** When should this be revisited?
**Context:** Why was this deferred?
**Scope:** What work is involved?
**Impact:** What are we living with?
```

---

## Active Deferrals

*No deferrals recorded yet. Add items as they are deferred.*

<!-- Example:
## DEF-001: Comprehensive Test Coverage for SDK

**Deferred:** 2025-01-01
**Trigger:** When SDK API stabilizes or before v2.0 release
**Context:** Focus on feature development over test coverage
**Scope:** Add integration tests for all builder types
**Impact:** Relying on TypeScript types and manual testing
-->

---

## Resolved Deferrals

*Move resolved deferrals here with resolution notes.*
</file>

<file path="system/TESTING.md">
# Testing

This repository uses [Vitest](https://vitest.dev/) for unit tests across all workspaces.

## Running all tests

```bash
pnpm test
```

Executes `vitest` across all configured projects defined in `vitest.config.ts`.

## Visualizing test runs

```bash
pnpm test:ui
```

Opens the interactive Vitest UI for all workspaces.

## Running a single workspace

```bash
pnpm vitest --project <name>
```

Use the project name from `vitest.config.ts` (`cli`, `sdk`, `docs`, or `playground`) to target an individual suite.

Each app and package includes a minimal smoke test and a local `TESTING.md` describing recommended scenarios to cover.
</file>

<file path="templates/issue.md">
# Issue Template

Use this template for every Linear-backed issue doc. **Draft locally with the placeholder ID `LOCAL-TBD`, then create the Linear issue and rename/update the file once the real ID exists.** The YAML front matter stays metadata-only and must include `id`, `parent`, `children`, `blocked_by`, `blocked`, and `related_to`. Everything after the first `---` is the canonical issue body that syncs to Linear, and the very first element must always be the TL;DR. Never restate the title/issue key as a top-level heading—the Linear UI already surfaces those fields.

### Body / Implementation Rules
- Drop `<!-- SECTION SCOPE [SYNC] -->` immediately before the TL;DR heading so parsers can anchor the Linear-facing body.
- Use the exact H2 order shown below: TL;DR → Deliverables → Acceptance Criteria → Testing / Verification → Dependencies / Notes.
- Keep the Quick Navigation list inside the Implementation Details block only; it should link back to the H2 anchors above.
- Insert a Markdown separator (`---`) followed by `<!-- SECTION IMPLEMENTATION [NOSYNC] -->` and `## Implementation Details (Local Only)` for deep specifics that never sync to Linear.
- Any additional subsections (logs, tables, TOCs) belong under Implementation Details.

```
id: <TEAM-123>
title: <Issue Title>
state: planned | in_progress | done
priority: 0 | 1 | 2 | 3 | 4
estimate: 0 | 1 | 2 | 3 | 4 | 8 | 16
project: <project-slug>
milestone: <milestone-id>
assignees: [codex]
labels: [optional]
parent: <PARENT-ID or null>
children: [<CHILD-IDS>]
blocked_by: [<ID>]
blocked: [<ID>]
related_to: [<ID>]
---

<!-- SECTION SCOPE [SYNC] -->
## TL;DR
- One-sentence summary that matches the opening line in Linear.

## Deliverables
- Tangible outputs scoped to this issue.

## Acceptance Criteria
- Verifiable checks that prove the work is complete.

## Testing / Verification
- Commands, scripts, or manual steps required for validation.

## Dependencies / Notes
- Human-readable list of blocking/blocked/related issues with Markdown links (mirrors the front-matter metadata for reviewers) plus any context that must live in Linear.

---

<!-- SECTION IMPLEMENTATION [NOSYNC] -->
## Implementation Details (Local Only)
- Scratch space for exploration notes or prompts. Do not sync this section to Linear.
- Include a Quick Navigation table so humans can jump back to the public sections.

### Quick Navigation
- [TL;DR](#tldr)
- [Deliverables](#deliverables)
- [Acceptance Criteria](#acceptance-criteria)
- [Testing / Verification](#testing--verification)
- [Dependencies / Notes](#dependencies--notes)
```
</file>

<file path="templates/milestone.md">
# Milestone Template

```
## <Milestone ID>: <Title>
**Goal:** <one-line outcome>
**Status:** Planned | Active | Complete
**Target Date:** <date>
**Owner:** <name/team>

### Acceptance Criteria
- ...

### Issues / Deliverables
- [ ] <Issue or task>

### Sequencing & Parallelization Plan
**Stacks Overview**
- Stack A: <parent issues or layers> (sequential)
- Stack B: <parent issues> (parallel with Stack A once prerequisites land)

**Notes**
- Reference `docs/GRAPHITE.md#stacks--milestones` for how to translate these stacks into Graphite branches, even when Linear context is missing.
- Update the matching Linear milestone description with the same plan so issue tracking and Git stacks stay in sync.

### Risks
- <Dependencies, blockers, verification gaps>

### Notes
- Risks, dependencies, links
```
</file>

<file path="templates/project.md">
# Project Template

```
# Project: <Name>
**Status:** Planned | Active | Complete
**Timeline:** <start → target end>
**Teams:** <team(s)>

## Scope & Objectives
- ...

## Deliverables
- [ ] Deliverable 1 — acceptance criteria
- [ ] Deliverable 2 — acceptance criteria

## Milestones
- M1: <name> — goal & target date
- M2: ...

## Links & References
- Issues: docs/projects/<project>/issues/
- Linear: <link>
- Templates: docs/templates/
```
</file>

<file path="templates/service.md">
# Service Template

```
# Service: <Name>

**Type:** Library | API | CLI | Plugin
**Package:** @civ7/<package-name>
**Status:** Stable | Beta | Experimental

## Purpose
What does this service do? (1-2 sentences)

## Quick Start
```bash
# Installation
pnpm add @civ7/<package-name>
```

```typescript
// Basic usage
import { ... } from '@civ7/<package-name>';
```

## API Overview
- `function1()` — description
- `function2()` — description

## Configuration
- `option1`: description (default: value)
- `option2`: description (default: value)

## Dependencies
- @civ7/other-package — why needed

## Links
- [Technical Guide](../system/<area>/technical-guide.md)
- [API Reference](../system/<area>/api.md)
```
</file>

<file path="DOCS.md">
# Documentation Architecture

> **Canonical specification** for how `docs/` is structured in this repo. This document defines where docs live, how they're named, and how to extend the structure. The pattern is reusable in other codebases.

---

## Quick Start

- **Product context?** → Start with `PRODUCT.md`
- **System architecture?** → Start with `SYSTEM.md`
- **How to work here?** → Start with `PROCESS.md`
- **Current direction?** → Start with `ROADMAP.md`
- **Adding a new doc?** → See [Section 4: Naming & Placement](#4-naming--placement-heuristics)

---

## 1. Goals

- Provide a stable, reusable pattern for `docs/` layout.
- Keep **evergreen canonical docs** distinct from **temporal project docs**.
- Make it easy to discover product, system, workflow, and project docs at a glance.
- Encode importance and scope via **ALL‑CAPS vs lowercase** naming.

This guide defines the target structure for `docs/` in this repo and can be reused as a template in other codebases.

---

## 2. Core Layout

Top-level structure of `docs/`:

```text
docs/
  PRODUCT.md      # Product entry: what this is and why it exists
  SYSTEM.md       # System entry: high-level system overview & map
  PROCESS.md      # Process entry: how we work here
  ROADMAP.md      # Directional entry: milestones and future path
  DOCS.md         # Docs architecture and navigation (this document)

  product/        # Product artifacts and decisions
  system/         # Architecture, testing, security, components
  process/        # Collaboration, process, and workflows
  projects/       # Time-bound work, tied to initiatives
  templates/      # Scaffolds for new docs
  _archive/       # Retired/old docs
```

### Root Gateway Docs

Each root file is a **gateway** into one major concern:

- `PRODUCT.md` — product narrative (what, who, why); links to `product/`.
- `SYSTEM.md` — high-level system overview; links to `system/ARCHITECTURE.md`, `TESTING.md`, `SECURITY.md`, and component docs.
- `PROCESS.md` — overview of collaboration, process, and workflows; links into `process/`.
- `ROADMAP.md` — high-level direction and milestones; links to relevant `projects/`.
- `DOCS.md` — docs architecture, naming rules, and a short “how to use these docs” section.

Listing `docs/` once gives humans and agents a complete view of the canonical entrypoints.

---

## 3. Directories and Their Roles

### 3.1 `product/` — Product Artifacts

Evergreen product-side documents:

```text
docs/product/
  BUGS.md        # Canonical list/summary of known UX/functional issues
  WISHLIST.md    # Canonical backlog of desired capabilities
  PDR.md         # Product Decision Record(s)
```

- These files are canonical at the **product scope**.
- Temporal product work tied to a specific project belongs under `docs/projects/`.

### 3.2 `system/` — System Architecture & Standards

System-wide technical references:

```text
docs/system/
  ARCHITECTURE.md   # Canonical architecture doc (layers, flows, monorepo)
  TESTING.md        # System-wide testing strategy
  SECURITY.md       # Security model/guidelines
  ADR.md            # Architecture Decision Records (decisions made)
  DEFERRALS.md      # Deferred work & tech debt (decisions postponed)

  backend/
    overview.md
    orchestration.md
    schemas.md

  frontend/
    overview.md
    old_architecture.md
```

- `ARCHITECTURE.md`, `TESTING.md`, `SECURITY.md` are canonical, evergreen for the system domain.
- `ADR.md` documents significant architectural decisions that have been made.
- `DEFERRALS.md` tracks intentionally deferred work with trigger conditions.
- Component-specific docs (backend/frontend/…) live under subdirectories, generally lowercase.

### 3.3 `process/` — Collaboration, Process & Workflows

```text
docs/process/
  GRAPHITE.md          # Canonical Graphite workflow & conventions
  LINEAR.md            # Canonical Linear conventions & patterns
  MAINTENANCE.md       # Canonical maintenance processes (docs, deps, cleanup)
  # Optional future canon:
  # RELEASES.md        # Canonical release process (if/when defined)

  playbooks/           # Single-flow guides (supporting docs)
    run-task.md        # Example: pick up a Linear issue and complete it with guardrails
```

- These files define “how we work with tools and collaboration practices” in a durable, repo-wide way.
- `PROCESS.md` at the root introduces this domain and links into these docs.

### 3.4 `projects/` — Time-Bound Work

```text
docs/projects/
  <project-slug>/
    README.md       # Project overview & status
    # milestones/, issues/, logs/, resources/ as needed
```

- Each project folder holds time-bound context:
  - Specs, logs, issue docs, resources tied to that initiative.
- Project docs are typically lowercased and can be archived when the project sunsets.

### 3.5 `templates/` — Scaffolds

```text
docs/templates/
  project.md
  service.md
  issue.md
  milestone.md
```

- Reusable scaffolds for new docs.
- Copy these into `projects/`, `system/`, or `product/` as appropriate; do not edit them in place for project-specific work.

### 3.6 `_archive/` — Retired Docs

- Store retired or superseded docs here.
- Preserve original filenames; update links and note moves in relevant logs/milestones where it matters.

---

## 4. Naming & Placement Heuristics

This section defines how to decide **where** a new doc goes and **how** to name it.

### 4.1 Temporal vs Evergreen

1. **Temporal (time-bound, project-specific)**
   - Tied to a specific project, milestone, release, or date.
   - Examples: issue specs, daily logs, project-only decisions.
   - **Location:** `docs/projects/<project>/...`
   - **Naming:** lowercase (`spec.md`, `log-2025-11-30.md`, `notes.md`).

2. **Evergreen**
   - Intended to remain valid across projects over time.
   - **Location:** `docs/` (root gateways), `docs/product/`, `docs/system/`, `docs/process/`.

### 4.2 Canonical vs Supporting

For **evergreen** docs, decide if they are canonical or supporting:

1. **Canonical**
   - Single source of truth for a recurring concept at this path’s scope.
   - You should be able to answer “Where do I learn how we do X here?” with exactly one file.
   - Applies broadly across the repo or across a clear domain (product, system, workflows).
   - **Naming:** ALL‑CAPS (see below).

2. **Supporting**
   - Scoped, narrower, or implementation-detail docs.
   - Examples: backend-only logging details, frontend-specific rendering quirks, project notes.
   - **Naming:** lowercase.

### 4.3 ALL‑CAPS vs lowercase

- **ALL‑CAPS filenames** (e.g., `PRODUCT.md`, `ARCHITECTURE.md`) **anywhere in `docs/`**
  - Means "canonical, evergreen doc for this concept within this directory's scope."
  - Examples:
    - Root: `PRODUCT.md`, `SYSTEM.md`, `PROCESS.md`, `ROADMAP.md`, `DOCS.md`.
    - Product: `BUGS.md`, `WISHLIST.md`, `PDR.md`.
    - System: `ARCHITECTURE.md`, `TESTING.md`, `SECURITY.md`, `ADR.md`.
    - Workflows: `GRAPHITE.md`, `LINEAR.md`, `MAINTENANCE.md`, `RELEASES.md` (if added).
  - Aim for a small, focused set of ALL‑CAPS files per directory so they remain easy to scan.

- **lowercase**
  - Scoped or detailed docs, usually within a subdomain or project.
  - Examples:
    - `system/backend/overview.md`, `schemas.md`, `orchestration.md`.
    - `system/frontend/overview.md`, `old_architecture.md`.
    - `projects/slides-v0/issues/per-38-local-sync.md`.

### 4.4 Practical Examples

- **System-wide API versioning strategy**
  - Evergreen, single source of truth, repo-wide impact.
  - `docs/system/API_VERSIONING.md`.

- **Backend logging specifics**
  - Evergreen but scoped to backend.
  - `docs/system/backend/logging.md` (lowercase).

- **Stable release process**
  - Evergreen, applies every time a release is cut.
  - `docs/process/RELEASES.md`.

- **One-off notes for a specific release**
  - Time-bound, project-specific.
  - `docs/projects/slides-v0/logs/2025-12-01-release-notes.md`.

---

## 5. Navigation Patterns

### 5.1 Agents

- Use `AGENTS.md` as the primary entrypoint; it should link to:
  - `docs/PRODUCT.md` for product grounding.
  - `docs/SYSTEM.md` for system grounding.
  - `docs/PROCESS.md` + specific process docs (`process/GRAPHITE.md`, `LINEAR.md`, `MAINTENANCE.md`) for collaboration and workflows.
  - `docs/ROADMAP.md` and relevant `docs/projects/<project>/README.md` for current/future work.
- When in doubt, scan for ALL‑CAPS filenames at or under a path to find canonical docs for that scope.

### 5.2 Humans

- `ls docs` to see all gateway docs at a glance:
  - Start with `PRODUCT.md` or `SYSTEM.md` depending on whether you need product or technical context.
  - Use `PROCESS.md` when you need to know “how do we work here?”
  - Use `ROADMAP.md` for directional context and future work.
  - Use `DOCS.md` to understand and evolve the documentation structure itself.

---

## 6. Quick Reference Table

| Content Type                | Location                          | Naming                      |
|-----------------------------|-----------------------------------|-----------------------------|
| Product overview & why      | `docs/PRODUCT.md`                 | ALL‑CAPS filename           |
| System overview             | `docs/SYSTEM.md`                  | ALL‑CAPS filename           |
| Process overview            | `docs/PROCESS.md`                 | ALL‑CAPS filename           |
| Roadmap & direction         | `docs/ROADMAP.md`                 | ALL‑CAPS filename           |
| Docs architecture/meta      | `docs/DOCS.md`                    | ALL‑CAPS filename           |
| Product artifacts           | `docs/product/`                   | ALL‑CAPS filename (canonical)|
| System-wide standards       | `docs/system/`                    | ALL‑CAPS filename (canonical)|
| Architecture decisions      | `docs/system/ADR.md`              | ALL‑CAPS filename           |
| Deferred work/tech debt     | `docs/system/DEFERRALS.md`        | ALL‑CAPS filename           |
| Process & workflow policies | `docs/process/`                   | ALL‑CAPS filename (canonical)|
| Component/system details    | `docs/system/<area>/`             | lowercase (see note below)  |
| Project work                | `docs/projects/<project>/`        | lowercase                   |
| Templates                   | `docs/templates/`                 | lowercase                   |
| Archived docs               | `docs/_archive/`                  | preserve original           |

---

## 7. Component Overview Guidelines

Each component directory (e.g., `system/backend/`, `system/frontend/`) should have an `overview.md` as its entry point. This file serves as orientation for developers working in that component.

### What belongs in `overview.md`

- What the component is (1-2 sentences)
- Directory structure / key files
- Core patterns and conventions
- Links to detailed docs for deep dives

### When to split

Include this HTML comment at the bottom of each component `overview.md` to guide future maintenance:

```html
<!-- NOTE FOR AGENTS:
If this overview exceeds ~300 lines or you find yourself adding a major subsystem
(e.g., [component-specific examples]), consider:
1. Splitting that subsystem into its own doc (e.g., `subsystem.md`)
2. Creating a dedicated `architecture.md` if structural decisions need deep explanation
3. Adding an ADR entry in `docs/system/ADR.md` if trade-offs were evaluated

Keep this overview focused on orientation ("how to work here") rather than deep dives.
-->
```

**Triggers for splitting:**
- Overview exceeds ~300 lines
- A subsystem is complex enough to need dedicated onboarding
- You're documenting trade-offs between alternatives (ADR territory)
- New contributors consistently need more context than the overview provides

**Keep overviews unified when:**
- The component is architecturally simple
- All content is essential for basic orientation
- Splitting would create maintenance burden without clear benefit
</file>

<file path="PROCESS.md">
# Process

> How we work here.

---

## Collaboration

- [Contributing](process/CONTRIBUTING.md) — Contribution guidelines
- [Graphite Workflow](process/GRAPHITE.md) — Stacked PR workflow
- [Linear Conventions](process/LINEAR.md) — Issue management conventions

## Development

- Build: `pnpm run build`
- Lint: `pnpm lint`
- Test: `pnpm test`
- Refresh dependencies: `pnpm refresh`
- Refresh game data: `pnpm refresh:data`

## Current Projects

- [Swooper Maps](projects/swooper-maps/) — Map generation mod development
</file>

<file path="PRODUCT.md">
# Product

> What this is and why it exists.

---

## Overview

**Civ7 Modding Tools** is a comprehensive monorepo workspace for Civilization VII modding. It provides tools, documentation, and an SDK for creating mods programmatically rather than manually editing XML files.

This repository began from [izica/civ7-modding-tools](https://github.com/izica/civ7-modding-tools) and has since diverged; it is maintained independently.

## Who It's For

- **Mod developers** who want type-safe, programmatic mod creation
- **Technical modders** who prefer code over manual XML editing
- **Tool builders** who need reusable libraries for Civ7 data manipulation

## Core Capabilities

- **SDK** — TypeScript SDK for programmatic mod generation with strongly-typed builders
- **CLI** — Command-line tools for managing game resources (zip/unzip, graph visualization)
- **Plugin Libraries** — Reusable logic for file operations, graph crawling, and mod management
- **Documentation** — Comprehensive modding guides and references
- **Playground** — Examples and experimentation space

## Quick Links

- [System Architecture](SYSTEM.md) — How the system is structured
- [How We Work](PROCESS.md) — Collaboration and workflow conventions
- [Roadmap](ROADMAP.md) — Direction and milestones

## Product Artifacts

- [product/](product/) — Product decisions and artifacts (BUGS.md, WISHLIST.md when needed)
</file>

<file path="ROADMAP.md">
# Roadmap

> Direction and milestones.

---

## Current Focus

Active development is focused on the Swooper Maps mod and its supporting infrastructure.

## Projects

### Active

- [Swooper Maps](projects/swooper-maps/) — Large-scale procedural map generation mod
  - Physics-based terrain generation
  - Climate simulation
  - Narrative overlay system

### Infrastructure

- SDK — Stable, published to npm
- CLI — Stable, resource management tools
- Plugin libraries — Active development for mapgen features

## Future Directions

See individual project README files for detailed milestones and plans.
</file>

<file path="SYSTEM.md">
# System

> High-level system overview and architecture map.

---

## Quick Start

- [Architecture Overview](system/ARCHITECTURE.md) — System-wide architecture
- [Testing Strategy](system/TESTING.md) — How we test across the monorepo

## Workspace Structure

```
civ7-modding-tools/
├── packages/
│   ├── sdk/              # TypeScript SDK for mod generation
│   ├── cli/              # Command-line tools (oclif)
│   ├── config/           # Shared config/path resolution
│   └── plugins/          # Reusable plugin libraries
├── apps/
│   ├── docs/             # Documentation site (Mintlify)
│   └── playground/       # Example mods and experiments
├── mods/
│   └── <mod-name>/       # Colocated mod workspaces
└── civ.config.jsonc      # CLI configuration
```

## Components

### Packages

- [SDK](system/sdk/) — TypeScript SDK for programmatic mod generation
- [CLI](system/cli/) — Command-line tools for resource management

### Plugins

- Mapgen notes are archived; see legacy reference under [Swooper Maps](system/mods/swooper-maps/reference/).

### Mods

- [Swooper Maps](system/mods/swooper-maps/) — Large-scale procedural map generation

## Standards

- [Architecture Decisions](system/ADR.md) — Significant decisions made
- [Deferred Work](system/DEFERRALS.md) — Intentionally postponed work with trigger conditions
</file>

</files>
