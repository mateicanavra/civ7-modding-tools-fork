This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
external/
  TypeScript-Voronoi-master/
    src/
      bounding_box.js
      cell.js
      diagram.js
      edge.js
      halfedge.js
      index.js
      rbtree.js
      site.js
      vertex.js
      voronoi.js
voronoi_generators/
  continent-generator.js
  map-generator.js
voronoi_maps/
  continents.js
  map-common.js
  pangaea.js
voronoi_rules/
  avoid-edge.js
  avoid-other-regions.js
  cell-area.js
  near-map-center.js
  near-neighbor.js
  near-plate-boundary.js
  near-region-seed.js
  neighbors-in-region.js
  prefer-latitude.js
  rules-base.js
age-transition-post-load.js
archipelago.js
assign-advanced-start-region.js
assign-starting-plots.js
continents-plus.js
continents-voronoi.js
continents.js
discovery-generator.js
elevation-terrain-generator.js
feature-biome-generator.js
fractal.js
heap.js
index.d.js
kd-tree.js
map-debug-helpers.js
map-globals.js
map-utilities.js
MathHelpers.js
natural-wonder-generator.js
pangaea-plus.js
pangaea-voronoi.js
quadtree.js
random-pcg-32.js
resource-generator.js
shuffle.js
snow-generator.js
terra-incognita.js
volcano-generator.js
voronoi-builder.js
voronoi-hex.js
voronoi-plate.js
voronoi-region.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="external/TypeScript-Voronoi-master/src/bounding_box.js">
class BoundingBox {
}

export { BoundingBox };
//# sourceMappingURL=bounding_box.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/cell.js">
class Cell {
  constructor(site) {
    this.site = site;
    this.halfedges = [];
    this.closeMe = false;
  }
  init(site) {
    this.site = site;
    this.halfedges = [];
    this.closeMe = false;
    return this;
  }
  prepareHalfedges() {
    let halfedges = this.halfedges;
    let iHalfedge = halfedges.length;
    let edge;
    while (iHalfedge--) {
      edge = halfedges[iHalfedge].edge;
      if (!edge.vb || !edge.va) {
        halfedges.splice(iHalfedge, 1);
      }
    }
    halfedges.sort((a, b) => {
      return b.angle - a.angle;
    });
    return halfedges.length;
  }
  // Return a list of the neighbor Ids
  getNeighborIds() {
    let neighbors = [];
    let iHalfedge = this.halfedges.length;
    let edge;
    while (iHalfedge--) {
      edge = this.halfedges[iHalfedge].edge;
      if (edge.lSite !== null && edge.lSite.id != this.site.id) {
        neighbors.push(edge.lSite.id);
      } else if (edge.rSite !== null && edge.rSite.id != this.site.id) {
        neighbors.push(edge.rSite.id);
      }
    }
    return neighbors;
  }
  // Compute bounding box
  //
  getBbox() {
    let halfedges = this.halfedges;
    let iHalfedge = halfedges.length;
    let xmin = Infinity;
    let ymin = Infinity;
    let xmax = -Infinity;
    let ymax = -Infinity;
    let v, vx, vy;
    while (iHalfedge--) {
      v = halfedges[iHalfedge].getStartpoint();
      vx = v.x;
      vy = v.y;
      if (vx < xmin) {
        xmin = vx;
      }
      if (vy < ymin) {
        ymin = vy;
      }
      if (vx > xmax) {
        xmax = vx;
      }
      if (vy > ymax) {
        ymax = vy;
      }
    }
    return {
      x: xmin,
      y: ymin,
      width: xmax - xmin,
      height: ymax - ymin
    };
  }
  // Return whether a point is inside, on, or outside the cell:
  //   -1: point is outside the perimeter of the cell
  //    0: point is on the perimeter of the cell
  //    1: point is inside the perimeter of the cell
  //
  pointIntersection(x, y) {
    let halfedges = this.halfedges;
    let iHalfedge = halfedges.length;
    let halfedge;
    let p0, p1;
    let r;
    while (iHalfedge--) {
      halfedge = halfedges[iHalfedge];
      p0 = halfedge.getStartpoint();
      p1 = halfedge.getEndpoint();
      r = (y - p0.y) * (p1.x - p0.x) - (x - p0.x) * (p1.y - p0.y);
      if (!r) {
        return 0;
      }
      if (r > 0) {
        return -1;
      }
    }
    return 1;
  }
}

export { Cell };
//# sourceMappingURL=cell.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/diagram.js">
class Diagram {
  constructor(site) {
    this.site = site;
  }
}

export { Diagram };
//# sourceMappingURL=diagram.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/edge.js">
class Edge {
  constructor(lSite, rSite) {
    this.lSite = lSite;
    this.rSite = rSite;
    this.va = this.vb = null;
  }
}

export { Edge };
//# sourceMappingURL=edge.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/halfedge.js">
class Halfedge {
  constructor(edge, lSite, rSite) {
    this.site = lSite;
    this.edge = edge;
    if (rSite) {
      this.angle = Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x);
    } else {
      let va = edge.va;
      let vb = edge.vb;
      this.angle = edge.lSite === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
  }
  getStartpoint() {
    return this.edge.lSite === this.site ? this.edge.va : this.edge.vb;
  }
  getEndpoint() {
    return this.edge.lSite === this.site ? this.edge.vb : this.edge.va;
  }
}

export { Halfedge };
//# sourceMappingURL=halfedge.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/index.js">
export { BoundingBox } from './bounding_box.js';
export { Cell } from './cell.js';
export { Diagram } from './diagram.js';
export { Edge } from './edge.js';
export { Halfedge } from './halfedge.js';
export { RBTree, RBTreeNode } from './rbtree.js';
export { Site } from './site.js';
export { Vertex } from './vertex.js';
export { Voronoi } from './voronoi.js';
//# sourceMappingURL=index.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/rbtree.js">
class RBTree {
  constructor() {
    this.root = null;
  }
  insertSuccessor(node, successor) {
    let parent;
    if (node) {
      successor.prev = node;
      successor.next = node.next;
      if (node.next) {
        node.next.prev = successor;
      }
      node.next = successor;
      if (node.right) {
        node = node.right;
        while (node.left) {
          node = node.left;
        }
        node.left = successor;
      } else {
        node.right = successor;
      }
      parent = node;
    } else if (this.root) {
      node = this.first(this.root);
      successor.prev = null;
      successor.next = node;
      node.prev = successor;
      node.left = successor;
      parent = node;
    } else {
      successor.prev = successor.next = null;
      this.root = successor;
      parent = null;
    }
    successor.left = successor.right = null;
    successor.parent = parent;
    successor.red = true;
    let grandpa, uncle;
    node = successor;
    while (parent && parent.red) {
      grandpa = parent.parent;
      if (parent === grandpa.left) {
        uncle = grandpa.right;
        if (uncle && uncle.red) {
          parent.red = uncle.red = false;
          grandpa.red = true;
          node = grandpa;
        } else {
          if (node === parent.right) {
            this.rotateLeft(parent);
            node = parent;
            parent = node.parent;
          }
          parent.red = false;
          grandpa.red = true;
          this.rotateRight(grandpa);
        }
      } else {
        uncle = grandpa.left;
        if (uncle && uncle.red) {
          parent.red = uncle.red = false;
          grandpa.red = true;
          node = grandpa;
        } else {
          if (node === parent.left) {
            this.rotateRight(parent);
            node = parent;
            parent = node.parent;
          }
          parent.red = false;
          grandpa.red = true;
          this.rotateLeft(grandpa);
        }
      }
      parent = node.parent;
    }
    this.root.red = false;
  }
  removeNode(node) {
    if (node.next) {
      node.next.prev = node.prev;
    }
    if (node.prev) {
      node.prev.next = node.next;
    }
    node.next = node.prev = null;
    let parent = node.parent;
    let left = node.left;
    let right = node.right;
    let next = null;
    if (!left) {
      next = right;
    } else if (!right) {
      next = left;
    } else {
      next = this.first(right);
    }
    if (parent) {
      if (parent.left === node) {
        parent.left = next;
      } else {
        parent.right = next;
      }
    } else {
      this.root = next;
    }
    let isRed;
    if (left && right) {
      isRed = next.red;
      next.red = node.red;
      next.left = left;
      left.parent = next;
      if (next !== right) {
        parent = next.parent;
        next.parent = node.parent;
        node = next.right;
        parent.left = node;
        next.right = right;
        right.parent = next;
      } else {
        next.parent = parent;
        parent = next;
        node = next.right;
      }
    } else {
      isRed = node.red;
      node = next;
    }
    if (node) {
      node.parent = parent;
    }
    if (isRed) {
      return;
    }
    if (node && node.red) {
      node.red = false;
      return;
    }
    let sibling;
    do {
      if (node === this.root) {
        break;
      }
      if (node === parent.left) {
        sibling = parent.right;
        if (sibling.red) {
          sibling.red = false;
          parent.red = true;
          this.rotateLeft(parent);
          sibling = parent.right;
        }
        if (sibling.left && sibling.left.red || sibling.right && sibling.right.red) {
          if (!sibling.right || !sibling.right.red) {
            sibling.left.red = false;
            sibling.red = true;
            this.rotateRight(sibling);
            sibling = parent.right;
          }
          sibling.red = parent.red;
          parent.red = sibling.right.red = false;
          this.rotateLeft(parent);
          node = this.root;
          break;
        }
      } else {
        sibling = parent.left;
        if (sibling.red) {
          sibling.red = false;
          parent.red = true;
          this.rotateRight(parent);
          sibling = parent.left;
        }
        if (sibling.left && sibling.left.red || sibling.right && sibling.right.red) {
          if (!sibling.left || !sibling.left.red) {
            sibling.right.red = false;
            sibling.red = true;
            this.rotateLeft(sibling);
            sibling = parent.left;
          }
          sibling.red = parent.red;
          parent.red = sibling.left.red = false;
          this.rotateRight(parent);
          node = this.root;
          break;
        }
      }
      sibling.red = true;
      node = parent;
      parent = parent.parent;
    } while (!node.red);
    if (node) {
      node.red = false;
    }
  }
  rotateLeft(node) {
    let p = node;
    let q = node.right;
    let parent = p.parent;
    if (parent) {
      if (parent.left === p) {
        parent.left = q;
      } else {
        parent.right = q;
      }
    } else {
      this.root = q;
    }
    q.parent = parent;
    p.parent = q;
    p.right = q.left;
    if (p.right) {
      p.right.parent = p;
    }
    q.left = p;
  }
  rotateRight(node) {
    let p = node;
    let q = node.left;
    let parent = p.parent;
    if (parent) {
      if (parent.left === p) {
        parent.left = q;
      } else {
        parent.right = q;
      }
    } else {
      this.root = q;
    }
    q.parent = parent;
    p.parent = q;
    p.left = q.right;
    if (p.left) {
      p.left.parent = p;
    }
    q.right = p;
  }
  first(node) {
    while (node.left) {
      node = node.left;
    }
    return node;
  }
  last(node) {
    while (node.right) {
      node = node.right;
    }
    return node;
  }
}
class RBTreeNode {
}

export { RBTree, RBTreeNode };
//# sourceMappingURL=rbtree.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/site.js">
class Site {
}

export { Site };
//# sourceMappingURL=site.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/vertex.js">
class Vertex {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

export { Vertex };
//# sourceMappingURL=vertex.js.map
</file>

<file path="external/TypeScript-Voronoi-master/src/voronoi.js">
import { RBTree, RBTreeNode } from './rbtree.js';
import { Vertex } from './vertex.js';
import { Edge } from './edge.js';
import { Cell } from './cell.js';
import { Diagram } from './diagram.js';
import { Halfedge } from './halfedge.js';

class Voronoi {
  constructor() {
    this.vertices = null;
    this.edges = null;
    this.cells = null;
    this.toRecycle = null;
    this.beachsectionJunkyard = [];
    this.circleEventJunkyard = [];
    this.vertexJunkyard = [];
    this.edgeJunkyard = [];
    this.cellJunkyard = [];
  }
  //
  // public methods
  //
  // ---------------------------------------------------------------------------
  // Top-level Fortune loop
  // rhill 2011-05-19:
  //   Voronoi sites are kept client-side now, to allow
  //   user to freely modify content. At compute time,
  //   *references* to sites are copied locally.
  compute(sites, bbox) {
    let startTime = /* @__PURE__ */ new Date();
    this.reset();
    if (this.toRecycle) {
      this.vertexJunkyard = this.vertexJunkyard.concat(this.toRecycle.vertices);
      this.edgeJunkyard = this.edgeJunkyard.concat(this.toRecycle.edges);
      this.cellJunkyard = this.cellJunkyard.concat(this.toRecycle.cells);
      this.toRecycle = null;
    }
    let siteEvents = sites.slice(0);
    siteEvents.sort(function(a, b) {
      let r = b.y - a.y;
      if (r) {
        return r;
      }
      return b.x - a.x;
    });
    let site = siteEvents.pop(), siteid = 0, xsitex, xsitey, cells = this.cells, circle;
    for (; ; ) {
      circle = this.firstCircleEvent;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== xsitex || site.y !== xsitey) {
          cells[siteid] = this.createCell(site);
          site.id = siteid++;
          this.addBeachsection(site);
          xsitey = site.y;
          xsitex = site.x;
        }
        site = siteEvents.pop();
      } else if (circle) {
        this.removeBeachsection(circle.arc);
      } else {
        break;
      }
    }
    this.clipEdges(bbox);
    this.closeCells(bbox);
    let stopTime = /* @__PURE__ */ new Date();
    let diagram = new Diagram();
    diagram.cells = this.cells;
    diagram.edges = this.edges;
    diagram.vertices = this.vertices;
    diagram.execTime = stopTime.getTime() - startTime.getTime();
    this.reset();
    return diagram;
  }
  //
  // private methods
  //
  sqrt(x) {
    return Math.sqrt(x);
  }
  abs(x) {
    return Math.abs(x);
  }
  eps() {
    return 1e-9;
  }
  inveps() {
    return 1 / this.eps();
  }
  equalWithEpsilon(a, b) {
    return this.abs(a - b) < this.eps();
  }
  greaterThanWithEpsilon(a, b) {
    return a - b > this.eps();
  }
  greaterThanOrEqualWithEpsilon(a, b) {
    return b - a < this.eps();
  }
  lessThanWithEpsilon(a, b) {
    return b - a > this.eps();
  }
  lessThanOrEqualWithEpsilon(a, b) {
    return a - b < this.eps();
  }
  // ---------------------------------------------------------------------------
  // Helper: Quantize sites
  // rhill 2013-10-12:
  // This is to solve https://github.com/gorhill/Javascript-Voronoi/issues/15
  // Since not all users will end up using the kind of coord values which would
  // cause the issue to arise, I chose to let the user decide whether or not
  // he should sanitize his coord values through this helper. This way, for
  // those users who uses coord values which are known to be fine, no overhead is
  // added.
  quantizeSites(sites) {
    let eps = this.eps(), n = sites.length, site;
    while (n--) {
      site = sites[n];
      site.x = Math.floor(site.x / eps) * eps;
      site.y = Math.floor(site.y / eps) * eps;
    }
  }
  // ---------------------------------------------------------------------------
  // Helper: Recycle diagram: all vertex, edge and cell objects are
  // "surrendered" to the Voronoi object for reuse.
  // TODO: rhill-voronoi-core v2: more performance to be gained
  // when I change the semantic of what is returned.
  recycle(diagram) {
    if (diagram) {
      if (diagram instanceof Diagram) {
        this.toRecycle = diagram;
      } else {
        throw "Voronoi.recycleDiagram() > Need a Diagram object.";
      }
    }
  }
  reset() {
    if (!this.beachline) {
      this.beachline = new RBTree();
    }
    if (this.beachline.root) {
      let beachsection = this.beachline.first(this.beachline.root);
      while (beachsection) {
        this.beachsectionJunkyard.push(beachsection);
        beachsection = beachsection.next;
      }
    }
    this.beachline.root = null;
    if (!this.circleEvents) {
      this.circleEvents = new RBTree();
    }
    this.circleEvents.root = this.firstCircleEvent = null;
    this.vertices = [];
    this.edges = [];
    this.cells = [];
  }
  createCell(site) {
    let cell = this.cellJunkyard.pop();
    if (cell) {
      cell.init(site);
      return cell.init(site);
    }
    return new Cell(site);
  }
  createHalfedge(edge, lSite, rSite) {
    return new Halfedge(edge, lSite, rSite);
  }
  createVertex(x, y) {
    let v = this.vertexJunkyard.pop();
    if (!v) {
      v = new Vertex(x, y);
    } else {
      v.x = x;
      v.y = y;
    }
    this.vertices.push(v);
    return v;
  }
  // this create and add an edge to internal collection, and also create
  // two halfedges which are added to each site's counterclockwise array
  // of halfedges.
  createEdge(lSite, rSite, va = null, vb = null) {
    let edge = this.edgeJunkyard.pop();
    if (!edge) {
      edge = new Edge(lSite, rSite);
    } else {
      edge.lSite = lSite;
      edge.rSite = rSite;
      edge.va = edge.vb = null;
    }
    this.edges.push(edge);
    if (va) {
      this.setEdgeStartpoint(edge, lSite, rSite, va);
    }
    if (vb) {
      this.setEdgeEndpoint(edge, lSite, rSite, vb);
    }
    this.cells[lSite.id].halfedges.push(this.createHalfedge(edge, lSite, rSite));
    this.cells[rSite.id].halfedges.push(this.createHalfedge(edge, rSite, lSite));
    return edge;
  }
  createBorderEdge(lSite, va, vb) {
    let edge = this.edgeJunkyard.pop();
    if (!edge) {
      edge = new Edge(lSite, null);
    } else {
      edge.lSite = lSite;
      edge.rSite = null;
    }
    edge.va = va;
    edge.vb = vb;
    this.edges.push(edge);
    return edge;
  }
  setEdgeStartpoint(edge, lSite, rSite, vertex) {
    if (!edge.va && !edge.vb) {
      edge.va = vertex;
      edge.lSite = lSite;
      edge.rSite = rSite;
    } else if (edge.lSite === rSite) {
      edge.vb = vertex;
    } else {
      edge.va = vertex;
    }
  }
  setEdgeEndpoint(edge, lSite, rSite, vertex) {
    this.setEdgeStartpoint(edge, rSite, lSite, vertex);
  }
  // rhill 2011-06-02: A lot of Beachsection instanciations
  // occur during the computation of the Voronoi diagram,
  // somewhere between the number of sites and twice the
  // number of sites, while the number of Beachsections on the
  // beachline at any given time is comparatively low. For this
  // reason, we reuse already created Beachsections, in order
  // to avoid new memory allocation. This resulted in a measurable
  // performance gain.
  createBeachsection(site) {
    let beachsection = this.beachsectionJunkyard.pop();
    if (!beachsection) {
      beachsection = new RBTreeNode();
    }
    beachsection.site = site;
    return beachsection;
  }
  // calculate the left break point of a particular beach section,
  // given a particular sweep line
  leftBreakPoint(arc, directrix) {
    let site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) {
      return rfocx;
    }
    let lArc = arc.prev;
    if (!lArc) {
      return -Infinity;
    }
    site = lArc.site;
    let lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) {
      return lfocx;
    }
    let hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) {
      return (-b + this.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    }
    return (rfocx + lfocx) / 2;
  }
  // calculate the right break point of a particular beach section,
  // given a particular directrix
  rightBreakPoint(arc, directrix) {
    let rArc = arc.next;
    if (rArc) {
      return this.leftBreakPoint(rArc, directrix);
    }
    let site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  detachBeachsection(beachsection) {
    this.detachCircleEvent(beachsection);
    this.beachline.removeNode(beachsection);
    this.beachsectionJunkyard.push(beachsection);
  }
  removeBeachsection(beachsection) {
    let circle = beachsection.circleEvent, x = circle.x, y = circle.ycenter, vertex = this.createVertex(x, y), previous = beachsection.prev, next = beachsection.next, disappearingTransitions = [beachsection], abs_fn = Math.abs;
    this.detachBeachsection(beachsection);
    let lArc = previous;
    while (lArc.circleEvent && abs_fn(x - lArc.circleEvent.x) < this.eps() && abs_fn(y - lArc.circleEvent.ycenter) < this.eps()) {
      previous = lArc.prev;
      disappearingTransitions.unshift(lArc);
      this.detachBeachsection(lArc);
      lArc = previous;
    }
    disappearingTransitions.unshift(lArc);
    this.detachCircleEvent(lArc);
    let rArc = next;
    while (rArc.circleEvent && abs_fn(x - rArc.circleEvent.x) < this.eps() && abs_fn(y - rArc.circleEvent.ycenter) < this.eps()) {
      next = rArc.next;
      disappearingTransitions.push(rArc);
      this.detachBeachsection(rArc);
      rArc = next;
    }
    disappearingTransitions.push(rArc);
    this.detachCircleEvent(rArc);
    let nArcs = disappearingTransitions.length, iArc;
    for (iArc = 1; iArc < nArcs; iArc++) {
      rArc = disappearingTransitions[iArc];
      lArc = disappearingTransitions[iArc - 1];
      this.setEdgeStartpoint(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearingTransitions[0];
    rArc = disappearingTransitions[nArcs - 1];
    rArc.edge = this.createEdge(lArc.site, rArc.site, void 0, vertex);
    this.attachCircleEvent(lArc);
    this.attachCircleEvent(rArc);
  }
  addBeachsection(site) {
    let x = site.x, directrix = site.y;
    let lArc, rArc, dxl, dxr, node = this.beachline.root;
    while (node) {
      dxl = this.leftBreakPoint(node, directrix) - x;
      if (dxl > this.eps()) {
        node = node.left;
      } else {
        dxr = x - this.rightBreakPoint(node, directrix);
        if (dxr > this.eps()) {
          if (!node.right) {
            lArc = node;
            break;
          }
          node = node.right;
        } else {
          if (dxl > -this.eps()) {
            lArc = node.prev;
            rArc = node;
          } else if (dxr > -this.eps()) {
            lArc = node;
            rArc = node.next;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    let newArc = this.createBeachsection(site);
    this.beachline.insertSuccessor(lArc, newArc);
    if (!lArc && !rArc) {
      return;
    }
    if (lArc === rArc) {
      this.detachCircleEvent(lArc);
      rArc = this.createBeachsection(lArc.site);
      this.beachline.insertSuccessor(newArc, rArc);
      newArc.edge = rArc.edge = this.createEdge(lArc.site, newArc.site);
      this.attachCircleEvent(lArc);
      this.attachCircleEvent(rArc);
      return;
    }
    if (lArc && !rArc) {
      newArc.edge = this.createEdge(lArc.site, newArc.site);
      return;
    }
    if (lArc !== rArc) {
      this.detachCircleEvent(lArc);
      this.detachCircleEvent(rArc);
      let lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = this.createVertex((cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay);
      this.setEdgeStartpoint(rArc.edge, lSite, rSite, vertex);
      newArc.edge = this.createEdge(lSite, site, void 0, vertex);
      rArc.edge = this.createEdge(site, rSite, void 0, vertex);
      this.attachCircleEvent(lArc);
      this.attachCircleEvent(rArc);
      return;
    }
  }
  attachCircleEvent(arc) {
    let lArc = arc.prev, rArc = arc.next;
    if (!lArc || !rArc) {
      return;
    }
    let lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) {
      return;
    }
    let bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    let d = 2 * (ax * cy - ay * cx);
    if (d >= -2e-12) {
      return;
    }
    let ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, ycenter = y + by;
    let circleEvent = this.circleEventJunkyard.pop();
    if (!circleEvent) {
      circleEvent = new RBTreeNode();
    }
    circleEvent.arc = arc;
    circleEvent.site = cSite;
    circleEvent.x = x + bx;
    circleEvent.y = ycenter + this.sqrt(x * x + y * y);
    circleEvent.ycenter = ycenter;
    arc.circleEvent = circleEvent;
    let predecessor = null, node = this.circleEvents.root;
    while (node) {
      if (circleEvent.y < node.y || circleEvent.y === node.y && circleEvent.x <= node.x) {
        if (node.left) {
          node = node.left;
        } else {
          predecessor = node.prev;
          break;
        }
      } else {
        if (node.right) {
          node = node.right;
        } else {
          predecessor = node;
          break;
        }
      }
    }
    this.circleEvents.insertSuccessor(predecessor, circleEvent);
    if (!predecessor) {
      this.firstCircleEvent = circleEvent;
    }
  }
  detachCircleEvent(arc) {
    let circleEvent = arc.circleEvent;
    if (circleEvent) {
      if (!circleEvent.prev) {
        this.firstCircleEvent = circleEvent.next;
      }
      this.circleEvents.removeNode(circleEvent);
      this.circleEventJunkyard.push(circleEvent);
      arc.circleEvent = null;
    }
  }
  // connect dangling edges (not if a cursory test tells us
  // it is not going to be visible.
  // return value:
  //   false: the dangling endpoint couldn't be connected
  //   true: the dangling endpoint could be connected
  connectEdge(edge, bbox) {
    let vb = edge.vb;
    if (!!vb) {
      return true;
    }
    let va = edge.va, xl = bbox.xl, xr = bbox.xr, yt = bbox.yt, yb = bbox.yb, lSite = edge.lSite, rSite = edge.rSite, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    this.cells[lSite.id].closeMe = true;
    this.cells[rSite.id].closeMe = true;
    if (ry !== ly) {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
    }
    if (fm === void 0) {
      if (fx < xl || fx >= xr) {
        return false;
      }
      if (lx > rx) {
        if (!va || va.y < yt) {
          va = this.createVertex(fx, yt);
        } else if (va.y >= yb) {
          return false;
        }
        vb = this.createVertex(fx, yb);
      } else {
        if (!va || va.y > yb) {
          va = this.createVertex(fx, yb);
        } else if (va.y < yt) {
          return false;
        }
        vb = this.createVertex(fx, yt);
      }
    } else if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!va || va.y < yt) {
          va = this.createVertex((yt - fb) / fm, yt);
        } else if (va.y >= yb) {
          return false;
        }
        vb = this.createVertex((yb - fb) / fm, yb);
      } else {
        if (!va || va.y > yb) {
          va = this.createVertex((yb - fb) / fm, yb);
        } else if (va.y < yt) {
          return false;
        }
        vb = this.createVertex((yt - fb) / fm, yt);
      }
    } else {
      if (ly < ry) {
        if (!va || va.x < xl) {
          va = this.createVertex(xl, fm * xl + fb);
        } else if (va.x >= xr) {
          return false;
        }
        vb = this.createVertex(xr, fm * xr + fb);
      } else {
        if (!va || va.x > xr) {
          va = this.createVertex(xr, fm * xr + fb);
        } else if (va.x < xl) {
          return false;
        }
        vb = this.createVertex(xl, fm * xl + fb);
      }
    }
    edge.va = va;
    edge.vb = vb;
    return true;
  }
  // line-clipping code taken from:
  //   Liang-Barsky function by Daniel White
  //   http://www.skytopia.com/project/articles/compsci/clipping.html
  // Thanks!
  // A bit modified to minimize code paths
  clipEdge(edge, bbox) {
    let ax = edge.va.x, ay = edge.va.y, bx = edge.vb.x, by = edge.vb.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay;
    let q = ax - bbox.xl;
    if (dx === 0 && q < 0) {
      return false;
    }
    let r = -q / dx;
    if (dx < 0) {
      if (r < t0) {
        return false;
      }
      if (r < t1) {
        t1 = r;
      }
    } else if (dx > 0) {
      if (r > t1) {
        return false;
      }
      if (r > t0) {
        t0 = r;
      }
    }
    q = bbox.xr - ax;
    if (dx === 0 && q < 0) {
      return false;
    }
    r = q / dx;
    if (dx < 0) {
      if (r > t1) {
        return false;
      }
      if (r > t0) {
        t0 = r;
      }
    } else if (dx > 0) {
      if (r < t0) {
        return false;
      }
      if (r < t1) {
        t1 = r;
      }
    }
    q = ay - bbox.yt;
    if (dy === 0 && q < 0) {
      return false;
    }
    r = -q / dy;
    if (dy < 0) {
      if (r < t0) {
        return false;
      }
      if (r < t1) {
        t1 = r;
      }
    } else if (dy > 0) {
      if (r > t1) {
        return false;
      }
      if (r > t0) {
        t0 = r;
      }
    }
    q = bbox.yb - ay;
    if (dy === 0 && q < 0) {
      return false;
    }
    r = q / dy;
    if (dy < 0) {
      if (r > t1) {
        return false;
      }
      if (r > t0) {
        t0 = r;
      }
    } else if (dy > 0) {
      if (r < t0) {
        return false;
      }
      if (r < t1) {
        t1 = r;
      }
    }
    if (t0 > 0) {
      edge.va = this.createVertex(ax + t0 * dx, ay + t0 * dy);
    }
    if (t1 < 1) {
      edge.vb = this.createVertex(ax + t1 * dx, ay + t1 * dy);
    }
    if (t0 > 0 || t1 < 1) {
      this.cells[edge.lSite.id].closeMe = true;
      this.cells[edge.rSite.id].closeMe = true;
    }
    return true;
  }
  // Connect/cut edges at bounding box
  clipEdges(bbox) {
    let edges = this.edges, iEdge = edges.length, edge, abs_fn = Math.abs;
    while (iEdge--) {
      edge = edges[iEdge];
      if (!this.connectEdge(edge, bbox) || !this.clipEdge(edge, bbox) || abs_fn(edge.va.x - edge.vb.x) < this.eps() && abs_fn(edge.va.y - edge.vb.y) < this.eps()) {
        edge.va = edge.vb = null;
        edges.splice(iEdge, 1);
      }
    }
  }
  // Close the cells.
  // The cells are bound by the supplied bounding box.
  // Each cell refers to its associated site, and a list
  // of halfedges ordered counterclockwise.
  closeCells(bbox) {
    let xl = bbox.xl, xr = bbox.xr, yt = bbox.yt, yb = bbox.yb, cells = this.cells, iCell = cells.length, cell, iLeft, halfedges, nHalfedges, edge, va, vb, vz, lastBorderSegment, abs_fn = Math.abs;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell.prepareHalfedges()) {
        continue;
      }
      if (!cell.closeMe) {
        continue;
      }
      halfedges = cell.halfedges;
      nHalfedges = halfedges.length;
      iLeft = 0;
      while (iLeft < nHalfedges) {
        va = halfedges[iLeft].getEndpoint();
        vz = halfedges[(iLeft + 1) % nHalfedges].getStartpoint();
        if (abs_fn(va.x - vz.x) >= this.eps() || abs_fn(va.y - vz.y) >= this.eps()) {
          switch (true) {
            // walk downward along left side
            case (this.equalWithEpsilon(va.x, xl) && this.lessThanWithEpsilon(va.y, yb)):
              lastBorderSegment = this.equalWithEpsilon(vz.x, xl);
              vb = this.createVertex(xl, lastBorderSegment ? vz.y : yb);
              edge = this.createBorderEdge(cell.site, va, vb);
              iLeft++;
              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));
              nHalfedges++;
              if (lastBorderSegment) {
                break;
              }
              va = vb;
            // fall through
            // walk rightward along bottom side
            case (this.equalWithEpsilon(va.y, yb) && this.lessThanWithEpsilon(va.x, xr)):
              lastBorderSegment = this.equalWithEpsilon(vz.y, yb);
              vb = this.createVertex(lastBorderSegment ? vz.x : xr, yb);
              edge = this.createBorderEdge(cell.site, va, vb);
              iLeft++;
              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));
              nHalfedges++;
              if (lastBorderSegment) {
                break;
              }
              va = vb;
            // fall through
            // walk upward along right side
            case (this.equalWithEpsilon(va.x, xr) && this.greaterThanWithEpsilon(va.y, yt)):
              lastBorderSegment = this.equalWithEpsilon(vz.x, xr);
              vb = this.createVertex(xr, lastBorderSegment ? vz.y : yt);
              edge = this.createBorderEdge(cell.site, va, vb);
              iLeft++;
              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));
              nHalfedges++;
              if (lastBorderSegment) {
                break;
              }
              va = vb;
            // fall through
            // walk leftward along top side
            case (this.equalWithEpsilon(va.y, yt) && this.greaterThanWithEpsilon(va.x, xl)):
              lastBorderSegment = this.equalWithEpsilon(vz.y, yt);
              vb = this.createVertex(lastBorderSegment ? vz.x : xl, yt);
              edge = this.createBorderEdge(cell.site, va, vb);
              iLeft++;
              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));
              nHalfedges++;
              if (lastBorderSegment) {
                break;
              }
              va = vb;
              lastBorderSegment = this.equalWithEpsilon(vz.x, xl);
              vb = this.createVertex(xl, lastBorderSegment ? vz.y : yb);
              edge = this.createBorderEdge(cell.site, va, vb);
              iLeft++;
              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));
              nHalfedges++;
              if (lastBorderSegment) {
                break;
              }
              va = vb;
              lastBorderSegment = this.equalWithEpsilon(vz.y, yb);
              vb = this.createVertex(lastBorderSegment ? vz.x : xr, yb);
              edge = this.createBorderEdge(cell.site, va, vb);
              iLeft++;
              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));
              nHalfedges++;
              if (lastBorderSegment) {
                break;
              }
              va = vb;
              lastBorderSegment = this.equalWithEpsilon(vz.x, xr);
              vb = this.createVertex(xr, lastBorderSegment ? vz.y : yt);
              edge = this.createBorderEdge(cell.site, va, vb);
              iLeft++;
              halfedges.splice(iLeft, 0, this.createHalfedge(edge, cell.site, null));
              nHalfedges++;
              if (lastBorderSegment) {
                break;
              }
            // fall through
            default:
              throw "Voronoi.closeCells() > this makes no sense!";
          }
        }
        iLeft++;
      }
      cell.closeMe = false;
    }
  }
}

export { Voronoi };
//# sourceMappingURL=voronoi.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="MathHelpers.js">
function op2(a, b, op) {
  return { x: op(a.x, b.x), y: op(a.y, b.y) };
}
function op3(a, b, op) {
  return { x: op(a.x, b.x), y: op(a.y, b.y), z: op(a.z, b.z) };
}
function op4(a, b, op) {
  return { x: op(a.x, b.x), y: op(a.y, b.y), z: op(a.z, b.z), w: op(a.w, b.w) };
}
function op2s(a, b, op) {
  return { x: op(a.x, b), y: op(a.y, b) };
}
function op3s(a, b, op) {
  return { x: op(a.x, b), y: op(a.y, b), z: op(a.z, b) };
}
function op4s(a, b, op) {
  return { x: op(a.x, b), y: op(a.y, b), z: op(a.z, b), w: op(a.w, b) };
}
function neg2(a) {
  return { x: -a.x, y: -a.y };
}
function neg3(a) {
  return { x: -a.x, y: -a.y, z: -a.z };
}
function neg4(a) {
  return { x: -a.x, y: -a.y, z: -a.z, w: -a.w };
}
function add1(a, b) {
  return a + b;
}
function add2(a, b) {
  return op2(a, b, add1);
}
function add3(a, b) {
  return op3(a, b, add1);
}
function add4(a, b) {
  return op4(a, b, add1);
}
function sub1(a, b) {
  return a - b;
}
function sub2(a, b) {
  return op2(a, b, sub1);
}
function sub3(a, b) {
  return op3(a, b, sub1);
}
function sub4(a, b) {
  return op4(a, b, sub1);
}
function mul1(a, b) {
  return a * b;
}
function mul2(a, b) {
  return op2(a, b, mul1);
}
function mul3(a, b) {
  return op3(a, b, mul1);
}
function mul4(a, b) {
  return op4(a, b, mul1);
}
function mul2s(a, b) {
  return op2s(a, b, mul1);
}
function mul3s(a, b) {
  return op3s(a, b, mul1);
}
function mul4s(a, b) {
  return op4s(a, b, mul1);
}
function div1(a, b) {
  return a / b;
}
function div2(a, b) {
  return op2(a, b, div1);
}
function div3(a, b) {
  return op3(a, b, div1);
}
function div4(a, b) {
  return op4(a, b, div1);
}
function div2s(a, b) {
  return op2s(a, b, div1);
}
function div3s(a, b) {
  return op3s(a, b, div1);
}
function div4s(a, b) {
  return op4s(a, b, div1);
}
function length2(a) {
  return Math.sqrt(dot2(a, a));
}
function length3(a) {
  return Math.sqrt(dot3(a, a));
}
function length4(a) {
  return Math.sqrt(dot4(a, a));
}
function norm2(a) {
  return div2s(a, length2(a));
}
function norm3(a) {
  return div3s(a, length3(a));
}
function norm4(a) {
  return div4s(a, length4(a));
}
function dot2(a, b) {
  const mul = mul2(a, b);
  return mul.x + mul.y;
}
function dot2_90(a, b) {
  return a.y * b.x - a.x * b.y;
}
function dot3(a, b) {
  const mul = mul3(a, b);
  return mul.x + mul.y + mul.z;
}
function dot4(a, b) {
  const mul = mul4(a, b);
  return mul.x + mul.y + mul.z + mul.w;
}
function rotate2(a, radians) {
  const sincos = { x: Math.cos(radians), y: Math.sin(radians) };
  return { x: sincos.x * a.x - sincos.y * a.y, y: sincos.y * a.x + sincos.x * a.y };
}

export { add1, add2, add3, add4, div1, div2, div2s, div3, div3s, div4, div4s, dot2, dot2_90, dot3, dot4, length2, length3, length4, mul1, mul2, mul2s, mul3, mul3s, mul4, mul4s, neg2, neg3, neg4, norm2, norm3, norm4, op2, op2s, op3, op3s, op4, op4s, rotate2, sub1, sub2, sub3, sub4 };
//# sourceMappingURL=MathHelpers.js.map
</file>

<file path="archipelago.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoasts, addMountains, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_NavigableRiverTerrain, g_OceanTerrain, g_CoastTerrain, g_LandmassFractal, g_FlatTerrain } from './map-globals.js';
import { needHumanNearEquator, markLandmassRegionId, isAdjacentToLand, getSector, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script Archipelago.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = g_OceanWaterColumns;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
  } else {
    console.log("Standard Map");
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
  }
  markLandmassRegionId(eastContinent, LandmassRegion.LANDMASS_REGION_EAST);
  markLandmassRegionId(westContinent, LandmassRegion.LANDMASS_REGION_WEST);
  TerrainBuilder.validateAndFixTerrain();
  expandCoasts(iWidth, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 70, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
  const PlayerList = Players.getAlive();
  for (let i = 0; i < PlayerList.length; ++i) {
    if (PlayerList[i].isValid && PlayerList[i].isMajor && PlayerList[i].isAI) {
      const playerAI = PlayerList[i].AI;
      playerAI?.scaleAiPreference("PseudoYieldBiases", "PSEUDOYIELD_STANDING_NAVY_UNIT", 200);
    }
  }
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded Archipelago.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
    }
  }
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    3
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    4
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    5
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    6
  );
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.removePlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function generateFractalLayerWithoutHills(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iCenterWeight = 0;
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain || GameplayMap.getTerrainType(iX, iY) == g_CoastTerrain) {
        let terrain = g_FlatTerrain;
        const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
        const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
        if (isAdjacentToLand(iX, iY)) {
          continue;
        } else if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
          continue;
        } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
          terrain = g_OceanTerrain;
        } else {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          let iStartSectorWeight = 0;
          let iFractalWeight = 1;
          if (iStartSectorRows > 0 && iStartSectorCols > 0 && startSectors[iSector]) {
            iStartSectorWeight = 0.5;
            iFractalWeight = 0.55;
          }
          const iPlotHeight = getHeightAdjustingForStartSector(
            iX,
            iY,
            iWaterHeight,
            iFractalWeight,
            iCenterWeight,
            iStartSectorWeight,
            continent1,
            continent2,
            iStartSectorRows,
            iStartSectorCols,
            startSectors
          );
          if (iPlotHeight < iWaterHeight) {
            continue;
          }
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
//# sourceMappingURL=archipelago.js.map
</file>

<file path="assign-advanced-start-region.js">
import { g_OceanTerrain, g_MountainTerrain, g_CoastTerrain, g_FlatTerrain, g_HillTerrain } from './map-globals.js';

const g_StartingScore = 20;
const g_BadTerrainScore = 1;
const g_GoodTerrainScore = 10;
const g_TooCloseToOtherPlayerPenalty = -3;
const g_TooCloseDistance = 10;
class AdvancedStartRegion {
  player;
  claimedPlots = [];
  potentialPlots;
  startPlot;
  constructor(inPlayer) {
    this.player = inPlayer;
    this.startPlot = { x: -1, y: -1 };
    this.potentialPlots = /* @__PURE__ */ new Map();
  }
}
function assignAdvancedStartRegions() {
  const playerIds = Players.getAliveIds();
  const playerRegions = [];
  const playerStartPositions = [];
  for (const playerId of playerIds) {
    const region = new AdvancedStartRegion(playerId);
    initializeRegion(region);
    playerStartPositions.push(region.startPlot);
    playerRegions.push(region);
  }
  let maxRegionSize = 0;
  const advStartParams = GameInfo.AdvancedStartParameters.lookup(Game.age);
  if (advStartParams !== null) {
    maxRegionSize = advStartParams.MaxRegionPlots;
  }
  let minRange = 3;
  const minRangeDef = GameInfo.GlobalParameters.lookup("CITY_MIN_RANGE");
  if (minRangeDef !== null) {
    minRange = parseInt(minRangeDef.Value);
  }
  for (let plotCount = 0; plotCount < maxRegionSize; plotCount++) {
    for (let i = 0; i < playerRegions.length; i++) {
      const plotIndex = claimPlot(playerRegions[i], playerStartPositions);
      if (plotIndex !== -1) {
        const plot = GameplayMap.getLocationFromIndex(plotIndex);
        const claimedPlots = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, minRange);
        for (let j = 0; j < playerRegions.length; j++) {
          if (i !== j) {
            for (const claimedPlot of claimedPlots) {
              playerRegions[j].potentialPlots.set(claimedPlot, -1);
            }
          }
        }
      }
    }
  }
  for (let i = 0; i < playerRegions.length; i++) {
    StartPositioner.setAdvancedStartRegion(playerRegions[i].player, playerRegions[i].claimedPlots);
  }
  dumpAdvancedStartRegions(playerRegions);
}
function initializeRegion(region) {
  const startPosition = StartPositioner.getStartPosition(region.player);
  if (startPosition === -1) {
    return;
  }
  region.startPlot = GameplayMap.getLocationFromIndex(startPosition);
  region.potentialPlots.set(startPosition, g_StartingScore + g_GoodTerrainScore);
}
function claimPlot(region, playerStartPositions) {
  let chosenPlot = -1;
  let maxScore = -1;
  for (const [potentialPlot, score] of region.potentialPlots.entries()) {
    if (score > maxScore) {
      maxScore = score;
      chosenPlot = potentialPlot;
    }
  }
  if (chosenPlot !== -1) {
    region.claimedPlots.push(chosenPlot);
    region.potentialPlots.set(chosenPlot, -1);
    const plot = GameplayMap.getLocationFromIndex(chosenPlot);
    const adjacentPlots = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, 1);
    for (let i = 0; i < adjacentPlots.length; i++) {
      const adjacentPlotIndex = adjacentPlots[i];
      if (region.potentialPlots.has(adjacentPlotIndex) == false) {
        const adjPlot = GameplayMap.getLocationFromIndex(adjacentPlotIndex);
        const terrainType = GameplayMap.getTerrainType(adjPlot.x, adjPlot.y);
        if (terrainType == g_OceanTerrain) {
          region.potentialPlots.set(adjacentPlotIndex, -1);
        } else if (terrainType == g_MountainTerrain || terrainType == g_CoastTerrain) {
          region.potentialPlots.set(adjacentPlotIndex, g_BadTerrainScore);
        } else {
          region.potentialPlots.set(adjacentPlotIndex, g_GoodTerrainScore);
        }
        let score = region.potentialPlots.get(adjacentPlotIndex);
        if (score) {
          if (score > 0) {
            let distScore = g_StartingScore - GameplayMap.getPlotDistance(region.startPlot.x, region.startPlot.y, adjPlot.x, adjPlot.y);
            if (distScore < 0) {
              distScore = 0;
            }
            score += distScore;
          }
          for (const playerPos of playerStartPositions) {
            const dist = GameplayMap.getPlotDistance(playerPos.x, playerPos.y, adjPlot.x, adjPlot.y);
            if (dist < g_TooCloseDistance) {
              score += g_TooCloseToOtherPlayerPenalty;
            }
          }
          region.potentialPlots.set(adjacentPlotIndex, score);
        }
      } else {
        const score = region.potentialPlots.get(adjacentPlotIndex);
        if (score && score > 0) {
          region.potentialPlots.set(adjacentPlotIndex, score + 1);
        }
      }
    }
  }
  return chosenPlot;
}
function dumpAdvancedStartRegions(playerRegions) {
  console.log("AdvancedStartRegions");
  const iHeight = GameplayMap.getGridHeight();
  const iWidth = GameplayMap.getGridWidth();
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      let terrainString = " ";
      if (terrain == g_FlatTerrain) {
        terrainString = ".";
      } else if (terrain == g_HillTerrain) {
        terrainString = "^";
      } else if (terrain == g_MountainTerrain) {
        terrainString = "M";
      } else if (terrain == g_OceanTerrain) {
        terrainString = "~";
      }
      str += terrainString;
      const plotIndex = GameplayMap.getIndexFromXY(iX, iY);
      const player = findPlotOwner(playerRegions, plotIndex);
      if (player !== -1) {
        str += player;
      } else {
        str += " ";
      }
    }
    console.log(str);
  }
}
function findPlotOwner(playerRegions, plot) {
  for (let player = 0; player < playerRegions.length; player++) {
    if (playerRegions[player].claimedPlots.indexOf(plot) !== -1) {
      return player;
    }
  }
  return -1;
}

export { assignAdvancedStartRegions };
//# sourceMappingURL=assign-advanced-start-region.js.map
</file>

<file path="assign-starting-plots.js">
import { g_DesiredBufferBetweenMajorStarts, g_RequiredBufferBetweenMajorStarts } from './map-globals.js';
import { getSectorRegion, shuffle, isOceanAccess } from './map-utilities.js';

class PlayerRegion {
  tiles = [];
  landmassId = 0;
  regionId = 0;
  toString() {
    return `[PlayerRegion] landmassId: ${this.landmassId}, regionId: ${this.regionId}, tile count: ${this.tiles.length}`;
  }
}
class PlayerRegionScores {
  scores = [];
  totalBias = 0;
  playerId = 0;
  playerIndex = 0;
  toString() {
    return `[PlayerRegionScores] playerId: ${this.playerId} (Index: ${this.playerIndex}), totalBias: ${this.totalBias}, scores: ${this.scores}`;
  }
}
function chooseStartSectors(iNumPlayersLandmass1, iNumPlayersLandmass2, iRows, iCols, bHumanNearEquator) {
  const returnValue = [];
  const iSectorsPerContinent = iRows * iCols;
  let iPlayersWestContinent = iNumPlayersLandmass1;
  let iPlayersEastContinent = iNumPlayersLandmass2;
  let iMaxNumMajors = 0;
  iMaxNumMajors = iPlayersWestContinent + iPlayersEastContinent;
  const aliveMajorIds = Players.getAliveMajorIds();
  const humanPlayers = [];
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
      humanPlayers.push(iMajorIndex);
    }
  }
  const numHumans = humanPlayers.length;
  const maxSide = Math.max(iPlayersWestContinent, iPlayersEastContinent);
  if (numHumans > maxSide) {
    const half = Math.floor(iMaxNumMajors / 2);
    iPlayersWestContinent = half;
    iPlayersEastContinent = iMaxNumMajors - half;
    iNumPlayersLandmass1 = iPlayersWestContinent;
    iNumPlayersLandmass2 = iPlayersEastContinent;
  }
  if (iNumPlayersLandmass1 == 1 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [[0], [1], [2], [3], [4], [5]];
    var validConfigs2 = [
      [0, 3, 4],
      [1, 2, 5]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 1) {
    var validConfigs1 = [
      [0, 3, 4],
      [1, 2, 5]
    ];
    var validConfigs2 = [[0], [1], [2], [3], [4], [5]];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 2) {
    var validConfigs1 = [
      [0, 2, 6, 8],
      [1, 3, 5, 7]
    ];
    var validConfigs2 = [
      [0, 8],
      [2, 6]
    ];
  } else if (iNumPlayersLandmass1 == 2 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 8],
      [2, 6]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8],
      [1, 3, 5, 7]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6, 8]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [3, 5, 7],
      [4, 6, 8]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 5) {
    var validConfigs1 = [
      [3, 5, 7],
      [4, 6, 8]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
    var validConfigs2 = [
      [1, 3, 5, 7],
      [4, 6, 8, 10]
    ];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 6) {
    var validConfigs1 = [
      [1, 3, 5, 7],
      [4, 6, 8, 10]
    ];
    var validConfigs2 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 2 && iNumPlayersLandmass2 == 2) {
    var validConfigs1 = [
      [0, 5],
      [1, 4]
    ];
    var validConfigs2 = [
      [0, 5],
      [1, 4]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [
      [0, 2, 7],
      [1, 6, 8]
    ];
    var validConfigs2 = [
      [0, 2, 7],
      [1, 6, 8]
    ];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 2, 6, 8],
      [3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8],
      [3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 5) {
    var validConfigs1 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 6) {
    var validConfigs1 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 8 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6, 8, 9, 11]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6]];
    var validConfigs2 = [[]];
  } else {
    console.log("THIS SHOULD NOT BE HIT IN STARTING POSITION");
    var validConfigs1 = [[0], [1], [2], [3], [4], [5]];
    var validConfigs2 = [
      [0, 2, 4],
      [1, 3, 5]
    ];
  }
  let iWestContinentConfig = validConfigs1.length - 1;
  if (!bHumanNearEquator)
    iWestContinentConfig = TerrainBuilder.getRandomNumber(validConfigs1.length, "West Continent Start Positions");
  for (let i = 0; i < iSectorsPerContinent; i++) {
    let bFoundIt = false;
    for (let j = 0; j < iPlayersWestContinent; j++) {
      if (i == validConfigs1[iWestContinentConfig][j]) {
        bFoundIt = true;
        break;
      }
    }
    returnValue[i] = bFoundIt;
  }
  let iEastContinentConfig = validConfigs2.length - 1;
  if (!bHumanNearEquator)
    iEastContinentConfig = TerrainBuilder.getRandomNumber(validConfigs2.length, "East Continent Start Positions");
  for (let i = 0; i < iSectorsPerContinent; i++) {
    let bFoundIt = false;
    for (let j = 0; j < iPlayersEastContinent; j++) {
      if (i == validConfigs2[iEastContinentConfig][j]) {
        bFoundIt = true;
        break;
      }
    }
    returnValue[i + iSectorsPerContinent] = bFoundIt;
  }
  return returnValue;
}
function assignStartPositions(iNumWest, iNumEast, west, east, iStartSectorRows, iStartSectorCols, sectors) {
  console.log("Assigning Starting Positions");
  const startPositions = [];
  console.log("iStartSectorRows: " + iStartSectorRows);
  console.log("iStartSectorCols: " + iStartSectorCols);
  console.log("iNumWest: " + iNumWest);
  console.log("iNumEast: " + iNumEast);
  let iMaxNumMajors = 0;
  iMaxNumMajors = iNumWest + iNumEast;
  console.log("iMaxNumMajors: " + iMaxNumMajors);
  let bEastBias = false;
  if (iNumEast > iNumWest) {
    console.log("EastSide");
    bEastBias = true;
  }
  const aliveMajorIds = Players.getAliveMajorIds();
  if (iMaxNumMajors < aliveMajorIds.length) {
    console.log("The input total is less than the total alive majors: " + aliveMajorIds.length);
  }
  const humanPlayers = [];
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
      humanPlayers.push(iMajorIndex);
    }
  }
  let iNumberHomelands = 0;
  let bHumansLargestLandmass = GameInfo.Ages.lookup(Game.age).HumanPlayersPrimaryHemisphere;
  if (bEastBias && iNumEast < humanPlayers.length) {
    bHumansLargestLandmass = false;
  } else if (!bEastBias && iNumWest < humanPlayers.length) {
    bHumansLargestLandmass = false;
  }
  if (bHumansLargestLandmass) {
    if (bEastBias) {
      iNumberHomelands = iNumEast;
    } else {
      iNumberHomelands = iNumWest;
    }
  } else {
    iNumberHomelands = (iNumWest + iNumEast) / 2;
  }
  const [iHomeLandmassRegionId, iDistantLandmassRegionId] = bEastBias ? [LandmassRegion.LANDMASS_REGION_EAST, LandmassRegion.LANDMASS_REGION_WEST] : [LandmassRegion.LANDMASS_REGION_WEST, LandmassRegion.LANDMASS_REGION_EAST];
  const homelandStartRegions = [];
  const distantStartRegions = [];
  let bAssignStartPositionsBySector = true;
  if (iStartSectorRows == 0 || iStartSectorCols == 0) {
    bAssignStartPositionsBySector = false;
  } else {
    bAssignStartPositionsBySector = checkStartSectorsViable(
      west,
      east,
      iStartSectorRows,
      iStartSectorCols,
      sectors
    );
  }
  if (bAssignStartPositionsBySector) {
    console.log("Using Sector-based Assignments");
    for (let iSector = 0; iSector < sectors.length; iSector++) {
      if (sectors[iSector] == true) {
        const region = getSectorRegion(
          iSector,
          iStartSectorRows,
          iStartSectorCols,
          east.south,
          east.north,
          west.west,
          west.east,
          east.west
        );
        const bEastHemis = iSector >= sectors.length / 2;
        let szHeading;
        if (bEastHemis == bEastBias) {
          homelandStartRegions.push(region);
          szHeading = "HOMELAND START REGION:";
        } else {
          distantStartRegions.push(region);
          szHeading = "DISTANT START REGION:";
        }
        console.log(szHeading);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("Start Sector: " + iSector);
      }
    }
  } else {
    console.log("Using Areas of Equal Fertility");
    const iMinMajorFertility = 25;
    const iMinMinorFertility = 5;
    {
      const iLeftCol = bEastBias ? east.west : west.west;
      const iRightCol = bEastBias ? east.east : west.east;
      StartPositioner.initializeValues();
      StartPositioner.divideMapIntoMajorRegions(
        iNumberHomelands,
        iMinMajorFertility,
        iMinMinorFertility,
        iLeftCol,
        iRightCol,
        PlotTags.PLOT_TAG_NONE,
        iHomeLandmassRegionId
      );
      console.log("Divided map into major regions for Homelands");
      for (let iRegion = 0; iRegion < iNumberHomelands; iRegion++) {
        homelandStartRegions[iRegion] = StartPositioner.getMajorStartRegion(iRegion);
        console.log("HOMELAND START REGION: " + iRegion);
        console.log("West: " + homelandStartRegions[iRegion].west);
        console.log("East: " + homelandStartRegions[iRegion].east);
        console.log("North: " + homelandStartRegions[iRegion].north);
        console.log("South: " + homelandStartRegions[iRegion].south);
        console.log("Continent: " + homelandStartRegions[iRegion].continent);
      }
    }
    {
      const iLeftCol = bEastBias ? west.west : east.west;
      const iRightCol = bEastBias ? west.east : east.east;
      StartPositioner.initializeValues();
      StartPositioner.divideMapIntoMajorRegions(
        iMaxNumMajors - iNumberHomelands,
        iMinMajorFertility,
        iMinMinorFertility,
        iLeftCol,
        iRightCol,
        PlotTags.PLOT_TAG_NONE,
        iDistantLandmassRegionId
      );
      console.log("Divided map into major regions for Distant Lands");
      for (let iRegion = 0; iRegion < iMaxNumMajors - iNumberHomelands; iRegion++) {
        distantStartRegions[iRegion] = StartPositioner.getMajorStartRegion(iRegion);
        console.log("DISTANT START REGION: " + iRegion);
        console.log("West: " + distantStartRegions[iRegion].west);
        console.log("East: " + distantStartRegions[iRegion].east);
        console.log("North: " + distantStartRegions[iRegion].north);
        console.log("South: " + distantStartRegions[iRegion].south);
        console.log("Continent: " + distantStartRegions[iRegion].continent);
      }
    }
  }
  const homelandPlayers = [];
  const distantPlayers = [];
  if (bHumansLargestLandmass) {
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
        homelandPlayers.push(iMajorIndex);
      }
    }
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length && Players.isAI(aliveMajorIds[iMajorIndex])) {
        if (homelandPlayers.length < iNumberHomelands) {
          homelandPlayers.push(iMajorIndex);
        } else {
          distantPlayers.push(iMajorIndex);
        }
      }
    }
    shuffle(homelandPlayers);
    shuffle(distantPlayers);
  } else {
    const tempPlayers = [];
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length) {
        console.log("Found real major at: " + aliveMajorIds[iMajorIndex]);
        tempPlayers.push(iMajorIndex);
      }
    }
    shuffle(tempPlayers);
    for (let i = 0; i < tempPlayers.length; i++) {
      if (homelandPlayers.length < iNumberHomelands) {
        homelandPlayers.push(tempPlayers[i]);
      } else {
        distantPlayers.push(tempPlayers[i]);
      }
    }
  }
  console.log("homelandPlayers: " + homelandPlayers.length);
  console.log("homelandStartRegions: " + homelandStartRegions.length);
  console.log("distantPlayers: " + distantPlayers.length);
  console.log("distantStartRegions: " + distantStartRegions.length);
  console.log("Update homelandPlayers:");
  updateRegionsForStartBias(homelandPlayers, homelandStartRegions);
  console.log("Update distantPlayers:");
  updateRegionsForStartBias(distantPlayers, distantStartRegions);
  for (let i = 0; i < homelandPlayers.length; i++) {
    const iStartPosition = homelandPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    const plotIndex = pickStartPlot(
      homelandStartRegions[i],
      i,
      playerId,
      false,
      startPositions,
      void 0,
      iHomeLandmassRegionId
    );
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  for (let i = 0; i < distantPlayers.length; i++) {
    const iStartPosition = distantPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    const plotIndex = pickStartPlot(
      distantStartRegions[i],
      i + homelandPlayers.length,
      playerId,
      false,
      startPositions,
      void 0,
      iDistantLandmassRegionId
    );
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  return startPositions;
}
function assignStartPositionsFromTiles(playerRegions) {
  console.log("Assigning Starting Positions");
  if (playerRegions.length === 0) {
    console.error("empty array passed to assignStartPositionsFromTiles()");
    return [];
  }
  const landmassRegions = /* @__PURE__ */ new Map();
  for (const region of playerRegions) {
    let regions = landmassRegions.get(region.landmassId) ?? [];
    regions.push(region.regionId);
    landmassRegions.set(region.landmassId, regions);
  }
  let largestLandmassId = -1;
  let largestTileCount = 0;
  for (const [id, lr] of landmassRegions) {
    const lrTileCount = lr.reduce((sum, regionId) => sum + playerRegions[regionId].tiles.length, 0);
    if (lrTileCount > largestTileCount) {
      largestTileCount = lrTileCount;
      largestLandmassId = id;
    }
  }
  const totalPlayers = playerRegions.length;
  console.log(
    `Largest landmass is region ${largestLandmassId} with ${landmassRegions.get(largestLandmassId).length} players and ${largestTileCount} total tiles.`
  );
  console.log(`Total players: ${totalPlayers}`);
  const aliveMajorIds = Players.getAliveMajorIds();
  let aliveMajorIndices = [...aliveMajorIds.keys()];
  if (totalPlayers !== aliveMajorIds.length) {
    console.log(`The input player total ${totalPlayers} is not equal to the alive majors: ${aliveMajorIds.length}`);
  }
  const regionGetter = {
    count: playerRegions.length,
    getTileCoords: function* (regionId) {
      for (const tile of playerRegions[regionId].tiles) yield [tile.x, tile.y];
    }
  };
  const playerRegionScores = getRegionScoresPerPlayer(aliveMajorIndices, regionGetter);
  console.log("Player region scores:");
  playerRegionScores.forEach((prs) => console.log(prs));
  const humanPlayerIndices = aliveMajorIndices.filter((index) => Players.isHuman(aliveMajorIds[index]));
  let bHumansTogether = humanPlayerIndices.length > 1 && GameInfo.Ages.lookup(Game.age).HumanPlayersPrimaryHemisphere && humanPlayerIndices.length <= landmassRegions.get(largestLandmassId).length;
  let regionPlayerBias = new Array(playerRegions.length).fill(-1);
  const assignPlayerBiases = (playerIndices, regions) => {
    for (const playerIndex of playerIndices) {
      let bestId = -1;
      let bestScore = -1;
      for (const regionId of regions) {
        const regionScore = playerRegionScores[playerIndex].scores[regionId];
        if (regionScore > bestScore && regionPlayerBias[regionId] == -1) {
          bestId = regionId;
          bestScore = regionScore;
        }
      }
      regionPlayerBias[bestId] = playerIndex;
    }
  };
  if (bHumansTogether) {
    console.log("Placing humans on same landmass.");
    aliveMajorIndices = aliveMajorIndices.filter((index) => !Players.isHuman(aliveMajorIds[index]));
    const regionsOnLargestLandmass = landmassRegions.get(largestLandmassId);
    humanPlayerIndices.sort((a, b) => playerRegionScores[b].totalBias - playerRegionScores[a].totalBias);
    assignPlayerBiases(humanPlayerIndices, regionsOnLargestLandmass);
  }
  aliveMajorIndices.sort((a, b) => playerRegionScores[b].totalBias - playerRegionScores[a].totalBias);
  console.log(`Sorted indices: ${aliveMajorIndices}`);
  assignPlayerBiases(
    aliveMajorIndices,
    playerRegions.map((v) => v.regionId)
  );
  console.log(`Player region biases:`);
  for (const [regionId, playerIndex] of regionPlayerBias.entries()) {
    const bestScore = playerRegionScores[playerIndex].scores.reduce((best, cur) => Math.max(best, cur), -1);
    const playerId = playerRegionScores[playerIndex].playerId;
    console.log(
      `  Player Id ${playerId} assigned to region ${regionId} with score ${playerRegionScores[playerIndex].scores[regionId]} (best score possible is ${bestScore})`
    );
  }
  let found = 0;
  let startPositions = new Array(regionPlayerBias.length);
  for (const [regionId, playerIndex] of regionPlayerBias.entries()) {
    const playerId = aliveMajorIds[playerIndex];
    const playerTiles = playerRegions[regionId].tiles;
    console.log(
      `Searching ${playerTiles.length} tiles in region ${regionId} (landmass ${playerRegions[regionId].landmassId}) for player ${playerId} (${Players.isHuman(playerId) ? "human" : "ai"})`
    );
    const plotIndex = pickStartPlotByTile(playerTiles, -1, found, playerId, false, startPositions);
    ++found;
    if (plotIndex >= 0) {
      startPositions[playerId] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  return startPositions;
}
function assignSingleContinentStartPositions(iNumPlayers, primaryLandmass, iStartSectorRows, iStartSectorCols, sectors) {
  console.log("Assigning Starting Positions");
  const startPositions = [];
  console.log("iStartSectorRows: " + iStartSectorRows);
  console.log("iStartSectorCols: " + iStartSectorCols);
  let iMaxNumMajors = 0;
  iMaxNumMajors = iNumPlayers;
  console.log("iMaxNumMajors: " + iMaxNumMajors);
  const aliveMajorIds = Players.getAliveMajorIds();
  if (iMaxNumMajors < aliveMajorIds.length) {
    console.log("The input total is less than the total alive majors: " + aliveMajorIds.length);
  }
  const homelandPlayers = [];
  const homelandStartRegions = [];
  let bAssignStartPositionsBySector = true;
  if (iStartSectorRows == 0 || iStartSectorCols == 0) {
    bAssignStartPositionsBySector = false;
  } else {
    bAssignStartPositionsBySector = checkStartSectorsViable(
      primaryLandmass,
      primaryLandmass,
      iStartSectorRows,
      iStartSectorCols,
      sectors
    );
  }
  if (bAssignStartPositionsBySector) {
    console.log("Using Sector-based Assignments");
    for (let iSector = 0; iSector < sectors.length; iSector++) {
      if (sectors[iSector] == true) {
        const region = getSectorRegion(
          iSector,
          iStartSectorRows,
          iStartSectorCols,
          primaryLandmass.south,
          primaryLandmass.north,
          primaryLandmass.west,
          primaryLandmass.east,
          primaryLandmass.west
        );
        let szHeading;
        homelandStartRegions.push(region);
        szHeading = "HOMELAND START REGION:";
        console.log(szHeading);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("Start Sector: " + iSector);
      }
    }
  } else {
    console.log("Assigning Starting Positions Across a Single Continent with Equal Fertility");
    const iMinMajorFertility = 25;
    const iMinMinorFertility = 5;
    StartPositioner.initializeValues();
    StartPositioner.divideMapIntoMajorRegions(
      iNumPlayers,
      iMinMajorFertility,
      iMinMinorFertility,
      primaryLandmass.west,
      primaryLandmass.east,
      PlotTags.PLOT_TAG_NONE,
      LandmassRegion.LANDMASS_REGION_ANY
    );
    const potentialRegions = [];
    for (let i = 0; i < iNumPlayers; i++) {
      const region = StartPositioner.getMajorStartRegion(i);
      if (region && region.east > primaryLandmass.west && region.west < primaryLandmass.east) {
        potentialRegions.push(region);
      }
    }
    potentialRegions.sort(
      (a, b) => (b.east - b.west) * (b.north - b.south) - (a.east - a.west) * (a.north - a.south)
    );
    for (const region of potentialRegions) {
      if (homelandStartRegions.length < iNumPlayers) {
        homelandStartRegions.push(region);
      }
    }
    if (homelandStartRegions.length < iNumPlayers) {
      console.log("WARNING: Not enough fertile regions found within the selected continent.");
    }
  }
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length) {
      homelandPlayers.push(iMajorIndex);
    }
  }
  shuffle(homelandPlayers);
  console.log("homelandPlayers: " + homelandPlayers.length);
  console.log("homelandStartRegions: " + homelandStartRegions.length);
  console.log("Update homelandPlayers:");
  updateRegionsForStartBias(homelandPlayers, homelandStartRegions);
  for (let i = 0; i < homelandPlayers.length; i++) {
    const iStartPosition = homelandPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    let plotIndex = pickStartPlot(homelandStartRegions[i], i, playerId, false, startPositions);
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId + " - Retrying with alternative regions.");
      for (const retryRegion of homelandStartRegions) {
        plotIndex = pickStartPlot(retryRegion, i, playerId, false, startPositions);
        if (plotIndex >= 0) {
          startPositions[iStartPosition] = plotIndex;
          StartPositioner.setStartPosition(plotIndex, playerId);
          console.log("Successfully found an alternative start position for " + playerId);
          break;
        }
      }
      if (plotIndex < 0) {
        console.log("FAILED AGAIN - NO VALID LOCATION FOUND FOR: " + playerId);
      }
    }
  }
  return startPositions;
}
function checkStartSectorsViable(west, east, iStartSectorRows, iStartSectorCols, sectors) {
  const tempStartPositions = [];
  for (let iSector = 0; iSector < sectors.length; iSector++) {
    if (sectors[iSector] == true) {
      const region = getSectorRegion(
        iSector,
        iStartSectorRows,
        iStartSectorCols,
        east.south,
        east.north,
        west.west,
        west.east,
        east.west
      );
      const startPlot = pickStartPlot(region, 0, 0, true, tempStartPositions);
      if (startPlot == -1) {
        console.log("LOW FERTILITY START SECTOR: " + iSector);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("ABORTING - Falling back to Civ VI start position assignment algorithm");
        return false;
      }
    }
  }
  return true;
}
function getRegionScoresPerPlayer(majorGroup, startRegions) {
  const biomeBiases = Array.from(
    { length: majorGroup.length },
    () => new Array(GameInfo.Biomes.length).fill(0)
  );
  const navRiverBias = new Array(majorGroup.length).fill(0);
  const NWBias = new Array(majorGroup.length).fill(0);
  const aliveMajorIds = Players.getAliveMajorIds();
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const playerId = aliveMajorIds[majorGroup[iMajorGroup]];
    const player = Players.get(playerId);
    if (player == null) {
      continue;
    }
    const uiCivType = player.civilizationType;
    const uiLeaderType = player.leaderType;
    console.log("Player Id:" + playerId + ", " + player.civilizationName + ", " + player.leaderName);
    for (let startBiomeIdx = 0; startBiomeIdx < GameInfo.StartBiasBiomes.length; startBiomeIdx++) {
      const startBiomeDef = GameInfo.StartBiasBiomes[startBiomeIdx];
      if (startBiomeDef) {
        const civString = startBiomeDef.CivilizationType;
        const ldrString = startBiomeDef.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          const biomeDef = GameInfo.Biomes.lookup(startBiomeDef.BiomeType);
          if (biomeDef) {
            const biomeIndex = biomeDef.$index;
            console.log("biomeIndex: " + biomeIndex + ", Score: " + startBiomeDef.Score);
            biomeBiases[iMajorGroup][biomeIndex] += startBiomeDef.Score;
          }
        }
      }
    }
    for (let startRiverIdx = 0; startRiverIdx < GameInfo.StartBiasTerrains.length; startRiverIdx++) {
      const startBiasTerrainDef = GameInfo.StartBiasTerrains[startRiverIdx];
      if (startBiasTerrainDef) {
        if (startBiasTerrainDef.TerrainType == "TERRAIN_NAVIGABLE_RIVER") {
          const civString = startBiasTerrainDef.CivilizationType;
          const ldrString = startBiasTerrainDef.LeaderType;
          let civHash = 0;
          let ldrHash = 0;
          if (civString != null) {
            const civObj = GameInfo.Civilizations.lookup(civString);
            if (civObj) {
              civHash = civObj.$hash;
            }
          }
          if (ldrString != null) {
            const ldrObj = GameInfo.Leaders.lookup(ldrString);
            if (ldrObj) {
              ldrHash = ldrObj.$hash;
            }
          }
          if (civHash == uiCivType || ldrHash == uiLeaderType) {
            navRiverBias[iMajorGroup] += startBiasTerrainDef.Score;
          }
        }
      }
    }
    for (let startNWIdx = 0; startNWIdx < GameInfo.StartBiasNaturalWonders.length; startNWIdx++) {
      const startBiasNWDef = GameInfo.StartBiasNaturalWonders[startNWIdx];
      if (startBiasNWDef) {
        const civString = startBiasNWDef.CivilizationType;
        const ldrString = startBiasNWDef.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          NWBias[iMajorGroup] += startBiasNWDef.Score;
        }
      }
    }
  }
  console.log("biomeBiases " + biomeBiases);
  console.log("navRiverBias " + navRiverBias);
  console.log("NWBias " + NWBias);
  const startRegionCount = Array.isArray(startRegions) ? startRegions.length : startRegions.count;
  const biomeCounts = new Array(startRegionCount);
  for (let i = 0; i < startRegionCount; i++) {
    biomeCounts[i] = [];
  }
  const navRiverCounts = [];
  const NWCounts = [];
  for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
    for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
      biomeCounts[iRegion][iBiome] = 0;
    }
    navRiverCounts[iRegion] = 0;
    NWCounts[iRegion] = 0;
  }
  for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
    let tileCount = 0;
    const processTile = (xCoord, yCoord) => {
      const biomeType = GameplayMap.getBiomeType(xCoord, yCoord);
      biomeCounts[iRegion][biomeType]++;
      if (GameplayMap.isNavigableRiver(xCoord, yCoord)) {
        navRiverCounts[iRegion]++;
      }
      if (GameplayMap.isNaturalWonder(xCoord, yCoord)) {
        NWCounts[iRegion]++;
      }
      ++tileCount;
    };
    if (Array.isArray(startRegions)) {
      const region = startRegions[iRegion];
      for (let iX = region.west; iX <= region.east; iX++) {
        for (let iY = region.south; iY <= region.north; iY++) {
          processTile(iX, iY);
        }
      }
    } else {
      for (const [iX, iY] of startRegions.getTileCoords(iRegion)) {
        processTile(iX, iY);
      }
    }
    console.log(`Processed ${tileCount} tiles in region ${iRegion}`);
  }
  console.log("biomeCounts " + biomeCounts);
  console.log("navRiverCounts " + navRiverCounts);
  console.log("NWCounts " + NWCounts);
  let regionScores = [];
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const regionScore = new PlayerRegionScores();
    regionScore.playerIndex = majorGroup[iMajorGroup];
    regionScore.playerId = aliveMajorIds[majorGroup[iMajorGroup]];
    for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
      regionScore.totalBias += biomeBiases[iMajorGroup][iBiome];
    }
    regionScore.totalBias += navRiverBias[iMajorGroup];
    regionScore.totalBias += NWBias[iMajorGroup];
    regionScores.push(regionScore);
  }
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const regionScore = regionScores[iMajorGroup];
    for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
      let regionScoreForMajor = 0;
      for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
        regionScoreForMajor += biomeBiases[iMajorGroup][iBiome] * biomeCounts[iRegion][iBiome];
      }
      regionScoreForMajor += navRiverBias[iMajorGroup] * navRiverCounts[iRegion];
      regionScoreForMajor += NWBias[iMajorGroup] * NWCounts[iRegion];
      console.log(`majorIndex ${iMajorGroup}, regionScore: ${regionScoreForMajor}`);
      regionScore.scores.push(regionScoreForMajor);
    }
  }
  return regionScores;
}
function updateRegionsForStartBias(majorGroup, startRegions) {
  const regionScores = getRegionScoresPerPlayer(majorGroup, startRegions);
  console.log(`totalMajorBiases: ${regionScores.map((v) => v.totalBias)}`);
  regionScores.sort((a, b) => b.totalBias - a.totalBias);
  console.log(`sortedMajorIndices: ${regionScores.map((v) => v.playerId)}`);
  majorGroup.fill(-1);
  for (const playerRegionScores of regionScores) {
    let iBestScore = -1;
    let iBestRegion = -1;
    for (let iRegion = 0; iRegion < playerRegionScores.scores.length; iRegion++) {
      if (majorGroup[iRegion] == -1) {
        const regionScoreForPlayer = playerRegionScores.scores[iRegion];
        if (regionScoreForPlayer > iBestScore) {
          iBestScore = regionScoreForPlayer;
          iBestRegion = iRegion;
        }
      }
    }
    if (iBestRegion >= 0) {
      majorGroup[iBestRegion] = playerRegionScores.playerIndex;
      console.log(
        `Region ${iBestRegion} is best for major: ${playerRegionScores.playerId} (index: ${playerRegionScores.playerIndex})`
      );
    }
  }
  console.log("Majors (final form):" + majorGroup);
}
function pickStartPlotByTile(tiles, continentId, numFoundEarlier, playerId, ignoreBias, startPositions, plotTagFilter, landmassRegionIdFilter) {
  let chosenPlotIndex = -1;
  let highestScore = 0;
  let passedFilter = 0;
  for (const tile of tiles) {
    const satisfiesPlotTagFilter = !plotTagFilter || plotTagFilter == PlotTags.PLOT_TAG_NONE || GameplayMap.hasPlotTag(tile.x, tile.y, plotTagFilter);
    const satisfiesLandmassRegionIdFilter = satisfiesPlotTagFilter && !landmassRegionIdFilter || landmassRegionIdFilter === LandmassRegion.LANDMASS_REGION_ANY || GameplayMap.getLandmassRegionId(tile.x, tile.y) === landmassRegionIdFilter;
    if (satisfiesPlotTagFilter && satisfiesLandmassRegionIdFilter) {
      passedFilter++;
      let score = scorePlot(tile.x, tile.y, continentId);
      if (score > 0) {
        if (!ignoreBias) {
          score += adjustScoreByStartBias(tile.x, tile.y, playerId);
        }
        if (numFoundEarlier > 0) {
          score = adjustScoreByClosestStart(score, tile.x, tile.y, startPositions);
        }
        if (score > highestScore) {
          highestScore = score;
          chosenPlotIndex = tile.y * GameplayMap.getGridWidth() + tile.x;
        }
      }
    }
  }
  console.log(`pickStartPlotByTile: checked ${tiles.length} tiles, ${passedFilter} of which passed the filter.`);
  return chosenPlotIndex;
}
function pickStartPlot(region, numFoundEarlier, playerId, ignoreBias, startPositions, plotTagFilter, landmassRegionIdFilter) {
  const tiles = [];
  for (let iY = region.south; iY <= region.north; iY++) {
    for (let iX = region.west; iX <= region.east; iX++) {
      tiles.push({ x: iX, y: iY });
    }
  }
  return pickStartPlotByTile(
    tiles,
    region.continent,
    numFoundEarlier,
    playerId,
    ignoreBias,
    startPositions,
    plotTagFilter,
    landmassRegionIdFilter
  );
}
function scorePlot(iX, iY, iContinent) {
  let score = -1;
  if (!GameplayMap.isWater(iX, iY) && !GameplayMap.isMountain(iX, iY)) {
    if (iContinent == -1 || GameplayMap.getContinentType(iX, iY) == iContinent) {
      score = StartPositioner.getStartPositionScore(iX, iY);
    }
  }
  return score;
}
function adjustScoreByClosestStart(originalScore, iX, iY, startPositions) {
  let score = originalScore;
  if (g_DesiredBufferBetweenMajorStarts <= g_RequiredBufferBetweenMajorStarts) return score;
  const distance = getDistanceToClosestStart(iX, iY, startPositions);
  if (distance < g_RequiredBufferBetweenMajorStarts) {
    score = 0;
  } else if (distance < g_DesiredBufferBetweenMajorStarts) {
    score = score * (distance - g_RequiredBufferBetweenMajorStarts + 1) / (g_DesiredBufferBetweenMajorStarts - g_RequiredBufferBetweenMajorStarts + 1);
  }
  return score;
}
function getDistanceToClosestStart(iX, iY, startPositions) {
  let minDistance = 32768;
  for (let iStart = 0; iStart < startPositions.length; iStart++) {
    const startPlotIndex = startPositions[iStart];
    if (startPlotIndex) {
      const iStartX = startPlotIndex % GameplayMap.getGridWidth();
      const iStartY = startPlotIndex / GameplayMap.getGridWidth();
      const distance = GameplayMap.getPlotDistance(iX, iY, iStartX, iStartY);
      if (distance < minDistance) {
        minDistance = distance;
      }
    }
  }
  return minDistance;
}
function adjustScoreByStartBias(iX, iY, playerId) {
  let score = 0;
  const player = Players.get(playerId);
  if (player == null || player.isAlive == false) {
    return score;
  }
  const eCivType = player.civilizationType;
  const eLeaderType = player.leaderType;
  for (let biomeIdx = 0; biomeIdx < GameInfo.StartBiasBiomes.length; biomeIdx++) {
    const startBiasCivilization = GameInfo.StartBiasBiomes[biomeIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasBiomes[biomeIdx]?.LeaderType;
    const startBiasBiome = GameInfo.StartBiasBiomes[biomeIdx]?.BiomeType;
    if (startBiasBiome) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getBiomeStartBiasScore(startBiasBiome, GameInfo.StartBiasBiomes[biomeIdx].Score, iX, iY);
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getBiomeStartBiasScore(startBiasBiome, GameInfo.StartBiasBiomes[biomeIdx].Score, iX, iY);
        }
      }
    }
  }
  for (let terrainIdx = 0; terrainIdx < GameInfo.StartBiasTerrains.length; terrainIdx++) {
    const startBiasCivilization = GameInfo.StartBiasTerrains[terrainIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasTerrains[terrainIdx]?.LeaderType;
    const startBiasTerrain = GameInfo.StartBiasTerrains[terrainIdx]?.TerrainType;
    if (startBiasTerrain) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getTerrainStartBiasScore(
            startBiasTerrain,
            GameInfo.StartBiasTerrains[terrainIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getTerrainStartBiasScore(
            startBiasTerrain,
            GameInfo.StartBiasTerrains[terrainIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let riverIdx = 0; riverIdx < GameInfo.StartBiasRivers.length; riverIdx++) {
    const startBiasCivilization = GameInfo.StartBiasRivers[riverIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasRivers[riverIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getRiverStartBiasScore(GameInfo.StartBiasRivers[riverIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getRiverStartBiasScore(GameInfo.StartBiasRivers[riverIdx].Score, iX, iY);
      }
    }
  }
  for (let coastIdx = 0; coastIdx < GameInfo.StartBiasAdjacentToCoasts.length; coastIdx++) {
    const startBiasCivilization = GameInfo.StartBiasAdjacentToCoasts[coastIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasAdjacentToCoasts[coastIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getCoastStartBiasScore(GameInfo.StartBiasAdjacentToCoasts[coastIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getCoastStartBiasScore(GameInfo.StartBiasAdjacentToCoasts[coastIdx].Score, iX, iY);
      }
    }
  }
  for (let featureIdx = 0; featureIdx < GameInfo.StartBiasFeatureClasses.length; featureIdx++) {
    const startBiasCivilization = GameInfo.StartBiasFeatureClasses[featureIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasFeatureClasses[featureIdx]?.LeaderType;
    const startBiasFeature = GameInfo.StartBiasFeatureClasses[featureIdx]?.FeatureClassType;
    if (startBiasFeature) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getFeatureClassStartBiasScore(
            startBiasFeature,
            GameInfo.StartBiasFeatureClasses[featureIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getFeatureClassStartBiasScore(
            startBiasFeature,
            GameInfo.StartBiasFeatureClasses[featureIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let resourceIdx = 0; resourceIdx < GameInfo.StartBiasResources.length; resourceIdx++) {
    const startBiasCivilization = GameInfo.StartBiasResources[resourceIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasResources[resourceIdx]?.LeaderType;
    const startBiasResource = GameInfo.StartBiasResources[resourceIdx]?.ResourceType;
    if (startBiasResource) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getResourceStartBiasScore(
            startBiasResource,
            GameInfo.StartBiasResources[resourceIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getResourceStartBiasScore(
            startBiasResource,
            GameInfo.StartBiasResources[resourceIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let lakeIdx = 0; lakeIdx < GameInfo.StartBiasLakes.length; lakeIdx++) {
    const startBiasCivilization = GameInfo.StartBiasLakes[lakeIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasLakes[lakeIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getLakeStartBiasScore(GameInfo.StartBiasLakes[lakeIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getLakeStartBiasScore(GameInfo.StartBiasLakes[lakeIdx].Score, iX, iY);
      }
    }
  }
  for (let nwIdx = 0; nwIdx < GameInfo.StartBiasNaturalWonders.length; nwIdx++) {
    const startBiasCivilization = GameInfo.StartBiasNaturalWonders[nwIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasNaturalWonders[nwIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getNaturalWonderStartBiasScore(GameInfo.StartBiasNaturalWonders[nwIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getNaturalWonderStartBiasScore(GameInfo.StartBiasNaturalWonders[nwIdx].Score, iX, iY);
      }
    }
  }
  return score;
}
function getBiomeStartBiasScore(biome, score, iX, iY) {
  const startBiasBiomeTypeIndex = GameInfo.Biomes.lookup(biome)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const biomeInfoTypeIndex = GameInfo.Biomes.lookup(GameplayMap.getBiomeType(iLocation.x, iLocation.y))?.$index;
    if (startBiasBiomeTypeIndex == biomeInfoTypeIndex) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getTerrainStartBiasScore(terrain, score, iX, iY) {
  const startBiasTerrainTypeIndex = GameInfo.Terrains.lookup(terrain)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const terrainInfoTypeIndex = GameInfo.Terrains.lookup(
      GameplayMap.getTerrainType(iLocation.x, iLocation.y)
    )?.$index;
    if (startBiasTerrainTypeIndex == terrainInfoTypeIndex) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getRiverStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isRiver(iLocation.x, iLocation.y)) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getCoastStartBiasScore(score, iX, iY) {
  let outputScore = 0;
  if (isOceanAccess(iX, iY)) {
    outputScore += score;
  }
  return outputScore;
}
function getFeatureClassStartBiasScore(feature, score, iX, iY) {
  const startBiasFeatureTypeIndex = GameInfo.FeatureClasses.lookup(feature)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const featureInfoTypeIndex = GameInfo.Features.lookup(
      GameplayMap.getFeatureType(iLocation.x, iLocation.y)
    )?.FeatureClassType;
    if (featureInfoTypeIndex) {
      const featureClassInfoTypeIndex = GameInfo.FeatureClasses.lookup(featureInfoTypeIndex)?.$index;
      if (featureClassInfoTypeIndex == startBiasFeatureTypeIndex) {
        let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
        if (distance < 1) {
          distance = 1;
        }
        outputScore += score / distance;
      }
    }
  }
  return outputScore;
}
function getResourceStartBiasScore(resource, score, iX, iY) {
  const startBiasResourceTypeIndex = GameInfo.Resources.lookup(resource)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const resourceInfoTypeIndex = GameInfo.Resources.lookup(
      GameplayMap.getResourceType(iLocation.x, iLocation.y)
    )?.$index;
    if (startBiasResourceTypeIndex == resourceInfoTypeIndex) {
      outputScore += score;
    }
  }
  return outputScore;
}
function getLakeStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isLake(iLocation.x, iLocation.y)) {
      outputScore += score;
    }
  }
  if (outputScore > 0) {
    console.log("Start Bias Score: " + outputScore);
  }
  return outputScore;
}
function getNaturalWonderStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isNaturalWonder(iLocation.x, iLocation.y)) {
      outputScore += score;
    }
  }
  if (outputScore > 0) {
    console.log("Start Bias Score: " + outputScore);
  }
  return outputScore;
}

export { PlayerRegion, PlayerRegionScores, assignSingleContinentStartPositions, assignStartPositions, assignStartPositionsFromTiles, chooseStartSectors };
//# sourceMappingURL=assign-starting-plots.js.map
</file>

<file path="continents-plus.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoastsPlus, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpTerrain, dumpContinents, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_OceanWaterColumns, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, createIslands, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, createOrganicLandmasses, markLandmassRegionId, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script continents-plus.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  let naturalWonderEvent = false;
  const requestedNaturalWonders = [];
  let liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_RACE_TO_WONDERS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    naturalWonderEvent = true;
    requestedNaturalWonders.push("FEATURE_BERMUDA_TRIANGLE");
  }
  liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_MARVELOUS_MOUNTAINS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    naturalWonderEvent = true;
    requestedNaturalWonders.push("FEATURE_MOUNT_EVEREST");
  }
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  console.log(
    westContinent.west,
    ", ",
    westContinent.east,
    ", ",
    eastContinent.west,
    ", ",
    eastContinent.east,
    ", ",
    westContinent2.west,
    ", ",
    westContinent2.east,
    ", ",
    eastContinent2.west,
    ", ",
    eastContinent2.east,
    ", "
  );
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash || naturalWonderEvent;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = !naturalWonderEvent ? TerrainBuilder.getRandomNumber(2, "East or West") : 0;
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    dumpTerrain(iWidth, iHeight);
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
    dumpTerrain(iWidth, iHeight);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 15;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    dumpTerrain(iWidth, iHeight);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
    dumpTerrain(iWidth, iHeight);
  }
  markLandmassRegionId(eastContinent, LandmassRegion.LANDMASS_REGION_EAST);
  markLandmassRegionId(westContinent, LandmassRegion.LANDMASS_REGION_WEST);
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders, naturalWonderEvent, requestedNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded continents-plus.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
//# sourceMappingURL=continents-plus.js.map
</file>

<file path="continents-voronoi.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { PlayerRegion, assignStartPositionsFromTiles } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_FlatTerrain, g_MountainTerrain, g_HillTerrain, g_VolcanoFeature, g_OceanTerrain, g_CoastTerrain, g_NavigableRiverTerrain } from './map-globals.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { kdTree, TerrainType } from '../scripts/kd-tree.js';
import { VoronoiContinents } from '../scripts/voronoi_maps/continents.js';
import { RuleAvoidEdge } from '../scripts/voronoi_rules/avoid-edge.js';
import './map-utilities.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../core/scripts/MathHelpers.js';
import '../scripts/random-pcg-32.js';
import '../scripts/voronoi_generators/map-generator.js';
import '../scripts/voronoi_maps/map-common.js';
import '../scripts/voronoi-builder.js';
import '../scripts/voronoi-hex.js';
import '../scripts/heap.js';
import '../scripts/voronoi_generators/continent-generator.js';
import '../scripts/quadtree.js';
import '../scripts/voronoi-region.js';
import '../scripts/voronoi_rules/avoid-other-regions.js';
import '../scripts/voronoi_rules/rules-base.js';
import '../scripts/voronoi_rules/cell-area.js';
import '../scripts/voronoi_rules/near-map-center.js';
import '../scripts/voronoi_rules/near-neighbor.js';
import '../scripts/voronoi_rules/near-plate-boundary.js';
import '../scripts/voronoi_rules/near-region-seed.js';
import '../scripts/voronoi_rules/neighbors-in-region.js';
import '../scripts/voronoi_rules/prefer-latitude.js';

console.log("Generating using script Continents-Voronoi.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
async function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iTotalPlayers = Players.getAliveMajorIds().length;
  const startTime = Date.now();
  const voronoiMap = new VoronoiContinents();
  voronoiMap.init(mapInfo.$index);
  const rules = voronoiMap.getBuilder().getGenerator().getRules();
  for (const value of Object.values(rules)) {
    for (const rule of value) {
      if (rule.name == RuleAvoidEdge.getName()) {
        rule.configValues.poleDistance = g_PolarWaterRows;
      }
    }
  }
  const generatorSettings = voronoiMap.getBuilder().getGenerator().getSettings();
  const sizeRatio = generatorSettings.landmass[0].size / (generatorSettings.landmass[0].size + generatorSettings.landmass[1].size);
  const iNumPlayers1 = Math.round(iTotalPlayers * sizeRatio);
  const iNumPlayers2 = iTotalPlayers - iNumPlayers1;
  generatorSettings.landmass[0].playerAreas = iNumPlayers1;
  generatorSettings.landmass[1].playerAreas = iNumPlayers2;
  voronoiMap.getBuilder().simulate();
  const tiles = voronoiMap.getBuilder().getTiles();
  const landmassKdTree = new kdTree((tile) => tile.pos);
  landmassKdTree.build(tiles.flatMap((row) => row.filter((tile) => tile.landmassId > 0)));
  for (let y = 0; y < tiles.length; ++y) {
    for (let x = 0; x < tiles[y].length; ++x) {
      const tile = tiles[y][x];
      if (tile.isLand()) {
        const type = tile.terrainType === TerrainType.Flat ? g_FlatTerrain : tile.terrainType === TerrainType.Mountainous || tile.terrainType === TerrainType.Volcano ? g_MountainTerrain : tile.terrainType === TerrainType.Rough ? g_HillTerrain : g_FlatTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        if (tile.terrainType === TerrainType.Volcano) {
          TerrainBuilder.setFeatureType(x, y, {
            Feature: g_VolcanoFeature,
            Direction: -1,
            Elevation: 0
          });
        }
        if (tile.landmassId === 1) {
          TerrainBuilder.setLandmassRegionId(x, y, LandmassRegion.LANDMASS_REGION_WEST);
        } else if (tile.landmassId === 2) {
          TerrainBuilder.setLandmassRegionId(x, y, LandmassRegion.LANDMASS_REGION_EAST);
        } else {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND);
        }
      } else if (tile.isWater()) {
        const type = tile.terrainType === TerrainType.Ocean ? g_OceanTerrain : g_CoastTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        if (tile.terrainType === TerrainType.Coast) {
          const landmassTile = landmassKdTree.search(tile.pos);
          const landmassId = landmassTile?.data.landmassId ?? -1;
          if (landmassId === 1) {
            TerrainBuilder.setLandmassRegionId(x, y, LandmassRegion.LANDMASS_REGION_WEST);
          } else if (landmassId === 2) {
            TerrainBuilder.setLandmassRegionId(x, y, LandmassRegion.LANDMASS_REGION_EAST);
          } else {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND);
          }
        }
      }
    }
  }
  const endTime = Date.now();
  console.log(`Initial Voronoi map generation took ${endTime - startTime} ms`);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  let startPositions = [];
  const fertilityGetter = (tile) => StartPositioner.getPlotFertilityForCoord(tile.coord.x, tile.coord.y);
  voronoiMap.getBuilder().createMajorPlayerAreas(fertilityGetter);
  const playerRegions = Array.from({ length: iTotalPlayers }, () => new PlayerRegion());
  playerRegions.forEach((region, index) => region.regionId = index);
  console.log(`Creating player regions.. initializing indices: ${playerRegions.map((pr) => pr.regionId)}`);
  let offset = 0;
  const offsets = [0].concat([...generatorSettings.landmass.map((n) => offset += n.playerAreas)]);
  for (const row of tiles) {
    for (const tile of row) {
      if (tile.majorPlayerRegionId >= 0 && tile.landmassId > 0) {
        const regionId = tile.majorPlayerRegionId + offsets[tile.landmassId - 1];
        const playerRegion = playerRegions[regionId];
        playerRegion.landmassId = tile.landmassId - 1;
        playerRegion.tiles.push({ x: tile.coord.x, y: tile.coord.y });
      }
    }
  }
  startPositions = assignStartPositionsFromTiles(playerRegions);
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
//# sourceMappingURL=continents-voronoi.js.map
</file>

<file path="continents.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoasts, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight, g_CoastTerrain } from './map-globals.js';
import { needHumanNearEquator, applyCoastalErosionAdjustingForStartSectors, createOrganicLandmasses, applyCoastalErosion, markLandmassRegionId, getHeightAdjustingForStartSector, getSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script Continents.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = g_OceanWaterColumns;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 18;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
  }
  markLandmassRegionId(eastContinent, LandmassRegion.LANDMASS_REGION_EAST);
  markLandmassRegionId(westContinent, LandmassRegion.LANDMASS_REGION_WEST);
  TerrainBuilder.validateAndFixTerrain();
  expandCoasts(iWidth, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded Continents.ts");
console.log("hey, continents is firing");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          if (startSectors[iSector]) {
            terrain = g_CoastTerrain;
          } else {
            terrain = g_OceanTerrain;
          }
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
//# sourceMappingURL=continents.js.map
</file>

<file path="discovery-generator.js">
import { g_OceanWaterColumns, g_RequiredDistanceFromMajorForDiscoveries, g_CoastTerrain, g_OceanTerrain } from './map-globals.js';
import { getDistanceToClosestStart } from './map-utilities.js';

function generateDiscoveries(iWidth, iHeight, startingPositions) {
  if (GameInfo.Ages.lookup(Game.age).GenerateDiscoveries == false) {
    console.log("DISCOVERIES TURNED OFF FOR " + Game.age);
    return;
  }
  if (Configuration.getGameValue("DiscoverySiftingType") == 2316276985) {
    console.log("DISCOVERIES TURNED OFF");
    return;
  }
  console.log("Discovery generation", iWidth, iHeight);
  let discoveryCounter = 0;
  let oceanDiscoveryCounter = 0;
  let discoveryPlacedCounter = 0;
  let totalCoastalDiscoveryNotPlaced = 0;
  let totalOceanDiscoveryNotPlaced = 0;
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 5;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  let distanceToClosestStart = 0;
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) {
    console.log("Skipping discoveries.  No mapInfo for map of size ", uiMapSize);
    return;
  }
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: 0,
    north: 0,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: 0,
    north: 0,
    continent: 0
  };
  function DiscoveryDiceRoller() {
    const randomthing = TerrainBuilder.getRandomNumber(100, "Discovery Type Roll");
    if (randomthing <= 65) {
      return DiscoveryActivationTypes.BASIC;
    } else if (randomthing <= 100) {
      return DiscoveryActivationTypes.INVESTIGATION;
    } else {
      return DiscoveryActivationTypes.MYTHIC;
    }
  }
  function DiscoveryVisualString(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
        return "Cave";
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
        return "Ruins";
      case DiscoveryVisualTypes.IMPROVEMENT_CAMPFIRE:
        return "Campfire";
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
        return "Tents";
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
        return "Cairn";
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
        return "Rich";
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return "Wreckage";
      default:
        return "";
    }
  }
  function DiscoveryTypeString(numb) {
    switch (numb) {
      case DiscoveryActivationTypes.BASIC:
        return "Basic";
      case DiscoveryActivationTypes.INVESTIGATION:
        return "Investigation";
      default:
        return "Unknown";
    }
  }
  function AllowedDiscoveryVisual(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAMPFIRE:
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return true;
      default:
        return false;
    }
  }
  function AllowedDiscoveryVisualExploration(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return true;
      default:
        return false;
    }
  }
  console.log("counting");
  console.log(DiscoveryVisualTypes.IMPROVEMENT_CAVE);
  const basicsMap = [];
  const investigationMap = [];
  if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
    GameInfo.DiscoverySiftingImprovements.forEach((discoverySift) => {
      if (AllowedDiscoveryVisualExploration(Database.makeHash(discoverySift.ConstructibleType))) {
        const amount = GameInfo.NarrativeStories.filter((def) => def.Queue == discoverySift.QueueType).length;
        if (amount > 0) {
          if (discoverySift.Activation === "BASIC") {
            basicsMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          } else if (discoverySift.Activation === "INVESTIGATION") {
            investigationMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          }
        }
      }
    });
  } else {
    GameInfo.DiscoverySiftingImprovements.forEach((discoverySift) => {
      if (AllowedDiscoveryVisual(Database.makeHash(discoverySift.ConstructibleType))) {
        const amount = GameInfo.NarrativeStories.filter((def) => def.Queue == discoverySift.QueueType).length;
        if (amount > 0) {
          if (discoverySift.Activation === "BASIC") {
            basicsMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          } else if (discoverySift.Activation === "INVESTIGATION") {
            investigationMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          }
        }
      }
    });
  }
  console.log("poisson number?: " + poisson);
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const iLocation = GameplayMap.getLocationFromIndex(index);
        const terrainType = GameplayMap.getTerrainType(iX, iY);
        if (startingPositions.length > 0) {
          distanceToClosestStart = getDistanceToClosestStart(
            iX,
            iY,
            startingPositions.length,
            startingPositions
          );
          if (distanceToClosestStart < g_RequiredDistanceFromMajorForDiscoveries) {
            continue;
          }
        } else {
          const owner = GameplayMap.getOwner(iX, iY);
          if (owner != PlayerIds.NO_PLAYER) {
            console.log(
              "Can't Place Discovery, tile already owned: ",
              "X=" + iLocation.x + " Y=" + iLocation.y
            );
            continue;
          }
        }
        if (GameplayMap.isImpassable(iX, iY)) {
          continue;
        }
        if (GameplayMap.isNavigableRiver(iX, iY)) {
          continue;
        }
        const resourceAtThisLocal = GameplayMap.getResourceType(iX, iY);
        if (resourceAtThisLocal !== -1) {
          continue;
        }
        if (GameplayMap.isNaturalWonder(iX, iY)) {
          continue;
        }
        if (terrainType === g_CoastTerrain && TerrainBuilder.getRandomNumber(100, "Coast Check") >= 65) {
          const discoveryType2 = DiscoveryDiceRoller();
          discoveryCounter++;
          if (MapConstructibles.addDiscovery(iX, iY, DiscoveryVisualTypes.IMPROVEMENT_COAST, discoveryType2)) {
            discoveryPlacedCounter++;
            console.log("Discovery #", discoveryCounter);
            console.log(
              "VALID coastal DISCOVERY SPOT FOUND!-------------------------------------",
              "X=" + iLocation.x + " Y=" + iLocation.y
            );
            continue;
          } else {
            ++totalCoastalDiscoveryNotPlaced;
            console.log("did not place COASTAL Discovery#: " + discoveryCounter);
            continue;
          }
        }
        if (terrainType === g_OceanTerrain) {
          if (Game.age == Database.makeHash("AGE_EXPLORATION") && TerrainBuilder.getRandomNumber(100, "Coast Check") >= 65) {
            if (iX < westContinent.west || iX > westContinent.east && iX < eastContinent.west || iX > eastContinent.east) {
              const discoveryType2 = DiscoveryDiceRoller();
              discoveryCounter++;
              if (MapConstructibles.addDiscovery(
                iX,
                iY,
                DiscoveryVisualTypes.IMPROVEMENT_SHIPWRECK,
                discoveryType2
              )) {
                discoveryPlacedCounter++;
                oceanDiscoveryCounter++;
                console.log("Discovery #", discoveryCounter);
                console.log(
                  "VALID coastal DISCOVERY SPOT FOUND!-------------------------------------",
                  "X=" + iLocation.x + " Y=" + iLocation.y
                );
                continue;
              } else {
                ++totalOceanDiscoveryNotPlaced;
                console.log("did not place OCEAN discovery#: " + discoveryCounter);
                continue;
              }
            }
          }
        }
        if (GameplayMap.isWater(iX, iY)) {
          continue;
        }
        discoveryCounter++;
        const discoveryType = DiscoveryDiceRoller();
        const discoveryTypeString = DiscoveryTypeString(discoveryType);
        let discoveryHash = DiscoveryVisualTypes.INVALID;
        let visualIndex = -1;
        if (discoveryType == DiscoveryActivationTypes.BASIC) {
          if (basicsMap.length > 0) {
            visualIndex = TerrainBuilder.getRandomNumber(basicsMap.length, "Discovery roll");
            discoveryHash = basicsMap[visualIndex][0];
          }
        } else {
          if (investigationMap.length > 0) {
            visualIndex = TerrainBuilder.getRandomNumber(investigationMap.length, "Discovery roll");
            discoveryHash = investigationMap[visualIndex][0];
          }
        }
        const discoveryVisual = DiscoveryVisualString(discoveryHash);
        if (discoveryHash == DiscoveryVisualTypes.INVALID) {
          console.log(
            "Could not find available discovery: ",
            discoveryTypeString,
            "Discovery#: ",
            discoveryCounter
          );
          continue;
        }
        if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
          console.log("in exploration age");
          console.log("Discovery #", discoveryCounter);
          console.log(
            "VALID DISCOVERY SPOT FOUND-------------------------------------",
            "X=" + iLocation.x + " Y=" + iLocation.y + "  Type: " + discoveryVisual
          );
          if (MapConstructibles.addDiscovery(iX, iY, discoveryHash, discoveryType)) {
            if (discoveryType == DiscoveryActivationTypes.BASIC) {
              --basicsMap[visualIndex][1];
              if (basicsMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                basicsMap.splice(visualIndex, 1);
              }
            } else {
              --investigationMap[visualIndex][1];
              if (investigationMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                investigationMap.splice(visualIndex, 1);
              }
            }
            discoveryPlacedCounter++;
            const discoveryX = iX;
            const discoveryY = iY;
            console.log(discoveryX, discoveryY, discoveryVisual, discoveryTypeString);
          } else {
            console.log(
              "did not place discovery#: " + discoveryCounter + " discovery visual: " + discoveryVisual + " discovery type: " + discoveryTypeString
            );
          }
        } else {
          console.log("in antiquity age");
          console.log("Discovery #", discoveryCounter);
          console.log(
            "VALID DISCOVERY SPOT FOUND-------------------------------------",
            "X=" + iLocation.x + " Y=" + iLocation.y + "  Type: " + discoveryVisual
          );
          if (MapConstructibles.addDiscovery(iX, iY, discoveryHash, discoveryType)) {
            if (discoveryType == DiscoveryActivationTypes.BASIC) {
              --basicsMap[visualIndex][1];
              if (basicsMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                basicsMap.splice(visualIndex, 1);
              }
            } else {
              --investigationMap[visualIndex][1];
              if (investigationMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                investigationMap.splice(visualIndex, 1);
              }
            }
            discoveryPlacedCounter++;
            const discoveryX = iX;
            const discoveryY = iY;
            console.log(discoveryX, discoveryY, discoveryVisual, discoveryTypeString);
          } else {
            console.log(
              "did not place discovery#: " + discoveryCounter + " discovery visual: " + discoveryVisual + " discovery type: " + discoveryTypeString
            );
          }
        }
      }
    }
  }
  console.log("Basics: ");
  for (const [key, value] of basicsMap) {
    console.log(key, "->", value);
  }
  console.log("investigations: ");
  for (const [key, value] of investigationMap) {
    console.log(key, "->", value);
  }
  console.log("Total Discoveries Placed: " + discoveryPlacedCounter);
  console.log("Total ocean Discoveries Placed: " + oceanDiscoveryCounter);
  console.log("Total Coastal Discoveries Not Placed: " + totalCoastalDiscoveryNotPlaced);
  console.log("Total Ocean Discoveries Not Placed: " + totalOceanDiscoveryNotPlaced);
  console.log("could not place this many discoveries: " + (discoveryCounter - discoveryPlacedCounter));
}

export { generateDiscoveries };
//# sourceMappingURL=discovery-generator.js.map
</file>

<file path="elevation-terrain-generator.js">
import { g_MountainFractal, g_HillFractal, g_MountainTerrain, g_FlatTerrain, g_HillTerrain, g_OceanTerrain, g_CoastTerrain, g_OceanWaterColumns, g_StandardRainfall, g_MountainTopIncrease, g_RainShadowDrop, g_RainShadowIncreasePerHex } from './map-globals.js';
import { isCliff } from './map-utilities.js';

function addMountains(iWidth, iHeight) {
  const adjustment = 3;
  let extra_mountains = 0;
  const iFlags = 0;
  const grainAmount = 5;
  const liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_MARVELOUS_MOUNTAINS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    extra_mountains = 40;
  }
  const mountains = 93 - adjustment - extra_mountains;
  FractalBuilder.create(g_MountainFractal, iWidth, iHeight, grainAmount, iFlags);
  FractalBuilder.create(g_HillFractal, iWidth, iHeight, grainAmount, iFlags);
  const iMountainThreshold = FractalBuilder.getHeightFromPercent(g_MountainFractal, mountains);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = GameplayMap.getTerrainType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false) {
        const iMountainHeight = FractalBuilder.getHeight(g_MountainFractal, iX, iY);
        if (iMountainHeight >= iMountainThreshold) {
          terrain = g_MountainTerrain;
        }
        if (terrain != g_FlatTerrain) {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      }
    }
  }
}
function addHills(iWidth, iHeight) {
  const adjustment = 3;
  const base_hills_threshold = 950;
  const extra_hills = 0;
  const hillsThreshold = base_hills_threshold - adjustment * 20 - extra_hills;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false && GameplayMap.isMountain(iX, iY) == false) {
        const iIndex = GameplayMap.getIndexFromXY(iX, iY);
        const iLocation = GameplayMap.getLocationFromIndex(iIndex);
        let iHillScore = 0;
        const iElevation = GameplayMap.getElevation(iX, iY);
        for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
          if (GameplayMap.isCliffCrossing(iX, iY, iDirection) == false) {
            const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
            const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
            const iAdjacentElevation = GameplayMap.getElevation(iAdjacentX, iAdjacentY);
            const iElevationDifference = iAdjacentElevation - iElevation;
            if (iElevationDifference > 0) {
              iHillScore = iHillScore + iElevationDifference;
            } else {
              iHillScore = iHillScore - iElevationDifference;
            }
          }
        }
        if (iHillScore > hillsThreshold) {
          TerrainBuilder.setTerrainType(iX, iY, g_HillTerrain);
        }
      }
    }
  }
}
function checkExpandCoast(iX, iY) {
  const terrain = GameplayMap.getTerrainType(iX, iY);
  if (terrain == g_OceanTerrain) {
    let adjacentToCoast = false;
    let adjacentLandmassId = 0;
    for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
      const adjacent = GameplayMap.getAdjacentPlotLocation({ x: iX, y: iY }, iDirection);
      if (GameplayMap.getTerrainType(adjacent.x, adjacent.y) == g_CoastTerrain) {
        adjacentToCoast = true;
        adjacentLandmassId = GameplayMap.getLandmassRegionId(adjacent.x, adjacent.y);
        break;
      }
    }
    if (adjacentToCoast && TerrainBuilder.getRandomNumber(4, "Shallow Water Scatter") == 0) {
      TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
      TerrainBuilder.setLandmassRegionId(iX, iY, adjacentLandmassId);
    }
  }
}
function expandCoasts(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (iX > g_OceanWaterColumns / 2 && (iX < (iWidth - g_OceanWaterColumns) / 2 || iX > (iWidth + g_OceanWaterColumns) / 2) && iX < iWidth - g_OceanWaterColumns / 2) {
        checkExpandCoast(iX, iY);
      }
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      checkExpandCoast(iX, iY);
    }
  }
}
function generateLakes(iWidth, iHeight, iTilesPerLake) {
  let iLakesAdded = 0;
  if (iTilesPerLake == 0) iTilesPerLake = 25;
  const ilakePlotRand = Math.floor(iWidth * iHeight / iTilesPerLake);
  console.log("Num Directions" + DirectionTypes.NUM_DIRECTION_TYPES);
  const lakeTiles = [];
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        if (GameplayMap.isCoastalLand(iX, iY) == false) {
          if (GameplayMap.isImpassable(iX, iY) == false) {
            const r = TerrainBuilder.getRandomNumber(ilakePlotRand, "MapGenerator AddLakes");
            if (r == 0) {
              iLakesAdded = iLakesAdded + 1;
              lakeTiles.push(...addMoreLake(iX, iY));
              lakeTiles.push({ x: iX, y: iY });
              TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
            }
          }
        }
      }
    }
  }
  if (iLakesAdded > 0) {
    console.log("Lakes Added: " + iLakesAdded);
  }
  return lakeTiles;
}
function addMoreLake(iX, iY) {
  let iLargeLakes = 0;
  const lakeTiles = [];
  const adjacentPlots = [];
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.isWater(iAdjacentX, iAdjacentY) == false) {
      if (GameplayMap.isAdjacentToShallowWater(iAdjacentX, iAdjacentY) == false) {
        if (GameplayMap.isImpassable(iAdjacentX, iAdjacentY) == false) {
          const r = TerrainBuilder.getRandomNumber(4 + iLargeLakes, "MapGenerator Enlarge Lakes");
          if (r < 3) {
            adjacentPlots.push(iAdjacentPlot);
            iLargeLakes = iLargeLakes + 1;
          }
        }
      }
    }
  }
  for (let adjacentIdx = 0; adjacentIdx < adjacentPlots.length; adjacentIdx++) {
    const x = adjacentPlots[adjacentIdx].x;
    const y = adjacentPlots[adjacentIdx].y;
    TerrainBuilder.setTerrainType(x, y, g_CoastTerrain);
    lakeTiles.push({ x, y });
  }
  return lakeTiles;
}
function buildRainfallMap(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    let iMountainXTilesAgo = -1;
    for (let iX = 0; iX < iWidth; iX++) {
      let iRainfall = g_StandardRainfall;
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (GameplayMap.isLake(iX, iY) == true) {
        TerrainBuilder.setRainfall(iX, iY, iRainfall * 2);
      } else if (GameplayMap.isWater(iX, iY) == false) {
        if (terrain == g_MountainTerrain || isCliff(iX, iY)) {
          iMountainXTilesAgo = 0;
        } else if (iMountainXTilesAgo >= 0) {
          iMountainXTilesAgo++;
        }
        if (iMountainXTilesAgo == 0) {
          iRainfall += g_MountainTopIncrease;
        } else if (iMountainXTilesAgo > 0) {
          iRainfall += g_RainShadowDrop;
          iRainfall += iMountainXTilesAgo * g_RainShadowIncreasePerHex;
          if (iRainfall > g_StandardRainfall) {
            iRainfall = g_StandardRainfall;
          }
        }
        TerrainBuilder.setRainfall(iX, iY, iRainfall);
      } else {
        iMountainXTilesAgo = -1;
      }
    }
  }
}

export { addHills, addMountains, buildRainfallMap, expandCoasts, expandCoastsPlus, generateLakes };
//# sourceMappingURL=elevation-terrain-generator.js.map
</file>

<file path="feature-biome-generator.js">
import { g_PlainsLatitude, g_MarineBiome, g_TropicalLatitude, g_PlainsBiome, g_TropicalBiome, g_DesertLatitude, g_DesertBiome, g_GrasslandLatitude, g_GrasslandBiome, g_TundraBiome } from './map-globals.js';
import { isAdjacentToNaturalWonder } from './map-utilities.js';

function designateBiomes(iWidth, iHeight) {
  console.log("Biomes");
  let iTotalLandPlots = 0;
  let iTotalLandPlotsAbove = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const latitude = GameplayMap.getPlotLatitude(iX, iY);
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots = iTotalLandPlots + 1;
      }
      if (!GameplayMap.isWater(iX, iY) && g_PlainsLatitude < latitude) {
        iTotalLandPlotsAbove = iTotalLandPlotsAbove + 1;
      }
    }
  }
  let iPlainsLowering = 0;
  let iDesertLowering = 0;
  let iGrassLowering = 0;
  let iTropicalLowering = 0;
  if (Math.round(iTotalLandPlots / 5 * 2 * 0.75) > iTotalLandPlotsAbove) {
    iPlainsLowering += 5;
    iDesertLowering += 4;
    iGrassLowering += 4;
    iTropicalLowering += 2;
    console.log(
      "Less  iTotalLandPlots: " + iTotalLandPlots + " iTotalLandPlotsAbove: " + iTotalLandPlotsAbove
    );
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY)) {
        TerrainBuilder.setBiomeType(iX, iY, g_MarineBiome);
      } else {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude;
        latitude += Math.round(GameplayMap.getElevation(iX, iY) / 120);
        if (GameplayMap.isRiver(iX, iY)) {
          latitude -= 10;
        } else if (GameplayMap.isAdjacentToRivers(iX, iY, 1)) {
          latitude -= 5;
        }
        const rainfall = GameplayMap.getRainfall(iX, iY);
        if (latitude < g_TropicalLatitude - iTropicalLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_PlainsBiome);
        } else if (latitude < g_TropicalLatitude - iTropicalLowering) {
          TerrainBuilder.setBiomeType(iX, iY, g_TropicalBiome);
        } else if (latitude < g_PlainsLatitude - iPlainsLowering || latitude < g_TropicalLatitude - iTropicalLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_PlainsBiome);
        } else if (latitude < g_DesertLatitude - iDesertLowering || latitude < g_PlainsLatitude - iPlainsLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_DesertBiome);
        } else if (latitude < g_GrasslandLatitude - iGrassLowering) {
          TerrainBuilder.setBiomeType(iX, iY, g_GrasslandBiome);
        } else {
          TerrainBuilder.setBiomeType(iX, iY, g_TundraBiome);
        }
      }
    }
  }
}
function addFeatures(iWidth, iHeight) {
  console.log("Features");
  addPositionalFeatures(iWidth, iHeight);
  scatterFeatures(iWidth, iHeight);
  addIce(iWidth, iHeight);
  addAquaticFeatures(iWidth, iHeight);
}
function addPositionalFeatures(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false && feature == FeatureTypes.NO_FEATURE && GameplayMap.isNavigableRiver(iX, iY) == false) {
        if (GameplayMap.isCoastalLand(iX, iY)) {
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              true,
              false,
              false,
              false,
              false,
              false,
              false
            )) {
              AddFeature(iX, iY, featIdx, 100, "Feature Scatter");
              break;
            }
          }
        } else if (GameplayMap.isAdjacentToRivers(iX, iY, 2)) {
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              true,
              false,
              false,
              false,
              false,
              false
            )) {
              AddFeature(iX, iY, featIdx, 100, "Feature Scatter");
              break;
            }
          }
        } else {
          if (GameplayMap.isAdjacentToRivers(iX, iY, 1)) {
            continue;
          } else if (GameplayMap.isCoastalLand(iX, iY)) {
            continue;
          }
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (!GameplayMap.isAdjacentToFeature(iX, iY, featIdx) && canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              false,
              true,
              false,
              false,
              false,
              false
            )) {
              AddFeature(iX, iY, featIdx, 100, "Feature Scatter");
              break;
            }
          }
        }
      }
    }
  }
}
function scatterFeatures(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false && feature == FeatureTypes.NO_FEATURE && GameplayMap.isNavigableRiver(iX, iY) == false) {
        for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
          if (canAddFeature(
            iX,
            iY,
            featIdx,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false
          )) {
            AddFeature(iX, iY, featIdx, 100, "Feature Scatter");
            break;
          }
        }
      }
    }
  }
}
function addAquaticFeatures(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude;
        for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
          if (canAddFeature(
            iX,
            iY,
            featIdx,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            false
          )) {
            if (GameInfo.Features[featIdx].MinLatitude <= latitude && GameInfo.Features[featIdx].MaxLatitude > latitude) {
              const iWeight = (latitude + 50) * 2;
              AddFeature(iX, iY, featIdx, iWeight, "Feature Reef");
              break;
            }
          }
        }
      }
    }
  }
  let skipPlotIndices = [];
  let skipPlot = false;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      for (let skipIndex = 0; skipIndex < skipPlotIndices.length; ++skipIndex) {
        const plot = GameplayMap.getLocationFromIndex(skipPlotIndices[skipIndex]);
        if (plot.x == iX && plot.y && iY) {
          skipPlot = true;
          break;
        }
      }
      if (!skipPlot) {
        if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
          let latitude = GameplayMap.getPlotLatitude(iX, iY);
          if (latitude < 0) latitude = -1 * latitude;
          for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              false,
              true
            )) {
              if (GameInfo.Features[featIdx].MinLatitude <= latitude && GameInfo.Features[featIdx].MaxLatitude > latitude) {
                if (shallowWaterAdjacencyCheck(iX, iY, "Feature Atoll Spawn Chance")) {
                  AddFeature(iX, iY, featIdx, 100, "Feature Atoll");
                  const neighbors = GameplayMap.getPlotIndicesInRadius(iX, iY, 1);
                  const iRollForClusterSize = TerrainBuilder.getRandomNumber(neighbors.length, "Feature Atoll Size");
                  const growthChancePercent = latitude <= 15 && latitude >= -15 ? 15 : 5;
                  for (let plotIndex = 0; plotIndex < iRollForClusterSize; ++plotIndex) {
                    const iLocation = GameplayMap.getLocationFromIndex(neighbors[plotIndex]);
                    if (canAddFeature(
                      iLocation.x,
                      iLocation.y,
                      featIdx,
                      false,
                      false,
                      false,
                      false,
                      false,
                      false,
                      false,
                      false,
                      true
                    )) {
                      if (shallowWaterAdjacencyCheck(iLocation.x, iLocation.y, "Feature Atoll Spawn Chance")) {
                        const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Atoll");
                        if (iRoll < growthChancePercent) {
                          AddFeature(iLocation.x, iLocation.y, featIdx, 30, "Feature Atoll");
                          skipPlotIndices.push(neighbors[plotIndex]);
                        }
                      }
                    }
                  }
                }
                break;
              }
            }
          }
        }
      } else {
        skipPlot = false;
        continue;
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
        for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
          if (canAddFeature(
            iX,
            iY,
            featIdx,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false
          )) {
            AddFeature(iX, iY, featIdx, 100, "Feature Lotus");
            break;
          }
        }
      }
    }
  }
}
function AddFeature(x, y, iCurrentFeatureIndex, iRandomRollMax, logMsg) {
  const iScatterChance = GameInfo.Features[iCurrentFeatureIndex].PlacementDensity;
  const iRoll = TerrainBuilder.getRandomNumber(iRandomRollMax, logMsg);
  if (iRoll < iScatterChance) {
    const featureParam = {
      Feature: iCurrentFeatureIndex,
      Direction: -1,
      Elevation: 0
    };
    TerrainBuilder.setFeatureType(x, y, featureParam);
  }
}
function shallowWaterAdjacencyCheck(x, y, log) {
  if (GameplayMap.isAdjacentToShallowWater(x, y)) {
    const spawnChance = TerrainBuilder.getRandomNumber(100, log);
    return spawnChance < 30;
  }
  return true;
}
function addIce(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude - 5;
        if (latitude > 78) {
          for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              false,
              false,
              false,
              true,
              false,
              false
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              let iScore = TerrainBuilder.getRandomNumber(100, "Feature Ice");
              iScore = iScore + latitude;
              if (GameplayMap.isAdjacentToLand(iX, iY)) {
                iScore = 0;
              }
              if (isAdjacentToNaturalWonder(iX, iY)) {
                iScore = 0;
              }
              if (iScore > iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        }
      }
    }
  }
}
function canAddFeature(iX, iY, feature, bScatterable, bRiverMouth, bCoastal, bNearRiver, bIsolated, bReef, bIce, bInLake, bOpenWaters) {
  if (!bScatterable || GameInfo.Features[feature].PlacementClass == "SCATTER") {
    if (!bRiverMouth || GameInfo.Features[feature].PlacementClass == "RIVERMOUTH") {
      if (!bCoastal || GameInfo.Features[feature].PlacementClass == "COASTAL") {
        if (!bNearRiver || GameInfo.Features[feature].PlacementClass == "NEARRIVER") {
          if (!bIsolated || GameInfo.Features[feature].PlacementClass == "ISOLATED") {
            if (!bReef || GameInfo.Features[feature].PlacementClass == "REEF") {
              if (!bInLake || GameInfo.Features[feature].PlacementClass == "IN_LAKE") {
                if (!bOpenWaters || GameInfo.Features[feature].PlacementClass == "OPEN_WATERS") {
                  if (!bIce || GameInfo.Features[feature].PlacementClass == "ICE") {
                    return TerrainBuilder.canHaveFeature(iX, iY, feature);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return false;
}

export { addFeatures, designateBiomes };
//# sourceMappingURL=feature-biome-generator.js.map
</file>

<file path="fractal.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoastsPlus, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_OceanWaterColumns, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, createIslands, createOrganicLandmasses, markLandmassRegionId, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script fractal.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 3;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 12;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  }
  markLandmassRegionId(eastContinent, LandmassRegion.LANDMASS_REGION_EAST);
  markLandmassRegionId(westContinent, LandmassRegion.LANDMASS_REGION_WEST);
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded fractal.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 3, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 13.5);
  const iBuffer2 = Math.floor(iWidth / 21);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          0,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * (g_FractalWeight + g_StartSectorWeight)) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
//# sourceMappingURL=fractal.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="map-debug-helpers.js">
import { g_FlatTerrain, g_HillTerrain, g_MountainTerrain, g_OceanTerrain, g_StandardRainfall, g_MountainTopIncrease, g_MarineBiome, g_PlainsBiome, g_DesertBiome, g_TropicalBiome, g_TundraBiome, g_GrasslandBiome } from './map-globals.js';

function dumpStartSectors(sectors) {
  for (let iX = 0; iX < sectors.length; iX++) {
    console.log(iX + ": " + sectors[iX]);
  }
}
function dumpContinents(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let terrainString = " ";
      if (GameplayMap.isWater(iX, iY) == false) {
        const continent = GameplayMap.getContinentType(iX, iY);
        if (typeof continent == "number") {
          terrainString = Math.floor(continent % 10).toString();
        }
      }
      str += terrainString + " ";
    }
    console.log(str);
  }
}
function dumpTerrain(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      let terrainString = " ";
      if (terrain == g_FlatTerrain) {
        terrainString = ".";
      } else if (terrain == g_HillTerrain) {
        terrainString = "^";
      } else if (terrain == g_MountainTerrain) {
        terrainString = "M";
      } else if (terrain == g_OceanTerrain) {
        terrainString = "~";
      }
      str += terrainString + " ";
    }
    console.log(str);
  }
}
function dumpElevation(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        const elevation = GameplayMap.getElevation(iX, iY);
        let elevationToDisplay = " ";
        const iNumToDisplay = Math.floor(elevation / 100);
        elevationToDisplay = iNumToDisplay.toString();
        str += elevationToDisplay + " ";
      } else {
        str += "  ";
      }
    }
    console.log(str);
  }
}
function dumpRainfall(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        const rainfall = GameplayMap.getRainfall(iX, iY);
        let rainfallToDisplay = " ";
        if (rainfall == g_StandardRainfall + g_MountainTopIncrease) {
          rainfallToDisplay = "D";
        } else if (rainfall == g_StandardRainfall) {
          rainfallToDisplay = "s";
        } else {
          const iNumToDisplay = Math.floor(rainfall / 10);
          rainfallToDisplay = iNumToDisplay.toString();
        }
        str += rainfallToDisplay + " ";
      } else {
        str += "  ";
      }
    }
    console.log(str);
  }
}
function dumpBiomes(iWidth, iHeight) {
  const biomes = new Array(GameInfo.Biomes.length);
  for (let biomeIdx = 0; biomeIdx < GameInfo.Biomes.length; biomeIdx++) {
    biomes[biomeIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const biome = GameplayMap.getBiomeType(iX, iY);
      let biomeString = " ";
      if (biome == g_MarineBiome) {
        biomeString = " ";
      } else if (biome == g_PlainsBiome) {
        biomeString = "_";
      } else if (biome == g_DesertBiome) {
        biomeString = ".";
      } else if (biome == g_TropicalBiome) {
        biomeString = "#";
      } else if (biome == g_TundraBiome) {
        biomeString = "*";
      } else if (biome == g_GrasslandBiome) {
        biomeString = "~";
      }
      str += biomeString + " ";
      if (typeof biome == "number") {
        biomes[biome]++;
      }
    }
    console.log(str);
  }
  for (let biomeIDx = 0; biomeIDx < GameInfo.Biomes.length; biomeIDx++) {
    let str = "";
    str += GameInfo.Biomes[biomeIDx].Name + " ( " + biomeIDx + " )  Count: " + biomes[biomeIDx];
    console.log(str);
  }
}
function getFeatureTypeIndex(name) {
  const def = GameInfo.Features.lookup(name);
  if (def) {
    return def.$index;
  }
  return -1;
}
function dumpFeatures(iWidth, iHeight) {
  console.log("Feature placement");
  const displayTypes = [
    { index: getFeatureTypeIndex("FEATURE_SAGEBRUSH_STEPPE"), ch: "P" },
    { index: getFeatureTypeIndex("FEATURE_OASIS"), ch: "O" },
    { index: getFeatureTypeIndex("FEATURE_DESERT_FLOODPLAIN_MINOR"), ch: "d" },
    { index: getFeatureTypeIndex("FEATURE_DESERT_FLOODPLAIN_NAVIGABLE"), ch: "d" },
    { index: getFeatureTypeIndex("FEATURE_FOREST"), ch: "F" },
    { index: getFeatureTypeIndex("FEATURE_MARSH"), ch: "M" },
    { index: getFeatureTypeIndex("FEATURE_GRASSLAND_FLOODPLAIN_MINOR"), ch: "g" },
    { index: getFeatureTypeIndex("FEATURE_GRASSLAND_FLOODPLAIN_NAVIGABLE"), ch: "g" },
    { index: getFeatureTypeIndex("FEATURE_REEF"), ch: "E" },
    { index: getFeatureTypeIndex("FEATURE_COLD_REEF"), ch: "E" },
    { index: getFeatureTypeIndex("FEATURE_ICE"), ch: "I" },
    { index: getFeatureTypeIndex("FEATURE_SAVANNA_WOODLAND"), ch: "T" },
    { index: getFeatureTypeIndex("FEATURE_WATERING_HOLE"), ch: "W" },
    { index: getFeatureTypeIndex("FEATURE_PLAINS_FLOODPLAIN_MINOR"), ch: "p" },
    { index: getFeatureTypeIndex("FEATURE_PLAINS_FLOODPLAIN_NAVIGABLE"), ch: "p" },
    { index: getFeatureTypeIndex("FEATURE_RAINFOREST"), ch: "R" },
    { index: getFeatureTypeIndex("FEATURE_MANGROVE"), ch: "G" },
    { index: getFeatureTypeIndex("FEATURE_TROPICAL_FLOODPLAIN_MINOR"), ch: "t" },
    { index: getFeatureTypeIndex("FEATURE_TROPICAL_FLOODPLAIN_NAVIGABLE"), ch: "t" },
    { index: getFeatureTypeIndex("FEATURE_TAIGA"), ch: "T" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_BOG"), ch: "B" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_FLOODPLAIN_MINOR"), ch: "u" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_FLOODPLAIN_NAVIGABLE"), ch: "u" },
    { index: getFeatureTypeIndex("FEATURE_VOLCANO"), ch: "%" },
    // Wonders
    { index: getFeatureTypeIndex("FEATURE_VALLEY_OF_FLOWERS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_BARRIER_REEF"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_BERMUDA_TRIANGLE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_REDWOOD_FOREST"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_GRAND_CANYON"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_GULLFOSS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_IGUAZU_FALLS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_KILIMANJARO"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_ZHANGJIAJIE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_THERA"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_TORRES_DEL_PAINE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_ULURU"), ch: "@" }
  ];
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let featureString = GameplayMap.isWater(iX, iY) == false ? "." : " ";
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (feature != FeatureTypes.NO_FEATURE) {
        for (const entry of displayTypes) {
          if (entry.index == feature) {
            featureString = entry.ch;
            break;
          }
        }
      }
      str += featureString + " ";
    }
    console.log(str);
  }
}
function dumpResources(iWidth, iHeight) {
  const resources = new Array(GameInfo.Resources.length);
  for (var resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resources[resourceIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const resource = GameplayMap.getResourceType(iX, iY);
      let resourcestring = " ";
      if (resource != ResourceTypes.NO_RESOURCE && typeof resource == "number") {
        resourcestring = resource.toString();
        resources[resource]++;
      } else {
        if (GameplayMap.isWater(iX, iY) == false) {
          resourcestring = "*";
        }
      }
      str += resourcestring + " ";
    }
    console.log(str);
  }
  let totalCount = 0;
  for (var resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    let str = "";
    str += GameInfo.Resources[resourceIdx].Name + " ( " + resourceIdx + " )  Count: " + resources[resourceIdx];
    totalCount += resources[resourceIdx];
    console.log(str);
  }
  console.log("Total resources on map after generation: " + totalCount);
}
function dumpNoisePredicate(iWidth, iHeight, noise, pred) {
  console.log("NOISE MAP (Predicate)");
  if (!pred) {
    console.log("dumpNoiseInterp error: no predicate provided");
    return;
  }
  if (noise.length != iWidth * iHeight) {
    console.log("dumpNoiseInterp error: noise map does not match map width*height");
    return;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      str += pred(noise[index]);
    }
    console.log(str);
  }
}

export { dumpBiomes, dumpContinents, dumpElevation, dumpFeatures, dumpNoisePredicate, dumpRainfall, dumpResources, dumpStartSectors, dumpTerrain };
//# sourceMappingURL=map-debug-helpers.js.map
</file>

<file path="map-globals.js">
const g_MountainTerrain = GameInfo.Terrains.find(
  (t) => t.TerrainType == "TERRAIN_MOUNTAIN"
).$index;
const g_HillTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_HILL").$index;
const g_FlatTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_FLAT").$index;
const g_CoastTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_COAST").$index;
const g_OceanTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_OCEAN").$index;
const g_NavigableRiverTerrain = GameInfo.Terrains.find(
  (t) => t.TerrainType == "TERRAIN_NAVIGABLE_RIVER"
).$index;
const g_TundraBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TUNDRA").$index;
const g_GrasslandBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_GRASSLAND").$index;
const g_PlainsBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_PLAINS").$index;
const g_TropicalBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TROPICAL").$index;
const g_DesertBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_DESERT").$index;
const g_MarineBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_MARINE").$index;
const g_VolcanoFeature = GameInfo.Features.find((t) => t.FeatureType == "FEATURE_VOLCANO").$index;
let temp;
let g_GrasslandLatitude = 0;
let g_PlainsLatitude = 0;
let g_DesertLatitude = 0;
let g_TropicalLatitude = 0;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_GRASSLAND").MaxLatitude;
if (temp) g_GrasslandLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_PLAINS").MaxLatitude;
if (temp) g_PlainsLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_DESERT").MaxLatitude;
if (temp) g_DesertLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TROPICAL").MaxLatitude;
if (temp) g_TropicalLatitude = temp;
const g_LandmassFractal = 0;
const g_MountainFractal = 1;
const g_HillFractal = 2;
const g_PolarWaterRows = 2;
const g_OceanWaterColumns = 4;
const g_FractalWeight = 0.8;
const g_WaterPercent = 20;
const g_IgnoreStartSectorPctFromCtr = 93;
const g_StartSectorWeight = 0.5;
const g_CenterWeight = 0.7;
const g_CenterExponent = 1.5;
const g_Cutoff = 2;
const g_AvoidSeamOffset = 2;
const g_IslandWidth = 5;
const g_StandardRainfall = 100;
const g_MountainTopIncrease = 100;
const g_RainShadowDrop = -80;
const g_RainShadowIncreasePerHex = 10;
const g_RequiredBufferBetweenMajorStarts = 6;
const g_DesiredBufferBetweenMajorStarts = 12;
const g_RequiredDistanceFromMajorForDiscoveries = 3;

export { g_AvoidSeamOffset, g_CenterExponent, g_CenterWeight, g_CoastTerrain, g_Cutoff, g_DesertBiome, g_DesertLatitude, g_DesiredBufferBetweenMajorStarts, g_FlatTerrain, g_FractalWeight, g_GrasslandBiome, g_GrasslandLatitude, g_HillFractal, g_HillTerrain, g_IgnoreStartSectorPctFromCtr, g_IslandWidth, g_LandmassFractal, g_MarineBiome, g_MountainFractal, g_MountainTerrain, g_MountainTopIncrease, g_NavigableRiverTerrain, g_OceanTerrain, g_OceanWaterColumns, g_PlainsBiome, g_PlainsLatitude, g_PolarWaterRows, g_RainShadowDrop, g_RainShadowIncreasePerHex, g_RequiredBufferBetweenMajorStarts, g_RequiredDistanceFromMajorForDiscoveries, g_StandardRainfall, g_StartSectorWeight, g_TropicalBiome, g_TropicalLatitude, g_TundraBiome, g_VolcanoFeature, g_WaterPercent };
//# sourceMappingURL=map-globals.js.map
</file>

<file path="map-utilities.js">
import { g_LandmassFractal, g_CenterExponent, g_IgnoreStartSectorPctFromCtr, g_FlatTerrain, g_OceanTerrain } from './map-globals.js';

function needHumanNearEquator() {
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  let iPlayerCount = 0;
  if (mapInfo) iPlayerCount = mapInfo.PlayersLandmass1 + mapInfo.PlayersLandmass2;
  for (let iPlay = 0; iPlay < iPlayerCount; iPlay++) {
    if (Players.getEverAlive()[iPlay] && Players.getEverAlive()[iPlay].isHuman) {
      const uiCivType = Players.getEverAlive()[iPlay].civilizationType;
      const uiLeaderType = Players.getEverAlive()[iPlay].leaderType;
      for (let startBiomeIdx = 0; startBiomeIdx < GameInfo.StartBiasBiomes.length; startBiomeIdx++) {
        const civString = GameInfo.StartBiasBiomes[startBiomeIdx]?.CivilizationType;
        const ldrString = GameInfo.StartBiasBiomes[startBiomeIdx]?.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null && GameInfo.Civilizations.lookup(civString) != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null && GameInfo.Leaders.lookup(ldrString) != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          const szBiome = GameInfo.StartBiasBiomes[startBiomeIdx].BiomeType;
          console.log(szBiome);
          if (szBiome == "BIOME_TROPICAL") {
            console.log("Human player needing a Tropical start.");
            return true;
          }
        }
      }
    }
  }
  return false;
}
function getMinimumResourcePlacementModifier() {
  const mapSizeInfo = GameInfo.Maps.lookup(GameplayMap.getMapSize());
  if (mapSizeInfo == null) return;
  let iMapMinimumModifer = 0;
  const mapType = Configuration.getMapValue("Name");
  for (const option of GameInfo.MapResourceMinimumAmountModifier) {
    if (option.MapType === mapType && option.MapSizeType == mapSizeInfo.MapSizeType) {
      iMapMinimumModifer = option.Amount;
      break;
    }
  }
  if (iMapMinimumModifer == 0) {
    for (const option of GameInfo.MapResourceMinimumAmountModifier) {
      if (option.MapType === "DEFAULT" && option.MapSizeType == mapSizeInfo.MapSizeType) {
        iMapMinimumModifer = option.Amount;
        console.log(
          "Using default map size for resuource placemtn, please update the table for this map type. Modifer is " + iMapMinimumModifer + " by default."
        );
        break;
      }
    }
  }
  return iMapMinimumModifer;
}
function getDistanceFromContinentCenter(iX, iY, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol, iEastContinentRightCol) {
  let iContinentLeftEdge = iWestContinentLeftCol;
  let iContinentRightEdge = iWestContinentRightCol;
  if (iX >= iEastContinentLeftCol) {
    iContinentLeftEdge = iEastContinentLeftCol;
    iContinentRightEdge = iEastContinentRightCol;
  }
  const iContinentHeight = iContinentTopRow - iContinentBottomRow;
  const iContinentWidth = iContinentRightEdge - iContinentLeftEdge;
  const iContinentCenterX = iContinentLeftEdge + iContinentWidth / 2;
  const iContinentCenterY = iContinentBottomRow + iContinentHeight / 2;
  const iDistance = GameplayMap.getPlotDistance(iX, iY, iContinentCenterX, iContinentCenterY);
  return iDistance;
}
function getMaxDistanceFromContinentCenter(iX, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol, iEastContinentRightCol) {
  let iContinentLeftEdge = iWestContinentLeftCol;
  let iContinentRightEdge = iWestContinentRightCol;
  if (iX >= iEastContinentLeftCol) {
    iContinentLeftEdge = iEastContinentLeftCol;
    iContinentRightEdge = iEastContinentRightCol;
  }
  const iContinentHeight = iContinentTopRow - iContinentBottomRow;
  const iContinentWidth = iContinentRightEdge - iContinentLeftEdge;
  const iContinentCenterX = iContinentLeftEdge + iContinentWidth / 2;
  const iContinentCenterY = iContinentBottomRow + iContinentHeight / 2;
  const iDistance = GameplayMap.getPlotDistance(
    iContinentLeftEdge,
    iContinentBottomRow,
    iContinentCenterX,
    iContinentCenterY
  );
  return iDistance;
}
function getSector(iX, iY, iRows, iCols, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol) {
  let iContinentBase = 0;
  if (iX >= iEastContinentLeftCol) {
    iContinentBase += iRows * iCols;
    iX = iX - iEastContinentLeftCol + iWestContinentLeftCol;
  }
  const iXSector = Math.floor(
    (iX - iWestContinentLeftCol) / ((iWestContinentRightCol - iWestContinentLeftCol) / iCols)
  );
  const iYSector = Math.floor(
    (iY - iContinentBottomRow) / ((iContinentTopRow - iContinentBottomRow) / iRows)
  );
  const iSector = iYSector * iCols + iXSector;
  const iReturnValue = iContinentBase + iSector;
  return iReturnValue;
}
function getSectorRegion(iSector, iRows, iCols, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol) {
  const region = { west: 0, east: 0, south: 0, north: 0, continent: 0 };
  if (iCols == 0) return region;
  const bIsEastContinent = iSector >= iRows * iCols;
  let iSectorAdjust = 0;
  if (bIsEastContinent) {
    iSectorAdjust = iRows * iCols;
  }
  const row = Math.floor((iSector - iSectorAdjust) / iCols);
  const col = Math.floor(iSector - iSectorAdjust - row * iCols);
  const iSectorWidth = (iWestContinentRightCol - iWestContinentLeftCol) / iCols;
  const iSectorHeight = (iContinentTopRow - iContinentBottomRow) / iRows;
  let iXAdjust = iWestContinentLeftCol;
  if (bIsEastContinent) {
    iXAdjust = iEastContinentLeftCol;
  }
  region.west = Math.floor(iXAdjust + iSectorWidth * col);
  region.east = Math.floor(iXAdjust + iSectorWidth * (col + 1));
  region.south = Math.floor(iContinentBottomRow + iSectorHeight * row);
  region.north = Math.floor(iContinentBottomRow + iSectorHeight * (row + 1));
  region.continent = -1;
  return region;
}
function getHeightAdjustingForStartSector(iX, iY, iWaterHeight, iFractalWeight, iCenterWeight, iStartSectorWeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  let iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
  iPlotHeight *= iFractalWeight;
  const iDistanceFromCenter = getDistanceFromContinentCenter(
    iX,
    iY,
    continent1.south,
    continent1.north,
    continent1.west,
    continent1.east,
    continent2.west,
    continent2.east
  );
  const iMaxDistanceFromCenter = getMaxDistanceFromContinentCenter(
    iX,
    continent1.south,
    continent1.north,
    continent1.west,
    continent1.east,
    continent2.west,
    continent2.east
  );
  const iPercentFromCenter = Math.min(100 * iDistanceFromCenter / iMaxDistanceFromCenter, 100);
  iPlotHeight += iCenterWeight * Math.pow(iWaterHeight * (100 - iPercentFromCenter) / 100, g_CenterExponent);
  if (iPercentFromCenter < g_IgnoreStartSectorPctFromCtr) {
    const iSector = getSector(
      iX,
      iY,
      iStartSectorRows,
      iStartSectorCols,
      continent1.south,
      continent1.north,
      continent1.west,
      continent1.east,
      continent2.west
    );
    if (startSectors[iSector]) {
      const sectorCenterX = (continent1.west + continent1.east) / 2;
      const sectorCenterY = (continent1.south + continent1.north) / 2;
      const distanceToSectorCenter = Math.sqrt((iX - sectorCenterX) ** 2 + (iY - sectorCenterY) ** 2);
      const maxSectorRadius = Math.min(continent1.east - continent1.west, continent1.north - continent1.south) / 3;
      const sectorBoostFactor = 1 - Math.pow(Math.min(distanceToSectorCenter / maxSectorRadius, 1), 1.5);
      iPlotHeight += iStartSectorWeight * iWaterHeight * sectorBoostFactor;
      if (iPercentFromCenter < g_IgnoreStartSectorPctFromCtr * 2 / 3) {
        iPlotHeight += iStartSectorWeight * iWaterHeight;
      }
    }
    if (iStartSectorCols > 2 && iStartSectorRows > 2) {
      let iTestSector = iSector;
      if (iTestSector >= iStartSectorRows * iStartSectorCols) {
        iTestSector = iSector - iStartSectorRows * iStartSectorCols;
      }
      if (iTestSector % iStartSectorCols > 0 && iTestSector % iStartSectorCols < iStartSectorCols - 1) {
        if (iTestSector >= iStartSectorCols && iTestSector < iStartSectorRows * iStartSectorCols - iStartSectorCols) {
          iPlotHeight += iCenterWeight * iWaterHeight;
        }
      }
    }
  }
  return iPlotHeight;
}
function createIslands(iWidth, iHeight, continent1, continent2, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iBuffer = Math.floor(iWidth / 24);
  const terrain = g_FlatTerrain;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      if (iY >= continent1.south + iRandom && iY <= continent1.north - iRandom && (iX >= continent1.west && iX <= continent1.east || iX >= continent2.west && iX <= continent2.east)) {
        const iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
        if (iPlotHeight > iWaterHeight) {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
          TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
        }
      }
    }
  }
}
function applyCoastalErosion(continent, strength, falloff, minRadiusFactor, verticalOnly) {
  console.log(
    `Applying Coastal Erosion with strength ${strength} to continent at (${continent.west}, ${continent.east})`
  );
  const centerX = (continent.west + continent.east) / 2;
  const centerY = (continent.south + continent.north) / 2;
  const maxRadiusY = (continent.north - continent.south) / 2;
  const maxRadius = verticalOnly ? maxRadiusY : Math.min(continent.east - continent.west, continent.north - continent.south) / 2;
  const minRadius = maxRadius * minRadiusFactor;
  const erosionTiles = [];
  for (let iY = continent.south; iY <= continent.north; iY++) {
    for (let iX = continent.west; iX <= continent.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) continue;
      let distance = 0;
      if (verticalOnly) {
        distance = Math.abs(iY - (continent.south + continent.north) / 2);
      } else {
        distance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);
      }
      if (distance <= minRadius) continue;
      const erosionFactor = distance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;
      const erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;
      const randomChance = TerrainBuilder.getRandomNumber(100, "Coastal Erosion") / 100;
      if (randomChance < erosionThreshold) {
        erosionTiles.push({ x: iX, y: iY });
      }
    }
  }
  const expandedErosion = /* @__PURE__ */ new Set();
  function addErosionTile(x, y) {
    const key = `${x},${y}`;
    if (!expandedErosion.has(key)) {
      expandedErosion.add(key);
      TerrainBuilder.setTerrainType(x, y, g_OceanTerrain);
    }
  }
  for (const tile of erosionTiles) {
    addErosionTile(tile.x, tile.y);
    const expansionChance = TerrainBuilder.getRandomNumber(100, "Erosion Expansion") / 100;
    if (expansionChance < 0.7) {
      const neighbors = [
        { x: tile.x + 1, y: tile.y },
        { x: tile.x - 1, y: tile.y },
        { x: tile.x, y: tile.y + 1 },
        { x: tile.x, y: tile.y - 1 }
      ];
      for (const neighbor of neighbors) {
        if (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== g_OceanTerrain) {
          addErosionTile(neighbor.x, neighbor.y);
        }
      }
    }
  }
  console.log("Coastal Erosion Applied.");
}
function applyCoastalErosionAdjustingForStartSectors(continent1, continent2, strength, falloff, minRadiusFactor, iStartSectorRows, iStartSectorCols, startSectors) {
  console.log(
    `Applying Coastal Erosion Ajdusting for Start Sectors with strength ${strength} to continent at (${continent1.west}, ${continent1.east})`
  );
  const centerX = (continent1.west + continent1.east) / 2;
  const centerY = (continent1.south + continent1.north) / 2;
  const maxRadius = Math.min(continent1.east - continent1.west, continent1.north - continent1.south) / 2;
  const minRadius = maxRadius * minRadiusFactor;
  const erosionTiles = [];
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) continue;
      let distance = 0;
      distance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);
      if (distance <= minRadius) continue;
      const erosionFactor = distance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;
      let erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;
      const randomChance = TerrainBuilder.getRandomNumber(100, "Coastal Erosion") / 100;
      const iSector = getSector(
        iX,
        iY,
        iStartSectorRows,
        iStartSectorCols,
        continent1.south,
        continent1.north,
        continent1.west,
        continent1.east,
        continent2.west
      );
      if (startSectors[iSector]) {
        if (!isNearContinentCorner(iX, iY, continent1, 0.1)) {
          erosionThreshold = erosionThreshold / 10;
        }
      }
      if (randomChance < erosionThreshold) {
        erosionTiles.push({ x: iX, y: iY });
      }
    }
  }
  function isNearContinentCorner(iX, iY, continent, bufferScale) {
    const continentWidth = continent.east - continent.west;
    const continentHeight = continent.north - continent.south;
    const bufferX = Math.max(2, Math.min(Math.floor(continentWidth * bufferScale), 10));
    const bufferY = Math.max(2, Math.min(Math.floor(continentHeight * bufferScale), 10));
    const topLeft = { x: continent.west, y: continent.north };
    const topRight = { x: continent.east, y: continent.north };
    const bottomLeft = { x: continent.west, y: continent.south };
    const bottomRight = { x: continent.east, y: continent.south };
    function isNearCorner(cornerX, cornerY) {
      return Math.abs(iX - cornerX) <= bufferX && Math.abs(iY - cornerY) <= bufferY;
    }
    return isNearCorner(topLeft.x, topLeft.y) || isNearCorner(topRight.x, topRight.y) || isNearCorner(bottomLeft.x, bottomLeft.y) || isNearCorner(bottomRight.x, bottomRight.y);
  }
  const expandedErosion = /* @__PURE__ */ new Set();
  function addErosionTile(x, y) {
    const key = `${x},${y}`;
    if (!expandedErosion.has(key)) {
      expandedErosion.add(key);
      TerrainBuilder.setTerrainType(x, y, g_OceanTerrain);
    }
  }
  for (const tile of erosionTiles) {
    addErosionTile(tile.x, tile.y);
    const expansionChance = TerrainBuilder.getRandomNumber(100, "Erosion Expansion") / 100;
    if (expansionChance < 0.7) {
      const neighbors = [
        { x: tile.x + 1, y: tile.y },
        { x: tile.x - 1, y: tile.y },
        { x: tile.x, y: tile.y + 1 },
        { x: tile.x, y: tile.y - 1 }
      ];
      for (const neighbor of neighbors) {
        if (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== g_OceanTerrain) {
          addErosionTile(neighbor.x, neighbor.y);
        }
      }
    }
  }
  console.log("Coastal Erosion Applied.");
}
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = TerrainBuilder.getRandomNumber(currentIndex, "Array Shuffle");
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}
function getContinentEdgeHeightBump(iX, iY) {
  if (GameplayMap.findSecondContinent(iX, iY, 1)) {
    return 100;
  } else if (GameplayMap.findSecondContinent(iX, iY, 2)) {
    return 40;
  } else if (GameplayMap.findSecondContinent(iX, iY, 3)) {
    return 20;
  }
  return 0;
}
function getDistanceToClosestStart(iX, iY, numFoundEarlier, startPositions) {
  let minDistance = 32768;
  for (let iStart = 0; iStart < numFoundEarlier; iStart++) {
    const startPlotIndex = startPositions[iStart];
    const iStartX = startPlotIndex % GameplayMap.getGridWidth();
    const iStartY = Math.floor(startPlotIndex / GameplayMap.getGridWidth());
    const distance = GameplayMap.getPlotDistance(iX, iY, iStartX, iStartY);
    if (distance < minDistance) {
      minDistance = distance;
    }
  }
  return minDistance;
}
function isAdjacentToNaturalWonder(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    if (GameplayMap.isNaturalWonder(iAdjacentX, iAdjacentY)) {
      return true;
    }
  }
  return false;
}
function isCliff(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    if (GameplayMap.isCliffCrossing(iX, iY, iDirection) == false) {
      return true;
    }
  }
  return false;
}
function isOceanAccess(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentIndex = GameplayMap.getIndexFromXY(iAdjacentX, iAdjacentY);
    if (GameplayMap.getRiverType(iAdjacentX, iAdjacentY) == RiverTypes.RIVER_NAVIGABLE && MapRivers.isRiverConnectedToOcean(iAdjacentIndex)) {
      return true;
    }
    if (GameplayMap.getAreaId(iAdjacentX, iAdjacentY) > -1 && GameplayMap.getAreaIsWater(iAdjacentX, iAdjacentY) && AreaBuilder.isAreaConnectedToOcean(GameplayMap.getAreaId(iAdjacentX, iAdjacentY))) {
      return true;
    }
  }
  return false;
}
function removeRuralDistrict(iX, iY) {
  const districtID = MapCities.getDistrict(iX, iY);
  if (districtID != null) {
    const cityID = MapCities.getCity(iX, iY);
    if (cityID != null) {
      const city = Cities.get(cityID);
      if (city != null) {
        if (city.location.x != iX || city.location.y != iY) {
          console.log("Removed district at (" + iX + ", " + iY + ")");
          city.Districts?.removeDistrict(districtID);
        }
      }
    }
  }
}
function placeRuralDistrict(iX, iY) {
  const cityID = MapCities.getCity(iX, iY);
  if (cityID != null) {
    const city = Cities.get(cityID);
    if (city != null) {
      if (city.location.x != iX || city.location.y != iY) {
        console.log("Placed district at (" + iX + ", " + iY + ")");
        city.Growth?.claimPlot({ x: iX, y: iY });
      }
    }
  }
}
function replaceIslandResources(iWidth, iHeight, zResourceClassType) {
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resources = [];
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    const resourceInfo = GameInfo.Resources.lookup(resourceIdx);
    if (resourceInfo && resourceInfo.Tradeable) {
      if (GameInfo.Resources.lookup(resourceIdx)?.ResourceClassType == zResourceClassType) {
        resources.push(resourceIdx);
      }
      resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
    }
    resourceRunningWeight[resourceIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {
        const resourceAtLocation = GameplayMap.getResourceType(iX, iY);
        if (resourceAtLocation != ResourceTypes.NO_RESOURCE) {
          if (resources.length > 0) {
            let resourceChosen = ResourceTypes.NO_RESOURCE;
            let resourceChosenIndex = 0;
            for (let iI = 0; iI < resources.length; iI++) {
              if (resources[iI] != resourceAtLocation) {
                if (ResourceBuilder.canHaveResource(iX, iY, resources[iI], true)) {
                  if (resourceChosen == ResourceTypes.NO_RESOURCE) {
                    resourceChosen = resources[iI];
                    resourceChosenIndex = resources[iI];
                  } else {
                    if (resourceRunningWeight[resources[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                      resourceChosen = resources[iI];
                      resourceChosenIndex = resources[iI];
                    } else if (resourceRunningWeight[resources[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                      const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                      if (iRoll >= 1) {
                        resourceChosen = resources[iI];
                        resourceChosenIndex = resources[iI];
                      }
                    }
                  }
                }
              }
            }
            if (resourceChosen != ResourceTypes.NO_RESOURCE) {
              const iResourcePlotIndex = GameplayMap.getIndexFromXY(iX, iY);
              if (iResourcePlotIndex != -1) {
                removeRuralDistrict(iX, iY);
                ResourceBuilder.setResourceType(iX, iY, ResourceTypes.NO_RESOURCE);
                ResourceBuilder.setResourceType(iX, iY, resourceChosen);
                placeRuralDistrict(iX, iY);
                resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
                const oldName = GameInfo.Resources.lookup(resourceAtLocation)?.Name;
                const name = GameInfo.Resources.lookup(resourceChosenIndex)?.Name;
                console.log("Replaced " + Locale.compose(oldName) + " at (" + iX + ", " + iY + ")");
                console.log("Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")");
              } else {
                console.log("Resource Index Failure");
              }
            } else {
              console.log("No valid resource replacement");
            }
          }
        }
      }
    }
  }
}
function isAdjacentToLand(iX, iY) {
  if (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {
    return true;
  } else {
    for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
      const iIndex = GameplayMap.getIndexFromXY(iX, iY);
      const iLocation = GameplayMap.getLocationFromIndex(iIndex);
      const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
      const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
      if (GameplayMap.hasPlotTag(iAdjacentX, iAdjacentY, PlotTags.PLOT_TAG_ISLAND)) {
        return true;
      }
    }
  }
  return false;
}
function shiftTerrain(iWidth, iHeight) {
  let shift_x = 0;
  let shift_y = 0;
  shift_x = determineXShift(iWidth, iHeight);
  shift_y = determineYShift(iWidth, iHeight);
  console.log("shift_x: " + shift_x);
  console.log("shift_y: ", shift_y);
  shiftPlotTypesBy(iWidth, iHeight, shift_x, shift_y);
}
function shiftPlotTypesBy(iWidth, iHeight, xshift, yshift) {
  if (xshift > 0 || yshift > 0) {
    const iTempTerrainArray = Array(iWidth).fill(g_OceanTerrain).map((_) => Array(iHeight));
    for (let iX = 0; iX < iWidth; iX++) {
      for (let iY = 0; iY < iHeight; iY++) {
        iTempTerrainArray[iX][iY] = GameplayMap.getTerrainType(iX, iY);
      }
    }
    for (let iDestX = 0; iDestX < iWidth; iDestX++) {
      for (let iDestY = 0; iDestY < iHeight; iDestY++) {
        const iSourceX = (iDestX + xshift) % iWidth;
        const iSourceY = (iDestY + yshift) % iHeight;
        const iTerrain = iTempTerrainArray[iSourceX][iSourceY];
        TerrainBuilder.setTerrainType(iDestX, iDestY, iTerrain);
      }
    }
  }
}
function determineXShift(iWidth, iHeight) {
  const waterTotals = [];
  for (let iX = 0; iX < iWidth; iX++) {
    let colWaterCount = 0;
    for (let iY = 0; iY < iHeight; iY++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain) {
        colWaterCount = colWaterCount + 1;
      }
    }
    waterTotals.push(colWaterCount);
  }
  const columnGroups = [];
  const groupRadius = Math.floor(iWidth / 10);
  for (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {
    let currentGroupTotal = 0;
    for (let currentCol = columnIndex - groupRadius; currentCol <= columnIndex + groupRadius; currentCol++) {
      const currentIdx = (currentCol + iWidth) % iWidth;
      currentGroupTotal = currentGroupTotal + waterTotals[currentIdx];
    }
    columnGroups.push(currentGroupTotal);
  }
  let bestValue = 0;
  let bestGroup = 0;
  for (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {
    if (columnGroups[columnIndex] > bestValue) {
      bestValue = columnGroups[columnIndex];
      bestGroup = columnIndex;
    }
  }
  const x_shift = bestGroup;
  return x_shift;
}
function determineYShift(iWidth, iHeight) {
  const waterTotals = [];
  for (let iY = 0; iY < iHeight; iY++) {
    let rowWaterCount = 0;
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain) {
        rowWaterCount = rowWaterCount + 1;
      }
    }
    waterTotals.push(rowWaterCount);
  }
  const rowGroups = [];
  const groupRadius = Math.floor(iHeight / 15);
  for (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {
    let currentGroupTotal = 0;
    for (let currentRow = rowIndex - groupRadius; currentRow <= rowIndex + groupRadius; currentRow++) {
      const currentIdx = (currentRow + iHeight) % iHeight;
      currentGroupTotal = currentGroupTotal + waterTotals[currentIdx];
    }
    rowGroups.push(currentGroupTotal);
  }
  let bestValue = 0;
  let bestGroup = 0;
  for (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {
    if (rowGroups[rowIndex] > bestValue) {
      bestValue = rowGroups[rowIndex];
      bestGroup = rowIndex;
    }
  }
  const y_shift = bestGroup;
  return y_shift;
}
function createOrganicLandmasses(iWidth, iHeight, continent1, continent2, iFractalGrain, iWaterPercent, iLargestContinentPercent) {
  let bLargeEnoughFound = false;
  while (!bLargeEnoughFound) {
    let iFlags = 0;
    iFlags = 1;
    iFlags += 2;
    FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iFractalGrain, iFlags);
    const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iWaterPercent);
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        let terrain = g_OceanTerrain;
        const iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
        if (iPlotHeight >= iWaterHeight) {
          terrain = g_FlatTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
    shiftTerrain(iWidth, iHeight);
    let iTilesChoppedInGutter = 0;
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        if (GameplayMap.getTerrainType(iX, iY) != g_OceanTerrain) {
          if (iY < continent1.south || iY >= continent1.north) {
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iY == continent1.south || iY == continent1.north - 1) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
          if (iX < continent1.west || iX > continent2.east - 1) {
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iX == continent1.west || iX == continent2.east - 1) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
          if (iX > continent1.east - 1 && iX < continent2.west) {
            iTilesChoppedInGutter = iTilesChoppedInGutter + 1;
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iX == continent1.east - 1 || iX == continent2.west) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
        }
      }
    }
    console.log("Tiles in Center Gutter:" + iTilesChoppedInGutter);
    const iMaxTilesToChop = iHeight * (continent2.west - continent1.east) / 2;
    console.log("Max Tiles to Chop: " + iMaxTilesToChop);
    if (iTilesChoppedInGutter >= iMaxTilesToChop) {
      console.log("Fail. Too many tiles lost in center gutter");
    } else {
      AreaBuilder.recalculateAreas();
      const iAreaID = AreaBuilder.findBiggestArea(false);
      const iPlotCount = AreaBuilder.getPlotCount(iAreaID);
      console.log("Plots in Largest Landmass:" + iPlotCount);
      const iPlotsNeeded = iWidth * iHeight * iLargestContinentPercent / 100;
      console.log("Plots Needed:" + iPlotsNeeded);
      if (iPlotCount >= iPlotsNeeded) {
        console.log("Useable continent found");
        bLargeEnoughFound = true;
      }
    }
  }
}
function clearContinent(continent) {
  for (let iY = continent.south; iY <= continent.north; iY++) {
    for (let iX = continent.west; iX <= continent.east; iX++) {
      const terrain = g_OceanTerrain;
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function markLandmassRegionId(continent, id) {
  for (let iY = continent.south; iY <= continent.north; iY++) {
    for (let iX = continent.west; iX <= continent.east; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) != g_OceanTerrain) {
        TerrainBuilder.setLandmassRegionId(iX, iY, id);
      }
    }
  }
}

export { applyCoastalErosion, applyCoastalErosionAdjustingForStartSectors, clearContinent, createIslands, createOrganicLandmasses, determineXShift, determineYShift, getContinentEdgeHeightBump, getDistanceFromContinentCenter, getDistanceToClosestStart, getHeightAdjustingForStartSector, getMaxDistanceFromContinentCenter, getMinimumResourcePlacementModifier, getSector, getSectorRegion, isAdjacentToLand, isAdjacentToNaturalWonder, isCliff, isOceanAccess, markLandmassRegionId, needHumanNearEquator, placeRuralDistrict, removeRuralDistrict, replaceIslandResources, shiftPlotTypesBy, shiftTerrain, shuffle };
//# sourceMappingURL=map-utilities.js.map
</file>

<file path="natural-wonder-generator.js">
import { shuffle } from './map-utilities.js';
import './map-globals.js';

function addNaturalWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive = false, requestedWonders = []) {
  if (GameInfo.Feature_NaturalWonders.length < iNumNaturalWonders) {
    iNumNaturalWonders = GameInfo.Feature_NaturalWonders.length;
  }
  console.log("Generating " + iNumNaturalWonders + " Natural Wonders");
  if (wonderEventActive) {
    console.log("Race to wonders event registered");
  }
  placeWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive, requestedWonders);
}
function placeWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive, requestedWonders) {
  let aPossibleWonders = [];
  let iPlacedWonders = 0;
  const requests = [];
  const configRequests = Configuration.getMapValue("RequestedNaturalWonders");
  if (configRequests) {
    for (const requested of configRequests) {
      if (typeof requested == "string") {
        requests.push(Database.makeHash(requested));
      } else if (typeof requested == "number") {
        requests.push(requested);
      }
    }
  }
  for (const nwDef of GameInfo.Feature_NaturalWonders) {
    if (requestedWonders.includes(nwDef.FeatureType)) {
      requests.push(nwDef.$hash);
    }
    aPossibleWonders.push(nwDef.$hash);
  }
  if (aPossibleWonders.length > 0) {
    aPossibleWonders = shuffle(aPossibleWonders);
    for (const requested of requests) {
      const index = aPossibleWonders.indexOf(requested);
      if (index >= 1) {
        aPossibleWonders.splice(index, 1);
        aPossibleWonders.unshift(requested);
      }
    }
    for (let iI = 0; iI < aPossibleWonders.length; iI++) {
      if (iPlacedWonders < iNumNaturalWonders) {
        const eFeature = aPossibleWonders[iI];
        const nwDef = GameInfo.Feature_NaturalWonders.lookup(eFeature);
        if (nwDef != null) {
          if (nwDef.PlaceFirst == true) {
            const aPossibleLocations = [];
            for (let iY = iHeight - 1; iY >= 0; iY--) {
              for (let iX = 0; iX < iWidth; iX++) {
                const iElevation = GameplayMap.getElevation(iX, iY);
                const featureParam = {
                  Feature: eFeature,
                  Direction: nwDef.Direction,
                  Elevation: iElevation
                };
                if (TerrainBuilder.canHaveFeatureParam(iX, iY, featureParam)) {
                  if (wonderEventActive) {
                    if (GameplayMap.getHemisphere(iX) != GameplayMap.getPrimaryHemisphere()) {
                      aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                    }
                  } else {
                    aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                  }
                }
              }
            }
            if (aPossibleLocations.length > 0) {
              const randomIndex = TerrainBuilder.getRandomNumber(
                aPossibleLocations.length,
                "Natural Wonder placement location"
              );
              const placementLocation = GameplayMap.getLocationFromIndex(
                aPossibleLocations[randomIndex]
              );
              const iElevation = GameplayMap.getElevation(placementLocation.x, placementLocation.y);
              const featureParam = {
                Feature: eFeature,
                Direction: nwDef.Direction,
                Elevation: iElevation
              };
              console.log("FeatureParam Elevation: " + featureParam.Elevation);
              TerrainBuilder.setFeatureType(placementLocation.x, placementLocation.y, featureParam);
              iPlacedWonders++;
              console.log(
                "Placed A Top Priority Natural Wonder " + nwDef.FeatureType + " At X:" + placementLocation.x + " Y:" + placementLocation.y + " out of " + aPossibleLocations.length + " possible locations."
              );
            } else {
              console.log("No valid location for " + nwDef.FeatureType);
            }
          }
        }
      }
    }
    for (let iI = 0; iI < aPossibleWonders.length; iI++) {
      if (iPlacedWonders < iNumNaturalWonders) {
        const eFeature = aPossibleWonders[iI];
        const nwDef = GameInfo.Feature_NaturalWonders.lookup(eFeature);
        if (nwDef != null && nwDef.PlaceFirst == false) {
          let iPlacementPercent = nwDef.PlacementPercentage;
          if (requests.indexOf(eFeature) != -1) {
            iPlacementPercent = 100;
            console.log(nwDef.FeatureType + " is requested to be placed.");
          }
          const iRoll = TerrainBuilder.getRandomNumber(100, "Random Natural Wonder Chance");
          if (iPlacementPercent > iRoll) {
            const aPossibleLocations = [];
            for (let iY = iHeight - 1; iY >= 0; iY--) {
              for (let iX = 0; iX < iWidth; iX++) {
                const iElevation = GameplayMap.getElevation(iX, iY);
                const featureParam = {
                  Feature: eFeature,
                  Direction: nwDef.Direction,
                  Elevation: iElevation
                };
                if (TerrainBuilder.canHaveFeatureParam(iX, iY, featureParam)) {
                  if (wonderEventActive) {
                    if (GameplayMap.getHemisphere(iX) != GameplayMap.getPrimaryHemisphere()) {
                      aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                    }
                  } else {
                    aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                  }
                }
              }
            }
            if (aPossibleLocations.length > 0) {
              const randomIndex = TerrainBuilder.getRandomNumber(
                aPossibleLocations.length,
                "Natural Wonder placement location"
              );
              const placementLocation = GameplayMap.getLocationFromIndex(
                aPossibleLocations[randomIndex]
              );
              const iElevation = GameplayMap.getElevation(placementLocation.x, placementLocation.y);
              const featureParam = {
                Feature: eFeature,
                Direction: nwDef.Direction,
                Elevation: iElevation
              };
              console.log("FeatureParam Elevation: " + featureParam.Elevation);
              TerrainBuilder.setFeatureType(placementLocation.x, placementLocation.y, featureParam);
              iPlacedWonders++;
              console.log(
                "Placed A Natural Wonder " + nwDef.FeatureType + " At X:" + placementLocation.x + " Y:" + placementLocation.y + " out of " + aPossibleLocations.length + " possible locations."
              );
            } else {
              console.log("No valid location for " + nwDef.FeatureType);
            }
          }
        }
      }
    }
  }
}

export { addNaturalWonders };
//# sourceMappingURL=natural-wonder-generator.js.map
</file>

<file path="pangaea-plus.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignSingleContinentStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoastsPlus, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, createIslands, applyCoastalErosionAdjustingForStartSectors, createOrganicLandmasses, applyCoastalErosion, markLandmassRegionId, replaceIslandResources, getHeightAdjustingForStartSector, clearContinent } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script pangaea-plus.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iNumPlayers1 = mapInfo.PlayersLandmass1;
  const iNumPlayers2 = mapInfo.PlayersLandmass2;
  const bWestDominant = TerrainBuilder.getRandomNumber(2, "Choose Dominant Hemisphere") === 0;
  console.log(`Dominant Landmass: ${bWestDominant ? "West (80%)" : "East (80%)"}`);
  let westContinent;
  let westContinent2;
  let eastContinent;
  let eastContinent2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  if (bWestDominant) {
    westContinent2 = {
      west: g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.1),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    westContinent = {
      west: westContinent2.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.8) - g_AvoidSeamOffset,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent = {
      west: westContinent.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.9),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent2 = {
      west: eastContinent.east,
      east: iWidth - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
  } else {
    westContinent2 = {
      west: g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.1),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    westContinent = {
      west: westContinent2.east,
      east: Math.floor(iWidth * 0.2) - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent = {
      west: westContinent.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.8),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent2 = {
      west: eastContinent.east + g_AvoidSeamOffset * 2,
      east: iWidth - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
  }
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const ISLAND_COVERAGE_TARGET = 0.04;
  const totalTiles = iWidth * iHeight;
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced && totalTiles != 0) {
    console.log("Balanced Map");
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createPrimaryLandmass(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      bWestDominant,
      iOceanWaterColumns
    );
    if (bWestDominant) {
      createSecondaryLandmass(iWidth, iHeight, eastContinent, eastContinent2);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 4);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 5);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      applyCoastalErosionAdjustingForStartSectors(
        westContinent,
        eastContinent,
        0.1,
        1.5,
        0.8,
        iStartSectorRows,
        iStartSectorCols,
        startSectors
      );
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    } else {
      createSecondaryLandmass(iWidth, iHeight, westContinent, westContinent2);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 4);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 5);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      applyCoastalErosionAdjustingForStartSectors(
        eastContinent,
        westContinent,
        0.1,
        1.5,
        0.8,
        iStartSectorRows,
        iStartSectorCols,
        startSectors
      );
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    }
  } else if (totalTiles != 0) {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 30;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    if (bWestDominant) {
      createSecondaryLandmass(iWidth, iHeight, eastContinent, eastContinent2);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 4);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      applyCoastalErosion(westContinent, 0.15, 1.5, 0.8, false);
      applyCoastalErosion(eastContinent, 0.01, 1.5, 0.8, true);
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    } else {
      createSecondaryLandmass(iWidth, iHeight, westContinent, westContinent2);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 4);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      applyCoastalErosion(westContinent, 0.01, 1.5, 0.8, true);
      applyCoastalErosion(eastContinent, 0.15, 1.5, 0.8, false);
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    }
    applyCoastalErosion(westContinent2, 0.01, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.01, 1.5, 0.8, true);
  }
  markLandmassRegionId(bWestDominant ? westContinent : eastContinent, 1);
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpStartSectors(startSectors);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  if (bWestDominant) {
    generateResources(iWidth, iHeight);
    startPositions = assignSingleContinentStartPositions(
      iNumPlayers1 + iNumPlayers2,
      westContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  } else {
    generateResources(iWidth, iHeight);
    startPositions = assignSingleContinentStartPositions(
      iNumPlayers1 + iNumPlayers2,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  }
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded pangaea-plus.ts");
function createPrimaryLandmass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createSecondaryLandmass(iWidth, iHeight, continent1, continent2) {
  console.log("Generating secondary landmass as small islands...");
  clearContinent(continent1);
  clearContinent(continent2);
  createIslands(iWidth, iHeight, continent1, continent2, 4);
  createIslands(iWidth, iHeight, continent1, continent2, 6);
  createIslands(iWidth, iHeight, continent1, continent2, 6);
}
function countIslandTiles(iWidth, iHeight) {
  let islandCount = 0;
  for (let y = 0; y < iHeight; y++) {
    for (let x = 0; x < iWidth; x++) {
      if (GameplayMap.hasPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND)) {
        islandCount++;
      }
    }
  }
  return islandCount;
}
//# sourceMappingURL=pangaea-plus.js.map
</file>

<file path="pangaea-voronoi.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { PlayerRegion, assignStartPositionsFromTiles } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_FlatTerrain, g_MountainTerrain, g_HillTerrain, g_VolcanoFeature, g_OceanTerrain, g_CoastTerrain, g_NavigableRiverTerrain } from './map-globals.js';
import { replaceIslandResources } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { kdTree, TerrainType } from '../scripts/kd-tree.js';
import { VoronoiPangaea } from '../scripts/voronoi_maps/pangaea.js';
import { RuleAvoidEdge } from '../scripts/voronoi_rules/avoid-edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../core/scripts/MathHelpers.js';
import '../scripts/random-pcg-32.js';
import '../scripts/voronoi_generators/map-generator.js';
import '../scripts/voronoi_maps/map-common.js';
import '../scripts/voronoi-builder.js';
import '../scripts/voronoi-hex.js';
import '../scripts/heap.js';
import '../scripts/voronoi_generators/continent-generator.js';
import '../scripts/quadtree.js';
import '../scripts/voronoi-region.js';
import '../scripts/voronoi_rules/avoid-other-regions.js';
import '../scripts/voronoi_rules/rules-base.js';
import '../scripts/voronoi_rules/cell-area.js';
import '../scripts/voronoi_rules/near-map-center.js';
import '../scripts/voronoi_rules/near-neighbor.js';
import '../scripts/voronoi_rules/near-plate-boundary.js';
import '../scripts/voronoi_rules/near-region-seed.js';
import '../scripts/voronoi_rules/neighbors-in-region.js';
import '../scripts/voronoi_rules/prefer-latitude.js';

console.log("Generating using script pangaea-voronoi.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iTotalPlayers = Players.getAliveMajorIds().length;
  const startTime = Date.now();
  const voronoiMap = new VoronoiPangaea();
  voronoiMap.init(mapInfo.$index);
  const rules = voronoiMap.getBuilder().getGenerator().getRules();
  for (const value of Object.values(rules)) {
    for (const rule of value) {
      if (rule.name == RuleAvoidEdge.getName()) {
        rule.configValues.poleDistance = g_PolarWaterRows;
      }
    }
  }
  const generatorSettings = voronoiMap.getBuilder().getGenerator().getSettings();
  generatorSettings.landmass[0].playerAreas = iTotalPlayers;
  voronoiMap.getBuilder().simulate();
  const tiles = voronoiMap.getBuilder().getTiles();
  const landmassKdTree = new kdTree((tile) => tile.pos);
  landmassKdTree.build(tiles.flatMap((row) => row.filter((tile) => tile.landmassId > 0)));
  for (let y = 0; y < tiles.length; ++y) {
    for (let x = 0; x < tiles[y].length; ++x) {
      const tile = tiles[y][x];
      if (tile.landmassId > 0) {
        TerrainBuilder.setLandmassRegionId(x, y, tile.landmassId);
      }
      if (tile.landmassId === 2) {
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND);
      }
      if (tile.isLand()) {
        const type = tile.terrainType === TerrainType.Flat ? g_FlatTerrain : tile.terrainType === TerrainType.Mountainous || tile.terrainType === TerrainType.Volcano ? g_MountainTerrain : tile.terrainType === TerrainType.Rough ? g_HillTerrain : g_FlatTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        if (tile.terrainType === TerrainType.Volcano) {
          TerrainBuilder.setFeatureType(x, y, {
            Feature: g_VolcanoFeature,
            Direction: -1,
            Elevation: 0
          });
        }
      } else {
        const type = tile.terrainType === TerrainType.Ocean ? g_OceanTerrain : g_CoastTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
      }
    }
  }
  const endTime = Date.now();
  console.log(`Initial Voronoi map generation took ${endTime - startTime} ms`);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  let startPositions = [];
  voronoiMap.getBuilder().createMajorPlayerAreas(
    (tile) => StartPositioner.getPlotFertilityForCoord(tile.coord.x, tile.coord.y)
  );
  const playerRegions = Array.from({ length: iTotalPlayers }, () => new PlayerRegion());
  playerRegions.forEach((region, index) => {
    region.regionId = index;
    region.landmassId = 0;
  });
  for (const row of tiles) {
    for (const tile of row) {
      if (tile.landmassId == 1 && tile.majorPlayerRegionId >= 0) {
        playerRegions[tile.majorPlayerRegionId].tiles.push({ x: tile.coord.x, y: tile.coord.y });
      }
    }
  }
  startPositions = assignStartPositionsFromTiles(playerRegions);
  replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded pangaea-voronoi.ts");
//# sourceMappingURL=pangaea-voronoi.js.map
</file>

<file path="resource-generator.js">
import { getMinimumResourcePlacementModifier, replaceIslandResources, shuffle } from './map-utilities.js';
import './map-globals.js';

function generateResources(iWidth, iHeight) {
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCount = /* @__PURE__ */ new Map();
  const getImportantResourceCounts = (landmassId) => {
    if (!importantResourceRegionalCount.has(landmassId)) {
      importantResourceRegionalCount.set(landmassId, new Array(GameInfo.Resources.length).fill(0));
    }
    return importantResourceRegionalCount.get(landmassId);
  };
  const resourcesPlacedCount = new Array(GameInfo.Resources.length);
  let minimumResourcePlacementModifier = getMinimumResourcePlacementModifier();
  if (minimumResourcePlacementModifier == void 0) {
    minimumResourcePlacementModifier = 0;
  }
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resourceWeight[resourceIdx] = 0;
    resourceRunningWeight[resourceIdx] = 0;
    resourcesPlacedCount[resourceIdx] = 0;
  }
  class ResourceLandmass {
    typeIdx = 0;
    landmassId = 0;
  }
  const aResourceTypes = [];
  const resources = ResourceBuilder.getGeneratedMapResources();
  for (let ridx = 0; ridx < resources.length; ++ridx) {
    const resourceInfo = GameInfo.Resources.lookup(resources[ridx]);
    if (resourceInfo && resourceInfo.Tradeable) {
      resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
      const landmassId = ResourceBuilder.getResourceLandmass(resourceInfo.$index);
      aResourceTypes.push({ typeIdx: resourceInfo.$index, landmassId });
    }
  }
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      const landmassRegionId = GameplayMap.getLandmassRegionId(iX, iY);
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const resources2 = [];
        aResourceTypes.forEach((resourceLandmass) => {
          const assignedLandmass = resourceLandmass.landmassId;
          const allowedOnLandmass = assignedLandmass == LandmassRegion.LANDMASS_REGION_ANY || assignedLandmass != LandmassRegion.LANDMASS_REGION_NONE && landmassRegionId != LandmassRegion.LANDMASS_REGION_DEFAULT && assignedLandmass % landmassRegionId == 0;
          if (allowedOnLandmass && canHaveFlowerPlot(iX, iY, resourceLandmass.typeIdx)) {
            resources2.push(resourceLandmass.typeIdx);
          }
        });
        if (resources2.length > 0) {
          let resourceChosen = ResourceTypes.NO_RESOURCE;
          let resourceChosenIndex = 0;
          for (let iI = 0; iI < resources2.length; iI++) {
            if (resourceChosen == ResourceTypes.NO_RESOURCE) {
              resourceChosen = resources2[iI];
              resourceChosenIndex = resources2[iI];
            } else {
              if (resourceRunningWeight[resources2[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                resourceChosen = resources2[iI];
                resourceChosenIndex = resources2[iI];
              } else if (resourceRunningWeight[resources2[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                if (iRoll >= 1) {
                  resourceChosen = resources2[iI];
                  resourceChosenIndex = resources2[iI];
                }
              }
            }
          }
          if (resourceChosen != ResourceTypes.NO_RESOURCE) {
            const iResourcePlotIndex = getFlowerPlot(iX, iY, resourceChosen);
            if (iResourcePlotIndex != -1) {
              const iLocation = GameplayMap.getLocationFromIndex(iResourcePlotIndex);
              const iResourceX = iLocation.x;
              const iResourceY = iLocation.y;
              ResourceBuilder.setResourceType(iResourceX, iResourceY, resourceChosen);
              resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
              resourcesPlacedCount[resourceChosenIndex]++;
              getImportantResourceCounts(landmassRegionId)[resourceChosenIndex]++;
            } else {
              console.log("Resource Index Failure");
            }
          } else {
            console.log("Resource Type Failure");
          }
        }
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const landmassRegionId = GameplayMap.getLandmassRegionId(iX, iY);
      const resourceAtLocation = GameplayMap.getResourceType(iX, iY);
      if (resourceAtLocation == ResourceTypes.NO_RESOURCE) {
        const resourcesEligible = [];
        for (let i = 0; i < resourcesPlacedCount.length; ++i) {
          const resourceToPlace = GameInfo.Resources.lookup(i);
          if (resourceToPlace) {
            const assignedLandmass = ResourceBuilder.getResourceLandmass(i);
            const allowedOnLandmass = landmassRegionId != LandmassRegion.LANDMASS_REGION_DEFAULT && (assignedLandmass == LandmassRegion.LANDMASS_REGION_ANY || assignedLandmass != LandmassRegion.LANDMASS_REGION_NONE && assignedLandmass % landmassRegionId == 0);
            if (allowedOnLandmass) {
              const minimumPerLandMass = resourceToPlace.MinimumPerHemisphere > 0 ? resourceToPlace.MinimumPerHemisphere + minimumResourcePlacementModifier : 0;
              if (getImportantResourceCounts(landmassRegionId)[i] < minimumPerLandMass && ResourceBuilder.isResourceRequiredForAge(i, Game.age) && ResourceBuilder.canHaveResource(iX, iY, i, false)) {
                let hasAdjResource = false;
                for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
                  const iIndex = GameplayMap.getIndexFromXY(iX, iY);
                  const iLocation = GameplayMap.getLocationFromIndex(iIndex);
                  const iAdjacentX = GameplayMap.getAdjacentPlotLocation(
                    iLocation,
                    iDirection
                  ).x;
                  const iAdjacentY = GameplayMap.getAdjacentPlotLocation(
                    iLocation,
                    iDirection
                  ).y;
                  if (GameplayMap.getResourceType(iAdjacentX, iAdjacentY) != ResourceTypes.NO_RESOURCE) {
                    hasAdjResource = true;
                    break;
                  }
                }
                if (!hasAdjResource) {
                  resourcesEligible.push(i);
                }
              }
            }
          }
        }
        let resourceChosenIndex = -1;
        if (resourcesEligible.length > 0) {
          let resourceChosen = ResourceTypes.NO_RESOURCE;
          for (let iI = 0; iI < resourcesEligible.length; iI++) {
            if (resourceChosen == ResourceTypes.NO_RESOURCE) {
              resourceChosen = resourcesEligible[iI];
              resourceChosenIndex = resourcesEligible[iI];
            } else {
              if (resourceRunningWeight[resourcesEligible[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                resourceChosen = resourcesEligible[iI];
                resourceChosenIndex = resourcesEligible[iI];
              } else if (resourceRunningWeight[resourcesEligible[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                if (iRoll >= 1) {
                  resourceChosen = resourcesEligible[iI];
                  resourceChosenIndex = resourcesEligible[iI];
                }
              }
            }
          }
        }
        if (resourceChosenIndex > -1) {
          ResourceBuilder.setResourceType(iX, iY, resourceChosenIndex);
          resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
          const name = GameInfo.Resources.lookup(resourceChosenIndex)?.Name;
          console.log("Force Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")");
          getImportantResourceCounts(landmassRegionId)[resourceChosenIndex]++;
          break;
        }
      }
    }
  }
  const definition = GameInfo.Ages.lookup(Game.age);
  if (definition) {
    const mapType = Configuration.getMapValue("Name");
    for (const option of GameInfo.MapIslandBehavior) {
      if (option.MapType === mapType) {
        replaceIslandResources(iWidth, iHeight, option.ResourceClassType);
      }
    }
  }
}
function canHaveFlowerPlot(iX, iY, resourceType) {
  if (ResourceBuilder.canHaveResource(iX, iY, resourceType, false)) {
    return true;
  }
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    if (ResourceBuilder.canHaveResource(iAdjacentX, iAdjacentY, resourceType, false)) {
      return true;
    }
  }
  return false;
}
function getFlowerPlot(iX, iY, resourceType) {
  if (ResourceBuilder.canHaveResource(iX, iY, resourceType, false)) {
    return GameplayMap.getIndexFromXY(iX, iY);
  }
  const resourcePlotIndexes = [];
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentIndex = GameplayMap.getIndexFromXY(iAdjacentX, iAdjacentY);
    if (ResourceBuilder.canHaveResource(iAdjacentX, iAdjacentY, resourceType, false)) {
      resourcePlotIndexes.push(iAdjacentIndex);
    }
  }
  if (resourcePlotIndexes.length > 0) {
    return shuffle(resourcePlotIndexes)[0];
  } else {
    return -1;
  }
}

export { canHaveFlowerPlot, generateResources, getFlowerPlot };
//# sourceMappingURL=resource-generator.js.map
</file>

<file path="shuffle.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoastsPlus, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_NavigableRiverTerrain, g_OceanTerrain, g_CoastTerrain, g_LandmassFractal, g_FlatTerrain, g_WaterPercent, g_StartSectorWeight, g_FractalWeight, g_CenterWeight, g_Cutoff } from './map-globals.js';
import { needHumanNearEquator, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, markLandmassRegionId, createIslands, isAdjacentToLand, getSector, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes } from './volcano-generator.js';

console.log("Generating using script shuffle.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
  if (iRandom == 1) {
    const iNum1 = iNumPlayers1;
    const iNum2 = iNumPlayers2;
    iNumPlayers1 = iNum2;
    iNumPlayers2 = iNum1;
  }
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iOceanWaterColumns
    );
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
  } else {
    console.log("Standard Map");
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iOceanWaterColumns
    );
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
  }
  markLandmassRegionId(eastContinent, LandmassRegion.LANDMASS_REGION_EAST);
  markLandmassRegionId(westContinent, LandmassRegion.LANDMASS_REGION_WEST);
  TerrainBuilder.validateAndFixTerrain();
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  const iRandomRiver = TerrainBuilder.getRandomNumber(10, "Intensity of Rivers");
  if (iRandomRiver == 0) {
    TerrainBuilder.modelRivers(10, 85, g_NavigableRiverTerrain);
  } else if (iRandomRiver < 3) {
    TerrainBuilder.modelRivers(5, 70, g_NavigableRiverTerrain);
  } else {
    TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  }
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded shuffle.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iOceanWaterColumns) {
  const iRandomLandmassSetup = TerrainBuilder.getRandomNumber(4, "Shuffle Map Landmass Structure");
  if (iRandomLandmassSetup == 0) {
    createArchipelago(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Archipelago");
  } else if (iRandomLandmassSetup == 1) {
    createContinents(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Continents");
  } else if (iRandomLandmassSetup == 2) {
    createFractal(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Fractal");
  } else if (iRandomLandmassSetup == 3) {
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      }
    }
    createTerraMass(
      iWidth,
      iHeight,
      continent1,
      continent2,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      true,
      iOceanWaterColumns
    );
    createTerraMass(
      iWidth,
      iHeight,
      continent1,
      continent2,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      false,
      iOceanWaterColumns
    );
    console.log("Random Landmass Setup: Terra");
  }
}
function createArchipelago(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
    }
  }
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    3
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    4
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    5
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    6
  );
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.removePlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function generateFractalLayerWithoutHills(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iCenterWeight = 0;
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain || GameplayMap.getTerrainType(iX, iY) == g_CoastTerrain) {
        let terrain = g_FlatTerrain;
        const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
        const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
        if (isAdjacentToLand(iX, iY)) {
          continue;
        } else if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
          continue;
        } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
          terrain = g_OceanTerrain;
        } else {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          let iStartSectorWeight = 0;
          let iFractalWeight = 1;
          if (startSectors[iSector]) {
            iStartSectorWeight = 0.7;
            iFractalWeight = 0.35;
          }
          const iPlotHeight = getHeightAdjustingForStartSector(
            iX,
            iY,
            iWaterHeight,
            iFractalWeight,
            iCenterWeight,
            iStartSectorWeight,
            continent1,
            continent2,
            iStartSectorRows,
            iStartSectorCols,
            startSectors
          );
          if (iPlotHeight < iWaterHeight) {
            continue;
          }
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function createContinents(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createFractal(iWidth, iHeight, westContinent, eastContinent, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 3, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 13.5);
  const iBuffer2 = Math.floor(iWidth / 21);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < westContinent.south + iRandom || iY >= westContinent.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX == 0) {
        terrain = g_OceanTerrain;
      } else if (iX < westContinent.west + iRandom2 || iX >= eastContinent.east - iRandom2) {
        terrain = g_OceanTerrain;
      } else if (iX >= westContinent.east - iRandom2 && iX < eastContinent.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          iFractalWeight,
          0,
          iStartSectorWeight,
          westContinent,
          eastContinent,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * (g_FractalWeight + g_StartSectorWeight)) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createTerraMass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bFirst, iOceanWaterColumns) {
  const iSize = TerrainBuilder.getRandomNumber(6, "Random Land Size") + 2;
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iRanHeight = 100 - (iSize * 10 - 20);
  const iMaxHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iRanHeight);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (bFirst == true) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      }
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        if (bFirst == true) {
          terrain = g_OceanTerrain;
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        if (bFirst == true) {
          terrain = g_OceanTerrain;
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      } else if (bFirst == true && iX > continent1.east + iOceanWaterColumns || bFirst == false && iX < continent2.west - iOceanWaterColumns) {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iMaxHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iMaxHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (bFirst == false && iX > continent1.east + iOceanWaterColumns || bFirst == true && iX < continent2.west - iOceanWaterColumns) {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iMaxHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iMaxHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
}
//# sourceMappingURL=shuffle.js.map
</file>

<file path="snow-generator.js">
import { g_PolarWaterRows } from './map-globals.js';

function generateSnow(mapWidth, mapHeight) {
  console.log("Generating permanent snow");
  const mapHalfHeight = GameplayMap.getGridHeight() / 2;
  const snowLatitudeEnd = 60;
  const snowRowEnd = Math.ceil(mapHalfHeight * ((90 - snowLatitudeEnd) / 90));
  const snowRowStarts = [g_PolarWaterRows, g_PolarWaterRows];
  const snowRowLimits = [
    snowRowEnd > snowRowStarts[0] ? snowRowEnd - snowRowStarts[0] : 0,
    snowRowEnd > snowRowStarts[1] ? snowRowEnd - snowRowStarts[1] : 0
  ];
  const snowRowDeltas = [-1, 1];
  console.log(
    "Snow latitude:" + snowLatitudeEnd.toString() + ", rows:" + snowRowStarts[0].toString() + " to " + (snowRowStarts[0] + snowRowLimits[0]).toString()
  );
  const aLightSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "LIGHT", "PERMANENT"]);
  const aMediumSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "MEDIUM", "PERMANENT"]);
  const aHeavySnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "HEAVY", "PERMANENT"]);
  const weightRange = 3;
  const changeTotalAdjustment = 60;
  const aWeightEffect = [-1, -1, -1];
  aWeightEffect[0] = aLightSnowEffects ? aLightSnowEffects[0] : -1;
  aWeightEffect[1] = aMediumSnowEffects ? aMediumSnowEffects[0] : -1;
  aWeightEffect[2] = aHeavySnowEffects ? aHeavySnowEffects[0] : -1;
  const colEnd = mapWidth;
  const rowStart = [mapHeight - 1 - snowRowStarts[0], snowRowStarts[1]];
  for (let pole = 0; pole != 2; ++pole) {
    const rowCount = snowRowLimits[pole];
    if (rowCount > 0) {
      const nextRowDelta = snowRowDeltas[pole];
      const rowEnd = rowStart[pole] + rowCount * nextRowDelta;
      const chanceAdjustment = Math.ceil(changeTotalAdjustment / rowCount);
      const aWeightChance = [10, 30, 60];
      let chanceForAny = 90;
      for (let row = rowStart[pole]; row != rowEnd; row += nextRowDelta) {
        for (let col = 0; col < colEnd; ++col) {
          if (GameplayMap.isWater(col, row) == false) {
            let rndVal = TerrainBuilder.getRandomNumber(100, "Any Snow");
            if (rndVal <= chanceForAny) {
              rndVal = TerrainBuilder.getRandomNumber(100, "Snow Weight");
              for (let weight = weightRange - 1; weight >= 0; --weight) {
                if (rndVal < aWeightChance[weight]) {
                  MapPlotEffects.addPlotEffect(
                    GameplayMap.getIndexFromXY(col, row),
                    aWeightEffect[weight]
                  );
                  break;
                } else {
                  rndVal -= aWeightChance[weight];
                }
              }
            }
          }
        }
        chanceForAny -= chanceAdjustment;
        const adjustBy = chanceAdjustment;
        aWeightChance[2] -= adjustBy;
        for (let weight = weightRange - 2; weight >= 0; --weight) {
          aWeightChance[weight] += adjustBy;
        }
      }
    }
  }
}
function dumpPermanentSnow(iWidth, iHeight) {
  console.log("Permanent Snow");
  console.log("@ = heavy");
  console.log("# = medium");
  console.log("* = light");
  console.log(". = no-snow");
  const aLightSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "LIGHT", "PERMANENT"]);
  const aMediumSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "MEDIUM", "PERMANENT"]);
  const aHeavySnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "HEAVY", "PERMANENT"]);
  const eLightPlotEffect = aLightSnowEffects ? aLightSnowEffects[0] : -1;
  const eMediumPlotEffect = aMediumSnowEffects ? aMediumSnowEffects[0] : -1;
  const eHeavyPlotEffect = aHeavySnowEffects ? aHeavySnowEffects[0] : -1;
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let effectString = " ";
      if (GameplayMap.isWater(iX, iY) == false) {
        const iIndex = GameplayMap.getIndexFromXY(iX, iY);
        if (MapPlotEffects.hasPlotEffect(iIndex, eLightPlotEffect)) {
          effectString = "*";
        } else if (MapPlotEffects.hasPlotEffect(iIndex, eMediumPlotEffect)) {
          effectString = "#";
        } else if (MapPlotEffects.hasPlotEffect(iIndex, eHeavyPlotEffect)) {
          effectString = "@";
        } else {
          effectString = ".";
        }
      }
      str += effectString + " ";
    }
    console.log(str);
  }
}

export { dumpPermanentSnow, generateSnow };
//# sourceMappingURL=snow-generator.js.map
</file>

<file path="terra-incognita.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoastsPlus, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, createIslands, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, createOrganicLandmasses, clearContinent, markLandmassRegionId, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script terra-incognita.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createPrimaryLandmass(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iNumPlayers1 > iNumPlayers2,
      iOceanWaterColumns
    );
    createSecondaryLandmassBalanced(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iNumPlayers1 > iNumPlayers2,
      iOceanWaterColumns
    );
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 15;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
      clearContinent(westContinent);
      createSecondaryLandmassStandard(westContinent);
    } else {
      clearContinent(eastContinent);
      createSecondaryLandmassStandard(eastContinent);
    }
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
  }
  markLandmassRegionId(eastContinent, LandmassRegion.LANDMASS_REGION_EAST);
  markLandmassRegionId(westContinent, LandmassRegion.LANDMASS_REGION_WEST);
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpStartSectors(startSectors);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded terra-incognita.ts");
function createPrimaryLandmass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createSecondaryLandmassBalanced(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  const iSize = TerrainBuilder.getRandomNumber(6, "Random Land Size");
  console.log("Random Land Size " + iSize);
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iRanHeight = 130 - iSize * 10;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(
    g_LandmassFractal,
    g_WaterPercent * iRanHeight / 100
  );
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
}
function createSecondaryLandmassStandard(continent1) {
  console.log("Creating new landmass in this box");
  console.log("  North: " + continent1.north);
  console.log("  South: " + continent1.south);
  console.log("  East:  " + continent1.east);
  console.log("  West:  " + continent1.west);
  const iGrain = TerrainBuilder.getRandomNumber(3, "Secondary Landmass Fractal Grain") + 2;
  console.log("Secondary Landmass Fractal Grain: " + iGrain);
  FractalBuilder.create(
    g_LandmassFractal,
    continent1.east - continent1.west + 1,
    continent1.north - continent1.south + 1,
    iGrain,
    0
  );
  const iWaterHeightRange = 30;
  const iRanHeight = TerrainBuilder.getRandomNumber(iWaterHeightRange, "Random Water Height");
  console.log("Random Water Height: " + iRanHeight);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(
    g_LandmassFractal,
    g_WaterPercent * g_Cutoff + iRanHeight - 5
  );
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = g_FlatTerrain;
      const iPlotHeight = FractalBuilder.getHeight(
        g_LandmassFractal,
        iX - continent1.west,
        iY - continent1.south
      );
      if (iPlotHeight >= iWaterHeight) {
        if (iY == continent1.south || iY == continent1.north || iX == continent1.west || iX == continent1.east) {
          if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
            TerrainBuilder.setTerrainType(iX, iY, terrain);
          }
        } else {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      }
    }
  }
}
//# sourceMappingURL=terra-incognita.js.map
</file>

<file path="volcano-generator.js">
import { g_VolcanoFeature, g_MountainTerrain, g_TundraBiome } from './map-globals.js';

function getContinentBoundaryPlotCount(iWidth, iHeight) {
  let iContinentBoundaryPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.findSecondContinent(iX, iY, 3)) {
        iContinentBoundaryPlots = iContinentBoundaryPlots + 1;
      }
    }
  }
  return iContinentBoundaryPlots;
}
function getNumberAdjacentMountains(iX, iY) {
  let iCount = 0;
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const pAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.isMountain(pAdjacentPlot.x, pAdjacentPlot.y)) {
      iCount = iCount + 1;
    }
  }
  return iCount;
}
function getNumberAdjacentVolcanoes(iX, iY) {
  let iCount = 0;
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const pAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.getFeatureType(pAdjacentPlot.x, pAdjacentPlot.y) == g_VolcanoFeature) {
      iCount = iCount + 1;
    }
  }
  return iCount;
}
function addVolcanoes(iWidth, iHeight, spacing = 2) {
  console.log("Volcanoes");
  const iMountainPercentByDistance = [30, 18, 6];
  let iCountVolcanoesPlaced = 0;
  const placedVolcanoes = [];
  const minDistanceBetweenVolcanoes = spacing;
  let iTotalLandPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots = iTotalLandPlots + 1;
      }
    }
  }
  const iDesiredVolcanoes = iTotalLandPlots / 150;
  console.log("Desired Volcanoes: " + iDesiredVolcanoes);
  const iContinentBoundaryPlots = getContinentBoundaryPlotCount(iWidth, iHeight);
  console.log("Continent Boundary Plots: " + iContinentBoundaryPlots);
  const iDesiredNearBoundaries = iDesiredVolcanoes * 2 / 3;
  console.log("Desired Boundary Volcanoes: " + iDesiredNearBoundaries);
  if (iDesiredNearBoundaries > 0) {
    const iBoundaryPlotsPerVolcano = iContinentBoundaryPlots / iDesiredNearBoundaries;
    console.log("Boundary Plots Per Volcano: " + iBoundaryPlotsPerVolcano);
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        if (!GameplayMap.isWater(iX, iY)) {
          let iPlotsFromBoundary = -1;
          let bVolcanoHere = false;
          const iNumAdjacentMountains = getNumberAdjacentMountains(iX, iY);
          if (iNumAdjacentMountains != 6) {
            if (GameplayMap.findSecondContinent(iX, iY, 1)) {
              if (TerrainBuilder.getRandomNumber(iBoundaryPlotsPerVolcano * 0.7, "Volcano on boundary") == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 1;
            } else if (GameplayMap.findSecondContinent(iX, iY, 2)) {
              if (TerrainBuilder.getRandomNumber(iBoundaryPlotsPerVolcano, "Volcano 1 from boundary") == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 2;
            } else if (GameplayMap.findSecondContinent(iX, iY, 3)) {
              if (TerrainBuilder.getRandomNumber(
                iBoundaryPlotsPerVolcano * 1.5,
                "Volcano 2 from boundary"
              ) == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 3;
            }
          }
          if (bVolcanoHere && !isTooCloseToExistingVolcanoes(iX, iY, placedVolcanoes, minDistanceBetweenVolcanoes)) {
            TerrainBuilder.setTerrainType(iX, iY, g_MountainTerrain);
            TerrainBuilder.setFeatureType(iX, iY, {
              Feature: g_VolcanoFeature,
              Direction: -1,
              Elevation: 0
            });
            placedVolcanoes.push({ x: iX, y: iY });
            iCountVolcanoesPlaced++;
          } else if (iPlotsFromBoundary > 0) {
            let iMountainChance = iMountainPercentByDistance[iPlotsFromBoundary - 1];
            if (getNumberAdjacentVolcanoes(iX, iY) > 0) {
              iMountainChance = iMountainChance / 2;
            }
            if (TerrainBuilder.getRandomNumber(100, "Mountain near boundary") < iMountainChance) {
              TerrainBuilder.setTerrainType(iX, iY, g_MountainTerrain);
            }
          }
        }
      }
    }
  }
  console.log("Continent Edge Volcanoes Placed: " + iCountVolcanoesPlaced);
}
function isTooCloseToExistingVolcanoes(iX, iY, existingVolcanoes, minDistance) {
  for (const volcano of existingVolcanoes) {
    const dx = volcano.x - iX;
    const dy = volcano.y - iY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < minDistance) return true;
  }
  return false;
}
function addTundraVolcanoes(iWidth, iHeight, spacing = 3) {
  console.log(`Adding tundra volcanoes`);
  let iTotalLandPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots++;
      }
    }
  }
  let tundraVolcanoesPlaced = 0;
  const iDesiredVolcanoes = Math.floor(iTotalLandPlots / 300);
  console.log("Desired Tundra Volcanoes: " + iDesiredVolcanoes);
  const placedVolcanoes = [];
  const tundraCandidates = [];
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const biome = GameplayMap.getBiomeType(iX, iY);
      if (biome === g_TundraBiome && GameplayMap.isMountain(iX, iY)) {
        const isInland = !GameplayMap.isCoastalLand(iX, iY);
        tundraCandidates.push({ x: iX, y: iY, isInland });
      }
    }
  }
  shuffleCandidates(tundraCandidates);
  tundraCandidates.sort((a, b) => {
    if (a.isInland === b.isInland) return 0;
    return a.isInland ? -1 : 1;
  });
  const baseChance = 20;
  const falloffPerVolcano = 5;
  for (const { x, y } of tundraCandidates) {
    if (tundraVolcanoesPlaced >= iDesiredVolcanoes) break;
    if (!isTooCloseToExistingVolcanoes(x, y, placedVolcanoes, spacing)) {
      const currentChance = Math.max(1, baseChance - tundraVolcanoesPlaced * falloffPerVolcano);
      if (TerrainBuilder.getRandomNumber(100, "Tundra Volcano Roll") < currentChance) {
        TerrainBuilder.setTerrainType(x, y, g_MountainTerrain);
        TerrainBuilder.setFeatureType(x, y, {
          Feature: g_VolcanoFeature,
          Direction: -1,
          Elevation: 0
        });
        placedVolcanoes.push({ x, y });
        tundraVolcanoesPlaced++;
        console.log(`Tundra Volcano Placed at (${x}, ${y})  chance was ${currentChance}%`);
      }
    }
  }
  console.log(`Total Tundra Volcanoes Placed: ${tundraVolcanoesPlaced}`);
  function shuffleCandidates(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = TerrainBuilder.getRandomNumber(i + 1, "Shuffle");
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
}

export { addTundraVolcanoes, addVolcanoes, isTooCloseToExistingVolcanoes };
//# sourceMappingURL=volcano-generator.js.map
</file>

<file path="voronoi_generators/continent-generator.js">
import { sub2, rotate2, add2, dot2, dot2_90, mul2s, mul2 } from '../../../core/scripts/MathHelpers.js';
import { QuadTree } from '../quadtree.js';
import { kdTree, PlateBoundaryPosGetter, RegionType, MapSize, VoronoiUtils, MapDims, RegionCell, RegionCellPosGetter, Aabb2, TerrainType } from '../kd-tree.js';
import { RandomImpl } from '../random-pcg-32.js';
import { PlateRegion, LandmassRegion } from '../voronoi-region.js';
import { MapGenerator, GeneratorType } from './map-generator.js';
import { RuleAvoidEdge } from '../voronoi_rules/avoid-edge.js';
import { RuleAvoidOtherRegions } from '../voronoi_rules/avoid-other-regions.js';
import { RuleCellArea } from '../voronoi_rules/cell-area.js';
import { RuleNearMapCenter } from '../voronoi_rules/near-map-center.js';
import { RuleNearNeighbor } from '../voronoi_rules/near-neighbor.js';
import { RuleNearPlateBoundary } from '../voronoi_rules/near-plate-boundary.js';
import { RuleNearRegionSeed } from '../voronoi_rules/near-region-seed.js';
import { RuleNeighborsInRegion } from '../voronoi_rules/neighbors-in-region.js';
import { RulePreferLatitude } from '../voronoi_rules/prefer-latitude.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../voronoi_rules/rules-base.js';

class ContinentGenerator extends MapGenerator {
  m_plateRegions = [];
  m_landmassRegions = [];
  m_plateBoundaries = new kdTree(PlateBoundaryPosGetter);
  m_platesDiagram;
  m_plateCells = [];
  m_plateRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.15, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.8, record: { scaleFactor: 0.5 } }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.02, record: {} }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.6, record: { preferredNeighborCount: 6, deviation: 3 } }]
  ];
  m_landmassRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 6,
          poleFalloffCurve: 0.2,
          meridianDistance: 2,
          meridianDistanceFalloff: 6,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleCellArea, { isActive: true, weight: 0.1, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.5, record: {} }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.05, record: { scaleFactor: 8 } }],
    [
      RuleNeighborsInRegion,
      { isActive: true, weight: 0.25, record: { preferredNeighborCount: 4, deviation: 1.5 } }
    ],
    [RuleNearMapCenter, { isActive: false, weight: 0.05, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 8, falloffCurve: 0.2, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 3, directionInfluence: 0.5 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ],
    [RulePreferLatitude, { isActive: true, weight: 0.5, record: {} }]
  ];
  m_coastalIslandRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 4,
          poleFalloffCurve: 0.2,
          meridianDistance: 2,
          meridianDistanceFalloff: 10,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleNearNeighbor, { isActive: true, weight: 0.5, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Other Landmass",
        key: "avoidOther",
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Own Landmass",
        key: "avoidSelf",
        isActive: true,
        weight: 1,
        record: { minDistance: 0.25, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Islands",
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Island }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 3, directionInfluence: 0.5 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ],
    [RuleNearRegionSeed, { isActive: true, weight: 0.3, record: { scaleFactor: 15, invert: 1 } }]
  ];
  m_islandRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 8,
          poleFalloffCurve: 0.5,
          meridianDistance: 2,
          meridianDistanceFalloff: 10,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleCellArea, { isActive: true, weight: 0.15, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.9, record: { scaleFactor: 0.5 } }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.03, record: {} }],
    [
      RuleNeighborsInRegion,
      { isActive: true, weight: 0.6, record: { preferredNeighborCount: 1.5, deviation: 0.5 } }
    ],
    [RuleNearMapCenter, { isActive: true, weight: 0.04, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 4, falloffCurve: 0.15, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 2, directionInfluence: 0.8 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ]
  ];
  m_mountainRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.3, record: { invert: true } }],
    [RuleNearNeighbor, { isActive: false, weight: 0.25, record: {} }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.6, record: { preferredNeighborCount: 6, deviation: 4 } }],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 1, directionInfluence: 0.4 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ]
  ];
  m_volcanoRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.3, record: { invert: true } }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.9, record: { preferredNeighborCount: 0, deviation: 1 } }]
  ];
  m_plateRules = [];
  m_landmassRules = [];
  m_coastalIslandRules = [];
  m_islandRules = [];
  m_mountainRules = [];
  m_volcanoRules = [];
  static plateDistributionDescription = "The distribution of sizes of plates is controlled by 'Plate Curve Power' and 'Plate Linear Strength'. This helps the world have a mix of plate sizes. The calculation is a lerp between y=x^(Plate Curve Power) and y=x (linear) based on 'Linear Strength'. A 'Linear Strength' of 1 will mean all the plates are about the same size, less than that and the distribution becomes more curved. 'Plate Curve Power' affects the steepness of the curve";
  m_generatorSettingsSchema = [
    {
      groupLabel: "Plates",
      key: "plate",
      children: {
        type: "configs",
        data: [
          {
            key: "factor",
            label: "Plate Factor",
            description: "Number of tectonic plates to spawn per 100 tiles.",
            min: 0,
            max: 2,
            default: 0.38,
            step: 0.01
          },
          {
            key: "curvePower",
            label: "Plate Curve Power",
            description: ContinentGenerator.plateDistributionDescription,
            min: 1,
            max: 50,
            default: 4,
            step: 1
          },
          {
            key: "linearStrength",
            label: "Plate Linear Strength",
            description: ContinentGenerator.plateDistributionDescription,
            min: 0,
            max: 1,
            default: 0.6,
            step: 0.01
          },
          {
            key: "useUniqueVoronoi",
            label: "Use Unique Voronoi",
            description: "Causes the plate generation to create it's own unique voronoi diagram instead of using the same one as the rest of the map. This allows using fewer cells for plates, leading to more blobby shapes and higher performance.",
            min: 0,
            max: 1,
            default: 1,
            step: 1
          },
          {
            key: "voronoiCellRatio",
            label: "Cell Count Multiple",
            description: "When 'Use Unique Voronoi' is on, this affects the ratio of plate voronoi cells relative to the rest of the map, squared.",
            min: 1e-3,
            max: 1,
            default: 0.25,
            step: 1e-3
          },
          {
            key: "plateRotationMultiple",
            label: "Plate Rotation Multiple",
            description: "A scalar for plate rotation. This is useful since larger plates on big maps will move more around the edges of the plate than smaller ones for the same rotation value.",
            min: 0,
            max: 10,
            default: 1,
            step: 0.1
          }
        ]
      }
    },
    {
      groupLabel: "Landmass",
      key: "landmass",
      childCount: 2,
      children: {
        type: "configs",
        data: [
          {
            key: "enabled",
            label: "Enabled",
            description: "Controls if this landmass is created. Useful for quickly turning on and off a landmass without removing its settings entirely.",
            min: 0,
            max: 1,
            default: 1,
            step: 1
          },
          {
            key: "size",
            label: "Size %",
            description: "The size of the landmass as a percentage of total map area.",
            min: 5,
            max: 40,
            default: 17,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance +/- %",
            description: "The random variance (plus or minus) percentage of the total size.",
            min: 0,
            max: 10,
            default: 1,
            step: 0.01
          },
          {
            key: "spawnCenterDistance",
            label: "Spawn Distance From Center",
            description: "The distance from center with 0 being center and 1 being the edge of a circle squished into the map dimensions",
            min: 0.25,
            max: 0.75,
            default: 0.5,
            step: 0.01
          },
          {
            key: "erosionPercent",
            label: "Erosion Percent",
            description: "The percent of cells in this region to erode.",
            min: 0,
            max: 25,
            step: 0.1,
            default: 8
          },
          {
            key: "playerAreas",
            label: "Player Areas",
            description: "The number of player areas to spawn on this landmass.",
            min: 0,
            max: 20,
            default: 4
          },
          {
            key: "coastalIslands",
            label: "Coastal Islands",
            description: "The number of spawn locations for coastal islands. These are cells just off the coast of landmasses, not too close to other landmasses or islands, which are used to add land to the landmass they spawn near. They follow their own grow rules.",
            min: 0,
            max: 20,
            default: 8
          },
          {
            key: "coastalIslandsMinDistance",
            label: "Coastal Islands Min Distance",
            description: "The minimum distance from the landmass for coastal islands to spawn",
            min: 1,
            max: 4,
            default: 2,
            step: 0.1
          },
          {
            key: "coastalIslandsMaxDistance",
            label: "Coastal Islands max Distance",
            description: "The maximum distance from the landmass for coastal islands to spawn",
            min: 1,
            max: 4,
            default: 3,
            step: 0.1
          },
          {
            key: "coastalIslandsSize",
            label: "Coastal Islands Size %",
            description: "The total amount of land area to create as coastal islands around this landmass as a percent of map size.",
            min: 0,
            max: 5,
            default: 1,
            step: 0.01
          },
          {
            key: "coastalIslandsSizeVariance",
            label: "Coastal Islands Size Variance %",
            description: "The random variance (plus or minus) percentage of the total coastal island size.",
            min: 0,
            max: 5,
            default: 0.5,
            step: 0.01
          }
        ]
      }
    },
    {
      groupLabel: "Islands",
      key: "island",
      children: {
        type: "configs",
        data: [
          {
            key: "factor",
            label: "Factor",
            description: "The number of distant land islands to spawn per 100 tiles.",
            min: 0,
            max: 2,
            default: 0.3,
            step: 0.01
          },
          {
            key: "minSize",
            label: "Minimum Size %",
            description: "The minimum size of -each- island as a percentage of total map size.",
            min: 0,
            max: 4,
            default: 0.33,
            step: 0.01
          },
          {
            key: "maxSize",
            label: "Maximum Size %",
            description: "The maximum size of -each- island as a percentage of total map size.",
            min: 0,
            max: 4,
            default: 2,
            step: 0.01
          },
          {
            key: "totalSize",
            label: "Size %",
            description: "The total size of all islands combined as a percentage of total map size.",
            min: 0,
            max: 10,
            default: 4,
            step: 0.01
          },
          {
            key: "variance",
            label: "Variance +/- %",
            description: "The random plus or minus variance in the total size of all islands as a percentage of total map size.",
            min: 0,
            max: 2,
            default: 0.2,
            step: 0.01
          },
          {
            key: "poleDistance",
            label: "Pole Distance Hexes",
            description: "The minimum distance from the poles that distant land islands can spawn.",
            min: 0,
            max: 10,
            default: 5
          },
          {
            key: "meridianDistance",
            label: "Meridian Distance Hexes",
            description: "The minimum distance from the meridian that distant land islands can spawn.",
            min: 0,
            max: 10,
            default: 5
          },
          {
            key: "landmassDistance",
            label: "Min Landmass Distance Hexes",
            description: "The minimum distance from the major landmasses that distant land islands can spawn.",
            min: 0,
            max: 15,
            default: 4
          },
          {
            key: "islandDistance",
            label: "Min Island Distance Hexes",
            description: "The minimum distance from other islands that distant land islands can spawn.",
            min: 0,
            max: 15,
            default: 3
          },
          {
            key: "erosionPercent",
            label: "Erosion Percent",
            description: "The percent of cells on any given distant land island to erode.",
            min: 0,
            max: 50,
            default: 20
          }
        ]
      }
    },
    {
      groupLabel: "Mountains",
      key: "mountain",
      children: {
        type: "configs",
        data: [
          {
            key: "percent",
            label: "Percent of Land",
            description: "The percentage of all land that should be mountainous",
            min: 0,
            max: 50,
            default: 8,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance Percent",
            description: "The random +/- percent to the total area covered by mountains",
            min: 0,
            max: 10,
            default: 2,
            step: 0.1
          },
          {
            key: "randomize",
            label: "Randomize",
            description: "The randomization applied to mountain scores",
            min: 0,
            max: 100,
            default: 2,
            step: 1
          }
        ]
      }
    },
    {
      groupLabel: "Volcanos",
      key: "volcano",
      children: {
        type: "configs",
        data: [
          {
            key: "percent",
            label: "Percent of Mountains",
            description: "The percentage of all mountains that should be volcanos",
            min: 0,
            max: 50,
            default: 15,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance Percent",
            description: "The random +/- percent to the total number of mountains that are volcanos",
            min: 0,
            max: 10,
            default: 5,
            step: 0.1
          },
          {
            key: "randomize",
            label: "Randomize",
            description: "The randomization applied to volcano scores",
            min: 0,
            max: 100,
            default: 10,
            step: 1
          }
        ]
      }
    }
  ];
  // Overrides for specific map sizes
  m_mapSizeSettings = {
    [MapSize.Tiny]: {},
    [MapSize.Small]: {},
    [MapSize.Standard]: {},
    [MapSize.Large]: {},
    [MapSize.Huge]: {}
  };
  constructor() {
    super();
    this.initializeRules();
    this.buildDefaultSettings(this.m_generatorSettingsSchema, this.m_mapSizeSettings);
  }
  initializeRules() {
    const initializeRuleGroup = (rules, config) => {
      rules.length = 0;
      for (const [ruleClass, ruleSetting] of config) {
        const rule = new ruleClass();
        rule.initialize(ruleSetting);
        rules.push(rule);
      }
    };
    initializeRuleGroup(this.m_plateRules, this.m_plateRuleConfigs);
    initializeRuleGroup(this.m_landmassRules, this.m_landmassRuleConfigs);
    initializeRuleGroup(this.m_coastalIslandRules, this.m_coastalIslandRuleConfigs);
    initializeRuleGroup(this.m_islandRules, this.m_islandRuleConfigs);
    initializeRuleGroup(this.m_mountainRules, this.m_mountainRuleConfigs);
    initializeRuleGroup(this.m_volcanoRules, this.m_volcanoRuleConfigs);
    const volcanoNeighborRule = this.m_volcanoRules.find(
      (rule) => rule.name === RuleNeighborsInRegion.getName()
    );
    volcanoNeighborRule.inRegionCheck = (_ctx, thisCell, neighborCell) => {
      return thisCell.terrainType === neighborCell.terrainType;
    };
  }
  resetToDefault() {
    super.resetToDefault();
    this.initializeRules();
  }
  getType() {
    return GeneratorType.Continent;
  }
  getGeneratorSettingsConfig() {
    return this.m_generatorSettingsSchema;
  }
  getTypedSettings() {
    return this.getSettings();
  }
  getRules() {
    return {
      Plates: this.m_plateRules,
      Landmasses: this.m_landmassRules,
      "Coastal Islands": this.m_coastalIslandRules,
      Islands: this.m_islandRules,
      Mountains: this.m_mountainRules,
      Volcanoes: this.m_volcanoRules
    };
  }
  simulate() {
    for (const regionCell of this.m_regionCells) {
      regionCell.reset();
    }
    VoronoiUtils.performanceMarker("Grow Plates");
    this.growPlates();
    VoronoiUtils.performanceMarker("Grow Landmasses");
    this.growLandmasses();
    VoronoiUtils.performanceMarker("Grow Islands");
    this.growIslands();
    VoronoiUtils.performanceMarker("Grow Coastal Islands");
    this.growCoastalIslands();
    VoronoiUtils.performanceMarker("Force Polar Margin");
    this.forcePoles();
    VoronoiUtils.performanceMarker("Mark Land and Ocean Tiles");
    this.markLandAndOcean();
    VoronoiUtils.performanceMarker("Remove Lakes");
    this.removeLakes();
    VoronoiUtils.performanceMarker("Add Coasts & Costal Erosion");
    this.addCoasts();
    VoronoiUtils.performanceMarker("Add Mountains & Volcanos");
    this.addMountains();
  }
  choosePlateToGrow(power, linearStrength, plateCount) {
    const x = RandomImpl.fRand("Plate Growth");
    const curve = plateCount * Math.pow(x, power);
    const linear = plateCount * x;
    return Math.floor(VoronoiUtils.lerp(curve, linear, linearStrength));
  }
  growPlates() {
    const area = this.m_worldDims.x * this.m_worldDims.y;
    const plateCount = Math.round(this.getTypedSettings().plate.factor * 0.01 * area) + 1;
    const power = this.getTypedSettings().plate.curvePower;
    const linearStrength = this.getTypedSettings().plate.linearStrength;
    const useUniqueDiagram = this.getTypedSettings().plate.useUniqueVoronoi;
    let voronoiCellRatio = this.getTypedSettings().plate.voronoiCellRatio;
    voronoiCellRatio *= voronoiCellRatio;
    const plateRotationMultiple = this.getTypedSettings().plate.plateRotationMultiple;
    const bbox = { xl: 0, xr: this.m_worldDims.x, yt: 0, yb: this.m_worldDims.y };
    const sites = VoronoiUtils.createRandomSites(plateCount, bbox.xr, bbox.yb);
    const diagram = VoronoiUtils.computeVoronoi(sites, bbox, 5);
    this.m_plateCells = this.m_regionCells;
    let cellKdTree = this.m_kdTree;
    if (useUniqueDiagram) {
      const cellCount = Math.floor(
        MapDims[this.m_mapSize].x * MapDims[this.m_mapSize].y * voronoiCellRatio
      );
      const sites2 = VoronoiUtils.createRandomSites(cellCount, bbox.xr, bbox.yb);
      this.m_platesDiagram = VoronoiUtils.computeVoronoi(sites2, bbox, 2);
      this.m_plateCells = this.m_platesDiagram.cells.map((cell, index) => {
        const area2 = VoronoiUtils.calculateCellArea(cell);
        const regionCell = new RegionCell(cell, index, area2);
        return regionCell;
      });
      cellKdTree = new kdTree(RegionCellPosGetter);
      cellKdTree.build(this.m_plateCells);
    } else {
      this.m_platesDiagram = void 0;
    }
    this.m_plateRegions = diagram.cells.map((cell, index) => {
      const region = new PlateRegion(
        "Plate" + index,
        index,
        0,
        bbox.xr * bbox.yb,
        VoronoiUtils.getRandColor(index)
      );
      region.seedLocation = { x: cell.site.x, y: cell.site.y };
      const regionCell = cellKdTree.search(region.seedLocation).data;
      region.considerationList.push({ id: regionCell.id, score: 1 });
      return region;
    });
    for (const region of this.m_plateRegions) {
      region.prepareGrowth(
        this.m_plateCells,
        this.m_plateRegions,
        this.m_plateRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      region.growStep();
    }
    const regionFull = new Array(plateCount).fill(false);
    let growingCount = plateCount;
    while (growingCount > 0) {
      let plateToGrow = this.choosePlateToGrow(power, linearStrength, plateCount);
      if (regionFull[plateToGrow]) {
        plateToGrow = 0;
        while (regionFull[plateToGrow]) {
          ++plateToGrow;
        }
      }
      const canGrow = this.m_plateRegions[plateToGrow].growStep();
      if (!canGrow) {
        regionFull[plateToGrow] = true;
        --growingCount;
      }
    }
    if (useUniqueDiagram) {
      for (const regionCell of this.m_regionCells) {
        const plateCell = cellKdTree.search(regionCell.cell.site).data;
        regionCell.plateId = plateCell?.plateId;
      }
    }
    for (const plateRegion of this.m_plateRegions) {
      plateRegion.logStats();
    }
    const plateBoundaries = [];
    for (const plateCell of this.m_plateCells) {
      plateCell.ruleConsideration = true;
      for (const neighborId of plateCell.cell.getNeighborIds()) {
        const neighbor = this.m_plateCells[neighborId];
        if (neighbor.plateId !== plateCell.plateId && !neighbor.ruleConsideration) {
          const pos = {
            x: (plateCell.cell.site.x + neighbor.cell.site.x) * 0.5,
            y: (plateCell.cell.site.y + neighbor.cell.site.y) * 0.5
          };
          const normal = VoronoiUtils.normalize({
            x: neighbor.cell.site.x - plateCell.cell.site.x,
            y: neighbor.cell.site.y - plateCell.cell.site.y
          });
          const calculateMovement = (plate, pos2) => {
            const relPos = sub2(pos2, plate.seedLocation);
            const angularMovement = plate.m_rotation * Math.PI / 180 * plateRotationMultiple;
            const rotatedPos = rotate2(relPos, angularMovement);
            const rotationMovement = sub2(relPos, rotatedPos);
            const movement = add2(rotationMovement, plate.m_movement);
            return movement;
          };
          const plate1Movement = calculateMovement(this.m_plateRegions[plateCell.plateId], pos);
          const plate2Movement = calculateMovement(this.m_plateRegions[neighbor.plateId], pos);
          const subduction = dot2(normal, plate1Movement) - dot2(normal, plate2Movement);
          const sliding = Math.abs(dot2_90(normal, plate1Movement) - dot2_90(normal, plate2Movement));
          plateBoundaries.push({
            pos,
            normal,
            plateSubduction: subduction,
            plateSliding: sliding,
            id1: plateCell.plateId,
            id2: neighbor.plateId
          });
        }
      }
    }
    this.m_plateBoundaries.build(plateBoundaries);
  }
  growLandmasses() {
    this.m_landmassRegions = this.getLandmassRegions();
    for (const region of this.m_landmassRegions) {
      region.considerationList = [];
    }
    for (let i = 1; i < this.m_landmassRegions.length; i++) {
      const cell = this.m_kdTree.search(this.m_landmassRegions[i].seedLocation).data;
      this.m_landmassRegions[i].considerationList.push({ id: cell.id, score: 1 });
    }
    const growingRegions = this.m_landmassRegions.slice(1);
    const quadRegion = new Aabb2({ x: 0, y: 0 }, this.m_worldDims);
    const quadTree = new QuadTree(
      quadRegion,
      (item) => item.cell.site
    );
    for (const region of growingRegions) {
      region.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_landmassRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      region.SetQuadTree(quadTree);
    }
    for (const rule of this.m_landmassRules) {
      if (rule.name == RuleAvoidOtherRegions.getName()) {
        rule.setQuadTree(quadTree);
      }
    }
    let regionIndex = 0;
    while (growingRegions.length > 0) {
      if (!growingRegions[regionIndex].growStep()) {
        growingRegions.splice(regionIndex, 1);
      } else {
        regionIndex++;
      }
      regionIndex %= growingRegions.length;
    }
    for (const region of this.m_landmassRegions.slice(1)) {
      region.logStats();
    }
  }
  growIslands() {
    const area = this.getUsableArea();
    const islandSettings = this.getTypedSettings().island;
    let islandMinSize = islandSettings.minSize;
    let islandMaxSize = islandSettings.maxSize;
    const islandCount = Math.round(islandSettings.factor * area * 0.01);
    const randsForIndices = Array.from({ length: islandCount }, () => RandomImpl.fRand("Island Index"));
    if (islandMinSize > islandMaxSize) {
      console.log("Error: Island min size is larger than max size. Capping min size to the max size");
      islandMinSize = islandMaxSize;
    }
    if (islandMinSize * islandCount > islandSettings.totalSize - islandSettings.variance) {
      console.log("Error: Island min size is too large. Capping value to total size / the number of islands.");
      islandMinSize = (islandSettings.totalSize - islandSettings.variance) / islandCount;
    }
    if (islandMaxSize * islandCount < islandSettings.totalSize + islandSettings.variance) {
      console.log("Error: Island max size is too small. Capping value to total size / the number of islands.");
      islandMaxSize = (islandSettings.totalSize + islandSettings.variance) / islandCount;
    }
    const finalTotalSize = islandSettings.totalSize + RandomImpl.fRand("Island Size Variance") * islandSettings.variance * 2 - islandSettings.variance;
    const maxMinDifference = islandMaxSize - islandMinSize;
    let randomSizeRemaining = finalTotalSize - islandMinSize * islandCount;
    const islandSizes = Array.from({ length: islandCount }, () => islandMinSize);
    for (let i = 0; i < islandSizes.length - 1; ++i) {
      const maxAdded = Math.min(maxMinDifference, randomSizeRemaining);
      const averageRandomSize = randomSizeRemaining / islandCount;
      const randomPower = Math.log(averageRandomSize / maxAdded) / Math.log(0.5);
      const randomSize = Math.pow(RandomImpl.fRand("Island Random Size"), randomPower) * maxAdded;
      randomSizeRemaining -= randomSize;
      islandSizes[i] += randomSize;
    }
    islandSizes[islandSizes.length - 1] += randomSizeRemaining;
    console.log(`Creating ${islandSizes.length} islands. Sizes: ${islandSizes}`);
    const maxLandmassCellCount = Math.max(...this.m_landmassRegions.map((r) => r.cellCount));
    const commonIslandsRegion = new LandmassRegion(
      "Islands",
      this.m_landmassRegions.length,
      RegionType.Island,
      0,
      0,
      VoronoiUtils.hexStringToRgb("#B3B333")
    );
    commonIslandsRegion.minOrder = maxLandmassCellCount;
    this.m_landmassRegions.push(commonIslandsRegion);
    const landmassesKdTree = new kdTree((data) => {
      return { x: data.cell.site.x, y: data.cell.site.y };
    });
    landmassesKdTree.build(
      this.m_regionCells.filter(
        (value) => this.m_landmassRegions[value.landmassId].type === RegionType.Landmass
      )
    );
    for (let i = 0; i < islandCount; ++i) {
      const islandKdTree = new kdTree((data) => {
        return { x: data.cell.site.x, y: data.cell.site.y };
      });
      islandKdTree.build(
        this.m_regionCells.filter(
          (value) => this.m_landmassRegions[value.landmassId].type === RegionType.Island
        )
      );
      const scoreCtx = {
        cells: this.m_regionCells,
        region: commonIslandsRegion,
        regions: this.m_landmassRegions,
        plateRegions: this.m_plateRegions,
        m_worldDims: this.m_worldDims,
        totalArea: 0,
        cellCount: 0,
        rules: this.m_islandRules
      };
      const islandSeedCandidates = [];
      for (const regionCell of this.m_regionCells) {
        const x = regionCell.cell.site.x;
        const y = regionCell.cell.site.y;
        if (x < islandSettings.meridianDistance || x > this.m_worldDims.x - islandSettings.meridianDistance || y < islandSettings.poleDistance || y > this.m_worldDims.y - islandSettings.poleDistance || regionCell.landmassId > 0)
          continue;
        const distanceToLandmass = Math.sqrt(landmassesKdTree.search({ x, y }).distSq);
        const nearestIsland = islandKdTree.search({ x, y });
        const distanceToIsland = nearestIsland ? Math.sqrt(nearestIsland.distSq) : Infinity;
        if (distanceToLandmass > islandSettings.landmassDistance && distanceToIsland > islandSettings.islandDistance) {
          let score = 0;
          for (const rule of this.m_islandRules) {
            if (rule.isActive) {
              score += rule.score(regionCell, scoreCtx);
            }
          }
          score *= distanceToIsland;
          islandSeedCandidates.push([score, regionCell]);
        }
      }
      if (islandSeedCandidates.length == 0) {
        console.log("Failed to find any candidate locations for island.");
        break;
      }
      islandSeedCandidates.sort((a, b) => a[0] - b[0]);
      const randomIndex = Math.floor(
        VoronoiUtils.lerp(islandSeedCandidates.length * 0.9, islandSeedCandidates.length, randsForIndices[i])
      );
      const finalIslandSize = islandSizes[i] * 0.01 * area;
      const islandRegion = new LandmassRegion(
        "Island" + String(i),
        this.m_landmassRegions.length,
        RegionType.Island,
        finalIslandSize,
        0,
        VoronoiUtils.hexStringToRgb("#B3B333")
      );
      islandRegion.seedLocation = islandSeedCandidates[randomIndex][1].cell.site;
      this.m_landmassRegions.push(islandRegion);
      islandRegion.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_islandRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      islandRegion.considerationList.push({ id: islandSeedCandidates[randomIndex][1].id, score: 1 });
      while (islandRegion.growStep()) {
        continue;
      }
      islandRegion.logStats();
      this.m_landmassRegions.pop();
      this.m_regionCells.forEach((value) => {
        if (value.landmassId === islandRegion.id) {
          value.landmassId = commonIslandsRegion.id;
          value.landmassOrder += maxLandmassCellCount;
        }
      });
    }
  }
  growCoastalIslands() {
    const oceanCells = this.m_regionCells.filter((cell) => cell.landmassId === 0);
    for (let i = 1; i < this.m_landmassRegions.length; ++i) {
      const landmassRegion = this.m_landmassRegions[i];
      if (landmassRegion.type !== RegionType.Landmass) {
        continue;
      }
      const landmassSettings = this.getTypedSettings().landmass[i - 1];
      const coastalIslandSpawnCount = landmassSettings.coastalIslands;
      if (coastalIslandSpawnCount === 0) {
        continue;
      }
      const minLandmassRange = landmassSettings.coastalIslandsMinDistance;
      const maxLandmassRange = landmassSettings.coastalIslandsMaxDistance;
      const nearCoastCells = oceanCells.filter((cell) => {
        let nearRegion = false;
        const filterCallback = (considerCell) => {
          if (considerCell.landmassId === landmassRegion.id) {
            if (VoronoiUtils.distanceBetweenSites(cell.cell.site, considerCell.cell.site) > minLandmassRange) {
              nearRegion = true;
            } else {
              return VoronoiUtils.RegionCellFilterResult.HaltFail;
            }
          } else if (considerCell.landmassId > 0) {
            return VoronoiUtils.RegionCellFilterResult.HaltFail;
          }
          return VoronoiUtils.RegionCellFilterResult.Continue;
        };
        const filterResult = VoronoiUtils.regionCellAreaFilter(
          cell,
          this.m_regionCells,
          maxLandmassRange,
          filterCallback
        );
        return filterResult === VoronoiUtils.RegionCellFilterResult.Continue ? nearRegion : false;
      });
      console.log(
        "Checking " + nearCoastCells.length + " cells near landmass " + landmassRegion.id + " for coastal island spots"
      );
      const minOtherLandmassRange = 4;
      const islandSpawnList = nearCoastCells.filter((cell) => {
        const filterCallback = (considerCell) => {
          if (considerCell.landmassId != 0 && considerCell.landmassId != landmassRegion.id) {
            return VoronoiUtils.RegionCellFilterResult.HaltFail;
          }
          return VoronoiUtils.RegionCellFilterResult.Continue;
        };
        const filterResult = VoronoiUtils.regionCellAreaFilter(
          cell,
          this.m_regionCells,
          minOtherLandmassRange,
          filterCallback
        );
        return filterResult === VoronoiUtils.RegionCellFilterResult.Continue;
      });
      for (const rule of this.m_coastalIslandRules) {
        if (rule instanceof RuleAvoidOtherRegions) {
          const avoidOtherRegionsRule = rule;
          if (avoidOtherRegionsRule.key === "avoidSelf") {
            avoidOtherRegionsRule.configValues.regionId = landmassRegion.id;
            console.log("setting islands for landmass " + landmassRegion.id + " to slightly avoid self");
          } else if (avoidOtherRegionsRule.key === "avoidOther") {
            avoidOtherRegionsRule.configValues.regionId = landmassRegion.id === 1 ? 2 : 1;
            console.log(
              "setting islands for landmass " + landmassRegion.id + " to strongly avoid " + avoidOtherRegionsRule.configValues.regionId
            );
          }
        }
      }
      const area = this.getUsableArea();
      const coastalIslandSize = landmassSettings.coastalIslandsSize;
      let coastalIslandSizeVariance = landmassSettings.coastalIslandsSizeVariance;
      coastalIslandSizeVariance *= RandomImpl.fRand("Coastal Island Size Variance") * 2 - 1;
      const finalIslandSize = (coastalIslandSize + coastalIslandSizeVariance) * 0.01 * area;
      const coastalIslandRegion = new LandmassRegion(
        "CoastalIsland",
        this.m_landmassRegions.length,
        RegionType.CoastalIsland,
        finalIslandSize,
        0,
        VoronoiUtils.hexStringToRgb("#66B333")
      );
      coastalIslandRegion.seedLocation = landmassRegion.seedLocation;
      coastalIslandRegion.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_coastalIslandRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      console.log("Found " + islandSpawnList.length + " cells for coastal island spots");
      let scoredIslandSpawnList = [];
      for (const cell of islandSpawnList) {
        scoredIslandSpawnList.push({ cell, score: coastalIslandRegion.scoreSingleCell(cell) });
      }
      scoredIslandSpawnList.sort((a, b) => b.score - a.score);
      scoredIslandSpawnList = scoredIslandSpawnList.slice(
        0,
        Math.max(coastalIslandSpawnCount, scoredIslandSpawnList.length * 0.25)
      );
      VoronoiUtils.shuffle(scoredIslandSpawnList, coastalIslandSpawnCount);
      scoredIslandSpawnList = scoredIslandSpawnList.slice(0, coastalIslandSpawnCount);
      scoredIslandSpawnList.forEach((tuple) => {
        coastalIslandRegion.considerationList.push({ id: tuple.cell.id, score: 100 });
      });
      let coastalCellCount = 0;
      while (coastalIslandRegion.growStep()) {
        ++coastalCellCount;
      }
      this.m_regionCells.forEach((cell) => {
        if (cell.landmassId == coastalIslandRegion.id) {
          cell.landmassId = landmassRegion.id;
          cell.landmassOrder += landmassRegion.cellCount;
        }
      });
      landmassRegion.cellCount += coastalCellCount;
    }
  }
  forcePoles() {
    for (const cell of this.m_regionCells) {
      const minDist = 2;
      if (cell.cell.site.y < minDist || cell.cell.site.y > this.m_worldDims.y - minDist) {
        cell.landmassId = 0;
      }
    }
  }
  markLandAndOcean() {
    for (const cell of this.m_regionCells) {
      cell.terrainType = cell.landmassId > 0 ? TerrainType.Flat : TerrainType.Ocean;
    }
  }
  removeLakes() {
    for (let cell of this.m_regionCells) {
      if (cell.terrainType == TerrainType.Unknown) {
        let isInlandSea = false;
        let neighboringLandmassId = 0;
        const considerationList = [cell];
        const lakeList = [];
        cell.ruleConsideration = true;
        while (considerationList.length > 0) {
          cell = considerationList.pop();
          lakeList.push(cell);
          let neighborsLand = false;
          for (const neighborId of cell.cell.getNeighborIds()) {
            const neighbor = this.m_regionCells[neighborId];
            if (!neighbor.ruleConsideration) {
              if (neighbor.terrainType == TerrainType.Unknown) {
                neighbor.ruleConsideration = true;
                considerationList.push(neighbor);
              } else {
                neighborsLand = true;
                neighboringLandmassId = neighbor.landmassId;
              }
            }
          }
          if (!neighborsLand) {
            isInlandSea = true;
          }
        }
        if (isInlandSea) {
          lakeList.forEach((cell2) => {
            cell2.ruleConsideration = false;
            cell2.terrainType = TerrainType.Ocean;
          });
        } else {
          lakeList.forEach((cell2) => {
            cell2.ruleConsideration = false;
            cell2.terrainType = TerrainType.Flat;
            cell2.landmassId = neighboringLandmassId;
          });
        }
      }
    }
  }
  addCoasts() {
    for (const region of this.m_landmassRegions) {
      if (region.id === 0) continue;
      const coastalCells = [];
      const regionCells = this.m_regionCells.filter((cell) => cell.landmassId === region.id);
      for (const regionCell of regionCells) {
        for (const neighborId of regionCell.cell.getNeighborIds()) {
          let onCoast = false;
          if (this.m_regionCells[neighborId].terrainType == TerrainType.Ocean) {
            onCoast = true;
            this.m_regionCells[neighborId].terrainType = TerrainType.Coast;
            this.m_regionCells[neighborId].landmassId = regionCell.landmassId;
            this.m_regionCells[neighborId].landmassOrder = region.minOrder + region.cellCount;
            region.cellCount++;
          }
          if (onCoast) {
            coastalCells.push(regionCell);
          }
        }
      }
      const erosionPercent = 0.01 * (region.type === RegionType.Landmass ? this.getTypedSettings().landmass[region.id - 1].erosionPercent : this.getTypedSettings().island.erosionPercent);
      let erosionCount = 0;
      const cellsInRegion = regionCells.length;
      const cellsToErode = erosionPercent * cellsInRegion;
      VoronoiUtils.shuffle(coastalCells);
      for (let i = 0; i < coastalCells.length; ++i) {
        const cell = coastalCells[i];
        if (i < cellsToErode) {
          const neighbors = cell.cell.getNeighborIds();
          for (const neighborId of neighbors) {
            const neighbor = this.m_regionCells[neighborId];
            if (neighbor.landmassId == region.id) {
              neighbor.terrainType = TerrainType.Coast;
              neighbor.landmassId = cell.landmassId;
              ++erosionCount;
              break;
            }
          }
        }
      }
      console.log(
        "Eroded " + erosionCount + " cells on landmass " + region.id + " from a total of " + region.considerationList.length + " coasts on a landmass with " + cellsInRegion + " cells."
      );
    }
  }
  addMountains() {
    const scoreCtx = {
      cells: this.m_regionCells,
      region: this.m_landmassRegions[1],
      regions: this.m_landmassRegions,
      plateRegions: this.m_plateRegions,
      m_worldDims: this.m_worldDims,
      totalArea: 0,
      cellCount: 0,
      rules: this.m_mountainRules
    };
    for (const rule of this.m_mountainRules) {
      if (rule.isActive) {
        rule.scoreAllCells(
          (cell) => cell.terrainType == TerrainType.Flat,
          scoreCtx,
          (cell) => this.m_landmassRegions[cell.landmassId],
          rule.weight
        );
      }
    }
    const mountainSettings = this.getTypedSettings().mountain;
    const scoredCells = this.m_regionCells.filter((cell) => cell.currentScore > 0);
    scoredCells.sort((a, b) => b.currentScore - a.currentScore);
    const mountainVariance = (RandomImpl.fRand("Mountain Variance") * 2 - 1) * mountainSettings.variance;
    const percentMountains = (mountainSettings.percent + mountainVariance) * 0.01;
    const totalMountains = Math.round(scoredCells.length * percentMountains);
    const totalMountainsToConsider = totalMountains + mountainSettings.randomize * 0.01 * (scoredCells.length - totalMountains);
    let mountainCells = scoredCells.slice(0, totalMountainsToConsider);
    VoronoiUtils.shuffle(mountainCells, totalMountains);
    mountainCells = mountainCells.slice(0, totalMountains);
    mountainCells.forEach((cell) => {
      cell.terrainType = TerrainType.Mountainous;
      cell.currentScore = 0;
    });
    scoreCtx.rules = this.m_volcanoRules;
    for (const rule of this.m_volcanoRules) {
      if (rule.isActive) {
        rule.scoreCells(
          mountainCells,
          scoreCtx,
          (cell) => this.m_landmassRegions[cell.landmassId],
          rule.weight
        );
      }
    }
    const volcanoSettings = this.getTypedSettings().volcano;
    const scoredVolcanoCells = mountainCells.filter((cell) => cell.currentScore > 0);
    scoredVolcanoCells.sort((a, b) => b.currentScore - a.currentScore);
    const volcanoVariance = (RandomImpl.fRand("Volcano Variance") * 2 - 1) * volcanoSettings.variance;
    const percentVolcanos = (volcanoSettings.percent + volcanoVariance) * 0.01;
    const totalVolcanos = Math.round(mountainCells.length * percentVolcanos);
    const totalVolcanosToConsider = totalVolcanos + volcanoSettings.randomize * 0.01 * (scoredVolcanoCells.length - totalVolcanos);
    let volcanoCells = scoredVolcanoCells.slice(0, totalVolcanosToConsider);
    VoronoiUtils.shuffle(volcanoCells, totalVolcanos);
    volcanoCells = volcanoCells.slice(0, totalVolcanos);
    volcanoCells.forEach((cell) => {
      cell.terrainType = TerrainType.Volcano;
    });
    this.m_regionCells.forEach((cell) => cell.currentScore = 0);
  }
  getLandmassRegions() {
    const regions = [
      new LandmassRegion("ocean", 0, RegionType.Ocean, 0, 0, VoronoiUtils.hexStringToRgb("#3333CC"))
    ];
    const area = this.getUsableArea();
    const numLandmasses = this.getTypedSettings().landmass.length;
    const arcOffset = Math.PI * 2 / numLandmasses;
    const randSpawnOffset = arcOffset * RandomImpl.fRand("Landmass spawn offset");
    for (let i = 0; i < numLandmasses; ++i) {
      const landmassSettings = this.getTypedSettings().landmass[i];
      if (!landmassSettings.enabled) {
        continue;
      }
      const landmassSize = landmassSettings.size * 0.01 * area + landmassSettings.variance * 0.01 * area * RandomImpl.fRand("Landmass " + i + " size variance") - landmassSettings.variance * 0.5;
      const landmassPlayerAreas = landmassSettings.playerAreas;
      const spawnOffset = randSpawnOffset + arcOffset * i;
      let circleOffset = { x: Math.cos(spawnOffset), y: Math.sin(spawnOffset) };
      circleOffset = mul2s(circleOffset, landmassSettings.spawnCenterDistance);
      const landmass = new LandmassRegion(
        "landmass" + i,
        1 + i,
        RegionType.Landmass,
        landmassSize,
        landmassPlayerAreas,
        VoronoiUtils.hexStringToRgb("#00CC00")
      );
      const halfMapDims = mul2s(this.m_worldDims, 0.5);
      landmass.seedLocation = add2(mul2(circleOffset, halfMapDims), halfMapDims);
      regions.push(landmass);
    }
    return regions;
  }
  getLandmasses() {
    return this.m_landmassRegions;
  }
  getPlates() {
    return this.m_plateRegions;
  }
  getPlateCells() {
    return this.m_plateCells;
  }
  getPlatesDiagram() {
    return this.m_platesDiagram || this.m_diagram;
  }
  getUsableArea() {
    const meridianMargin = 2;
    const polarMargin = 2;
    const width = this.m_worldDims.x - meridianMargin * 2;
    const height = this.m_worldDims.y - polarMargin * 2;
    return width * height;
  }
}

export { ContinentGenerator };
//# sourceMappingURL=continent-generator.js.map
</file>

<file path="voronoi_generators/map-generator.js">
import { VoronoiUtils, MapSize, kdTree, RegionCellPosGetter, RegionCell } from '../kd-tree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';

var GeneratorType = /* @__PURE__ */ ((GeneratorType2) => {
  GeneratorType2[GeneratorType2["Continent"] = 0] = "Continent";
  return GeneratorType2;
})(GeneratorType || {});
class GeneratorSettingConfigGroup {
  groupLabel = "";
  key = "";
  childCount;
  // define this to allow this group to contain arrays of settings.
  children = { type: "configs", data: [] };
}
class MapGenerator {
  m_defaultGeneratorSettings = {};
  m_mapSizeOverrides = VoronoiUtils.defaultEnumRecord(MapSize);
  m_generatorSettings = {};
  m_regionCells = [];
  m_diagram;
  // initialized in init()
  m_worldDims = { x: 0, y: 0 };
  m_mapSize = MapSize.Standard;
  m_kdTree = new kdTree(RegionCellPosGetter);
  init(worldDims, diagram, mapSize) {
    this.m_diagram = diagram;
    this.m_worldDims = worldDims;
    this.m_mapSize = mapSize;
    if (Object.entries(this.m_generatorSettings).length === 0) {
      this.m_generatorSettings = VoronoiUtils.clone(this.m_defaultGeneratorSettings);
    }
    VoronoiUtils.deepMerge(this.m_generatorSettings, this.m_mapSizeOverrides[this.m_mapSize]);
    this.m_regionCells = diagram.cells.map((cell, index) => {
      const area = VoronoiUtils.calculateCellArea(cell);
      const regionCell = new RegionCell(cell, index, area);
      return regionCell;
    });
    this.m_kdTree.build(this.m_regionCells);
  }
  logSettings() {
    console.log(
      "generator " + this.getType() + " for map size [" + this.m_mapSize + "] initialized with the following settings:"
    );
    const logObject = (obj, indent, lastKey = "") => {
      if (obj === null) {
        console.log(indent + "null");
      } else if (Array.isArray(obj)) {
        console.log(indent + lastKey + ": [");
        for (let i = 0; i < obj.length; ++i) {
          logObject(obj[i], indent + "  ", i.toString());
        }
        console.log(indent + "]");
      } else if (typeof obj === "object") {
        if (lastKey != "") {
          console.log(indent + lastKey + ": ");
        }
        for (const [key, value] of Object.entries(obj)) {
          if (key[0] === "_") continue;
          logObject(value, indent + "  ", key);
        }
      } else {
        console.log(indent + lastKey + ": " + obj);
      }
    };
    logObject(this.m_generatorSettings, "  ");
    console.log("Rules:");
    const rules = this.getRules();
    for (const ruleSection of Object.keys(rules)) {
      console.log("  " + ruleSection + ":");
      for (const rule of rules[ruleSection]) {
        console.log("    " + rule.name + ": weight: " + rule.weight);
        for (const [key, value] of Object.entries(rule.configValues)) {
          logObject(value, "      ", key);
        }
      }
    }
  }
  buildDefaultSettings(nodes, mapsSizeOverrides) {
    const processConfigNodes = (nodes2) => {
      const out = {};
      for (const node of nodes2) {
        if ("children" in node) {
          if (node.children.type === "configs") {
            if (node.childCount && node.childCount > 0) {
              out["_defaultChild"] = processConfigNodes(node.children.data);
              const arr = [];
              for (let i = 0; i < node.childCount; ++i) {
                arr[i] = processConfigNodes(node.children.data);
              }
              out[node.key] = arr;
            } else {
              out[node.key] = processConfigNodes(node.children.data);
            }
          }
        } else {
          out[node.key] = node.default;
        }
      }
      return out;
    };
    this.m_defaultGeneratorSettings = processConfigNodes(nodes);
    this.m_mapSizeOverrides = mapsSizeOverrides;
  }
  getRegionCells() {
    return this.m_regionCells;
  }
  getPlateCells() {
    return this.m_regionCells;
  }
  getKdTree() {
    return this.m_kdTree;
  }
  getSettings() {
    return this.m_generatorSettings;
  }
  getDiagram() {
    return this.m_diagram;
  }
  getPlatesDiagram() {
    return this.m_diagram;
  }
  resetToDefault() {
    this.m_generatorSettings = VoronoiUtils.clone(this.m_defaultGeneratorSettings);
    VoronoiUtils.deepMerge(this.m_generatorSettings, this.m_mapSizeOverrides[this.m_mapSize]);
  }
}

export { GeneratorSettingConfigGroup, GeneratorType, MapGenerator };
//# sourceMappingURL=map-generator.js.map
</file>

<file path="voronoi_maps/continents.js">
import { RandomImpl } from '../random-pcg-32.js';
import { MapDims } from '../kd-tree.js';
import { GeneratorType } from '../voronoi_generators/map-generator.js';
import { VoronoiMap } from './map-common.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../voronoi-builder.js';
import '../voronoi-hex.js';
import '../heap.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../voronoi-region.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';

const continentSettings = {
  "generatorKey": 0,
  "mapConfig": {
    "totalLandmassSize": 42,
    "minLandmassSize": 16
  },
  "generatorConfig": {
    "plate": {
      "plateRotationMultiple": 5
    },
    "landmass": [
      {
        "variance": 5,
        "erosionPercent": 4,
        "coastalIslands": 12
      },
      {
        "variance": 5,
        "erosionPercent": 4,
        "coastalIslands": 12
      }
    ],
    "island": {
      "totalSize": 5.5,
      "variance": 1,
      "meridianDistance": 3,
      "landmassDistance": 5,
      "erosionPercent": 15
    },
    "mountain": {
      "percent": 12,
      "randomize": 35
    }
  },
  "rulesConfig": {
    "Plates": {
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.8,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.02,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 3
    },
    "Landmasses": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 12,
      "Cell Area.weight": 0.01,
      "Near Neighbor.weight": 0.75,
      "Near Region Seed.weight": 0.05,
      "Near Region Seed.scaleFactor": 8,
      "Neighbors In Region.weight": 0.25,
      "Neighbors In Region.preferredNeighborCount": 3.5,
      "Neighbors In Region.deviation": 1.5,
      "Near Map Center.weight": 0.05,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.minDistance": 5,
      "Avoid Other Regions.distanceFalloff": 8,
      "Avoid Other Regions.falloffCurve": 0.2,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1.5,
      "Prefer Latitude.weight": 0.76,
      "Prefer Latitude.overlap": 4,
      "Prefer Latitude.latitudes": [
        {
          "latitude": 25,
          "weight": 20
        },
        {
          "latitude": 45,
          "weight": 20
        },
        {
          "latitude": 70,
          "weight": 20
        }
      ]
    },
    "Coastal Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 5,
      "Avoid Edge.meridianFalloffCurve": 0.2,
      "Avoid Edge.avoidCorners": 12,
      "Near Neighbor.weight": 0.5,
      "Avoid Other Landmass.weight": 1,
      "Avoid Other Landmass.distanceFalloff": 2,
      "Avoid Other Landmass.regionType": 2,
      "Avoid Other Landmass.regionId": 1,
      "Avoid Own Landmass.weight": 1,
      "Avoid Own Landmass.minDistance": 1,
      "Avoid Own Landmass.distanceFalloff": 2,
      "Avoid Own Landmass.regionType": 2,
      "Avoid Own Landmass.regionId": 2,
      "Avoid Islands.weight": 1,
      "Avoid Islands.distanceFalloff": 2,
      "Avoid Islands.regionType": 3,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Region Seed.weight": 0.3,
      "Near Region Seed.scaleFactor": 15,
      "Near Region Seed.invert": 1
    },
    "Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 4,
      "Avoid Edge.poleFalloffCurve": 0.5,
      "Avoid Edge.meridianDistance": 1,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 6,
      "Cell Area.weight": 0.15,
      "Cell Area.scaleFactor": -0.2,
      "Near Neighbor.weight": 0.9,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.03,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 1.5,
      "Neighbors In Region.deviation": 0.5,
      "Near Map Center.weight": 0.04,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.falloffCurve": 0.15,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.8
    },
    "Mountains": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Near Neighbor.weight": 0.25,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 4,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1,
      "Near Plate Boundary.directionInfluence": 0.4
    },
    "Volcanoes": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Neighbors In Region.weight": 0.9,
      "Neighbors In Region.preferredNeighborCount": 0
    }
  }
};

class VoronoiContinents extends VoronoiMap {
  m_schema = {
    voronoiCellCountMultiple: {
      label: "Cell Count Multiple",
      description: "The number of voronoi cells to use relative to hexes.",
      default: 1,
      min: 0.5,
      max: 4,
      step: 0.1
    },
    voronoiRelaxationSteps: {
      label: "Cell Relaxation Steps",
      description: "The number times to relax the voronoi diagram from its original random positions.",
      default: 3,
      min: 0,
      max: 10,
      step: 1
    },
    totalLandmassSize: {
      label: "Total Landmass Size",
      description: "The total percentage of land to be taken up by the major landmasses.",
      default: 32,
      min: 20,
      max: 50,
      step: 0.25
    },
    minLandmassSize: {
      label: "Minimum Landmass Size",
      description: "The minimum size a specific landmass can be.",
      default: 12,
      min: 5,
      max: 30,
      step: 0.25
    }
  };
  m_settings;
  constructor() {
    super();
    this.m_settings = this.createDefaultSettings();
  }
  getName() {
    return "Continents";
  }
  init(mapSize) {
    this.initInternal(
      mapSize,
      GeneratorType.Continent,
      continentSettings,
      this.m_settings.voronoiCellCountMultiple,
      this.m_settings.voronoiRelaxationSteps
    );
    const generatorSettings = this.getBuilder().getGenerator().getSettings();
    const landmassCount = generatorSettings.landmass.length;
    const totalSize = this.m_settings.totalLandmassSize;
    const minSize = this.m_settings.minLandmassSize;
    const dims = MapDims[mapSize];
    const tileCount = dims.x * dims.y;
    const avgDim = dims.x + dims.y / 2;
    const landmassSeparationWidth = 4;
    const landmassSeparationTiles = avgDim * (landmassCount - 1) * landmassSeparationWidth;
    const usablePercentage = (tileCount - landmassSeparationTiles) / tileCount;
    const adjustedTotalSize = totalSize * usablePercentage;
    const adjustedMinSize = minSize * usablePercentage;
    let minTotalSize = adjustedMinSize * landmassCount;
    if (adjustedMinSize > adjustedTotalSize) {
      console.error(
        `Minimum landmass size of ${minSize} is too large to fit ${landmassCount} landmasses with less than ${totalSize} total size.`
      );
      minTotalSize = adjustedTotalSize / landmassCount;
    }
    const remaining = adjustedTotalSize - minTotalSize;
    const cuts = Array.from(
      { length: landmassCount - 1 },
      (_value, index) => RandomImpl.fRand(`Landmass ${index + 1} Size Variance`) * remaining
    );
    cuts.sort((a, b) => a - b);
    const landmassSizes = [];
    let prev = 0;
    for (const cut of cuts) {
      landmassSizes.push(cut - prev + adjustedMinSize);
      prev = cut;
    }
    landmassSizes.push(remaining - prev + adjustedMinSize);
    generatorSettings.landmass.forEach((value, index) => {
      value.size = landmassSizes[index];
    });
    const settingsConfig = this.getBuilder().getGenerator().getGeneratorSettingsConfig();
    const landmassConfig = settingsConfig.find(
      (value) => value.key == "landmass"
    );
    const sizeConfig = landmassConfig.children.data.find(
      (value) => value.key == "size"
    );
    sizeConfig.locked = true;
    this.m_builder.getGenerator().logSettings();
  }
  getSettings() {
    return this.getTypedSettings();
  }
  getTypedSettings() {
    return this.m_settings;
  }
  getSettingsConfig() {
    return this.m_schema;
  }
  getFilename() {
    return "continents.mapconfig.js";
  }
}

export { VoronoiContinents };
//# sourceMappingURL=continents.js.map
</file>

<file path="voronoi_maps/map-common.js">
import { VoronoiBuilder } from '../voronoi-builder.js';
import { VoronoiUtils } from '../kd-tree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../voronoi-hex.js';
import '../../../core/scripts/MathHelpers.js';
import '../heap.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../random-pcg-32.js';
import '../voronoi-region.js';
import '../voronoi_generators/map-generator.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

var MapType = /* @__PURE__ */ ((MapType2) => {
  MapType2[MapType2["Continents"] = 0] = "Continents";
  MapType2[MapType2["Pangaea"] = 1] = "Pangaea";
  return MapType2;
})(MapType || {});
class VoronoiMap {
  m_builder = new VoronoiBuilder();
  m_initialized = false;
  getBuilder() {
    return this.m_builder;
  }
  initInternal(mapSize, generatorType, defaultGeneratorSettings, cellCountMultiple, relaxationSteps) {
    this.m_builder.init(mapSize, generatorType, cellCountMultiple, relaxationSteps);
    if (defaultGeneratorSettings && !this.m_initialized) {
      VoronoiUtils.loadSettingsFromJson(defaultGeneratorSettings, this);
    }
    this.m_initialized = true;
  }
  createDefaultSettings() {
    const settings = {};
    for (const [key, value] of Object.entries(this.getSettingsConfig())) {
      settings[key] = value.default;
    }
    return settings;
  }
}

export { MapType, VoronoiMap };
//# sourceMappingURL=map-common.js.map
</file>

<file path="voronoi_maps/pangaea.js">
import { GeneratorType } from '../voronoi_generators/map-generator.js';
import { VoronoiMap } from './map-common.js';
import '../kd-tree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';
import '../voronoi-builder.js';
import '../voronoi-hex.js';
import '../heap.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../voronoi-region.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';

const pangaeaSettings = {
  "generatorKey": 0,
  "mapConfig": {},
  "generatorConfig": {
    "plate": {
      "plateRotationMultiple": 5
    },
    "landmass": [
      {
        "size": 44,
        "spawnCenterDistance": 0.25,
        "coastalIslands": 20,
        "coastalIslandsSize": 3
      }
    ],
    "island": {
      "minSize": 0.15,
      "maxSize": 2.25,
      "totalSize": 6,
      "poleDistance": 3,
      "meridianDistance": 2
    },
    "mountain": {
      "percent": 12,
      "randomize": 50
    }
  },
  "rulesConfig": {
    "Plates": {
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.8,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.02,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 3
    },
    "Landmasses": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 5,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 4,
      "Avoid Edge.polePerturbationWavelength": 5,
      "Avoid Edge.meridianDistanceFalloff": 12,
      "Avoid Edge.meridianFalloffCurve": 0.3,
      "Avoid Edge.avoidCorners": 18,
      "Cell Area.weight": 0.02,
      "Cell Area.scaleFactor": -0.5,
      "Near Neighbor.weight": 0.8,
      "Near Region Seed.weight": 0.04,
      "Near Region Seed.scaleFactor": 8,
      "Neighbors In Region.weight": 0.25,
      "Neighbors In Region.preferredNeighborCount": 4,
      "Neighbors In Region.deviation": 1.5,
      "Near Map Center.weight": 0.39,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.distanceFalloff": 8,
      "Avoid Other Regions.falloffCurve": 0.2,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.7,
      "Prefer Latitude.weight": 0.76,
      "Prefer Latitude.overlap": 4,
      "Prefer Latitude.latitudes": [
        {
          "latitude": 25,
          "weight": 20
        },
        {
          "latitude": 45,
          "weight": 20
        },
        {
          "latitude": 70,
          "weight": 20
        }
      ]
    },
    "Coastal Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 12,
      "Near Neighbor.weight": 0.5,
      "Avoid Other Landmass.weight": 1,
      "Avoid Other Landmass.distanceFalloff": 2,
      "Avoid Other Landmass.regionType": 2,
      "Avoid Other Landmass.regionId": 2,
      "Avoid Own Landmass.weight": 0.63,
      "Avoid Own Landmass.minDistance": 0.9,
      "Avoid Own Landmass.distanceFalloff": 3,
      "Avoid Own Landmass.falloffCurve": 0.7,
      "Avoid Own Landmass.regionType": 2,
      "Avoid Own Landmass.regionId": 1,
      "Avoid Islands.weight": 1,
      "Avoid Islands.distanceFalloff": 2,
      "Avoid Islands.regionType": 3,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 3,
      "Near Region Seed.weight": 0.3,
      "Near Region Seed.scaleFactor": 15,
      "Near Region Seed.invert": 1
    },
    "Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 4,
      "Avoid Edge.poleFalloffCurve": 0.5,
      "Avoid Edge.meridianDistanceFalloff": 10,
      "Avoid Edge.meridianFalloffCurve": 0.3,
      "Avoid Edge.avoidCorners": 12,
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.9,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.03,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 1.5,
      "Neighbors In Region.deviation": 0.5,
      "Near Map Center.weight": 0.04,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.falloffCurve": 0.15,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.8
    },
    "Mountains": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Near Neighbor.weight": 0.25,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 4,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1,
      "Near Plate Boundary.directionInfluence": 0.4
    },
    "Volcanoes": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Neighbors In Region.weight": 0.9,
      "Neighbors In Region.preferredNeighborCount": 0
    }
  }
};

class VoronoiPangaea extends VoronoiMap {
  m_schema = {
    voronoiCellCountMultiple: {
      label: "Cell Count Multiple",
      description: "The number of voronoi cells to use relative to hexes.",
      default: 1,
      min: 0.5,
      max: 4,
      step: 0.1
    },
    voronoiRelaxationSteps: {
      label: "Cell Relaxation Steps",
      description: "The number times to relax the voronoi diagram from its original random positions.",
      default: 3,
      min: 0,
      max: 10,
      step: 1
    }
  };
  m_settings;
  constructor() {
    super();
    this.m_settings = this.createDefaultSettings();
  }
  getName() {
    return "Continents";
  }
  init(mapSize) {
    this.initInternal(
      mapSize,
      GeneratorType.Continent,
      pangaeaSettings,
      this.m_settings.voronoiCellCountMultiple,
      this.m_settings.voronoiRelaxationSteps
    );
    this.m_builder.getGenerator().logSettings();
  }
  getSettings() {
    return this.getTypedSettings();
  }
  getTypedSettings() {
    return this.m_settings;
  }
  getSettingsConfig() {
    return this.m_schema;
  }
  getFilename() {
    return "pangaea.mapconfig.js";
  }
}

export { VoronoiPangaea };
//# sourceMappingURL=pangaea.js.map
</file>

<file path="voronoi_rules/avoid-edge.js">
import { RandomImpl } from '../random-pcg-32.js';
import { VoronoiUtils } from '../kd-tree.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';

class RuleAvoidEdge extends Rule {
  static getName() {
    return "Avoid Edge";
  }
  name = RuleAvoidEdge.getName();
  description = "This rule is used to avoid edges of the map (poles and meridian) and also contains some useful parameters to help break up the edges. It will forcibly disqualify cells that get too close, and allows for a tapering of the score as cells get closer to the edge.";
  configDefs = {
    poleDistance: {
      label: "Polar Margin",
      description: "Cells within this many hexes of either pole are excluded.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    poleDistanceFalloff: {
      label: "Poles Distance Falloff",
      description: "The distance from the poles beyond the margin at which scores will start to be reduced, gently pushing new cells away from the poles.",
      defaultValue: 6,
      min: 0,
      max: 10,
      step: 0.1
    },
    poleFalloffCurve: {
      label: "Pole Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    polePerturbationScale: {
      label: "Pole Perturbation Scale",
      description: "The maximum distance to perturb the polar margins with a sine wave.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    polePerturbationWavelength: {
      label: "Pole Perturbation Wavelength",
      description: "The wavelength of the perturbation sine wave.",
      defaultValue: 4,
      min: 1,
      max: 10,
      step: 0.1
    },
    meridianDistance: {
      label: "Meridian Margin",
      description: "Cells within this many hexes of either meridian are excluded.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    meridianDistanceFalloff: {
      label: "Meridian Distance Falloff",
      description: "The distance from the meridian beyond the margin at which scores will start to be reduced, gently pushing new cells away from the meridian.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    meridianFalloffCurve: {
      label: "Meridian Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    avoidCorners: {
      label: "Avoid Corners",
      description: "Increases the meridian falloff by this much as it approaches the poles to discourage cells from clumping up in the corners of the map.",
      defaultValue: 8,
      min: 0,
      max: 20,
      step: 0.1
    }
  };
  configValues = {
    poleDistance: this.configDefs.poleDistance.defaultValue,
    poleDistanceFalloff: this.configDefs.poleDistanceFalloff.defaultValue,
    poleFalloffCurve: this.configDefs.poleFalloffCurve.defaultValue,
    polePerturbationScale: this.configDefs.polePerturbationScale.defaultValue,
    polePerturbationWavelength: this.configDefs.polePerturbationWavelength.defaultValue,
    meridianDistance: this.configDefs.meridianDistance.defaultValue,
    meridianDistanceFalloff: this.configDefs.meridianDistanceFalloff.defaultValue,
    meridianFalloffCurve: this.configDefs.meridianFalloffCurve.defaultValue,
    avoidCorners: this.configDefs.avoidCorners.defaultValue
  };
  randomOffsetTop = 0;
  randomOffsetBottom = 0;
  prepare() {
    this.randomOffsetTop = RandomImpl.fRand("RuleAvoidEdge random offset top");
    this.randomOffsetBottom = RandomImpl.fRand("RuleAvoidEdge random offset bottom");
  }
  score(regionCell, ctx) {
    let cornerAvoidance = Math.abs(ctx.m_worldDims.y - 2 * regionCell.cell.site.y) / ctx.m_worldDims.y;
    cornerAvoidance *= cornerAvoidance * this.configValues.avoidCorners;
    const meridianDistance = Math.min(regionCell.cell.site.x, ctx.m_worldDims.x - regionCell.cell.site.x);
    const meridianDistanceHex = meridianDistance;
    const minMeridianDistance = this.configValues.meridianDistance;
    const maxMeridianDistance = this.configValues.meridianDistance + this.configValues.meridianDistanceFalloff + cornerAvoidance;
    let meridianScore = VoronoiUtils.clamp(
      VoronoiUtils.iLerp(minMeridianDistance, maxMeridianDistance, meridianDistanceHex),
      0,
      1
    );
    meridianScore = Math.pow(meridianScore, this.configValues.meridianFalloffCurve);
    if (meridianDistanceHex < minMeridianDistance) {
      meridianScore = -100;
    }
    let poleDistance = Math.min(regionCell.cell.site.y, ctx.m_worldDims.y - regionCell.cell.site.y);
    const scale = this.configValues.polePerturbationScale * 0.5;
    const wavelength = this.configValues.polePerturbationWavelength;
    const randomOffset = regionCell.cell.site.y < ctx.m_worldDims.y - regionCell.cell.site.y ? this.randomOffsetTop : this.randomOffsetBottom;
    const randomPerturbation = scale + Math.sin((regionCell.cell.site.x + randomOffset * ctx.m_worldDims.x) / wavelength) * scale;
    poleDistance -= randomPerturbation;
    const minPoleDistance = this.configValues.poleDistance;
    const maxPoleDistance = minPoleDistance + this.configValues.poleDistanceFalloff;
    let poleScore = VoronoiUtils.clamp(VoronoiUtils.iLerp(minPoleDistance, maxPoleDistance, poleDistance), 0, 1);
    poleScore = Math.pow(poleScore, this.configValues.poleFalloffCurve);
    if (poleDistance < minPoleDistance) {
      poleScore = -100;
    }
    return Math.min(meridianScore, poleScore);
  }
}

export { RuleAvoidEdge };
//# sourceMappingURL=avoid-edge.js.map
</file>

<file path="voronoi_rules/avoid-other-regions.js">
import { RegionType, VoronoiUtils } from '../kd-tree.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';

class RuleAvoidOtherRegions extends Rule {
  static getName() {
    return "Avoid Other Regions";
  }
  name = RuleAvoidOtherRegions.getName();
  description = "This rule is used to avoid other regions within some radius. Cells that are too close will be forcibly disqualified, and scores will be tapered as they get close to this minimum distance. By default any region not in the source region is filtered, but at the code level filters can be added to avoid only specific region types or region ids.";
  configDefs = {
    minDistance: {
      label: "Minimum Separation",
      description: "Cells within this many hexes of another region are excluded.",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    distanceFalloff: {
      label: "Distance Falloff",
      description: "The distance from other regions beyond the minimum at which scores will start to be reduced, gently pushing new cells away from other regions.",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    falloffCurve: {
      label: "Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    regionType: {
      label: "Region Type",
      description: "Used to only avoid a specific region type instead of all regions.",
      defaultValue: RegionType.None,
      visible: false
    },
    regionId: {
      label: "Region Id",
      description: "Used to avoid only a specific region ID.",
      defaultValue: -1,
      visible: false
    }
  };
  configValues = {
    minDistance: this.configDefs.minDistance.defaultValue,
    distanceFalloff: this.configDefs.distanceFalloff.defaultValue,
    falloffCurve: this.configDefs.falloffCurve.defaultValue,
    regionType: this.configDefs.regionType.defaultValue,
    regionId: this.configDefs.regionId.defaultValue
  };
  quadtree;
  score(regionCell, ctx) {
    const minDistance = this.configValues.minDistance;
    const minDistanceSq = minDistance * minDistance;
    const maxDistance = minDistance + this.configValues.distanceFalloff;
    const maxDistanceSq = maxDistance * maxDistance;
    let closestDistSq = maxDistanceSq;
    if (this.quadtree) {
      const filter = (item) => ctx.region.getRegionIdForCell(item) != ctx.region.id;
      const nearest = this.quadtree.nearest(regionCell.cell.site, filter, maxDistanceSq);
      if (nearest.cell) {
        closestDistSq = nearest.distSq;
      }
    } else {
      regionCell.ruleConsideration = true;
      const considerList = [regionCell.id];
      const clearList = [regionCell];
      while (considerList.length > 0) {
        const cellId = considerList.pop();
        const cell = ctx.cells[cellId];
        const distanceSq = VoronoiUtils.sqDistanceBetweenSites(regionCell.cell.site, cell.cell.site);
        if (distanceSq < closestDistSq) {
          const regionId = ctx.region.getRegionIdForCell(cell);
          let bAvoidRegion = regionId != ctx.region.id && (regionId === this.configValues.regionId || this.configValues.regionId === -1);
          bAvoidRegion = bAvoidRegion && (this.configValues.regionType === RegionType.None || ctx.regions[regionId].type == this.configValues.regionType);
          if (bAvoidRegion) {
            closestDistSq = Math.min(distanceSq, closestDistSq);
            if (closestDistSq < minDistanceSq) {
              break;
            }
          } else {
            for (const neighborId of cell.cell.getNeighborIds()) {
              const neighbor = ctx.cells[neighborId];
              if (!neighbor.ruleConsideration) {
                neighbor.ruleConsideration = true;
                clearList.push(neighbor);
                considerList.push(neighborId);
              }
            }
          }
        }
      }
      for (const cell of clearList) {
        cell.ruleConsideration = false;
      }
    }
    if (closestDistSq < minDistanceSq) {
      return -100;
    }
    const closestDist = Math.sqrt(closestDistSq);
    let score = VoronoiUtils.clamp(VoronoiUtils.iLerp(minDistance, maxDistance, closestDist), 0, 1);
    score = Math.pow(score, this.configValues.falloffCurve);
    return score;
  }
  setQuadTree(quadtree) {
    this.quadtree = quadtree;
  }
}

export { RuleAvoidOtherRegions };
//# sourceMappingURL=avoid-other-regions.js.map
</file>

<file path="voronoi_rules/cell-area.js">
import { VoronoiUtils } from '../kd-tree.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';

class RuleCellArea extends Rule {
  static getName() {
    return "Cell Area";
  }
  name = RuleCellArea.getName();
  description = "This is a simple rule that scores larger cells higher than smaller cells. This is primary used to add some random variation to the score.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The cell area that represents a score of 0.5. Any cell smaller will score between 0 and 0.5, and any cell larger will score between 0.5 and 1.0",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    },
    invert: {
      label: "Invert",
      description: "Invert the calculation to score smaller cells higher.",
      defaultValue: 0,
      min: 0,
      max: 1,
      step: 1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    invert: this.configDefs.invert.defaultValue
  };
  score(cell, _ctx) {
    const cellArea = VoronoiUtils.calculateCellArea(cell.cell);
    let score = cellArea / (cellArea + this.configValues.scaleFactor);
    if (this.configValues.invert > 0) {
      score = 1 - score;
    }
    return score;
  }
}

export { RuleCellArea };
//# sourceMappingURL=cell-area.js.map
</file>

<file path="voronoi_rules/near-map-center.js">
import { VoronoiUtils } from '../kd-tree.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';

class RuleNearMapCenter extends Rule {
  static getName() {
    return "Near Map Center";
  }
  name = RuleNearMapCenter.getName();
  description = "This is a simple rule that scores cells closer to the map center higher than cells further away.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor %",
      description: "The distance from the center as a percentage of map width that represents a score of 0.5. Any distance smaller will score between 0.5 and 1.0, and any distance larger will score between 0.0 and 0.5",
      defaultValue: 50,
      min: 0,
      max: 100,
      step: 0.1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue
  };
  score(regionCell, ctx) {
    let distanceToCenter = VoronoiUtils.sqDistance(
      { x: ctx.m_worldDims.x * 0.5, y: ctx.m_worldDims.y * 0.5 },
      { x: regionCell.cell.site.x, y: regionCell.cell.site.y }
    );
    distanceToCenter = Math.sqrt(distanceToCenter);
    let scaleFactor = this.configValues.scaleFactor * 0.01 * ctx.m_worldDims.x;
    scaleFactor *= 0.5;
    return 1 - distanceToCenter / (distanceToCenter + scaleFactor);
  }
}

export { RuleNearMapCenter };
//# sourceMappingURL=near-map-center.js.map
</file>

<file path="voronoi_rules/near-neighbor.js">
import { VoronoiUtils } from '../kd-tree.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';

class RuleNearNeighbor extends Rule {
  static getName() {
    return "Near Neighbor";
  }
  name = RuleNearNeighbor.getName();
  description = "This is a simple rule that scores nearby cells higher than cells farther away. This is primary used to add some random variation to the score.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The distance from a neighboring cell that represents a score of 0.5. Any distance smaller will score between 0.5 and 1.0, and any distance larger will score between 0.0 and 0.5",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue
  };
  score(regionCell, ctx) {
    let neighborDistanceScore = 1;
    for (const neighborId of regionCell.cell.getNeighborIds()) {
      const neighbor = ctx.cells[neighborId];
      if (ctx.region.getRegionIdForCell(neighbor) == ctx.region.id) {
        const neighborDistance = VoronoiUtils.distanceBetweenSites(
          regionCell.cell.site,
          neighbor.cell.site
        );
        neighborDistanceScore = Math.min(
          neighborDistanceScore,
          neighborDistance / (neighborDistance + this.configValues.scaleFactor)
        );
      }
    }
    return 1 - neighborDistanceScore;
  }
}

export { RuleNearNeighbor };
//# sourceMappingURL=near-neighbor.js.map
</file>

<file path="voronoi_rules/near-plate-boundary.js">
import { kdTree, PlateBoundaryPosGetter, VoronoiUtils } from '../kd-tree.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';

class RuleNearPlateBoundary extends Rule {
  static getName() {
    return "Near Plate Boundary";
  }
  name = RuleNearPlateBoundary.getName();
  description = "Scores cells based on the distance from their site to the nearest plate boundary.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The distance from a plate boundary that represents a score of 0.5. Any cell nearer to a plate boundary will score between 0.5 and 1.0, and any cell farther away will score between 0.0 and 0.5",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    directionInfluence: {
      label: "Plate Direction Influence",
      description: "How much the direction of plate movement relative to the neighboring plate influences the score.",
      defaultValue: 0.5,
      min: 0,
      max: 1,
      step: 0.05
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    directionInfluence: this.configDefs.directionInfluence.defaultValue
  };
  // This must be provided before the rule can run.
  m_plateBoundaries = new kdTree(PlateBoundaryPosGetter);
  score(regionCell, _ctx) {
    const cellPos = { x: regionCell.cell.site.x, y: regionCell.cell.site.y };
    const boundary = this.m_plateBoundaries.search(cellPos);
    const distance = Math.sqrt(boundary.distSq);
    const distanceScore = 1 - distance / (distance + this.configValues.scaleFactor);
    const plateMovementScore = distanceScore * boundary.data.plateSubduction * 0.5;
    return VoronoiUtils.lerp(distanceScore, plateMovementScore, this.configValues.directionInfluence);
  }
}

export { RuleNearPlateBoundary };
//# sourceMappingURL=near-plate-boundary.js.map
</file>

<file path="voronoi_rules/near-region-seed.js">
import { VoronoiUtils } from '../kd-tree.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../../core/scripts/MathHelpers.js';
import '../random-pcg-32.js';

class RuleNearRegionSeed extends Rule {
  static getName() {
    return "Near Region Seed";
  }
  name = RuleNearRegionSeed.getName();
  description = "This rule scores cells nearer to the region seed higher than cells farther away.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor %",
      description: "The distance from the region seed as a percentage of map width that represents a score of 0.5. Any cell nearer to the region seed will score between 0.5 and 1.0, and any cell farther away will score between 0.0 and 0.5",
      defaultValue: 20,
      min: 0,
      max: 100,
      step: 0.1
    },
    invert: {
      label: "Invert",
      description: "Invert the calculation to prefer tile further away from the region seed.",
      defaultValue: 0,
      min: 0,
      max: 1,
      step: 1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    invert: this.configDefs.invert.defaultValue
  };
  score(regionCell, ctx) {
    let distanceToSeed = VoronoiUtils.sqDistance(
      { x: ctx.region.seedLocation.x, y: ctx.region.seedLocation.y },
      { x: regionCell.cell.site.x, y: regionCell.cell.site.y }
    );
    distanceToSeed = Math.sqrt(distanceToSeed);
    let scaleFactor = this.configValues.scaleFactor * 0.01 * ctx.m_worldDims.x;
    scaleFactor *= 0.5;
    let score = distanceToSeed / (distanceToSeed + scaleFactor);
    if (!this.configValues.invert) {
      score = 1 - score;
    }
    return score;
  }
}

export { RuleNearRegionSeed };
//# sourceMappingURL=near-region-seed.js.map
</file>

<file path="voronoi_rules/neighbors-in-region.js">
import { Rule } from './rules-base.js';

class RuleNeighborsInRegion extends Rule {
  static getName() {
    return "Neighbors In Region";
  }
  name = RuleNeighborsInRegion.getName();
  description = "Scores cells based on how many of their neighbors are already in the region";
  configDefs = {
    preferredNeighborCount: {
      label: "Preferred Neighbor Count",
      description: "The normal distribution used for scoring is centered on this value. Any cells with exactly this number of neighbors will score 1, everything else will be less than that.",
      defaultValue: 3,
      min: 0,
      max: 10,
      step: 0.1
    },
    deviation: {
      label: "Preferred Neighbors Deviation",
      description: "The standard deviation for the normal distribution. Higher values will score number near the preferred count higher.",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    }
  };
  configValues = {
    preferredNeighborCount: this.configDefs.preferredNeighborCount.defaultValue,
    deviation: this.configDefs.deviation.defaultValue
  };
  // Can be replaced with custom logic.
  inRegionCheck = (ctx, _thisCell, neighborCell) => {
    return ctx.region.getRegionIdForCell(neighborCell) === ctx.region.id;
  };
  score(regionCell, ctx) {
    let neighborCount = 0;
    for (const neighborId of regionCell.cell.getNeighborIds()) {
      const neighbor = ctx.cells[neighborId];
      if (this.inRegionCheck(ctx, regionCell, neighbor)) {
        neighborCount++;
      }
    }
    const x = neighborCount;
    const d = this.configValues.deviation;
    const m = this.configValues.preferredNeighborCount;
    const zScore = (x - m) / d;
    const score = Math.exp(-0.5 * zScore * zScore);
    return score;
  }
}

export { RuleNeighborsInRegion };
//# sourceMappingURL=neighbors-in-region.js.map
</file>

<file path="voronoi_rules/prefer-latitude.js">
import { Rule } from './rules-base.js';

class LatitudeCells {
  totalCells = 0;
  cellsPerLatitude;
  constructor(numLatitudes) {
    this.cellsPerLatitude = new Array(numLatitudes).fill(0);
  }
}
class RulePreferLatitude extends Rule {
  static getName() {
    return "Prefer Latitude";
  }
  name = RulePreferLatitude.getName();
  description = "This rule scores cells based on how much area a given region occupies at different latitudes. When it is lacking certain latitudes, then it scores cells in that are higher. When it already has plenty of cells in a latitude, those cells will be scored lower. ";
  configDefs = {
    overlap: {
      label: "Overlap %",
      description: "The amount of overlap allowed between latitudes",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    mirror: {
      label: "Mirror",
      description: "Should the preferred latitudes be mirrored across the equator",
      defaultValue: true,
      min: 0,
      max: 1,
      step: 1
    },
    latitudes: {
      label: "Latitudes",
      description: "latitude bands from -90 to +90 degrees",
      defaultValue: [],
      arrayField: {
        latitude: {
          label: "Latitude",
          description: "A latitude bands between -90 and +90 degrees",
          defaultValue: 0
        },
        weight: {
          label: "Weight %",
          description: "What percentage of this continent should be in this latitude band",
          defaultValue: 0,
          min: 0,
          max: 100,
          step: 1
        }
      }
    }
  };
  configValues = {
    overlap: this.configDefs.overlap.defaultValue,
    mirror: this.configDefs.mirror.defaultValue,
    latitudes: new Array(0)
  };
  m_latitudeBounds = [];
  m_regionLatitudeCells = /* @__PURE__ */ new Map();
  prepare() {
    super.prepare();
    this.m_latitudeBounds = [];
    this.m_regionLatitudeCells.clear();
    let previousBoundary = 0;
    const overlap = this.configValues.overlap * 0.01;
    const halfOverlap = overlap * 0.5;
    let latitudes = this.configValues.latitudes.map((value, index) => [index, value]);
    if (this.configValues.mirror) {
      latitudes = latitudes.concat(
        latitudes.map((value) => {
          return [value[0], { latitude: -value[1].latitude, weight: value[1].weight }];
        })
      );
    }
    latitudes.sort((a, b) => b[1].latitude - a[1].latitude);
    for (let i = 0; i < latitudes.length; ++i) {
      const latitudeDegrees = latitudes[i][1].latitude;
      const latitude = -latitudeDegrees / 180 + 0.5;
      const last = i === latitudes.length - 1;
      const nextBoundary = (() => {
        if (last) {
          return 1;
        } else {
          const nextLatitudeDegrees = latitudes[i + 1][1].latitude;
          const nextLatitude = -nextLatitudeDegrees / 180 + 0.5;
          const difference = nextLatitude - latitude;
          return latitude + 0.5 * difference;
        }
      })();
      const latitudeSetting = {
        min: Math.max(0, previousBoundary - halfOverlap),
        max: Math.min(1, nextBoundary + halfOverlap),
        center: latitude,
        weight: latitudes[i][1].weight * 0.01,
        index: latitudes[i][0]
      };
      this.m_latitudeBounds.push(latitudeSetting);
      previousBoundary = nextBoundary;
    }
  }
  score(regionCell, ctx) {
    let latitudeCells = this.m_regionLatitudeCells.get(ctx.region.id);
    if (!latitudeCells) {
      latitudeCells = new LatitudeCells(this.configValues.latitudes.length);
      this.m_regionLatitudeCells.set(regionCell.landmassId, latitudeCells);
    }
    const overlap = this.configValues.overlap * 0.01;
    const yPos = regionCell.cell.site.y / ctx.m_worldDims.y;
    let score = 0;
    for (let i = 0; i < this.m_latitudeBounds.length; ++i) {
      const bounds = this.m_latitudeBounds[i];
      if (yPos < bounds.min || yPos > bounds.max) continue;
      const weight = yPos < bounds.min + overlap ? (yPos - bounds.min) / overlap : yPos > bounds.max - overlap ? (bounds.max - yPos) / overlap : 1;
      const currentPercentage = (latitudeCells.cellsPerLatitude[bounds.index] ?? 0) / Math.max(latitudeCells.totalCells, 1);
      const desiredPercentage = bounds.weight;
      score += weight * Math.min(1, Math.max(0, (desiredPercentage - currentPercentage) / desiredPercentage));
    }
    return score;
  }
  notifySelectedCell(cell, ctx) {
    super.notifySelectedCell(cell, ctx);
    let latitudeCells = this.m_regionLatitudeCells.get(cell.landmassId);
    if (!latitudeCells) {
      latitudeCells = new LatitudeCells(this.configValues.latitudes.length);
      this.m_regionLatitudeCells.set(cell.landmassId, latitudeCells);
    }
    latitudeCells.totalCells++;
    const overlap = this.configValues.overlap * 0.01;
    const yPos = cell.cell.site.y / ctx.m_worldDims.y;
    for (let i = 0; i < this.m_latitudeBounds.length; ++i) {
      const bounds = this.m_latitudeBounds[i];
      if (yPos < bounds.min) break;
      if (yPos < bounds.min + overlap) {
        latitudeCells.cellsPerLatitude[bounds.index] += (yPos - bounds.min) / overlap;
      } else if (yPos < bounds.max - overlap) {
        latitudeCells.cellsPerLatitude[bounds.index] += 1;
      } else if (yPos < bounds.max) {
        latitudeCells.cellsPerLatitude[bounds.index] += (bounds.max - yPos) / overlap;
      }
    }
  }
}

export { RulePreferLatitude };
//# sourceMappingURL=prefer-latitude.js.map
</file>

<file path="voronoi_rules/rules-base.js">
class RuleSetting {
  isActive = false;
  weight = 0;
  record = {};
  nameOverride;
  internalConfig = {};
  key;
}
class Rule {
  key;
  description;
  isActive = false;
  weight = 1;
  notifySelectedCell(_cell, _ctx) {
  }
  initialize(config) {
    this.isActive = config.isActive;
    this.weight = config.weight;
    this.name = config.nameOverride ?? this.name;
    this.key = config.key ?? this.name;
    for (const [recordName, recordValue] of Object.entries(config.record)) {
      if (recordName in this.configValues) {
        this.configValues[recordName] = recordValue;
      }
    }
    if (config.internalConfig) {
      for (const [recordName, recordValue] of Object.entries(config.internalConfig)) {
        if (recordName in this) {
          this[recordName] = recordValue;
        } else {
          console.log("Unable to find " + recordName + " in " + this.name);
        }
      }
    }
  }
  prepare() {
  }
  // Optionally overridden
  scoreAllCells(filter, ctx, regionIdGetter, weight = 1) {
    for (const cell of ctx.cells) {
      if (filter(cell)) {
        ctx.region = regionIdGetter(cell);
        cell.currentScore += this.score(cell, ctx) * weight;
      }
    }
  }
  scoreCells(cells, ctx, regionIdGetter, weight = 1) {
    for (const cell of cells) {
      ctx.region = regionIdGetter(cell);
      cell.currentScore += this.score(cell, ctx) * weight;
    }
  }
}

export { Rule, RuleSetting };
//# sourceMappingURL=rules-base.js.map
</file>

<file path="age-transition-post-load.js">
import { generateDiscoveries } from '../maps/discovery-generator.js';
import { dumpResources } from '../maps/map-debug-helpers.js';
import { removeRuralDistrict, placeRuralDistrict, getMinimumResourcePlacementModifier, shuffle, replaceIslandResources } from '../maps/map-utilities.js';
import '../maps/map-globals.js';

console.log("Loading age-transition-post-load.ts");
let g_numMajorPlayers = 0;
let g_incomingAge = 0;
function requestInitializationParameters(initParams) {
  console.log("Getting Age Transition Parameters");
  console.log("Players: ", initParams.numMajorPlayers);
  console.log("Old Age: ", initParams.outgoingAge);
  console.log("New Age: ", initParams.incomingAge);
  g_numMajorPlayers = initParams.numMajorPlayers;
  g_incomingAge = initParams.incomingAge;
  engine.call("SetAgeInitializationParameters", initParams);
}
function doMapUpdates() {
  TerrainBuilder.storeWaterData();
}
function generateTransition() {
  console.log("Generating age transition!");
  const setting = Configuration.getGameValue("AgeTransitionSettingName");
  console.log("Age Transition Setting: " + setting);
  let continuityMode = false;
  if (setting == "AGE_TRANSITION_SETTING_KEEP_MORE") {
    console.log("Using continuity setting");
    continuityMode = true;
  }
  doMapUpdates();
  const iRemovedResourcePlots = [];
  const aGeneratedResources = ResourceBuilder.getGeneratedMapResources();
  removeObsoleteResources(iRemovedResourcePlots, aGeneratedResources);
  addNewResources(iRemovedResourcePlots, aGeneratedResources);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  generateDiscoveries(iWidth, iHeight, []);
  for (let iPlayer = 0; iPlayer < g_numMajorPlayers; iPlayer++) {
    if (!Players.get(iPlayer)?.isAlive) {
      continue;
    }
    const regressedCities = regressCitiesToTowns(iPlayer);
    if (continuityMode) {
      positionUnits(iPlayer);
    } else {
      positionArmyCommanders(iPlayer);
      positionFleetCommanders(iPlayer);
    }
    capGold(iPlayer, continuityMode);
    capInfluence(iPlayer, continuityMode);
    changeCapitalCards(iPlayer);
    generateDarkAgeCards(iPlayer);
    generateDynamicVictoryCards(iPlayer);
    generateRetainCityCards(iPlayer, regressedCities);
    Players.AdvancedStart.get(iPlayer)?.dynamicCardsAddedComplete();
  }
}
function removeObsoleteResources(iRemovedResourcePlots, aGeneratedResources) {
  console.log("Removing old resources");
  const aTypesRemoved = [];
  const aCutResources = [];
  const resourcesAvailable = ResourceBuilder.getResourceCounts(-1);
  let countOnMap = 0;
  let countRemoved = 0;
  for (let i = 0; i < resourcesAvailable.length; ++i) {
    if (resourcesAvailable[i] > 0) {
      countOnMap++;
    }
  }
  const countToAdd = aGeneratedResources.length;
  console.log("Adding new resources: " + countToAdd);
  console.log("Resources already on map: " + countOnMap);
  let totalResourceToCut = countOnMap + countToAdd - countOnMap;
  if (totalResourceToCut < 0) {
    totalResourceToCut = 0;
  }
  console.log("Number of resources to cut: " + totalResourceToCut);
  const resourceToCut = ResourceBuilder.getBestMapResourceCuts(aGeneratedResources, totalResourceToCut);
  for (let iI = 0; iI < resourceToCut.length; ++iI) {
    const resourceInfo = GameInfo.Resources.lookup(resourceToCut[iI]);
    if (resourceInfo) {
      aCutResources.push(resourceInfo.$index);
    }
  }
  console.log("Cutting " + aCutResources.length + " resources");
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const iIndex = iY * iWidth + iX;
      const resource = GameplayMap.getResourceType(iX, iY);
      if (resource != ResourceTypes.NO_RESOURCE) {
        let removeResource = false;
        if (aCutResources.find((x) => x == resource)) {
          removeResource = true;
        }
        if (!removeResource && !ResourceBuilder.isResourceValidForAge(resource, g_incomingAge)) {
          removeResource = true;
        }
        if (removeResource) {
          const resourceInfo = GameInfo.Resources.lookup(resource);
          if (resourceInfo) {
            countRemoved++;
            removeRuralDistrict(iX, iY);
            ResourceBuilder.setResourceType(iX, iY, ResourceTypes.NO_RESOURCE);
            console.log(
              "Removed resource: " + Locale.compose(resourceInfo.Name) + " at (" + iX + ", " + iY + ")"
            );
            iRemovedResourcePlots.push(iIndex);
            placeRuralDistrict(iX, iY);
            const resourceType = resourceInfo.$index;
            if (!aTypesRemoved.find((x) => x == resourceType)) {
              aTypesRemoved.push(resourceType);
            }
          }
        }
      }
    }
  }
  console.log("Removed total resource locations: " + countRemoved);
  return aTypesRemoved.length;
}
function addNewResources(iRemovedResourcePlots, aGeneratedResources) {
  console.log("Adding new resources");
  const iResourceCounts = ResourceBuilder.getResourceCounts(-1);
  const aResourceTypes = [];
  for (let ridx = 0; ridx < aGeneratedResources.length; ++ridx) {
    const resourceInfo = GameInfo.Resources.lookup(aGeneratedResources[ridx]);
    if (resourceInfo && resourceInfo.Tradeable) {
      if (iResourceCounts[resourceInfo.$index] == 0) {
        aResourceTypes.push(resourceInfo.$index);
      }
    }
  }
  let iMapMinimumModifer = getMinimumResourcePlacementModifier();
  if (iMapMinimumModifer == void 0) {
    iMapMinimumModifer = 0;
  }
  const aPlacementPlots = [];
  const seed = GameplayMap.getRandomSeed() * (1 + g_incomingAge);
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const districtID = MapCities.getDistrict(iX, iY);
        if (districtID == null) {
          aPlacementPlots.push(index);
        }
      }
    }
  }
  iRemovedResourcePlots.forEach((index) => {
    if (index) {
      if (!aPlacementPlots.find((x) => x == index)) {
        aPlacementPlots.push(index);
      }
    }
  });
  shuffle(aPlacementPlots);
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const resourcesPlacedCount = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCount = /* @__PURE__ */ new Map();
  const getImportantResourceCounts = (landmassId) => {
    if (!importantResourceRegionalCount.has(landmassId)) {
      importantResourceRegionalCount.set(landmassId, new Array(GameInfo.Resources.length).fill(0));
    }
    return importantResourceRegionalCount.get(landmassId);
  };
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resourceWeight[resourceIdx] = 0;
    resourceRunningWeight[resourceIdx] = 0;
    resourcesPlacedCount[resourceIdx] = 0;
  }
  let maxPerHemisphere = 0;
  const resourceDistribution = GameInfo.Resource_Distribution.lookup(g_incomingAge);
  if (resourceDistribution) {
    maxPerHemisphere = resourceDistribution.ResourceTypeMaxPerHemisphere;
  }
  aResourceTypes.forEach((resourceType) => {
    if (resourceType) {
      const resourceInfo = GameInfo.Resources[resourceType];
      if (resourceInfo) {
        resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
      }
    }
  });
  let iNumPlaced = 0;
  aPlacementPlots.forEach((index) => {
    if (index) {
      const kLocation = GameplayMap.getLocationFromIndex(index);
      const landmassRegionId = GameplayMap.getLandmassRegionId(kLocation.x, kLocation.y);
      const resources = [];
      aResourceTypes.forEach((resourceIdx) => {
        const assignedLandmass = ResourceBuilder.getResourceLandmass(resourceIdx);
        const allowedOnLandmass = assignedLandmass == LandmassRegion.LANDMASS_REGION_ANY || assignedLandmass != LandmassRegion.LANDMASS_REGION_NONE && landmassRegionId != LandmassRegion.LANDMASS_REGION_DEFAULT && assignedLandmass % landmassRegionId == 0;
        if (allowedOnLandmass) {
          const existingResource = GameplayMap.getResourceType(kLocation.x, kLocation.y);
          if (existingResource != ResourceTypes.NO_RESOURCE && !ResourceBuilder.isResourceClassRequiredForLegacyPath(existingResource)) {
            if (ResourceBuilder.canHaveResource(kLocation.x, kLocation.y, resourceIdx, true)) {
              resources.push(resourceIdx);
            }
          } else {
            if (ResourceBuilder.canHaveResource(kLocation.x, kLocation.y, resourceIdx, true)) {
              resources.push(resourceIdx);
            }
          }
        }
      });
      if (resources.length > 0) {
        let resourceChosen = ResourceTypes.NO_RESOURCE;
        let resourceChosenIndex = 0;
        for (let iI = 0; iI < resources.length; iI++) {
          if (resourceChosen == ResourceTypes.NO_RESOURCE) {
            resourceChosen = resources[iI];
            resourceChosenIndex = resources[iI];
          } else {
            if (resourceRunningWeight[resources[iI]] > resourceRunningWeight[resourceChosenIndex]) {
              resourceChosen = resources[iI];
              resourceChosenIndex = resources[iI];
            } else if (resourceRunningWeight[resources[iI]] == resourceRunningWeight[resourceChosenIndex]) {
              const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
              if (iRoll >= 1) {
                resourceChosen = resources[iI];
                resourceChosenIndex = resources[iI];
              }
            }
          }
        }
        if (getImportantResourceCounts(landmassRegionId)[resourceChosenIndex] < maxPerHemisphere) {
          if (resourceChosen != ResourceTypes.NO_RESOURCE) {
            ResourceBuilder.setResourceType(kLocation.x, kLocation.y, resourceChosen);
            resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
            const name = GameInfo.Resources[resourceChosenIndex].Name;
            console.log(
              "Placed " + Locale.compose(name) + " at (" + kLocation.x + ", " + kLocation.y + ")"
            );
            iNumPlaced++;
            getImportantResourceCounts(landmassRegionId)[resourceChosenIndex]++;
            resourcesPlacedCount[resourceChosenIndex]++;
            removeRuralDistrict(kLocation.x, kLocation.y);
            placeRuralDistrict(kLocation.x, kLocation.y);
          } else {
            console.log("Resource Type Failure");
          }
        }
      }
    }
  });
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const districtID = MapCities.getDistrict(iX, iY);
      if (districtID == null) {
        const landmassRegionId = GameplayMap.getLandmassRegionId(iX, iY);
        for (let i = 0; i < resourcesPlacedCount.length; ++i) {
          const resourceToPlace = GameInfo.Resources.lookup(i);
          if (resourceToPlace) {
            const assignedLandmass = ResourceBuilder.getResourceLandmass(i);
            const allowedOnLandmass = landmassRegionId != LandmassRegion.LANDMASS_REGION_DEFAULT && (assignedLandmass == LandmassRegion.LANDMASS_REGION_ANY || assignedLandmass != LandmassRegion.LANDMASS_REGION_NONE && assignedLandmass % landmassRegionId == 0);
            if (!allowedOnLandmass) {
              continue;
            }
            const minimumPerLandMass = resourceToPlace.MinimumPerHemisphere > 0 ? resourceToPlace.MinimumPerHemisphere + iMapMinimumModifer : 0;
            if (getImportantResourceCounts(landmassRegionId)[i] < minimumPerLandMass) {
              if (resourcesPlacedCount[i] > 0 && ResourceBuilder.isResourceRequiredForAge(i, Game.age)) {
                if (ResourceBuilder.canHaveResource(iX, iY, i, false)) {
                  ResourceBuilder.setResourceType(iX, iY, i);
                  const name = GameInfo.Resources.lookup(i)?.Name;
                  console.log(
                    "Force Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")"
                  );
                  getImportantResourceCounts(landmassRegionId)[i]++;
                  removeRuralDistrict(iX, iY);
                  placeRuralDistrict(iX, iY);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  const ageDefinition = GameInfo.Ages.lookup(g_incomingAge);
  if (ageDefinition) {
    const mapType = Configuration.getMapValue("Name");
    for (const option of GameInfo.MapIslandBehavior) {
      if (option.MapType === mapType && option.AgeType == ageDefinition.AgeType) {
        replaceIslandResources(iWidth, iHeight, option.ResourceClassType);
      }
    }
  }
  dumpResources(iWidth, iHeight);
}
var DynamicCardTypes = /* @__PURE__ */ ((DynamicCardTypes2) => {
  DynamicCardTypes2[DynamicCardTypes2["None"] = 0] = "None";
  DynamicCardTypes2[DynamicCardTypes2["Capital"] = 1] = "Capital";
  DynamicCardTypes2[DynamicCardTypes2["City"] = 2] = "City";
  DynamicCardTypes2[DynamicCardTypes2["Commander"] = 3] = "Commander";
  DynamicCardTypes2[DynamicCardTypes2["Wonder"] = 4] = "Wonder";
  DynamicCardTypes2[DynamicCardTypes2["Gold"] = 5] = "Gold";
  DynamicCardTypes2[DynamicCardTypes2["DarkAge"] = 6] = "DarkAge";
  DynamicCardTypes2[DynamicCardTypes2["Victory"] = 7] = "Victory";
  DynamicCardTypes2[DynamicCardTypes2["Unit"] = 8] = "Unit";
  return DynamicCardTypes2;
})(DynamicCardTypes || {});
function regressCitiesToTowns(iPlayer) {
  const player = Players.get(iPlayer);
  const playerSettlements = player?.Cities?.getCityIds();
  const regressedCities = [];
  if (playerSettlements != null) {
    for (let i = 0; i < playerSettlements.length; i++) {
      const settlement = Cities.get(playerSettlements[i]);
      if (settlement != null) {
        if (!settlement.isCapital && !settlement.isTown) {
          regressedCities.push(playerSettlements[i]);
          settlement.changeHasBuildQueue(-1);
        }
      }
    }
  }
  return regressedCities;
}
function changeCapitalCards(iPlayer) {
  const capitalOptions = 2;
  const player = Players.get(iPlayer);
  let playerSettlements = player?.Cities?.getCityIds();
  let currentPlayerCapitalName = "LOC_ERROR_NO_CAPITAL_NAME";
  const currentPlayerCapital = player?.Cities?.getCapital();
  if (currentPlayerCapital != null) {
    currentPlayerCapitalName = currentPlayerCapital.name;
  }
  if (player != null && playerSettlements != null) {
    playerSettlements = playerSettlements.sort((a, b) => {
      const popA = Cities.get(a)?.population;
      const popB = Cities.get(b)?.population;
      if (popA == null) return 1;
      if (popB == null) return -1;
      return popB - popA;
    });
    let capitalName = "LOC_ERROR_NO_CAPITAL_NAME";
    const civ = GameInfo.Civilizations.lookup(player.civilizationType);
    if (civ != null) {
      capitalName = civ.CapitalName;
    }
    let cardsGenerated = 0;
    for (let i = 0; i < playerSettlements.length && cardsGenerated < capitalOptions; i++) {
      const settlement = Cities.get(playerSettlements[i]);
      if (settlement != null) {
        if (!settlement.isCapital && settlement.Trade != null && settlement.Trade.isConnectedToOwnersCapitalByLand()) {
          const card = {
            id: "CARD_AT_CHANGE_CAPITAL_" + cardsGenerated,
            name: "LOC_CARD_AT_CHANGE_CAPITAL",
            description: "LOC_CARD_AT_CHANGE_CAPITAL_DESCRIPTION\\" + settlement.name + "\\" + capitalName + "\\" + currentPlayerCapitalName,
            tooltip: "",
            iconOverride: "",
            limitID: "CARD_AT_CHANGE_CAPITAL_0",
            individualLimit: 1,
            groupLimit: 1,
            categorySortOrder: 100,
            cost: [{ category: CardCategories.CARD_CATEGORY_WILDCARD, value: 0 }],
            effects: [
              {
                id: "CARD_AT_CHANGE_CAPITAL_" + cardsGenerated,
                type: "CARD_AT_CHANGE_CAPITAL",
                name: "",
                description: "",
                amount: 1,
                special: 0,
                metadata: {
                  Type: 1 /* Capital */,
                  SettlementId: settlement.id.id
                }
              }
            ],
            aiModifierLists: []
          };
          Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
          cardsGenerated += 1;
        }
      }
    }
  }
}
function positionUnits(iPlayer) {
  const player = Players.get(iPlayer);
  if (player != null) {
    const playerUnits = player?.Units;
    if (playerUnits != null) {
      let commanderIds = playerUnits.getUnitIds();
      if (commanderIds != null) {
        commanderIds = commanderIds.filter((unitId) => {
          return Units.get(unitId)?.isCommanderUnit;
        });
        const shadows = playerUnits.getUnitShadows();
        for (const shadow of shadows) {
          const unit = createUnitFromShadowAtLocation(player, shadow, shadow.location);
          if (unit != null && shadow.isInCommander) {
            console.log("In commander");
            for (const commanderId of commanderIds) {
              const army = Armies.get(commanderId);
              console.log(
                "Locations: " + army?.location.x + "," + army?.location.y + " " + shadow.location.x + "," + shadow.location.y + " " + (army != null) + " " + (army?.location == shadow.location)
              );
              if (army != null && army.location.x == shadow.location.x && army.location.y == shadow.location.y) {
                console.log("Packing");
                army.packUnit(unit);
              }
            }
          }
        }
      }
    }
  }
}
function positionArmyCommanders(iPlayer) {
  const LAND_DOMAIN_HASH = Database.makeHash("DOMAIN_LAND");
  const CORE_CLASS_MILITARY_HASH = Database.makeHash("CORE_CLASS_MILITARY");
  const numDefensiveUnits = getNumDefenders();
  const player = Players.get(iPlayer);
  if (player != null) {
    let playerSettlements = player?.Cities?.getCityIds();
    if (playerSettlements != null && playerSettlements.length > 0) {
      playerSettlements = playerSettlements.sort((a, b) => {
        const popA = Cities.get(a)?.population;
        const popB = Cities.get(b)?.population;
        if (popA == null) return 1;
        if (popB == null) return -1;
        return popB - popA;
      });
      const cityCount = playerSettlements.length;
      console.log("Cities available ", cityCount);
      const playerUnits = player?.Units;
      if (playerUnits != null) {
        let totalUnitsCreated = 0;
        let shadows = playerUnits.getUnitShadows();
        let unitIds = player?.Units?.getUnitIds();
        if (unitIds != null) {
          unitIds.forEach((unitID) => {
            const unit = Units.get(unitID);
            if (unit != null && unit.isArmyCommander) {
              console.log("Packing commander with previous units");
              const army = Armies.get(unit.armyId);
              const packedUnits = [];
              for (let i = 0; i < shadows.length; i++) {
                if (shadows[i].location.x == unit.location.x && shadows[i].location.y == unit.location.y && shadows[i].isInCommander) {
                  console.log("Found previous packed unit");
                  packedUnits.push(i);
                }
              }
              for (let i = 0; i < packedUnits.length; i++) {
                const newUnitID = createUnitFromShadowAtLocation(
                  player,
                  shadows[packedUnits[i]],
                  unit.location
                );
                totalUnitsCreated++;
                if (newUnitID != null) {
                  console.log("Packing unit");
                  army?.packUnit(newUnitID);
                }
              }
              while (packedUnits.length > 0) {
                const index = packedUnits.pop();
                if (index != null) {
                  playerUnits.removeUnitShadowAtIndex(index);
                }
              }
              shadows = playerUnits.getUnitShadows();
            }
          });
        }
        shadows = playerUnits.getUnitShadows();
        for (let i = 0; i < shadows.length; i++) {
          console.log(JSON.stringify(shadows[i]));
        }
        let cityIndex = 0;
        for (let i = 0; i < numDefensiveUnits; i++) {
          const city = Cities.get(playerSettlements[cityIndex]);
          if (city != null) {
            const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
              city.location,
              LAND_DOMAIN_HASH,
              CORE_CLASS_MILITARY_HASH
            );
            if (shadowIndex >= 0 && shadowIndex < shadows.length) {
              createUnitFromShadowAtLocation(player, shadows[shadowIndex], city.location);
              playerUnits.removeUnitShadowAtIndex(shadowIndex);
              shadows = playerUnits.getUnitShadows();
              totalUnitsCreated++;
            } else if (totalUnitsCreated < numDefensiveUnits) {
              console.log("Spawning free unit as defender");
              player.AdvancedStart?.createDefender(
                city.location,
                Database.makeHash("UNIT_CLASS_INFANTRY")
              );
              totalUnitsCreated++;
            }
          }
          cityIndex++;
          if (cityIndex >= cityCount) {
            cityIndex = 0;
          }
        }
        unitIds = player?.Units?.getUnitIds();
        if (unitIds != null) {
          unitIds = unitIds.filter((unitId) => {
            return Units.get(unitId)?.Experience?.canEarnExperience == true && Units.get(unitId)?.isArmyCommander;
          });
          unitIds = unitIds.sort((a, b) => {
            let expA = 0;
            let expB = 0;
            const expCompA = Units.get(a)?.Experience;
            if (expCompA != null) {
              expA = expCompA.experiencePoints;
            }
            const expCompB = Units.get(b)?.Experience;
            if (expCompB != null) {
              expB = expCompB.experiencePoints;
            }
            return expB - expA;
          });
          if (unitIds.length == 0) {
            const city = Cities.get(playerSettlements[0]);
            if (city != null) {
              const commanderType = player.Units?.getBuildUnit("UNIT_ARMY_COMMANDER");
              const result = Units.create(player.id, { Type: commanderType, Location: city.location });
              if (result.Success && result.ID) {
                unitIds.push(result.ID);
              }
            }
          }
          unitIds.forEach((unitID) => {
            const unit = Units.get(unitID);
            if (unit != null && playerSettlements != null) {
              console.log(Locale.compose(unit.name));
              if (unit.isArmyCommander) {
                const army = Armies.get(unit.armyId);
                const prevArmyLocation = unit.location;
                const city = player.Cities?.findClosest(unit.location);
                if (city != null && army != null) {
                  Units.setLocation(unitID, city.location);
                  unit.setProperty("PROPERTY_CHECK_COMMANDER", true);
                  unit.setProperty("PROPERTY_KEEP_COMMANDER", true);
                  const capacityRemaining = army.combatUnitCapacity - army.unitCount;
                  for (let i = 0; i < capacityRemaining && shadows.length > 0; i++) {
                    const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
                      prevArmyLocation,
                      LAND_DOMAIN_HASH,
                      CORE_CLASS_MILITARY_HASH
                    );
                    if (shadowIndex >= 0 && shadowIndex < shadows.length) {
                      const newUnitID = createUnitFromShadowAtLocation(
                        player,
                        shadows[shadowIndex],
                        city.location
                      );
                      playerUnits.removeUnitShadowAtIndex(shadowIndex);
                      shadows = playerUnits.getUnitShadows();
                      totalUnitsCreated++;
                      if (newUnitID != null) {
                        army.packUnit(newUnitID);
                      }
                    }
                  }
                }
              }
            }
          });
        }
      }
    }
  }
}
function positionFleetCommanders(iPlayer) {
  const SEA_DOMAIN_HASH = Database.makeHash("DOMAIN_SEA");
  const CORE_CLASS_MILITARY_HASH = Database.makeHash("CORE_CLASS_MILITARY");
  const player = Players.get(iPlayer);
  if (player != null) {
    let unitIds = player?.Units?.getUnitIds();
    if (unitIds != null) {
      unitIds = unitIds.filter((unitId) => {
        return Units.get(unitId)?.Experience?.canEarnExperience == true && Units.get(unitId)?.isFleetCommander;
      });
      unitIds = unitIds.sort((a, b) => {
        let expA = 0;
        let expB = 0;
        const expCompA = Units.get(a)?.Experience;
        if (expCompA != null) {
          expA = expCompA.experiencePoints;
        }
        const expCompB = Units.get(b)?.Experience;
        if (expCompB != null) {
          expB = expCompB.experiencePoints;
        }
        return expB - expA;
      });
      const playerUnits = player?.Units;
      if (playerUnits != null) {
        let shadows = playerUnits.getUnitShadows();
        unitIds.forEach((unitID) => {
          const unit = Units.get(unitID);
          if (unit != null) {
            console.log(Locale.compose(unit.name));
            if (unit.isFleetCommander) {
              const army = Armies.get(unit.armyId);
              const locationIndex = Game.PlacementRules.getValidOceanNavalLocation(iPlayer);
              console.log("Location Index: " + locationIndex);
              if (army != null && locationIndex != -1) {
                const location = GameplayMap.getLocationFromIndex(locationIndex);
                const prevArmyLocation = unit.location;
                Units.setLocation(unitID, location);
                console.log("Location: " + JSON.stringify(location));
                unit.setProperty("PROPERTY_CHECK_COMMANDER", true);
                unit.setProperty("PROPERTY_KEEP_COMMANDER", true);
                for (let i = 0; i < army.combatUnitCapacity && shadows.length > 0; i++) {
                  const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
                    prevArmyLocation,
                    SEA_DOMAIN_HASH,
                    CORE_CLASS_MILITARY_HASH
                  );
                  if (shadowIndex >= 0 && shadowIndex < shadows.length) {
                    const newUnitID = createUnitFromShadowAtLocation(
                      player,
                      shadows[shadowIndex],
                      prevArmyLocation
                    );
                    playerUnits.removeUnitShadowAtIndex(shadowIndex);
                    shadows = playerUnits.getUnitShadows();
                    if (newUnitID != null) {
                      army.packUnit(newUnitID);
                    }
                  } else {
                    console.log("Shadow index outside of valid range");
                  }
                }
              }
            }
          }
        });
      }
    }
  }
}
function createUnitFromShadowAtLocation(player, shadow, location) {
  for (const shadowOption of GameInfo.Unit_ShadowReplacements) {
    if (Database.makeHash(shadowOption.Domain) == shadow.domainHash && Database.makeHash(shadowOption.CoreClass) == shadow.coreClassHash && Database.makeHash(shadowOption.Tag) == shadow.tagHash) {
      const buildUnit = player.Units?.getBuildUnit(shadowOption.UnitType);
      if (buildUnit != null) {
        const result = Units.create(player.id, { Type: buildUnit, Location: location, Validate: true });
        if (result.Success && result.ID) {
          return result.ID;
        }
      }
    }
  }
  return null;
}
function getNumDefenders() {
  const definition = GameInfo.Ages.lookup(Game.age);
  if (definition != null) {
    return definition.NumDefenders;
  }
  return 0;
}
function capGold(iPlayer, bContinuityMode) {
  const player = Players.get(iPlayer);
  let defaultGold = Game.EconomicRules.adjustForGameSpeed(3e3);
  if (bContinuityMode) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      defaultGold = Game.EconomicRules.adjustForGameSpeed(6e3);
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      defaultGold = Game.EconomicRules.adjustForGameSpeed(9e3);
    }
  }
  console.log("Default gold: " + defaultGold);
  const currentGold = player?.Treasury?.goldBalance;
  if (currentGold != null) {
    if (currentGold > defaultGold) {
      player?.Treasury?.changeGoldBalance(defaultGold - currentGold);
    }
  }
}
function capInfluence(iPlayer, bContinuityMode) {
  const player = Players.get(iPlayer);
  let defaultInfluence = Game.EconomicRules.adjustForGameSpeed(500);
  if (bContinuityMode) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      defaultInfluence = Game.EconomicRules.adjustForGameSpeed(800);
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      defaultInfluence = Game.EconomicRules.adjustForGameSpeed(1200);
    }
  }
  console.log("Default influence: " + defaultInfluence);
  const currentInfluence = player?.DiplomacyTreasury?.diplomacyBalance;
  if (currentInfluence != null) {
    if (currentInfluence > defaultInfluence) {
      player?.DiplomacyTreasury?.changeDiplomacyBalance(defaultInfluence - currentInfluence);
    }
  }
}
function generateDarkAgeCards(iPlayer) {
  if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
    const card = {
      id: "CARD_AT_EXP_DARK_AGE_MILITARY",
      name: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_DARK_AGE_NAME",
      description: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_DARK_AGE_DESCRIPTION",
      tooltip: "",
      iconOverride: "agecard_dark.png",
      limitID: "",
      individualLimit: 1,
      unlock: "UNLOCK_DARK_AGE_MILITARISTIC_1",
      categorySortOrder: 100,
      cost: [{ category: CardCategories.CARD_CATEGORY_DARK_AGE, value: 1 }],
      effects: [
        {
          id: "CARD_AT_EXP_DARK_AGE_ARMY",
          type: "CARD_ADD_ARMY_CAVALRY_PLUS_SIEGE",
          name: "",
          description: "",
          amount: 3,
          special: 0,
          metadata: {
            Type: 6 /* DarkAge */
          }
        },
        {
          id: "CARD_AT_EXP_DARK_AGE_LOSE_ALL_BUT_CAPITAL",
          type: "",
          name: "",
          description: "",
          amount: 1,
          special: 0,
          metadata: {
            Type: 6 /* DarkAge */
          }
        }
      ],
      aiModifierLists: ["Dark Age Armies Pseudoyields"]
    };
    Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
  }
}
function generateRetainCityCards(iPlayer, aSettlements) {
  const player = Players.get(iPlayer);
  if (player != null) {
    if (aSettlements.length > 0) {
      if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
        const card = {
          id: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC",
          name: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_GOLDEN_AGE_NAME",
          description: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_GOLDEN_AGE_DESCRIPTION",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_EXP_VICTORY_CULTURE_GOLDEN_AGE",
          individualLimit: 1,
          goldenAgeReward: true,
          categorySortOrder: 10,
          unlock: "UNLOCK_WON_ECONOMIC_VICTORY_1",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [],
          aiModifierLists: []
        };
        for (let i = 0; i < aSettlements.length; i++) {
          card.effects.push({
            id: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC_" + i,
            type: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC",
            name: "",
            description: "",
            amount: 1,
            special: 0,
            metadata: {
              Type: 2 /* City */,
              SettlementId: aSettlements[i].id
            }
          });
        }
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      } else if (Game.age == Database.makeHash("AGE_MODERN")) {
        const card = {
          id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC",
          name: "LOC_LEGACY_PATH_EXPLORATION_ECONOMIC_GOLDEN_AGE_NAME",
          description: "LOC_LEGACY_PATH_EXPLORATION_ECONOMIC_GOLDEN_AGE_DESCRIPTION",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_MOD_VICTORY_MILITARISTIC_FIRST",
          individualLimit: 1,
          goldenAgeReward: true,
          categorySortOrder: 10,
          unlock: "UNLOCK_WON_ECONOMIC_VICTORY_2",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_POPULATION",
              type: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_POPULATION",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {}
            }
          ],
          aiModifierLists: []
        };
        for (let i = 0; i < aSettlements.length; i++) {
          card.effects.push({
            id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_" + i,
            type: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC",
            name: "",
            description: "",
            amount: 1,
            special: 0,
            metadata: {
              Type: 2 /* City */,
              SettlementId: aSettlements[i].id
            }
          });
        }
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    }
  }
}
function generateDynamicVictoryCards(iPlayer) {
  const player = Players.get(iPlayer);
  if (player != null) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      let yield_multiplier = 5;
      const numberOfroutes = player.getProperty("PROPERTY_ANTIQUITY_TRADE_ROUTE_TOTAL");
      let totalYield = numberOfroutes * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
          name: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_MILESTONE_2_DESCRIPTION_DYNAMIC\\5\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          categorySortOrder: 20,
          unlock: "UNLOCK_AT_LEAST_SECOND_ECONOMIC_VICTORY_1",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
              type: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
      yield_multiplier = 1;
      const numberOfGreatWorks = player.getProperty("PROPERTY_PREVIOUS_AGE_GREAT_WORK_TOTAL");
      totalYield = numberOfGreatWorks * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
          name: "LOC_LEGACY_PATH_ANTIQUITY_SCIENCE_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_ANTIQUITY_SCIENCE_MILESTONE_2_DESCRIPTION_DYNAMIC\\1\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          unlock: "UNLOCK_AT_LEAST_SECOND_SCIENTIFIC_VICTORY_1",
          categorySortOrder: 20,
          cost: [{ category: CardCategories.CARD_CATEGORY_SCIENTIFIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
              type: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
      {
        const card = {
          id: "CARD_AT_EXP_VICTORY_MILITARISTIC_UNITS",
          name: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_GOLDEN_AGE_NAME",
          description: "",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_EXP_VICTORY_CULTURE_GOLDEN_AGE",
          individualLimit: 1,
          goldenAgeReward: true,
          unlock: "UNLOCK_WON_MILITARISTIC_VICTORY_1",
          categorySortOrder: 10,
          cost: [{ category: CardCategories.CARD_CATEGORY_MILITARISTIC, value: 2 }],
          effects: [],
          aiModifierLists: []
        };
        let totalUnits = 0;
        if (player.Cities?.getCities() != null) {
          for (const city of player.Cities?.getCities()) {
            if (city.getProperty(Database.makeHash("PROPERTY_WAS_CONQUERED"))) {
              console.log("Was conquered: " + city.name);
              card.effects.push({
                id: "CARD_EFFECT_AT_EXP_VICTORY_MILITARISTIC_UNITS" + totalUnits,
                type: "CARD_AT_EXP_VICTORY_MILITARISTIC_UNITS",
                name: "",
                description: "",
                amount: 1,
                special: 0,
                metadata: {
                  Type: 8 /* Unit */,
                  SettlementId: city.id.id
                }
              });
              totalUnits++;
            }
          }
        }
        card.description = "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_GOLDEN_AGE_DESCRIPTION_DYNAMIC\\" + totalUnits;
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      const yield_multiplier = 2;
      const numberOfGreatWorks = player.getProperty("PROPERTY_PREVIOUS_AGE_GREAT_WORK_TOTAL");
      const totalYield = numberOfGreatWorks * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
          name: "LOC_LEGACY_PATH_EXPLORATION_CULTURE_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_EXPLORATION_CULTURE_MILESTONE_2_DESCRIPTION_DYNAMIC\\2\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          unlock: "UNLOCK_AT_LEAST_SECOND_CULTURAL_VICTORY_2",
          categorySortOrder: 20,
          cost: [{ category: CardCategories.CARD_CATEGORY_CULTURAL, value: 2 }],
          effects: [
            {
              id: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
              type: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    }
  }
}
engine.on("RequestAgeInitializationParameters", requestInitializationParameters);
engine.on("GenerateAgeTransition", generateTransition);
console.log("Loaded age-transition-post-load.ts");
//# sourceMappingURL=age-transition-post-load.js.map
</file>

<file path="heap.js">
class Heap {
  constructor(compare) {
    this.compare = compare;
  }
  items = [];
  get size() {
    return this.items.length;
  }
  peak() {
    return this.items[0];
  }
  push(value) {
    this.items.push(value);
    this.bubbleUp(this.items.length - 1);
  }
  pop() {
    const top = this.items[0];
    const last = this.items.pop();
    if (this.items.length > 0) {
      this.items[0] = last;
      this.bubbleDown(0);
    }
    return top;
  }
  clear() {
    this.items = [];
  }
  bubbleUp(index) {
    while (index > 0) {
      const parent = Math.floor((index - 1) / 2);
      if (this.compare(this.items[index], this.items[parent]) >= 0) break;
      [this.items[parent], this.items[index]] = [this.items[index], this.items[parent]];
      index = parent;
    }
  }
  bubbleDown(index) {
    const length = this.items.length;
    while (true) {
      const left = 2 * index + 1;
      const right = left + 1;
      let smallest = index;
      if (left < length && this.compare(this.items[left], this.items[smallest]) < 0) {
        smallest = left;
      }
      if (right < length && this.compare(this.items[right], this.items[smallest]) < 0) {
        smallest = right;
      }
      if (smallest === index) break;
      [this.items[index], this.items[smallest]] = [this.items[smallest], this.items[index]];
      index = smallest;
    }
  }
}

export { Heap };
//# sourceMappingURL=heap.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="kd-tree.js">
import { Voronoi } from '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import { sub2, dot2, div3s } from '../../core/scripts/MathHelpers.js';
import { RandomImpl } from './random-pcg-32.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

class kdNode {
  data;
  left;
  right;
  constructor(data) {
    this.data = data;
  }
}
class kdTree {
  rootNode;
  getPos;
  constructor(getPos) {
    this.getPos = getPos;
  }
  build(data) {
    this.rootNode = this.buildInternal([...data]);
  }
  search(pos) {
    return this.rootNode ? this.searchInternal(this.rootNode, pos, 0, { data: this.rootNode.data, distSq: Infinity }) : void 0;
  }
  searchMultiple(pos, count) {
    return this.searchInternalMultiple(this.rootNode, pos, 0, [], count).sort((a, b) => a.distSq - b.distSq);
  }
  buildInternal(data, axis = 0) {
    if (data.length === 0) return void 0;
    data.sort((a, b) => axis === 0 ? this.getPos(a).x - this.getPos(b).x : this.getPos(a).y - this.getPos(b).y);
    const midIndex = Math.floor(data.length / 2);
    const midItem = data[midIndex];
    axis = (axis + 1) % 2;
    const node = new kdNode(midItem);
    node.left = this.buildInternal(data.slice(0, midIndex), axis);
    node.right = this.buildInternal(data.slice(midIndex + 1), axis);
    return node;
  }
  searchInternal(node, pos, axis, best) {
    if (!node) return best;
    const distSq = this.distSq(pos, this.getPos(node.data));
    if (best.distSq > distSq) {
      best = { data: node.data, distSq };
    }
    const diff = axis === 0 ? pos.x - this.getPos(node.data).x : pos.y - this.getPos(node.data).y;
    const nearChild = diff < 0 ? node.left : node.right;
    best = this.searchInternal(nearChild, pos, (axis + 1) % 2, best);
    if (diff * diff < best.distSq) {
      const farChild = diff < 0 ? node.right : node.left;
      best = this.searchInternal(farChild, pos, (axis + 1) % 2, best);
    }
    return best;
  }
  searchInternalMultiple(node, pos, axis, bestList, maxCount) {
    if (!node) return bestList;
    const distSq = this.distSq(pos, this.getPos(node.data));
    if (bestList.length < maxCount) {
      bestList.push({ data: node.data, distSq });
    } else {
      let bestI = 0;
      for (let i = 1; i < bestList.length; ++i) {
        if (bestList[i].distSq > bestList[bestI].distSq) {
          bestI = i;
        }
      }
      if (bestList[bestI].distSq > distSq) {
        bestList[bestI] = { data: node.data, distSq };
      }
    }
    const diff = axis === 0 ? pos.x - this.getPos(node.data).x : pos.y - this.getPos(node.data).y;
    const nearChild = diff < 0 ? node.left : node.right;
    bestList = this.searchInternalMultiple(nearChild, pos, (axis + 1) % 2, bestList, maxCount);
    const axisDistSq = diff * diff;
    const furthestDistanceSq = bestList.reduce((max, data) => Math.max(max, data.distSq), 0);
    if (axisDistSq < furthestDistanceSq) {
      const farChild = diff < 0 ? node.right : node.left;
      bestList = this.searchInternalMultiple(farChild, pos, (axis + 1) % 2, bestList, maxCount);
    }
    return bestList;
  }
  distSq(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }
}
class WrappedKdTree extends kdTree {
  bounds;
  wrapType;
  constructor(getPos, bounds, wrapType) {
    super(getPos);
    this.bounds = bounds;
    this.wrapType = wrapType;
  }
  search(pos) {
    if (!this.rootNode) return void 0;
    const { pos: wrappedTarget, signedNearest } = this.bounds.getWrappedData(pos, this.wrapType);
    const size = this.bounds.size();
    let nearest = this.searchInternal(this.rootNode, pos, 0, { data: this.rootNode.data, distSq: Infinity });
    if (nearest.distSq > signedNearest.x * signedNearest.x) {
      const xWrappedTarget = { x: wrappedTarget.x + Math.sign(signedNearest.x) * size.x, y: wrappedTarget.y };
      const xNearest = this.searchInternal(this.rootNode, xWrappedTarget, 0, nearest);
      if (xNearest.distSq < nearest.distSq) {
        nearest = xNearest;
      }
    }
    if (nearest.distSq > signedNearest.y * signedNearest.y) {
      const yWrappedTarget = { x: wrappedTarget.x, y: wrappedTarget.y + Math.sign(signedNearest.y) * size.y };
      const yNearest = this.searchInternal(this.rootNode, yWrappedTarget, 0, nearest);
      if (yNearest.distSq < nearest.distSq) {
        nearest = yNearest;
      }
    }
    if (this.wrapType === WrapType.WrapXY && nearest.distSq > signedNearest.x * signedNearest.x + signedNearest.y * signedNearest.y) {
      const xyWrappedTarget = {
        x: wrappedTarget.x + Math.sign(signedNearest.x) * size.x,
        y: wrappedTarget.y + Math.sign(signedNearest.y) * size.y
      };
      const xyNearest = this.searchInternal(this.rootNode, xyWrappedTarget, 0, nearest);
      if (xyNearest.distSq < nearest.distSq) {
        nearest = xyNearest;
      }
    }
    return nearest;
  }
}

var MapSize = /* @__PURE__ */ ((MapSize2) => {
  MapSize2[MapSize2["Tiny"] = 0] = "Tiny";
  MapSize2[MapSize2["Small"] = 1] = "Small";
  MapSize2[MapSize2["Standard"] = 2] = "Standard";
  MapSize2[MapSize2["Large"] = 3] = "Large";
  MapSize2[MapSize2["Huge"] = 4] = "Huge";
  return MapSize2;
})(MapSize || {});
const MapDims = {
  [0 /* Tiny */]: { x: 60, y: 38 },
  [1 /* Small */]: { x: 74, y: 46 },
  [2 /* Standard */]: { x: 84, y: 54 },
  [3 /* Large */]: { x: 96, y: 60 },
  [4 /* Huge */]: { x: 106, y: 66 }
};
var RegionType = /* @__PURE__ */ ((RegionType2) => {
  RegionType2[RegionType2["None"] = 0] = "None";
  RegionType2[RegionType2["Ocean"] = 1] = "Ocean";
  RegionType2[RegionType2["Landmass"] = 2] = "Landmass";
  RegionType2[RegionType2["Island"] = 3] = "Island";
  RegionType2[RegionType2["CoastalIsland"] = 4] = "CoastalIsland";
  RegionType2[RegionType2["_Length"] = 5] = "_Length";
  return RegionType2;
})(RegionType || {});
var TerrainType = /* @__PURE__ */ ((TerrainType2) => {
  TerrainType2[TerrainType2["Unknown"] = 0] = "Unknown";
  TerrainType2[TerrainType2["Ocean"] = 1] = "Ocean";
  TerrainType2[TerrainType2["Coast"] = 2] = "Coast";
  TerrainType2[TerrainType2["Flat"] = 3] = "Flat";
  TerrainType2[TerrainType2["Rough"] = 4] = "Rough";
  TerrainType2[TerrainType2["Mountainous"] = 5] = "Mountainous";
  TerrainType2[TerrainType2["Volcano"] = 6] = "Volcano";
  TerrainType2[TerrainType2["NavRiver"] = 7] = "NavRiver";
  TerrainType2[TerrainType2["_Length"] = 8] = "_Length";
  return TerrainType2;
})(TerrainType || {});
var BiomeType = /* @__PURE__ */ ((BiomeType2) => {
  BiomeType2[BiomeType2["Unknown"] = 0] = "Unknown";
  BiomeType2[BiomeType2["Ocean"] = 1] = "Ocean";
  BiomeType2[BiomeType2["Desert"] = 2] = "Desert";
  BiomeType2[BiomeType2["Grassland"] = 3] = "Grassland";
  BiomeType2[BiomeType2["Plains"] = 4] = "Plains";
  BiomeType2[BiomeType2["Tropical"] = 5] = "Tropical";
  BiomeType2[BiomeType2["Tundra"] = 6] = "Tundra";
  BiomeType2[BiomeType2["_Length"] = 7] = "_Length";
  return BiomeType2;
})(BiomeType || {});
var DetailsType = /* @__PURE__ */ ((DetailsType2) => {
  DetailsType2[DetailsType2["None"] = 0] = "None";
  DetailsType2[DetailsType2["MinorRiver"] = 1] = "MinorRiver";
  DetailsType2[DetailsType2["Wet"] = 2] = "Wet";
  DetailsType2[DetailsType2["Vegetated"] = 3] = "Vegetated";
  DetailsType2[DetailsType2["Floodplain"] = 4] = "Floodplain";
  DetailsType2[DetailsType2["Snow"] = 5] = "Snow";
  DetailsType2[DetailsType2["_Length"] = 6] = "_Length";
  return DetailsType2;
})(DetailsType || {});
var WrapType = /* @__PURE__ */ ((WrapType2) => {
  WrapType2[WrapType2["None"] = 0] = "None";
  WrapType2[WrapType2["WrapX"] = 1] = "WrapX";
  WrapType2[WrapType2["WrapY"] = 2] = "WrapY";
  WrapType2[WrapType2["WrapXY"] = 3] = "WrapXY";
  return WrapType2;
})(WrapType || {});
class RegionCell {
  id = 0;
  cell;
  area = 0;
  landmassId = 0;
  landmassOrder = 0;
  plateId = -1;
  plateOrder = 0;
  elevation = 0;
  terrainType = 0 /* Unknown */;
  biomeType = 0 /* Unknown */;
  detailsType = 0 /* None */;
  regionConsiderationBits = 0n;
  // helps avoid a set lookup when on a region's consideration heap during processing.
  ruleConsideration = false;
  // used by individual rules. Rule should clear back to false after each use.
  currentScore = 0;
  // can hold a current score temporarily, but should be zeroed out between operations.
  constructor(cell, id, area) {
    this.cell = cell;
    this.id = id;
    this.area = area;
  }
  reset() {
    this.landmassId = 0;
    this.landmassOrder = 0;
    this.plateId = -1;
    this.plateOrder = 0;
    this.elevation = 0;
    this.terrainType = 0 /* Unknown */;
    this.biomeType = 0 /* Unknown */;
    this.detailsType = 0 /* None */;
  }
}
const RegionCellPosGetter = (cell) => {
  return { x: cell.cell.site.x, y: cell.cell.site.y };
};
class PlateBoundary {
  pos = { x: 0, y: 0 };
  normal = { x: 0, y: 0 };
  plateSubduction = 0;
  plateSliding = 0;
  id1 = 0;
  id2 = 0;
}
const PlateBoundaryPosGetter = (data) => {
  return { x: data.pos.x, y: data.pos.y };
};
class Aabb2 {
  min = { x: 0, y: 0 };
  max = { x: 0, y: 0 };
  constructor(min, max) {
    this.min = min;
    this.max = max;
  }
  clone() {
    return new Aabb2({ x: this.min.x, y: this.min.y }, { x: this.max.x, y: this.max.y });
  }
  contains(pos) {
    return pos.x >= this.min.x && pos.x <= this.max.x && pos.y >= this.min.y && pos.y <= this.max.y;
  }
  size() {
    return sub2(this.max, this.min);
  }
  distSqToPoint(p) {
    const d = { x: 0, y: 0 };
    if (p.x < this.min.x) d.x = this.min.x - p.x;
    else if (p.x >= this.max.x) d.x = p.x - this.max.x;
    if (p.y < this.min.y) d.y = this.min.y - p.y;
    else if (p.y >= this.max.y) d.y = p.y - this.max.y;
    return dot2(d, d);
  }
  intersects(other) {
    return !(other.min.x >= this.max.x || other.max.x <= other.min.x || other.min.y >= this.max.y || other.max.y <= other.min.y);
  }
  getWrappedData(pos, wrapType) {
    const wrappedPos = { x: pos.x, y: pos.y };
    const signedNearest = { x: Infinity, y: Infinity };
    const size = this.size();
    const min = this.min;
    const max = this.max;
    if (wrapType === 1 /* WrapX */ || wrapType === 3 /* WrapXY */) {
      wrappedPos.x = min.x + VoronoiUtils.posMod(pos.x - min.x, size.x);
      signedNearest.x = pos.x - min.x <= max.x - pos.x ? -(pos.x - min.x) : max.x - pos.x;
    }
    if (wrapType === 2 /* WrapY */ || wrapType === 3 /* WrapXY */) {
      wrappedPos.y = min.y + VoronoiUtils.posMod(pos.y - min.y, size.y);
      signedNearest.y = pos.y - min.y <= max.y - pos.y ? -(pos.y - min.y) : max.y - pos.y;
    }
    return { pos: wrappedPos, signedNearest };
  }
}
var VoronoiUtils;
((VoronoiUtils2) => {
  const stringColors = [
    "#e57373",
    "#4db6ac",
    "#f06292",
    "#64b5f6",
    "#ba68c8",
    "#81c784",
    "#9575cd",
    "#ffb74d",
    "#7986cb",
    "#aed581",
    "#4fc3f7",
    "#f4511e",
    "#4dd0e1",
    "#dce775",
    "#43a047",
    "#ff8a65",
    "#8e24aa",
    "#c0ca33",
    "#1e88e5",
    "#fb8c00",
    "#00acc1",
    "#fbc02d",
    "#00897b",
    "#ef6c00",
    "#5e35b1",
    "#ffd54f",
    "#3949ab",
    "#d81b60",
    "#90a4ae",
    "#ff7043",
    "#7cb342",
    "#6d4c41"
  ];
  function hexStringToRgb(hexString) {
    const num = Number("0x" + hexString.slice(1));
    return div3s({ x: num >> 16 & 255, y: num >> 8 & 255, z: num & 255 }, 255);
  }
  VoronoiUtils2.hexStringToRgb = hexStringToRgb;
  VoronoiUtils2.numericColors = stringColors.map((v) => hexStringToRgb(v));
  function getRandColor(idx) {
    return VoronoiUtils2.numericColors[idx % VoronoiUtils2.numericColors.length];
  }
  VoronoiUtils2.getRandColor = getRandColor;
  function getRandStringColor(idx) {
    return stringColors[idx % VoronoiUtils2.numericColors.length];
  }
  VoronoiUtils2.getRandStringColor = getRandStringColor;
  function voronoiCentroid(cell) {
    const site = { x: 0, y: 0, id: 0 };
    for (const halfedge of cell.halfedges) {
      site.x += halfedge.getStartpoint().x;
      site.y += halfedge.getStartpoint().y;
    }
    site.x /= cell.halfedges.length;
    site.y /= cell.halfedges.length;
    return site;
  }
  VoronoiUtils2.voronoiCentroid = voronoiCentroid;
  function lloydRelaxation(cells, strength) {
    return cells.map((cell) => {
      const centerSite = voronoiCentroid(cell);
      const newX = cell.site.x + strength * (centerSite.x - cell.site.x);
      const newY = cell.site.y + strength * (centerSite.y - cell.site.y);
      return {
        id: 0,
        x: newX,
        y: newY
      };
    });
  }
  VoronoiUtils2.lloydRelaxation = lloydRelaxation;
  function computeVoronoi(sites, bbox, relaxationSteps, wrap = 0 /* None */) {
    if (wrap == 2 /* WrapY */ || wrap == 3 /* WrapXY */) {
      console.log("Voronoi currently only supports wrapping in X. Reverting to no wrap.");
      wrap = 0 /* None */;
    }
    const voronoi = new Voronoi();
    const width = bbox.xr - bbox.xl;
    const height = bbox.yb - bbox.yt;
    const density = Math.sqrt(sites.length / (width * height));
    const wrapMargin = Math.min(density * 4, width);
    const createDiagram = (sites2) => {
      if (wrap == 1 /* WrapX */) {
        sites2 = sites2.filter((value) => value.x >= bbox.xl && value.x < bbox.xr);
        const marginSites = [];
        for (const site of sites2) {
          if (site.x <= bbox.xl + wrapMargin) {
            marginSites.push({ x: site.x + width, y: site.y, id: 0 });
          } else if (site.x > bbox.xr - wrapMargin) {
            marginSites.push({ x: site.x - width, y: site.y, id: 0 });
          }
        }
        sites2 = sites2.concat(marginSites);
        console.log(`Duplicating ${sites2.length} sites around the voronoi graph margins.`);
        const wrappedBbox = {
          xl: bbox.xl - wrapMargin,
          xr: bbox.xr + wrapMargin,
          yt: bbox.yt,
          yb: bbox.yb
        };
        return voronoi.compute(sites2, wrappedBbox);
      } else {
        return voronoi.compute(sites2, bbox);
      }
    };
    let diagram = createDiagram(sites);
    for (let index = 0; index < relaxationSteps; index++) {
      sites = lloydRelaxation(diagram.cells, 1);
      voronoi.toRecycle = diagram;
      diagram = createDiagram(sites);
    }
    const isInside = (v, bounds) => {
      return v != null && v.x >= bounds.xl && v.x < bounds.xr && v.y >= bounds.yt && v.y < bounds.yb;
    };
    if (wrap == 1 /* WrapX */) {
      const boundedCells = diagram.cells.filter((cell) => isInside(cell.site, bbox));
      const cellKdTree = new kdTree((data) => data.site);
      cellKdTree.build(boundedCells);
      diagram.edges = diagram.edges.filter((edge) => {
        const rInside = isInside(edge.rSite, bbox);
        const lInside = isInside(edge.lSite, bbox);
        if (rInside !== lInside) {
          if (rInside) {
            if (edge.lSite != null) {
              const sitePos = { x: edge.lSite.x, y: edge.lSite.y };
              sitePos.x += sitePos.x < bbox.xr ? wrapMargin : -wrapMargin;
              edge.lSite = cellKdTree.search(sitePos).data.site;
            }
          } else {
            if (edge.rSite != null) {
              const sitePos = { x: edge.rSite.x, y: edge.rSite.y };
              sitePos.x += sitePos.x < bbox.xr ? wrapMargin : -wrapMargin;
              edge.rSite = cellKdTree.search(sitePos).data.site;
            }
          }
        }
        return rInside || lInside;
      });
      diagram.cells = boundedCells;
      diagram.cells.forEach((cell, index) => {
        cell.site.id = index;
      });
    }
    return diagram;
  }
  VoronoiUtils2.computeVoronoi = computeVoronoi;
  function createRandomSites(count, maxX, maxY) {
    return Array.from({ length: count }, () => ({
      id: 0,
      x: RandomImpl.fRand("Voronoi Site X") * maxX,
      y: RandomImpl.fRand("Voronoi Site Y") * maxY
    }));
  }
  VoronoiUtils2.createRandomSites = createRandomSites;
  function dot(dir1, dir2) {
    return dir1.x * dir2.x + dir1.y * dir2.y;
  }
  VoronoiUtils2.dot = dot;
  function crossZ(dir1, dir2) {
    return dir1.x * dir2.y - dir1.y * dir2.x;
  }
  VoronoiUtils2.crossZ = crossZ;
  function lerp(a, b, t) {
    return a + t * (b - a);
  }
  VoronoiUtils2.lerp = lerp;
  function normalize(v) {
    const len = Math.sqrt(v.x * v.x + v.y * v.y);
    return { x: v.x / len, y: v.y / len };
  }
  VoronoiUtils2.normalize = normalize;
  function iLerp(a, b, t) {
    return (t - a) / (b - a);
  }
  VoronoiUtils2.iLerp = iLerp;
  function clamp(a, min, max) {
    const lowerClamp = Math.max(a, min);
    return Math.min(lowerClamp, max);
  }
  VoronoiUtils2.clamp = clamp;
  function pointInsideCell(cell, point) {
    for (const halfEdge of cell.halfedges) {
      const ept1 = halfEdge.getStartpoint();
      const ept2 = halfEdge.getEndpoint();
      const edgeDir = { x: ept2.x - ept1.x, y: ept2.y - ept1.y };
      const ptDir = { x: point.x - ept1.x, y: point.y - ept1.y };
      if (crossZ(edgeDir, ptDir) > 0) {
        return false;
      }
    }
    return true;
  }
  VoronoiUtils2.pointInsideCell = pointInsideCell;
  function calculateCellArea(cell) {
    let area = 0;
    for (const halfedge of cell.halfedges) {
      const pt1 = halfedge.getStartpoint();
      const pt2 = halfedge.getEndpoint();
      area += pt1.x * pt2.y - pt2.x * pt1.y;
    }
    return area * -0.5;
  }
  VoronoiUtils2.calculateCellArea = calculateCellArea;
  function sqDistance(pt1, pt2) {
    const xDiff = pt1.x - pt2.x;
    const yDiff = pt1.y - pt2.y;
    return xDiff * xDiff + yDiff * yDiff;
  }
  VoronoiUtils2.sqDistance = sqDistance;
  function sqDistanceBetweenSites(site1, site2) {
    return sqDistance({ x: site1.x, y: site1.y }, { x: site2.x, y: site2.y });
  }
  VoronoiUtils2.sqDistanceBetweenSites = sqDistanceBetweenSites;
  function distanceBetweenSites(site1, site2) {
    return Math.sqrt(sqDistance({ x: site1.x, y: site1.y }, { x: site2.x, y: site2.y }));
  }
  VoronoiUtils2.distanceBetweenSites = distanceBetweenSites;
  function defaultEnumRecord(e) {
    const obj = {};
    for (const k of Object.values(e)) {
      if (typeof k === "number") obj[k] = {};
    }
    return obj;
  }
  VoronoiUtils2.defaultEnumRecord = defaultEnumRecord;
  function shuffle(arr, count = arr.length) {
    for (let i = 0; i < count; ++i) {
      const idx = RandomImpl.getRandomNumber(arr.length - i, "Shuffle Idx") + i;
      [arr[i], arr[idx]] = [arr[idx], arr[i]];
    }
  }
  VoronoiUtils2.shuffle = shuffle;
  let RegionCellFilterResult;
  ((RegionCellFilterResult2) => {
    RegionCellFilterResult2[RegionCellFilterResult2["Continue"] = 0] = "Continue";
    RegionCellFilterResult2[RegionCellFilterResult2["HaltSuccess"] = 1] = "HaltSuccess";
    RegionCellFilterResult2[RegionCellFilterResult2["HaltFail"] = 2] = "HaltFail";
  })(RegionCellFilterResult = VoronoiUtils2.RegionCellFilterResult || (VoronoiUtils2.RegionCellFilterResult = {}));
  function regionCellAreaFilter(cell, regionCells, maxDistance, filterCallback) {
    const consideringList = [cell.id];
    cell.ruleConsideration = true;
    let filterResult = 0 /* Continue */;
    for (let i = 0; i < consideringList.length; ++i) {
      const considerCell = regionCells[consideringList[i]];
      filterResult = filterCallback(considerCell);
      if (filterResult != 0 /* Continue */) {
        break;
      }
      const neighborIds = considerCell.cell.getNeighborIds();
      for (const neighborId of neighborIds) {
        const neighbor = regionCells[neighborId];
        if (!neighbor.ruleConsideration && VoronoiUtils2.distanceBetweenSites(cell.cell.site, neighbor.cell.site) < maxDistance) {
          neighbor.ruleConsideration = true;
          consideringList.push(neighborId);
        }
      }
    }
    consideringList.forEach((cellId) => {
      regionCells[cellId].ruleConsideration = false;
    });
    return filterResult;
  }
  VoronoiUtils2.regionCellAreaFilter = regionCellAreaFilter;
  function deepMerge(a, b) {
    for (const key in b) {
      if (b[key] && typeof b[key] === "object" && !Array.isArray(b[key]) && typeof a[key] === "object" && a[key] !== null) {
        deepMerge(a[key], b[key]);
      } else if (Array.isArray(a[key]) && Array.isArray(b[key])) {
        const aArr = a[key];
        const bArr = b[key];
        if (aArr.length < bArr.length && "_defaultChild" in a) {
          while (aArr.length < bArr.length) {
            aArr.push(clone(a["_defaultChild"]));
          }
        }
        aArr.length = bArr.length;
        for (let i = 0; i < bArr.length; ++i) {
          deepMerge(aArr[i], bArr[i]);
        }
      } else if (key in a) {
        a[key] = b[key];
      } else {
        console.log("Warning: key " + key + " not in merged object.");
      }
    }
  }
  VoronoiUtils2.deepMerge = deepMerge;
  async function loadTextFromPath(url) {
    if (typeof fetch == "function") {
      try {
        const response = await fetch(url, { cache: "no-cache" });
        if (!response.ok) {
          console.error(`Failed to load ${url}: ${response.statusText}`);
          return null;
        }
        return await response.text();
      } catch (err) {
        console.error(`Error loading ${url}`, err);
        return null;
      }
    } else {
      console.error("Environment does not support fetch().");
      return null;
    }
  }
  VoronoiUtils2.loadTextFromPath = loadTextFromPath;
  async function loadJsonFromPath(url) {
    const text = await loadTextFromPath(url);
    if (text) {
      return JSON.parse(text);
    }
    return null;
  }
  VoronoiUtils2.loadJsonFromPath = loadJsonFromPath;
  async function loadJsFromPath(url) {
    const text = await loadTextFromPath(url);
    if (text) {
      const match = text.match(/export\s+default\s+({[\s\S]*});?\s*$/);
      if (!match) throw new Error("Could not find export default object");
      return JSON.parse(match[1]);
    }
    return null;
  }
  VoronoiUtils2.loadJsFromPath = loadJsFromPath;
  function loadSettingsFromJson(json, map) {
    const configObject = typeof json === "string" ? JSON.parse(json) : json;
    VoronoiUtils2.deepMerge(map.getSettings(), configObject.mapConfig);
    const generator = map.getBuilder().getGenerator();
    generator.resetToDefault();
    VoronoiUtils2.deepMerge(generator.getSettings(), configObject.generatorConfig);
    const rules = generator.getRules();
    for (const [groupKey, groupValue] of Object.entries(configObject.rulesConfig)) {
      const rulesGroup = rules[groupKey];
      for (const [ruleKey, ruleValue] of Object.entries(groupValue)) {
        const ruleKeyParts = ruleKey.split(".");
        for (const rule of rulesGroup) {
          if (rule.name === ruleKeyParts[0]) {
            if (ruleKeyParts[1] === "weight") {
              rule.weight = ruleValue;
            } else {
              rule.configValues[ruleKeyParts[1]] = ruleValue;
            }
            break;
          }
        }
      }
    }
  }
  VoronoiUtils2.loadSettingsFromJson = loadSettingsFromJson;
  function loadSettingsFromJs(jsText, map) {
    const match = jsText.match(/export\s+default\s+({[\s\S]*});?\s*$/);
    if (!match) throw new Error("Could not find export default object");
    return loadSettingsFromJson(match[1], map);
  }
  VoronoiUtils2.loadSettingsFromJs = loadSettingsFromJs;
  function clone(obj) {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    } else {
      return JSON.parse(JSON.stringify(obj));
    }
  }
  VoronoiUtils2.clone = clone;
  function getRoundedString(value, precision) {
    return String(parseFloat(value.toFixed(precision)));
  }
  VoronoiUtils2.getRoundedString = getRoundedString;
  function swapAndPop(arr, indexToRemove) {
    arr[indexToRemove] = arr[arr.length - 1];
    arr.pop();
  }
  VoronoiUtils2.swapAndPop = swapAndPop;
  function performanceMarker(label) {
    if (typeof BuildInfo === "undefined") {
      performance.mark(label);
    } else {
      console.log(label);
    }
  }
  VoronoiUtils2.performanceMarker = performanceMarker;
  function posMod(n, m) {
    return (n % m + m) % m;
  }
  VoronoiUtils2.posMod = posMod;
  function getGeneratorSettingConfigNode(key, settingsConfig) {
    const keyArr = key.split(".");
    let config = settingsConfig;
    let finalNode = void 0;
    for (key of keyArr) {
      const entry = config.find((value) => value.key == key);
      if (entry && !finalNode) {
        if ("children" in entry) {
          config = entry.children.data;
        } else {
          finalNode = entry;
        }
      } else {
        return void 0;
      }
    }
    return finalNode;
  }
  VoronoiUtils2.getGeneratorSettingConfigNode = getGeneratorSettingConfigNode;
  function lockGeneratorSetting(key, settingsConfig) {
    const node = getGeneratorSettingConfigNode(key, settingsConfig);
    if (node) {
      node.locked = true;
    } else {
      console.log(`Unable to lock setting "${key}": not found.`);
    }
  }
  VoronoiUtils2.lockGeneratorSetting = lockGeneratorSetting;
  function unifyGeneratorSetting(key, settingsConfig) {
    const node = getGeneratorSettingConfigNode(key, settingsConfig);
    if (node) {
      node.unified = true;
    } else {
      console.log(`Unable to unify setting "${key}": not found.`);
    }
  }
  VoronoiUtils2.unifyGeneratorSetting = unifyGeneratorSetting;
  function hashString(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; ++i) {
      hash = (hash << 5) + hash ^ str.charCodeAt(i);
    }
    return hash | 0;
  }
  VoronoiUtils2.hashString = hashString;
})(VoronoiUtils || (VoronoiUtils = {}));

export { Aabb2, BiomeType, DetailsType, MapDims, MapSize, PlateBoundary, PlateBoundaryPosGetter, RegionCell, RegionCellPosGetter, RegionType, TerrainType, VoronoiUtils, WrapType, WrappedKdTree, kdTree };
//# sourceMappingURL=kd-tree.js.map
</file>

<file path="quadtree.js">
import { div2s, add2 } from '../../core/scripts/MathHelpers.js';
import { VoronoiUtils, Aabb2, WrapType } from './kd-tree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';

var QuadIdx = /* @__PURE__ */ ((QuadIdx2) => {
  QuadIdx2[QuadIdx2["SW"] = 0] = "SW";
  QuadIdx2[QuadIdx2["SE"] = 1] = "SE";
  QuadIdx2[QuadIdx2["NW"] = 2] = "NW";
  QuadIdx2[QuadIdx2["NE"] = 3] = "NE";
  return QuadIdx2;
})(QuadIdx || {});
class QuadTree {
  bounds;
  capacity;
  maxDepth;
  depth;
  getPos;
  items = [];
  children = null;
  constructor(bounds, getPos, capacity = 4, maxDepth = 16, depth = 0) {
    this.bounds = bounds;
    this.getPos = getPos;
    this.capacity = capacity;
    this.maxDepth = maxDepth;
    this.depth = depth;
  }
  size() {
    return this.items.length + (this.children ? this.children.reduce((a, c) => a + c.size(), 0) : 0);
  }
  insert(item) {
    if (!this.bounds.contains(this.getPos(item))) return false;
    if (!this.children) {
      if (this.items.length < this.capacity || this.depth >= this.maxDepth) {
        this.items.push(item);
        return true;
      }
      this.subdivide();
      this.items.forEach((item2) => this.insertIntoChild(item2));
      this.items.length = 0;
    }
    return this.insertIntoChild(item);
  }
  nearest(target, filter = void 0, maxDistance = Infinity) {
    const st = { best: null, bestDistSq: maxDistance };
    this.nearestInternal(target.x, target.y, st, filter);
    return { cell: st.best, distSq: st.bestDistSq };
  }
  nearestInternal(x, y, st, filter = void 0) {
    for (const item of this.items) {
      if (!filter || filter(item)) {
        const d = VoronoiUtils.sqDistance(this.getPos(item), { x, y });
        if (d < st.bestDistSq) {
          st.bestDistSq = d;
          st.best = item;
        }
      }
    }
    if (!this.children) {
      return;
    }
    const cx = (this.bounds.min.x + this.bounds.max.x) * 0.5;
    const cy = (this.bounds.min.y + this.bounds.max.y) * 0.5;
    const right = x >= cx ? 1 : 0;
    const top = y >= cy ? 2 : 0;
    const primary = right + top;
    const order = [primary, primary ^ 1, primary ^ 2, primary ^ 3];
    for (const i of order) {
      const child = this.children[i];
      const cb = child.bounds;
      const aabbd2 = cb.distSqToPoint({ x, y });
      if (aabbd2 < st.bestDistSq) {
        child.nearestInternal(x, y, st, filter);
      }
    }
  }
  queryRange(range = this.bounds, out) {
    if (!this.bounds.intersects(range)) return;
    for (const item of this.items) {
      if (range.contains(this.getPos(item))) out.push(item);
    }
    if (this.children) {
      for (const child of this.children) child.queryRange(range, out);
    }
  }
  insertIntoChild(item) {
    this.children[this.childIndex(item)].insert(item);
  }
  subdivide() {
    const childDepth = this.depth + 1;
    const min = this.bounds.min;
    const hDims = div2s(this.bounds.size(), 2);
    const mins = [min, { x: min.x + hDims.x, y: min.y }, { x: min.x, y: min.y + hDims.y }, add2(min, hDims)];
    const maxes = mins.map((v) => add2(v, hDims));
    this.children = [
      new QuadTree(new Aabb2(mins[0], maxes[0]), this.getPos, this.capacity, this.maxDepth, childDepth),
      new QuadTree(new Aabb2(mins[1], maxes[1]), this.getPos, this.capacity, this.maxDepth, childDepth),
      new QuadTree(new Aabb2(mins[2], maxes[2]), this.getPos, this.capacity, this.maxDepth, childDepth),
      new QuadTree(new Aabb2(mins[3], maxes[3]), this.getPos, this.capacity, this.maxDepth, childDepth)
    ];
  }
  childIndex(item) {
    const center = add2(this.bounds.min, div2s(this.bounds.size(), 2));
    const pos = this.getPos(item);
    const east = pos.x >= center.x;
    const north = pos.y >= center.y;
    return north ? east ? 3 /* NE */ : 2 /* NW */ : east ? 1 /* SE */ : 0 /* SW */;
  }
}
class WrappedQuadTree extends QuadTree {
  wrapType = WrapType.WrapX;
  constructor(bounds, getPos, capacity = 4, maxDepth = 16, wrapType) {
    super(bounds, getPos, capacity, maxDepth, 0);
    this.wrapType = wrapType;
  }
  nearest(target, filter = void 0, maxDistance = Infinity) {
    const { pos: wrappedTarget, signedNearest } = this.bounds.getWrappedData(target, this.wrapType);
    const size = this.bounds.size();
    let nearest = super.nearest(wrappedTarget, filter, maxDistance);
    if (nearest.distSq > signedNearest.x * signedNearest.x) {
      const xWrappedTarget = { x: wrappedTarget.x + Math.sign(signedNearest.x) * size.x, y: wrappedTarget.y };
      const xNearest = super.nearest(xWrappedTarget, filter, maxDistance);
      if (xNearest.distSq < nearest.distSq) {
        nearest = xNearest;
      }
    }
    if (nearest.distSq > signedNearest.y * signedNearest.y) {
      const yWrappedTarget = { x: wrappedTarget.x, y: wrappedTarget.y + Math.sign(signedNearest.y) * size.y };
      const yNearest = super.nearest(yWrappedTarget, filter, maxDistance);
      if (yNearest.distSq < nearest.distSq) {
        nearest = yNearest;
      }
    }
    if (this.wrapType === WrapType.WrapXY && nearest.distSq > signedNearest.x * signedNearest.x + signedNearest.y * signedNearest.y) {
      const xyWrappedTarget = {
        x: wrappedTarget.x + Math.sign(signedNearest.x) * size.x,
        y: wrappedTarget.y + Math.sign(signedNearest.y) * size.y
      };
      const xyNearest = super.nearest(xyWrappedTarget, filter, maxDistance);
      if (xyNearest.distSq < nearest.distSq) {
        nearest = xyNearest;
      }
    }
    return nearest;
  }
  queryRange(rangeBounds = this.bounds, out = []) {
    const size = this.bounds.size();
    const min = this.bounds.min;
    const max = this.bounds.max;
    const range = rangeBounds.clone();
    const ranges = [range];
    if (this.wrapType === WrapType.WrapX || this.wrapType === WrapType.WrapXY) {
      if (range.size().x >= size.x) {
        range.min.x = min.x;
        range.max.x = max.x;
      } else {
        const start = min.x + VoronoiUtils.posMod(range.min.x - min.x, size.x);
        const end = start + range.size().x;
        range.min.x = start;
        range.max.x = Math.min(end, max.x);
        if (end > max.x) {
          const wrappedRange = range.clone();
          wrappedRange.min.x = min.x;
          wrappedRange.max.x = min.x + end - max.x;
          ranges.push(wrappedRange);
        }
      }
    }
    if (this.wrapType === WrapType.WrapY || this.wrapType === WrapType.WrapXY) {
      if (range.size().y >= size.y) {
        range.min.y = min.y;
        range.max.y = max.y;
      } else {
        const start = min.y + VoronoiUtils.posMod(range.min.y - min.y, size.y);
        const end = start + range.size().y;
        ranges.forEach((r) => {
          r.min.y = start;
          r.max.y = Math.min(end, max.y);
        });
        if (end > max.y) {
          const tempRange = [...ranges];
          for (const r of tempRange) {
            const wrappedRange = r.clone();
            wrappedRange.min.y = min.y;
            wrappedRange.max.y = min.y + end - max.y;
            ranges.push(wrappedRange);
          }
        }
      }
    }
    ranges.forEach((r) => super.queryRange(r, out));
  }
}

export { QuadTree, WrappedQuadTree };
//# sourceMappingURL=quadtree.js.map
</file>

<file path="random-pcg-32.js">
var RandomPCG32;
((RandomPCG322) => {
  class RandomState {
    state = 0x08f5dc87e5c07d8an;
    inc = 0x3n;
  }
  RandomPCG322.RandomState = RandomState;
  function seed(value) {
    RandomPCG322.randomPCG32State.state = 0n;
    RandomPCG322.randomPCG32State.inc = 0x3n;
    rand();
    RandomPCG322.randomPCG32State.state += BigInt(value);
    rand();
  }
  RandomPCG322.seed = seed;
  function rand() {
    const oldState = RandomPCG322.randomPCG32State.state;
    RandomPCG322.randomPCG32State.state = (oldState * 6364136223846793005n & 0xffffffffffffffffn) + RandomPCG322.randomPCG32State.inc & 0xffffffffffffffffn;
    const xorshifted = (oldState >> 18n ^ oldState) >> 27n & 0xffffffffn;
    const rot0 = oldState >> 59n & 0xffffffffn;
    const rot1 = ~rot0 + 1n & 31n;
    const output = (xorshifted >> rot0 | xorshifted << rot1) & 0xffffffffn;
    return Number(output);
  }
  RandomPCG322.rand = rand;
  function fRand(strLog) {
    return getRandomNumber(65535, strLog) / 65535;
  }
  RandomPCG322.fRand = fRand;
  function getRandomNumber(iRange, strLog) {
    if (typeof TerrainBuilder == "object" && typeof TerrainBuilder.getRandomNumber == "function") {
      return TerrainBuilder.getRandomNumber(iRange, strLog);
    } else {
      return Math.floor((rand() & 65535) * (iRange / 65536));
    }
  }
  RandomPCG322.getRandomNumber = getRandomNumber;
  function getState() {
    return { state: RandomPCG322.randomPCG32State.state, inc: RandomPCG322.randomPCG32State.inc };
  }
  RandomPCG322.getState = getState;
  function setState(state) {
    RandomPCG322.randomPCG32State.state = state.state;
    RandomPCG322.randomPCG32State.inc = state.inc;
  }
  RandomPCG322.setState = setState;
  RandomPCG322.randomPCG32State = new RandomState();
})(RandomPCG32 || (RandomPCG32 = {}));
var GameCoreRandom;
((GameCoreRandom2) => {
  const RANDOM_A = 1103515245n;
  const RANDOM_C = 12345n;
  const RANDOM_SHIFT = 16n;
  const LOG_OUTPUT = false;
  class RandomState {
    state = 0x08f5dc87e5c07d8an;
  }
  GameCoreRandom2.RandomState = RandomState;
  function seed(value) {
    GameCoreRandom2.randomState.state = BigInt(value);
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: setting seed to " + value);
    }
  }
  GameCoreRandom2.seed = seed;
  function rand() {
    GameCoreRandom2.randomState.state = RANDOM_A * GameCoreRandom2.randomState.state + RANDOM_C & 0xffffffffn;
    return GameCoreRandom2.randomState.state >> RANDOM_SHIFT & 0xffffn;
  }
  GameCoreRandom2.rand = rand;
  function fRand(strLog) {
    return getRandomNumber(65535, strLog) / 65535;
  }
  GameCoreRandom2.fRand = fRand;
  function getRandomNumber(iRange, strLog) {
    let num = 0;
    if (typeof TerrainBuilder == "object" && typeof TerrainBuilder.getRandomNumber == "function") {
      num = TerrainBuilder.getRandomNumber(iRange, strLog);
    } else {
      num = Math.floor(Number(rand()) * (iRange / 65536));
    }
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: getRandomNumber(" + iRange + ', "' + strLog + '") = ' + num);
    }
    return num;
  }
  GameCoreRandom2.getRandomNumber = getRandomNumber;
  function getState() {
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: getState() called with current state " + GameCoreRandom2.randomState.state);
    }
    return { state: GameCoreRandom2.randomState.state };
  }
  GameCoreRandom2.getState = getState;
  function setState(state) {
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: setState(" + state.state + ")");
    }
    GameCoreRandom2.randomState.state = state.state;
  }
  GameCoreRandom2.setState = setState;
  GameCoreRandom2.randomState = new RandomState();
})(GameCoreRandom || (GameCoreRandom = {}));
const RandomImpl = GameCoreRandom;

export { GameCoreRandom, RandomImpl, RandomPCG32 };
//# sourceMappingURL=random-pcg-32.js.map
</file>

<file path="voronoi-builder.js">
import { Diagram } from '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import { VoronoiHex } from './voronoi-hex.js';
import { MapDims, VoronoiUtils } from './kd-tree.js';
import { ContinentGenerator } from './voronoi_generators/continent-generator.js';
import { GeneratorType } from './voronoi_generators/map-generator.js';
import '../../core/scripts/MathHelpers.js';
import './heap.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';
import './quadtree.js';
import './voronoi-region.js';
import './voronoi_rules/avoid-edge.js';
import './voronoi_rules/rules-base.js';
import './voronoi_rules/avoid-other-regions.js';
import './voronoi_rules/cell-area.js';
import './voronoi_rules/near-map-center.js';
import './voronoi_rules/near-neighbor.js';
import './voronoi_rules/near-plate-boundary.js';
import './voronoi_rules/near-region-seed.js';
import './voronoi_rules/neighbors-in-region.js';
import './voronoi_rules/prefer-latitude.js';

class VoronoiBuilder {
  m_generators = {
    [GeneratorType.Continent]: ContinentGenerator
  };
  m_diagram = new Diagram();
  m_diagramDims = { x: 0, y: 0 };
  m_hexDims = { x: 0, y: 0 };
  m_generator;
  m_hexTiles = new VoronoiHex();
  m_generatorType = void 0;
  constructor() {
  }
  init(mapSize, generatorType, cellCountMultiple, relaxationSteps) {
    this.m_generatorType = generatorType;
    this.m_diagramDims = { x: MapDims[mapSize].x * Math.sqrt(3) * 0.5, y: MapDims[mapSize].y * 0.75 };
    this.m_hexDims = MapDims[mapSize];
    const totalCells = MapDims[mapSize].x * MapDims[mapSize].y * cellCountMultiple;
    console.log("Initializing voronoi-builder");
    console.log("  Diagram dims: {x:" + this.m_diagramDims.x + ", y:" + this.m_diagramDims.y + "}");
    console.log("  Hex dims {x:" + this.m_hexDims.x + ", y:" + this.m_hexDims.y + "}");
    console.log("  Total cells: " + totalCells + ", relaxed " + relaxationSteps + " times.");
    this.buildVoronoi(this.m_diagramDims.x, this.m_diagramDims.y, totalCells, relaxationSteps);
    console.log("  voronoi built...");
    const newGenerator = new this.m_generators[generatorType]();
    console.log("  generator created...");
    if (!this.m_generator || this.m_generator.constructor.name != newGenerator.constructor.name) {
      this.m_generator = newGenerator;
    }
    this.m_generator.init(this.m_diagramDims, this.m_diagram, mapSize);
    console.log("  generator initialized...");
  }
  simulate() {
    this.m_generator.simulate();
    this.m_hexTiles.initFromRegionCells(this.m_hexDims.x, this.m_hexDims.y, this.m_generator.getKdTree());
    this.m_hexTiles.validate();
  }
  createMajorPlayerAreas(valueFunction) {
    const playerLandmasses = [];
    for (const landmass of this.m_generator.getLandmasses()) {
      if (landmass.playerAreas > 0) {
        playerLandmasses.push(landmass);
      }
    }
    this.m_hexTiles.createMajorPlayerAreas(playerLandmasses, valueFunction);
  }
  getDiagram() {
    return this.m_diagram;
  }
  getGenerator() {
    return this.m_generator;
  }
  getGeneratorType() {
    return this.m_generatorType;
  }
  getTiles() {
    return this.m_hexTiles.getTiles();
  }
  buildVoronoi(width, height, cellCount, relaxationSteps) {
    const bbox = { xl: 0, xr: width, yt: 0, yb: height };
    const sites = VoronoiUtils.createRandomSites(cellCount, width, height);
    this.m_diagram = VoronoiUtils.computeVoronoi(sites, bbox, relaxationSteps);
  }
}

export { VoronoiBuilder };
//# sourceMappingURL=voronoi-builder.js.map
</file>

<file path="voronoi-hex.js">
import { rotate2, add2 } from '../../core/scripts/MathHelpers.js';
import { Heap } from './heap.js';
import { TerrainType, BiomeType, DetailsType, VoronoiUtils, kdTree } from './kd-tree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';

class HexTile {
  pos = { x: 0, y: 0 };
  coord = { x: 0, y: 0 };
  plateId = -1;
  landmassId = -1;
  // elevation = 0;
  majorPlayerRegionId = -1;
  terrainType = TerrainType.Unknown;
  biomeType = BiomeType.Unknown;
  detailsType = DetailsType.None;
  visited = 0;
  // used during map creation and processing.
  isLand() {
    return this.terrainType === TerrainType.Flat || this.terrainType === TerrainType.Mountainous || this.terrainType === TerrainType.Volcano || this.terrainType === TerrainType.Rough;
  }
  isWater() {
    return this.terrainType === TerrainType.Ocean || this.terrainType === TerrainType.Coast || this.terrainType === TerrainType.NavRiver;
  }
}
class HexTileDesc {
  plateId = -1;
  landmassId = -1;
  terrainType = TerrainType.Unknown;
  biomeType = BiomeType.Unknown;
  detailsType = DetailsType.None;
}
var FloodFillResult = /* @__PURE__ */ ((FloodFillResult2) => {
  FloodFillResult2[FloodFillResult2["Include"] = 0] = "Include";
  FloodFillResult2[FloodFillResult2["Exclude"] = 1] = "Exclude";
  FloodFillResult2[FloodFillResult2["Halt"] = 2] = "Halt";
  return FloodFillResult2;
})(FloodFillResult || {});
class VoronoiHex {
  static POLE_MARGIN = 2;
  // guaranteed rows of ocean near poles.
  m_tiles = [];
  m_wrappedXIndices = [];
  // Saves lots of % calls
  initFromRegionCells(width, height, tree) {
    const offsetPoint = { x: 0.736 * 0.5, y: 0 };
    const offsetPoints = [{ x: 0, y: 0 }];
    for (let i = 0; i < 6; ++i) {
      offsetPoints.push(rotate2(offsetPoint, i * Math.PI / 3));
    }
    this.initFromTiles(width, height, (_x, _y, centerPos) => {
      const getRegionCellKey = (cell) => {
        return `${cell.terrainType}`;
      };
      const regionCells = /* @__PURE__ */ new Map();
      for (const offsetPos of offsetPoints) {
        const samplePos = add2(offsetPos, centerPos);
        const regionCell = tree.search(samplePos)?.data;
        if (regionCell) {
          const regionCellKey = getRegionCellKey(regionCell);
          const entry = regionCells.get(regionCellKey);
          if (entry) {
            entry[0]++;
          } else {
            regionCells.set(regionCellKey, [1, regionCell]);
          }
        }
      }
      let dominantCell = null;
      let maxCount = 0;
      for (const [_key, [count, cell]] of regionCells) {
        if (count > maxCount) {
          dominantCell = cell;
          maxCount = count;
        }
      }
      const hexTileDesc = new HexTileDesc();
      if (dominantCell) {
        hexTileDesc.plateId = dominantCell.plateId;
        hexTileDesc.landmassId = dominantCell.landmassId;
        hexTileDesc.terrainType = dominantCell.terrainType;
        hexTileDesc.biomeType = dominantCell.biomeType;
        hexTileDesc.detailsType = dominantCell.detailsType;
      }
      return hexTileDesc;
    });
  }
  initFromTiles(xCount, yCount, getTile) {
    this.m_wrappedXIndices = Array.from({ length: xCount * 3 }, (_, index) => index % xCount);
    this.m_tiles = new Array(yCount);
    const yOffset = 0.325;
    for (let y = 0; y < yCount; ++y) {
      const xOffset = y % 2 == 0 ? 0 : Math.sqrt(3) * 0.25;
      this.m_tiles[y] = new Array(xCount);
      for (let x = 0; x < xCount; ++x) {
        const centerPos = { x: xOffset + x * Math.sqrt(3) * 0.5, y: yOffset + y * 0.75 };
        const tileDesc = getTile(x, y, centerPos);
        const tile = new HexTile();
        tile.coord = { x, y };
        tile.pos = centerPos;
        Object.assign(tile, tileDesc);
        this.m_tiles[y][x] = tile;
      }
    }
  }
  // returns neighbors in clockwise order starting from upper-right. Tiles may be undefined if near poles. Wraps in x.
  getNeighbors(tile) {
    return this.getNeighborsOfArr(tile.coord, this.m_tiles);
  }
  EvenRowDeltas = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1]
  ];
  OddRowDeltas = [
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 0],
    [0, -1]
  ];
  getNeighborsOfArr(coord, arr) {
    const deltas = coord.y % 2 === 0 ? this.EvenRowDeltas : this.OddRowDeltas;
    return deltas.map(([dx, dy]) => {
      const ny = coord.y + dy;
      if (ny < 0 || ny >= arr.length) return void 0;
      const nx = coord.x + dx + arr[0].length;
      return arr[ny][this.m_wrappedXIndices[nx]];
    });
  }
  forAllTiles(callback) {
    for (const row of this.m_tiles) {
      for (const tile of row) {
        callback(tile);
      }
    }
  }
  validate() {
    this.validatePoles(VoronoiHex.POLE_MARGIN);
    this.validateCoasts();
    this.removeLakes();
    this.removeAdjacentVolcanoes();
    this.removeBridgingCoasts();
  }
  validatePoles(marginSize) {
    for (let y = 0; y < marginSize; ++y) {
      for (const tile of this.m_tiles[y]) {
        tile.terrainType = TerrainType.Ocean;
      }
    }
    for (let y = this.m_tiles.length - marginSize; y < this.m_tiles.length; ++y) {
      for (const tile of this.m_tiles[y]) {
        tile.terrainType = TerrainType.Ocean;
      }
    }
  }
  validateCoasts() {
    this.forAllTiles((tile) => {
      if (tile.terrainType !== TerrainType.Ocean && tile.terrainType !== TerrainType.Coast) {
        const neighbors = this.getNeighbors(tile);
        for (const neighbor of neighbors) {
          if (neighbor && neighbor.terrainType === TerrainType.Ocean) {
            neighbor.terrainType = TerrainType.Coast;
            neighbor.landmassId = tile.landmassId;
          }
        }
      }
    });
  }
  removeLakes() {
    this.forAllTiles((tile) => {
      if (tile.terrainType === TerrainType.Coast && !tile.visited) {
        let foundOcean = false;
        let landmassId = 0;
        const floodTiles = this.floodFill(tile, (tile2) => {
          if (tile2.terrainType === TerrainType.Coast) {
            return 0 /* Include */;
          } else if (tile2.terrainType === TerrainType.Ocean) {
            foundOcean = true;
          } else if (tile2.terrainType === TerrainType.Flat) {
            landmassId = tile2.landmassId;
          }
          return 1 /* Exclude */;
        });
        if (!foundOcean) {
          for (const tile2 of floodTiles) {
            tile2.terrainType = TerrainType.Flat;
            tile2.landmassId = landmassId;
          }
        }
      }
    });
    this.clearVisited();
  }
  removeAdjacentVolcanoes() {
    this.forAllTiles((tile) => {
      if (tile.terrainType === TerrainType.Volcano) {
        for (const neighbor of this.getNeighbors(tile)) {
          if (neighbor?.terrainType === TerrainType.Volcano) {
            tile.terrainType = TerrainType.Mountainous;
            break;
          }
        }
      }
    });
  }
  removeBridgingCoasts() {
    this.forAllTiles((tile) => {
      if (tile.terrainType === TerrainType.Coast) {
        let allNeighborsAreWater = true;
        let hasForeignNeighbor = false;
        for (const neighbor of this.getNeighbors(tile)) {
          if (neighbor?.terrainType !== TerrainType.Coast && neighbor?.terrainType !== TerrainType.Ocean) {
            allNeighborsAreWater = false;
            break;
          }
          if (neighbor.landmassId != tile.landmassId && neighbor.landmassId != 0) {
            hasForeignNeighbor = true;
          }
        }
        if (allNeighborsAreWater && hasForeignNeighbor) {
          tile.landmassId = 0;
          tile.terrainType = TerrainType.Ocean;
        }
      }
    });
  }
  createMajorPlayerAreas(landmasses, valueFunction) {
    console.log("Creating major player regions...");
    const detailedLogs = false;
    VoronoiUtils.performanceMarker("createMajorPlayerAreas - Begin");
    for (const landmass of landmasses) {
      console.log(`Requesting ${landmass.playerAreas} player areas on landmass ${landmass.id}`);
      if (landmass.playerAreas == 0) continue;
      let landmassTiles = this.m_tiles.flatMap(
        (row) => row.filter((tile) => tile.landmassId === landmass.id)
      );
      const tileIsPassable = (tile) => {
        return tile.terrainType != TerrainType.Mountainous && tile.terrainType != TerrainType.Volcano && tile.terrainType != TerrainType.Ocean;
      };
      const floodBucket = [];
      for (const tile of landmassTiles) {
        if (!tile.visited) {
          floodBucket.push(
            this.floodFill(
              tile,
              (tile2) => tileIsPassable(tile2) ? 0 /* Include */ : 1 /* Exclude */
            )
          );
        }
      }
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        tile.majorPlayerRegionId = -1;
      });
      landmassTiles = floodBucket.sort((a, b) => b.length - a.length)[0];
      if (landmass.playerAreas == 1) {
        landmassTiles.forEach((tile) => tile.majorPlayerRegionId = 0);
        continue;
      }
      const landmassKdTree = new kdTree((tile) => tile.pos);
      landmassKdTree.build(landmassTiles);
      class SeedTile {
        tile;
        count;
      }
      const seedTiles = new Array(landmass.playerAreas);
      for (let i = 0; i < landmass.playerAreas; ++i) {
        seedTiles[i] = {
          tile: landmassTiles[i * Math.floor(landmassTiles.length / landmass.playerAreas)],
          count: 0
        };
      }
      const getAverageRegionPositions = (seedTiles2) => {
        for (let j = 0; j < seedTiles2.length; ++j) {
          const totalPos = { x: 0, y: 0 };
          const tilesForSeed = landmassTiles.filter((tile) => tile.majorPlayerRegionId == j);
          tilesForSeed.forEach((tile) => {
            totalPos.x += tile.pos.x;
            totalPos.y += tile.pos.y;
          });
          const averagePos = {
            x: totalPos.x / tilesForSeed.length,
            y: totalPos.y / tilesForSeed.length
          };
          seedTiles2[j] = { tile: landmassKdTree.search(averagePos).data, count: 0 };
        }
      };
      const relaxationSteps = 10;
      let lastSizeDiff = Infinity;
      for (let i = 0; i < relaxationSteps; ++i) {
        for (const tile of landmassTiles) {
          let bestRegion = 0;
          let closestDistSq = VoronoiUtils.sqDistance(seedTiles[0].tile.pos, tile.pos);
          for (let j = 1; j < seedTiles.length; ++j) {
            const distSq = VoronoiUtils.sqDistance(seedTiles[j].tile.pos, tile.pos);
            if (distSq < closestDistSq) {
              bestRegion = j;
              closestDistSq = distSq;
            }
          }
          tile.majorPlayerRegionId = bestRegion;
          ++seedTiles[bestRegion].count;
        }
        const counts = seedTiles.map((seedTile) => seedTile.count);
        const sizeDiff = Math.max(...counts) - Math.min(...counts);
        if (detailedLogs) {
          console.log("Player region sizes: " + counts.join(", ") + ". Total size difference: " + sizeDiff);
        }
        if (Math.abs(lastSizeDiff - sizeDiff) < 5) {
          break;
        }
        lastSizeDiff = sizeDiff;
        getAverageRegionPositions(seedTiles);
      }
      landmassTiles.forEach((tile) => tile.majorPlayerRegionId = -1);
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - K-means clustering done");
      class ScoredTile {
        tile;
        scores = new Array(playerRegions.length).fill(-1);
        expScores = new Array(playerRegions.length).fill(-1);
        expSum = 0;
        constructor(tile) {
          this.tile = tile;
        }
      }
      class MajorPlayerRegion {
        id = 0;
        totalValue = 0;
        centerPos = { x: 0, y: 0 };
        considerationHeap;
        finalSet = /* @__PURE__ */ new Set();
        borderSet = Array.from({ length: landmass.playerAreas }, () => /* @__PURE__ */ new Set());
      }
      const playerRegions = Array.from({ length: seedTiles.length }, () => new MajorPlayerRegion());
      const scoredTiles = this.m_tiles.map((row) => row.map((item) => new ScoredTile(item)));
      const getScoredTile = (tile) => scoredTiles[tile.coord.y][tile.coord.x];
      const getTileCost = (tile) => {
        return [TerrainType.Coast, TerrainType.NavRiver, TerrainType.Rough].includes(tile.terrainType) ? 2 : 1;
      };
      for (let playerRegionId = 0; playerRegionId < playerRegions.length; ++playerRegionId) {
        const playerRegionBit = 1 << playerRegionId;
        const initialTile = getScoredTile(seedTiles[playerRegionId].tile);
        initialTile.scores[playerRegionId] = 0;
        const considerationHeap = new Heap(
          (a, b) => a.scores[playerRegionId] - b.scores[playerRegionId]
        );
        considerationHeap.push(initialTile);
        while (considerationHeap.size > 0) {
          const bestTile = considerationHeap.pop();
          for (const neighbor of this.getNeighbors(bestTile.tile)) {
            if (neighbor && (neighbor.visited & playerRegionBit) == 0) {
              neighbor.visited |= playerRegionBit;
              const scoredNeighbor = getScoredTile(neighbor);
              scoredNeighbor.scores[playerRegionId] = bestTile.scores[playerRegionId] + getTileCost(neighbor);
              considerationHeap.push(scoredNeighbor);
            }
          }
        }
      }
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        const scoredTile = getScoredTile(tile);
        const softMaxTemp = 5;
        scoredTile.expScores = scoredTile.scores.map((s) => Math.exp(-s / softMaxTemp));
        scoredTile.expSum = scoredTile.expScores.reduce((a, b) => a + b, 0);
      });
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Scoring Done");
      let majorPlayerRegionId = 0;
      for (const region of playerRegions) {
        const seedTile = seedTiles[majorPlayerRegionId].tile;
        const scoredSeedTile = getScoredTile(seedTile);
        scoredSeedTile.scores[majorPlayerRegionId] = 0;
        scoredSeedTile.tile.visited = 1 << majorPlayerRegionId;
        region.id = majorPlayerRegionId;
        region.considerationHeap = new Heap((a, b) => {
          const scoreA = a.expScores[region.id] / a.expSum;
          const scoreB = b.expScores[region.id] / b.expSum;
          return scoreB - scoreA;
        });
        region.considerationHeap.push(scoredSeedTile);
        region.centerPos = seedTile.pos;
        ++majorPlayerRegionId;
      }
      const scoringRegions = [...playerRegions];
      while (scoringRegions.length > 0) {
        for (const scoringRegion of scoringRegions) {
          let bestTile = void 0;
          while (bestTile === void 0 && scoringRegion.considerationHeap.size > 0) {
            bestTile = scoringRegion.considerationHeap.pop();
            if (bestTile.tile.majorPlayerRegionId != -1) {
              bestTile = void 0;
            }
          }
          if (bestTile === void 0) {
            scoringRegions.splice(scoringRegions.indexOf(scoringRegion), 1);
            continue;
          }
          bestTile.tile.majorPlayerRegionId = scoringRegion.id;
          scoringRegion.finalSet.add(bestTile.tile);
          const regionBit = 1 << scoringRegion.id;
          for (const neighbor of this.getNeighborsOfArr(bestTile.tile.coord, scoredTiles)) {
            if (neighbor?.tile.majorPlayerRegionId == -1 && (neighbor.tile.visited & regionBit) == 0) {
              neighbor.tile.visited |= regionBit;
              if (tileIsPassable(neighbor.tile)) {
                scoringRegion.considerationHeap.push(neighbor);
              }
            }
          }
        }
      }
      const getTileValue = valueFunction ? valueFunction : (tile) => {
        switch (tile.terrainType) {
          case TerrainType.Coast:
            return 0.5;
          default:
            return 1;
        }
      };
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        if (tile.majorPlayerRegionId >= 0) {
          playerRegions[tile.majorPlayerRegionId].totalValue += getTileValue(tile);
        }
      });
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Initial Growth Done");
      console.log(
        `After initial growth, region sizes are: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] and vales are: [${playerRegions.map((region) => region.totalValue).join(", ")}]`
      );
      class Border {
        regionId1 = -1;
        regionId2 = -1;
        count = 1;
        constructor(regionId1, regionId2) {
          [this.regionId1, this.regionId2] = [regionId1, regionId2];
          this.count = 1;
        }
        regionValueDiff() {
          return Math.abs(
            //playerRegions[this.regionId1].finalSet.size - playerRegions[this.regionId2].finalSet.size,
            playerRegions[this.regionId1].totalValue - playerRegions[this.regionId2].totalValue
          );
        }
        isSame(regionId1, regionId2) {
          return this.regionId1 == regionId1 && this.regionId2 == regionId2 || this.regionId2 == regionId1 && this.regionId1 == regionId2;
        }
        getOrderedRegions() {
          return playerRegions[this.regionId1].totalValue < playerRegions[this.regionId2].totalValue ? [this.regionId1, this.regionId2] : [this.regionId2, this.regionId1];
        }
      }
      const borders = [];
      const addBorder = (regionId1, regionId2) => {
        const existingBorder = borders.find(
          (border) => border.isSame(regionId1, regionId2)
        );
        if (existingBorder) {
          ++existingBorder.count;
        } else {
          borders.push(new Border(regionId1, regionId2));
        }
      };
      const getBorderNeighbors = (tile) => {
        const borderNeighbors = [];
        for (const neighbor of this.getNeighbors(tile)) {
          if (neighbor && neighbor.majorPlayerRegionId != -1 && neighbor.majorPlayerRegionId != tile.majorPlayerRegionId) {
            borderNeighbors.push(neighbor);
          }
        }
        return borderNeighbors;
      };
      const isBridgeForRegion = (tile) => {
        const regions = this.getNeighbors(tile).map(
          (n) => n == void 0 || n.majorPlayerRegionId != tile.majorPlayerRegionId ? 0 : 1
        );
        let lastRegionId = regions[0];
        let nonRegionBlobs = 1 - lastRegionId;
        let regionBlobs = lastRegionId;
        for (let i = 1; i < regions.length; ++i) {
          const regionId = regions[i];
          if (lastRegionId == 0 && regionId == 1) ++regionBlobs;
          else if (lastRegionId == 1 && regionId == 0) ++nonRegionBlobs;
          lastRegionId = regionId;
        }
        return nonRegionBlobs > 1 && regionBlobs > 1;
      };
      for (const tile of landmassTiles) {
        if (tile.majorPlayerRegionId == -1) {
          continue;
        }
        const region = playerRegions[tile.majorPlayerRegionId];
        const borderNeighbors = getBorderNeighbors(tile);
        for (const neighbor of borderNeighbors) {
          region.borderSet[neighbor.majorPlayerRegionId].add(tile);
          addBorder(tile.majorPlayerRegionId, neighbor.majorPlayerRegionId);
        }
      }
      const borderSorter = (a, b) => {
        return b.regionValueDiff() - a.regionValueDiff();
      };
      borders.sort(borderSorter);
      if (borders.length === 0) {
        console.warn(
          "No borders found between player regions, unable to balance the size of player starting areas."
        );
        return;
      }
      let count = 0;
      while (borders[0].regionValueDiff() > 1 && count < 100) {
        ++count;
        let bestScore = -Infinity;
        let bestSteal;
        let bestSource;
        let [smallRegionId, bigRegionId] = borders[0].getOrderedRegions();
        let [smallRegion, bigRegion] = [playerRegions[smallRegionId], playerRegions[bigRegionId]];
        let i = 0;
        let border = borders[i];
        while (bestSteal == void 0 && i < borders.length) {
          border = borders[i];
          ++i;
          bestScore = -Infinity;
          [smallRegionId, bigRegionId] = border.getOrderedRegions();
          [smallRegion, bigRegion] = [playerRegions[smallRegionId], playerRegions[bigRegionId]];
          for (const borderTile of smallRegion.borderSet[bigRegionId]) {
            for (const neighbor of getBorderNeighbors(borderTile)) {
              if (neighbor.majorPlayerRegionId == bigRegionId) {
                const neighborPairTile = getScoredTile(neighbor);
                const neighborValue = getTileValue(neighborPairTile.tile);
                const bigRegionScore = neighborPairTile.scores[bigRegionId] - neighborValue;
                const smallRegionScore = neighborPairTile.scores[smallRegionId] - neighborValue;
                const swapScore = bigRegionScore - smallRegionScore;
                if (swapScore > bestScore && !isBridgeForRegion(neighbor) && // doesn't cut region in two
                borders[0].regionValueDiff() - neighborValue > 0) {
                  bestScore = swapScore;
                  bestSteal = neighbor;
                  bestSource = borderTile;
                }
              }
            }
          }
        }
        if (bestSteal != void 0 && bestSource != void 0) {
          if (detailedLogs) {
            console.log(
              `Stealing (${bestSteal.coord.x}, ${bestSteal.coord.y}) from region ${bestSteal.majorPlayerRegionId} to region ${bestSource.majorPlayerRegionId} with score ${bestScore}`
            );
          }
          border.count -= getBorderNeighbors(bestSteal).length;
          {
            const bestStealValue = getTileValue(bestSteal);
            let count2 = 0;
            for (const borderSet of bigRegion.borderSet) {
              count2 += Number(borderSet.delete(bestSteal));
            }
            if (count2 == 0) throw new Error();
            if (!bigRegion.finalSet.delete(bestSteal)) throw new Error();
            bigRegion.totalValue -= bestStealValue;
            bestSteal.majorPlayerRegionId = smallRegionId;
            count2 = 0;
            for (const neighbor of getBorderNeighbors(bestSteal)) {
              if (neighbor.majorPlayerRegionId != smallRegion.id) {
                smallRegion.borderSet[neighbor.majorPlayerRegionId].add(bestSteal);
                ++count2;
              }
            }
            if (count2 == 0) throw new Error();
            smallRegion.finalSet.add(bestSteal);
            smallRegion.totalValue += bestStealValue;
            const borderNeighbors = getBorderNeighbors(bestSteal);
            for (const neighbor of borderNeighbors) {
              addBorder(smallRegionId, neighbor.majorPlayerRegionId);
              bigRegion.borderSet[smallRegionId].add(neighbor);
            }
          }
          if (getBorderNeighbors(bestSource).length == 0) {
            if (!smallRegion.borderSet[bigRegionId].delete(bestSource)) throw new Error();
          }
          if (border.count == 0) {
            VoronoiUtils.swapAndPop(borders, i - 1);
            borders.sort(borderSorter);
          }
          for (let i2 = 0; i2 < borders.length - 1; ++i2) {
            if (borders[i2].regionValueDiff() < borders[i2 + 1].regionValueDiff()) {
              [borders[i2], borders[i2 + 1]] = [borders[i2 + 1], borders[i2]];
            } else {
              break;
            }
          }
        } else {
          break;
        }
        if (detailedLogs) {
          console.log(`  Region sizes: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] `);
          console.log(`  Region values: [${playerRegions.map((region) => region.totalValue).join(", ")}] `);
          console.log(
            `  Borders: [${borders.map((border2) => "([" + border2.getOrderedRegions()[0] + ", " + border2.getOrderedRegions()[1] + "], diff: " + border2.regionValueDiff() + ", count: " + border2.count + ")").join(", ")}] `
          );
        }
      }
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Region Area Balancing Done");
      for (const region of playerRegions) {
        const inBorderTiles = /* @__PURE__ */ new Set();
        region.finalSet.forEach((tile) => {
          if (getBorderNeighbors(tile).length > 0) inBorderTiles.add(getScoredTile(tile));
        });
        const outBorderTiles = Array.from(
          { length: playerRegions.length },
          () => /* @__PURE__ */ new Set()
        );
        for (const tile of inBorderTiles) {
          for (const neighbor of getBorderNeighbors(tile.tile)) {
            outBorderTiles[neighbor.majorPlayerRegionId].add(getScoredTile(neighbor));
          }
        }
        while (true) {
          const regionPairs = /* @__PURE__ */ new Map();
          for (const inTile2 of inBorderTiles) {
            if (isBridgeForRegion(inTile2.tile)) {
              continue;
            }
            const borderRegions = [];
            for (const neighbor of getBorderNeighbors(inTile2.tile)) {
              if (borderRegions.indexOf(neighbor.majorPlayerRegionId) == -1) {
                borderRegions.push(neighbor.majorPlayerRegionId);
              }
            }
            for (const regionId of borderRegions) {
              let bestTradeScore = 0;
              let bestTradeTile;
              for (const outTile2 of outBorderTiles[regionId]) {
                const inTileValue = getTileValue(inTile2.tile);
                const outTileValue = getTileValue(outTile2.tile);
                const tileValueDiff = inTileValue - outTileValue;
                const scoreBefore = inTile2.scores[region.id] + outTile2.scores[outTile2.tile.majorPlayerRegionId] + tileValueDiff;
                const scoreAfter = inTile2.scores[outTile2.tile.majorPlayerRegionId] + outTile2.scores[region.id] - tileValueDiff;
                const tradeScore = scoreBefore - scoreAfter;
                if (tradeScore > bestTradeScore && !isBridgeForRegion(outTile2.tile)) {
                  bestTradeScore = tradeScore;
                  bestTradeTile = outTile2;
                }
              }
              if (bestTradeTile != void 0) {
                const tradeCandidate = regionPairs.get(regionId);
                if (tradeCandidate == void 0) {
                  regionPairs.set(regionId, {
                    inside: inTile2,
                    outside: bestTradeTile,
                    delta: bestTradeScore
                  });
                } else if (tradeCandidate.delta < bestTradeScore) {
                  tradeCandidate.inside = inTile2;
                  tradeCandidate.outside = bestTradeTile;
                  tradeCandidate.delta = bestTradeScore;
                }
              }
            }
          }
          if (regionPairs.size == 0) {
            break;
          }
          let bestTradeCandidate;
          for (const [_key, value] of regionPairs) {
            if (bestTradeCandidate == void 0 || bestTradeCandidate.delta < value.delta) {
              bestTradeCandidate = value;
            }
          }
          let [inTile, outTile] = [bestTradeCandidate.inside, bestTradeCandidate.outside];
          if (inTile.tile.majorPlayerRegionId == outTile.tile.majorPlayerRegionId) throw new Error("");
          {
            const scoreBefore = inTile.scores[region.id] + outTile.scores[outTile.tile.majorPlayerRegionId];
            const scoreAfter = inTile.scores[outTile.tile.majorPlayerRegionId] + outTile.scores[region.id];
            if (detailedLogs) {
              console.log(
                `Trading (${inTile.tile.coord.x}, ${inTile.tile.coord.y}), region: ${inTile.tile.majorPlayerRegionId} with (${outTile.tile.coord.x}, ${outTile.tile.coord.y}), region: ${outTile.tile.majorPlayerRegionId} to improve total score from ${scoreBefore} to ${scoreAfter} `
              );
            }
          }
          if (!inBorderTiles.delete(inTile)) throw new Error();
          if (!outBorderTiles[outTile.tile.majorPlayerRegionId].delete(outTile)) throw new Error();
          if (!playerRegions[inTile.tile.majorPlayerRegionId].finalSet.delete(inTile.tile)) throw new Error();
          if (!playerRegions[outTile.tile.majorPlayerRegionId].finalSet.delete(outTile.tile))
            throw new Error();
          playerRegions[inTile.tile.majorPlayerRegionId].totalValue -= getTileValue(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].totalValue -= getTileValue(outTile.tile);
          [inTile.tile.majorPlayerRegionId, outTile.tile.majorPlayerRegionId] = [
            outTile.tile.majorPlayerRegionId,
            inTile.tile.majorPlayerRegionId
          ];
          [inTile, outTile] = [outTile, inTile];
          if (inTile.tile.majorPlayerRegionId != region.id) throw new Error("");
          inBorderTiles.add(inTile);
          outBorderTiles[outTile.tile.majorPlayerRegionId].add(outTile);
          playerRegions[inTile.tile.majorPlayerRegionId].finalSet.add(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].finalSet.add(outTile.tile);
          playerRegions[inTile.tile.majorPlayerRegionId].totalValue += getTileValue(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].totalValue += getTileValue(outTile.tile);
          for (const neighbor of this.getNeighbors(inTile.tile)) {
            if (neighbor && getBorderNeighbors(neighbor).length == 0) {
              inBorderTiles.delete(getScoredTile(neighbor));
            }
          }
          for (const neighbor of this.getNeighbors(outTile.tile)) {
            if (neighbor && getBorderNeighbors(neighbor).length == 0) {
              outBorderTiles[neighbor.majorPlayerRegionId].delete(getScoredTile(neighbor));
            }
          }
        }
      }
      this.m_tiles.forEach((row) => row.forEach((tile) => tile.visited = 0));
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Region Optimizing Done");
      console.log(
        `"Finished creating major player regions for landmass ${landmass.id}, region sizes are: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] and vales are: [${playerRegions.map((region) => region.totalValue).join(", ")}]`
      );
    }
  }
  floodFill(initialTile, considerCallback) {
    initialTile.visited = 1;
    const considerationList = [initialTile];
    const returnList = [];
    while (considerationList.length > 0) {
      const tile = considerationList.pop();
      returnList.push(tile);
      const neighbors = this.getNeighbors(tile);
      for (const neighbor of neighbors) {
        if (neighbor && !neighbor.visited) {
          neighbor.visited = 1;
          const result = considerCallback(neighbor);
          switch (result) {
            case 0 /* Include */:
              considerationList.push(neighbor);
              break;
            case 2 /* Halt */:
              return returnList;
          }
        }
      }
    }
    return returnList;
  }
  clearVisited() {
    for (const row of this.m_tiles) {
      for (const tile of row) {
        tile.visited = 0;
      }
    }
  }
  getTiles() {
    return this.m_tiles;
  }
}

export { HexTile, HexTileDesc, VoronoiHex };
//# sourceMappingURL=voronoi-hex.js.map
</file>

<file path="voronoi-plate.js">
class VoronoiPlate {
  m_center = { x: 0, y: 0 };
  m_direction = { x: 0, y: 0 };
  m_rotation = 0;
}

export { VoronoiPlate };
//# sourceMappingURL=voronoi-plate.js.map
</file>

<file path="voronoi-region.js">
import { RandomImpl } from './random-pcg-32.js';
import { VoronoiUtils } from './kd-tree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../../core/scripts/MathHelpers.js';

class IdScorePair {
  id = 0;
  score = 0;
}
class VoronoiRegion {
  name;
  id = 0;
  type = 0;
  maxArea = 0;
  playerAreas = 0;
  color = { x: 0, y: 0, z: 0 };
  seedLocation = { x: 0, y: 0 };
  considerationList = [];
  cellCount = 0;
  minOrder = 0;
  // Used for offsetting the order of individual cells, for visualizing and debugging region growth over time.
  scoringContext;
  colorString = "";
  quadTree;
  constructor(name, id, type, maxArea, playerAreas, color) {
    this.name = name;
    this.id = id;
    this.type = type;
    this.maxArea = maxArea;
    this.playerAreas = playerAreas;
    this.color = color;
    const r = Math.floor(color.x * 255);
    const g = Math.floor(color.y * 255);
    const b = Math.floor(color.z * 255);
    this.colorString = "rgb(" + r + " ," + g + ", " + b + ")";
  }
  prepareGrowth(regionCells, regions, rules, worldDims, plateRegions) {
    this.scoringContext = {
      cells: regionCells,
      region: this,
      regions,
      plateRegions,
      m_worldDims: { x: worldDims.x, y: worldDims.y },
      totalArea: 0,
      cellCount: 0,
      rules
    };
    for (const rule of Object.values(rules)) {
      rule.prepare();
    }
    regionCells.forEach((cell) => {
      cell.regionConsiderationBits = 0n;
    });
    this.quadTree = void 0;
  }
  growStep() {
    let newCellIndex = 0;
    const regionCells = this.scoringContext.cells;
    for (let i = 0; i < this.considerationList.length; ) {
      const cell = regionCells[this.considerationList[i].id];
      if (this.isCellClaimed(cell)) {
        VoronoiUtils.swapAndPop(this.considerationList, i);
        continue;
      }
      if (this.considerationList[i].score > this.considerationList[newCellIndex].score) {
        newCellIndex = i;
      }
      ++i;
    }
    if (this.considerationList.length == 0 || this.considerationList[newCellIndex].score < 0) {
      return false;
    }
    const newCellId = this.considerationList[newCellIndex].id;
    VoronoiUtils.swapAndPop(this.considerationList, newCellIndex);
    const newCell = regionCells[newCellId];
    this.setRegionIdForCell(newCell, this.id, this.scoringContext);
    this.scoringContext.totalArea += newCell.area;
    this.scoringContext.cellCount++;
    this.cellCount = this.scoringContext.cellCount;
    if (this.quadTree) {
      this.quadTree.insert(newCell);
    }
    this.scoringContext.rules.forEach((rule) => rule.notifySelectedCell(newCell, this.scoringContext));
    for (const neighborId of newCell.cell.getNeighborIds()) {
      const neighbor = regionCells[neighborId];
      if (this.isCellClaimed(neighbor)) {
        continue;
      }
      const score = this.scoreCell(neighbor, this.scoringContext);
      if (neighbor.regionConsiderationBits & BigInt(1 << this.id)) {
        const index = this.considerationList.findIndex((value) => value.id === neighborId);
        this.considerationList[index].score = score;
      } else {
        this.considerationList.push({ id: neighborId, score });
      }
    }
    return this.considerationList.length > 0 && this.scoringContext.totalArea < this.maxArea;
  }
  logStats() {
    console.log(
      "Region " + this.id + " total area: " + this.scoringContext?.totalArea + ", cell count: " + this.scoringContext?.cellCount
    );
  }
  getColorString() {
    return this.colorString;
  }
  scoreCell(regionCell, scoringContext) {
    let score = 0;
    for (const rule of Object.values(scoringContext.rules)) {
      if (rule.isActive) {
        score += rule.score(regionCell, scoringContext) * rule.weight;
      }
    }
    return score;
  }
  scoreSingleCell(regionCell) {
    return this.scoreCell(regionCell, this.scoringContext);
  }
  SetQuadTree(quadtree) {
    this.quadTree = quadtree;
  }
}
class LandmassRegion extends VoronoiRegion {
  setRegionIdForCell(cell, id, scoringContext) {
    cell.landmassId = id;
    cell.landmassOrder = scoringContext.cellCount;
  }
  getRegionIdForCell(cell) {
    return cell.landmassId;
  }
  isCellClaimed(cell) {
    return cell.landmassId != 0;
  }
}
class PlateRegion extends VoronoiRegion {
  m_movement = { x: 0, y: 0 };
  m_rotation = 0;
  constructor(name, id, type, maxArea, color) {
    super(name, id, type, maxArea, 0, color);
    const dir = RandomImpl.fRand("Plate Movement Direction") * Math.PI * 2;
    const movementSpeed = RandomImpl.fRand("Plate Movement Speed");
    this.m_movement.x = Math.cos(dir) * movementSpeed;
    this.m_movement.y = Math.sin(dir) * movementSpeed;
    this.m_rotation = RandomImpl.fRand("Plate Rotation") * 2 - 1;
  }
  setRegionIdForCell(cell, id, scoringContext) {
    cell.plateId = id;
    cell.plateOrder = scoringContext.cellCount;
  }
  getRegionIdForCell(cell) {
    return cell.plateId;
  }
  isCellClaimed(cell) {
    return cell.plateId != -1;
  }
}

export { LandmassRegion, PlateRegion, VoronoiRegion };
//# sourceMappingURL=voronoi-region.js.map
</file>

</files>
