# Gameplay Domain Refactor - Unified Design Direction (Civ7 MapGen)

## Objective and Context

The **Gameplay domain refactor** aims to consolidate all map generation gameplay logic into a coherent domain, without altering the overall pipeline sequence. In **Phase A**, the new Gameplay domain will focus on producing **overlays** (narrative story data) and orchestrating high-level game setup (starts, resources, etc.) via engine APIs - **without directly mutating physical world data** [1]. This preserves the existing stage "braid" (interleaving gameplay and physics stages) while clarifying ownership and responsibilities. "Gameplay" in this context encompasses all **board setup** (e.g. player start positions), **content placement** (resources, wonders, discoveries, etc.), and **story overlays** that shape the narrative context [2]. The goal is a clear architectural separation where physics domains simulate the world, and the Gameplay domain layers on player-facing meaning and final game-ready modifications, all in a controlled manner.

## Scope of the Gameplay Domain in Map Generation

**Gameplay's mapgen-time responsibilities** are derived from Civ7's official scripts and data and can be summarized as follows [3]:

- **Board setup:** Placing major civ start positions and defining advanced start regions (the extended starting area beyond the initial city plot) [4]. This includes applying any start bias rules (preferences for certain terrains, biomes, etc. by each civ/leader) as defined in game data [5]. It also involves labeling landmasses for gameplay purposes (e.g. distinguishing "homelands" vs "distant lands") to inform start placement logic [6] [7].
- **Content placement:** Placing map content like resources, natural wonders, and discoveries (goody huts) in the world [8] [9]. This also covers any related post-processing of the map required by gameplay - for example, generating floodplains along rivers [10], recalculating fertility and storing water data for scoring once terrain and resources are placed [11] [12], and even minor adjustments like replacing "island" resources via special rules. These steps ensure the final map has all gameplay-relevant features placed according to design rules.
- **Story overlays:** Producing structured narrative overlays (sometimes called **"motifs"** or **"corridors"**) that represent the story of how the world was formed [13]. Overlays are data layers (e.g. tectonic hotspot markers, rift lines, climate corridors, biome swatches) that encode higher-level thematic or gameplay-relevant information about the map. They are generated during **narrative** stages and consumed by later steps in multiple domains to bias or shape outcomes [14] [15]. In short, overlays tell a story (such as where mountain ranges formed or which areas are arid vs fertile) that influences placement and ecology without directly modifying the physical terrain.

All these concerns are part of Civ7's map generation "gameplay levers" evidenced in the base game's scripts [16] [17]. The new Gameplay domain will unify these into a single conceptual model. Importantly, **gameplay does not generate terrain or climate** - those remain the responsibility of physics domains (e.g. Foundation, Morphology, Hydrology). Instead, gameplay consumes the world produced by physics and then **adds the final layer of game-specific meaning** (placements, labels, overlays) on top [18].

## Domain Responsibilities and Boundaries

**What Gameplay Owns:**

The Gameplay domain will own the **player-facing "meaning" of the map** - essentially, anything about map setup that directly affects game rules and player experience [19]. This includes the contracts and logic for placing civs and content, as well as defining the **overlay system** (the keys, types, and semantics of overlays that explain world features) [20]. Gameplay is the authority on these higher-level constructs; it decides how the world's physical features translate into starting positions, resource distribution patterns, special regions, etc. It also defines what overlays exist (e.g. what constitutes a _Hotspot_ or _Rift_ motif) and publishes those overlays for others to use [21].

**What Gameplay Does _Not_ Own:**

Gameplay does _not_ own the low-level generation of the physical world or the fundamental simulation outputs. Terrain formation, climate simulation, hydrology, and ecology (biome growth) remain **physics domain** responsibilities [22]. Gameplay will influence these indirectly (for example, via overlays that physics steps read as input, like marking certain areas to guide river or biome generation [15] [23]). Also, not every creation or use of an overlay must be in a Gameplay-owned step - if a physics-driven step is the natural producer of a certain overlay, we allow that in order to "let truth come from the source" [24]. For instance, the **Morphology** domain's island formation step generates HOTSPOTS overlays (indicating island cluster locations) as a byproduct of its terrain shaping logic [25]. We consider overlays a Gameplay-defined contract, but **physics steps may publish them when they are the authoritative source**, and physics steps may consume overlays as guidelines or constraints. This flexible boundary ensures we don't contort the pipeline just for ownership purity - Gameplay owns the _meaning_ of overlays, but any domain can contribute to or utilize them as needed so long as the contract is respected [24] [26].

Crucially, **Gameplay in Phase A will not mutate core physics data** such as heightmaps, climate grids, or hydrology buffers during map generation [1]. Any rule or effect that _would_ alter those (for example, the legacy _paleo rainfall artifacts_ which wrote directly to climate data) must either be re-homed under a physics domain or disabled, to maintain a clean separation [27] [1]. Gameplay's influence on the physical world is exerted through overlays and through engine-level calls that place game entities, rather than direct modification of terrain/climate arrays in the generation pipeline.

## Stage Integration and Interaction Patterns

The **stage braid** (the sequence of map generation stages) is **preserved** in the new design - gameplay-related stages remain interwoven with physics stages as in the current pipeline [26]. The standard mapgen recipe's stage order illustrates this interleaving of domains [28] [29]:

- Physics-oriented stages like **foundation**, **morphology-pre/mid/post**, **hydrology-pre/core/post**, **ecology** handle world simulation in sequence.
- Gameplay-oriented stages labeled **narrative-** _(narrative-pre, narrative-mid, narrative-swatches, narrative-post) and the final_ _placement_\* stage are threaded between those physics stages at key points [28] [29].

In practice, this means gameplay decisions are applied in phases: e.g. after initial terrain formation, narrative-pre runs to generate story overlays (like tectonic motifs) which subsequent morphology and hydrology stages can consider [30] [31]; later, after rivers are carved, narrative-post runs to adjust overlays (corridors after rivers) [32]; finally, after all world physics are done, the placement stage runs to place resources, starts, etc. The **Placement** stage is the last in the chain, acting as the bridge to the actual game engine application [33].

**Narrative Stages and Overlays:**

The narrative stages produce and append to a global **overlays container** artifact that is initialized early (in narrative-pre) and passed through the pipeline [34] [35]. Each narrative step contributes specific overlays: for example, story-hotspots appends _HOTSPOTS_ overlays, story-rifts appends _RIFTS_ overlays (using Foundation's plate data as input), story-corridors steps compute corridor overlays at different points (pre- and post-river) [36] [37]. By the end of narrative-post, overlays like **motifs.hotspots**, **motifs.rifts**, **motifs.margins** (plate boundary effects), **corridors** (paths of low obstacles), **swatches** (regional climate zones), etc., are all collected in that container. These overlays are then consumed by various downstream steps in **physics domains** to fine-tune the world: e.g. Morphology's _ruggedCoasts_ step reads **margins** and **corridors** overlays to shape coastal cliffs [38]; Hydrology's _climateRefine_ reads **rifts** and **hotspots** to adjust climate after rivers [39]; Ecology's _biomes_ and _features_ steps read overlays (corridors, rifts, hotspots, margins) to influence biome distribution and feature placement [23]. This cross-pipeline use of overlays is a fundamental interaction pattern - **gameplay overlays serve as a contract that later steps in _multiple_ domains honor** [15]. Any refactor must maintain this contract: overlays' structure and meaning should remain consistent so that consumers in Morphology, Hydrology, Ecology, etc., continue to function correctly [40].

**Placement Stage:**

The placement stage is where the **Gameplay domain "applies" changes to the world** using the game engine's capabilities. It has two main steps today [41] [42]:

- _derive-placement-inputs_, which prepares planning data (e.g. consolidating the chosen start positions, resource plans, etc., into a placementInputs artifact) by running domain ops like planStarts, planWonders, planFloodplains [43].
- _placement (apply)_, which takes those plans and calls the engine to enact them, producing a placementOutputs artifact (mostly for logging/verification) [42].

The **engine apply boundary** is a critical concept: this step uses the **EngineAdapter** interface to call into Civ7's native mapgen functions (for adding resources, placing starts, etc.) [44] [45]. No direct game-state mutation happens in our TypeScript pipeline; instead, we delegate to the engine at this final boundary.

The stage integration design can be summed up as **"braid preserved, ownership clarified"** [26]. We continue to run the same sequence of interleaved stages, but now we regard all **narrative-\* stages and the placement stage as Gameplay-owned** (under the new domain), while the other stages remain physics-owned. Physics stages may still consume or even produce overlays, but the definition and primary publication of overlays falls under Gameplay's purview as part of its domain contract [26] [46]. By keeping the braid, we avoid a massive orchestration change - domains still hand off to each other in the same order as before - but by clarifying ownership, we make it clear which team or system owns which logic.

## Domain Consolidation and Code Absorption

To implement this refactor, we plan to **merge the existing Placement and Narrative domain code into a new unified Gameplay domain module** [47]. All functionality that was previously split between @mapgen/domain/placement and @mapgen/domain/narrative will be absorbed or re-homed accordingly:

- The **Placement domain ops** - currently used for planning starts, wonders, floodplains, etc. - will be migrated into Gameplay wholesale [48] [49]. These ops already form a "planning surface" with clear inputs and outputs (plans in, plans out) that feed the placement stage, so they naturally become part of Gameplay's internal logic [50]. Gameplay will thus include ops like planStarts, planWonders, planFloodplains (and any similar planning routines) as first-class operations under its domain.
- The **Narrative domain's overlay machinery and motif generation utilities** will also become part of Gameplay [51] [52]. This includes the overlay key definitions, overlay registry/normalization helpers (ensuring overlays are well-formed) [53], and the specific algorithms for deriving motifs and corridors: e.g. hotspot detection, rift detection, margin tagging, orogeny (mountain narrative) analysis, and corridor carving [54] [55]. These were previously under a loosely-defined Narrative domain; going forward, they are considered **Gameplay's toolkit** for producing the story overlays. We will sort out which parts of these are genuinely gameplay-specific rules versus which are essentially physics policies expressed as overlays (for example, the _orogeny_ overlay might be tightly coupled to plate simulations). Anything that is purely representational or for gameplay use will live in Gameplay, whereas if an overlay is essentially exposing a physics calculation, we might treat it as a physics responsibility to compute (even if the overlay type itself is defined by Gameplay).
- Some narrative code that doesn't fit the gameplay domain's remit will be **re-homed or deprecated**. For instance, the _paleo climate artifacts_ (a Narrative module that attempted to simulate ancient rainfall effects by directly modifying climate data) is an **ambiguous case** [27]. Since Gameplay Phase A avoids direct physics mutation, this functionality likely needs to move into the Hydrology/Climate domain or be removed, rather than being carried into Gameplay as-is [56] [1]. We will decide on a case-by-case basis whether a given "story" computation remains as a pure overlay (safe) or becomes a physics concern. The **key decision point** here is: **if it writes to physics buffers, it cannot remain a Gameplay responsibility in Phase A** [1]. Either we convert it into a read-only overlay or shift the logic under the appropriate simulation domain.

After absorption, the new module (tentatively @mapgen/domain/gameplay) will expose a **public contract surface** (ops, schemas, overlay definitions) that covers all the above functionality [47]. The older modules (placement and narrative) will eventually be deprecated and removed [57]. By unifying them, we reduce duplication and make it clear that there is one Gameplay domain responsible for the entire "board setup and narrative overlays" space.

## Phase A Posture: Overlay-Focused Gameplay Shaping

In **Phase A of the Gameplay refactor**, the domain's posture is "**overlay-only**" shaping. This means that Gameplay will **influence map generation by publishing overlays and by invoking engine-provided map generation routines**, **not by directly altering terrain or other physics-generated fields in the pipeline** [1]. Practically, the Gameplay domain will behave as follows in Phase A:

- **Overlay Production:** Gameplay stages (narrative-pre/mid/swatches/post) will continue to publish the same overlays (HOTSPOTS, RIFTS, MARGINS, OROGENY, CORRIDORS, SWATCHES, etc.) as today, providing high-level signals and story context about the world [36] [30]. These overlays act as **policy inputs** or modifiers for subsequent worldgen logic, but they do not themselves alter the terrain - they are data that other steps can choose to heed. By the end of map generation, the overlays collectively represent the "story" of the map's creation as understood by gameplay. This overlay contract will remain stable in Phase A so that all existing consumers (as listed in the previous section) continue to function [40]. We explicitly **allow physics stages to publish to overlays** if they are the natural producer (e.g. island hotspot marking), to keep the system practical [25] [24]. Gameplay oversees the overlay definitions and ensures their consistency, but doesn't monopolize their creation when another domain has the authoritative info.
- **Engine Calls for Content Placement:** The final placement step in Gameplay will use the **EngineAdapter** to call Civ7's built-in map generation functions for everything from placing resources to assigning start positions. The adapter already provides methods corresponding to all the major gameplay mapgen actions [45] [58] [59]. For example, the mod's placement apply step calls: EngineAdapter.addNaturalWonders() to place natural wonders [60], EngineAdapter.generateResources() to populate strategic/luxury resources [61], EngineAdapter.generateDiscoveries() for goody huts [58], EngineAdapter.assignStartPositions() (and related functions) for start location assignment [62] [63], EngineAdapter.assignAdvancedStartRegions() for secondary start areas [64], EngineAdapter.addFloodplains() to add floodplain terrain under rivers [10], and calls like EngineAdapter.recalculateFertility() and EngineAdapter.storeWaterData() to update scoring metrics once everything is placed [65] [12]. All of these calls correspond to Civ7 "official" script entry points (e.g. the game's resource-generator.js, natural-wonder-generator.js, etc.), meaning our mod is simply triggering the same routines the base game would, but in a controlled order with our own data inputs [66] [67]. **Phase A leverages these high-level engine capabilities to achieve feature parity with Civ7** without re-implementing low-level mechanics or requiring new engine features. Gameplay domain acts as an orchestrator: it collects the necessary context (overlays, plans, config settings), then instructs the engine to execute the heavy lifting of placement.
- **No Direct Physics Mutation:** As stated, Phase A avoids any direct writes to physics buffers. If a gameplay logic needs to _cause_ a physical change, it must do so via the engine or not at all. For example, if an overlay or rule would imply altering terrain (say, removing a mountain or changing a tile type), Gameplay would either (a) pass that as a suggestion to a physics step or (b) require an engine call to handle it (if such exists), rather than manipulating the heightfield/terrain array itself. In the current design, there is no Phase A case where gameplay directly changes the heightmap or climate - all such influences are indirect. A concrete case: the **"paleo rainfall artifact"** code that was in narrative (which painted some rain shadow effects into the climate) cannot remain as-is. The solution is likely to handle it as part of climate modeling in Hydrology (thus, a physics responsibility) or drop it for now, because in Phase A **Gameplay will only output an overlay to mark such regions, rather than physically adjusting rainfall in the climate buffer** [56] [1]. This principle keeps the separation clean and ensures the physics simulation remains authoritative for world state, with gameplay layering interpretation on top.

By adopting this overlay-focused, engine-call-driven approach in Phase A, we ensure the refactored Gameplay domain can achieve all the same outcomes as the current system (since Civ7's own map scripts handle the actual placement and adjustments when invoked). We also minimize risk: the **EngineAdapter's existing methods cover the needed functionality**, so we aren't introducing new integration points that could fail [68] [69]. This approach respects the "phase contract" of the pipeline - we don't invent new phases or radically change when things happen, we just change _who_ manages them [70]. The **adapter boundary remains the execution boundary**, meaning Gameplay steps never call the game's internals directly, they only call our adapter, which in turn calls the game engine [71]. This containment makes it easier to maintain and later replace parts of the engine's behavior if needed (by swapping out adapter implementations) without breaking the pipeline.

## Anticipated Phase B: Deferred Gameplay Shaping Capabilities

While Phase A focuses on unifying existing behavior, we anticipate a **Phase B** (or later enhancements) where the Gameplay domain could take on more ambitious shaping capabilities. These are **explicitly deferred for now** to keep scope manageable [68] [69], but we recognize them as potential evolutions once the Gameplay domain is established:

- **Direct Resource Placement:** Currently, resource placement is treated as a bulk generation black-box (we call the engine's generateResources which handles distribution). In the future, we might want finer control - e.g. a Gameplay op that decides exact resource locations based on our own rules. Civ7's scripts hint at this with functions like ResourceBuilder.setResourceType(...) used in certain contexts [72]. In Phase B, we could introduce new adapter methods (e.g. EngineAdapter.setResourceAt(x,y)) and Gameplay planning ops to place resources explicitly. This would allow mod authors to override or custom-tailor resource distribution. For now, **this is not needed** - Phase A sticks with the engine's generation routine [73] [74].
- **Conditional Resource Post-Processing:** Some map scripts adjust resources based on map type (for example, the _island replacement_ logic that swaps out certain resources on island maps using replaceIslandResources in Civ7 scripts) [75]. Phase B could expose this as a mod-editable rule (perhaps an overlay or config-driven rule in Gameplay domain) instead of being hard-coded in the engine. That would require new APIs or at least new logic in our pipeline. In Phase A, we rely on the built-in behavior (since calling generateResources on an "islands" map automatically triggers that internal logic) [76] [77]. Later, we might externalize it if needed.
- **Mapgen-Time City/District Adjustments:** There is evidence that Civ7's map generation can manipulate city data - for instance, removing or placing _Rural Districts_ (city outposts) as part of the island resource replacement routine [78] [79]. Our current mod doesn't use this at all (and the adapter doesn't wrap an explicit "place district" function for mapgen). In a future phase, the Gameplay domain might include scenarios where cities or districts are pre-placed or adjusted for gameplay reasons (imagine pre-set city-states, or scenario maps with existing cities). We would then consider adding an adapter method or logic to leverage MapCities APIs. **For now, this is out of scope** - Gameplay v1 will not deal with any city or district placement at generation time [80], aside from the standard start position placement. We note it as a possible lever for the future.
- **Plot Effects and Other Board Modifiers:** Civ7 allows adding permanent plot effects (like the permanent snow effect that reduces movement) during map generation [81]. Currently, these are applied in physics scripts (e.g. the snow-generator.js script calls MapPlotEffects.addPlotEffect(...) for tiles above a certain latitude) [82]. In a future Gameplay expansion, we might want to control such effects - for example, a gameplay script that says "all tiles in this region get a custom effect". That would require exposing plot effect placement via the adapter. Phase A does not require this; we consider it a **nice-to-have later** (any needed plot effects from base game are already applied by the engine's own scripts that we trigger) [83].
- **Exposure of Scoring/Tuning Internals:** Gameplay domain might later expose some of the internal logic behind start position scoring or resource distribution for modders to tweak (for instance, weights for start bias scoring, which currently are just data-driven via XML, or threshold values for what counts as a "large landmass" for homelands). At present, we treat these as black-box behaviors - e.g. **start position scoring** is entirely handled inside the engine's assignStartPositions and related calls [84]. Phase B could consider providing more levers if there's demand, but any such move would have to be carefully designed and likely require engine support or at least deeper integration. For now, we log it as **out-of-scope** for the initial refactor [85].

In summary, Phase B would be about **graduating Gameplay from an orchestrator to an author** of map content. It would entail expanding the adapter and domain to cover lower-level "primitives" (individual placements, rule overrides) that Phase A avoids. By deferring these, we ensure the **Phase A Gameplay domain ("Gameplay v1") can be delivered with minimal risk and parity with existing functionality** [69]. We explicitly triaged these future ideas and concluded none are blocking for the initial refactor [68] - the current high-level engine calls suffice to do what Civ7 does. However, we maintain a **backlog of these real engine levers** (as evidenced by Civ7's scripts) so that once Gameplay domain is stable, we have a roadmap of enhancements to consider [69]. This phased approach prevents scope creep now, while keeping us aware of what's possible later.

## Engine Integration and Adapter Boundary

The **EngineAdapter** remains the sole gateway for the Gameplay domain to effect changes in the actual game world [70]. One of the strengths of the existing system is that we already have an adapter interface exposing the Civ7 map generation script APIs [86]. The Gameplay domain refactor will continue to use this adapter boundary without breaking it.

**No Direct Script Imports:**

Gameplay steps will **not import or execute Civ7's .js scripts directly** [87]. Instead, when gameplay logic needs to, say, place resources or assign starts, it will call an EngineAdapter method (which under the hood invokes the Civ7 engine's implementation). This keeps a clean separation between our mod's logic and the game's internal code - we request actions through a defined API rather than meddling with the engine's internals. This is an important guardrail to maintain integrity: if the engine changes its script implementations, as long as the adapter contract stays consistent, our domain logic doesn't have to change. It also means all such interactions are centralized in the adapter, which is easier to update or stub for testing.

**Adapter Coverage:**

As detailed earlier, the adapter covers all **major gameplay mapgen functions**: adding natural wonders, generating resources, discoveries, start positions, etc. [88] [59]. An audit confirmed that for each key concern in Civ7's mapgen, there is a corresponding adapter method and that our current mod calls them at least once in the placement apply step [89] [90]. We do not anticipate needing any new adapter functions for the Phase A refactor - **Gameplay v1 can be implemented entirely with existing EngineAdapter capabilities** [68] [69]. For example, even the new Landmass Region labeling will be done via either an existing or minimally extended adapter call (setLandmassRegionId) since the engine likely has a way to tag continents (and if not, we will add an adapter method for it as a one-off, which is a contained change) [7] [91]. Our triage of "gaps" found that none were truly blocking for v1; they were all enhancements for later [92] [69].

**Apply-Boundary Execution:**

By design, all calls that mutate the actual game state (tiles, resources, etc.) happen in the **placement stage's apply step**, right at the end of the generation pipeline [42] [44]. This stage is essentially the **bridge between our generated data and the live game map**. We will preserve this pattern: the Gameplay domain will gather decisions and data throughout earlier stages (overlays, plans, labels), and then one final step commits those to the game via adapter calls. This ensures a single synchronization point with the engine - making it easier to reason about and to potentially roll back or replay if needed. It also aligns with Civ7's approach: their map scripts accumulate context (like which plots are suitable for starts, where resources could go) and then perform the placements in a sequence; our mod does similarly, but distributed across domain stages and culminating in the adapter calls.

In short, the **engine integration strategy remains stable**: the adapter is our friend. Gameplay domain refactor will use it exactly as before, just from a new unified domain. **No physics or engine shortcuts** are introduced in Phase A - everything stays behind the proper abstraction boundaries.

## Overlay Contract Stability and Usage

Because overlays are so central to Gameplay's role, we must emphasize the importance of the **overlay contract** that Gameplay provides. Overlays (like motifs.hotspots, motifs.rifts, corridors, etc.) are effectively a **public API of the Gameplay domain** for other domains. They need well-defined schema (keys, data structures) and semantic meaning. In the refactor, **Gameplay will explicitly own the overlay definitions** - cleaning up and formally documenting what each overlay represents and when it's produced [21].

We will ensure that **existing overlay consumers see no disruption** in Phase A [40]. The refactor will preserve all currently produced overlay types and their key names. For example, Morphology's steps expect motifs.margins to mark plate boundaries for coastal roughness [38] - Gameplay must continue to produce that overlay in narrative-pre or mid as it does today. Ecology expects a corridors overlay to avoid placing certain features in chokepoints [23] - again, preserved. The only changes might be internal (e.g. if we decide to compute a certain overlay slightly differently or in a different narrative sub-stage, we'll do so behind the scenes without changing its external interface). Any change to overlay content or structure would require simultaneously updating all consumers, which we consider out of scope for Phase A. Thus, **stability is a guardrail** - refactor the code, but keep the contract.

Another aspect is acknowledging that **overlays span multiple stages and domains**. They are "cross-cutting" data. We've already noted that some physics stages produce overlays (like HOTSPOTS in Morphology's island step) [25]. Our stance is pragmatic: **Gameplay is the home of overlays, but not a monopoly producer** [24]. For Phase A, we will not attempt to move, say, the island HOTSPOTS generation into a gameplay stage - that would involve reorganizing how islands are made. Instead, we accept this as a valid exception where a physics step contributes to a gameplay-defined overlay. Documentation (and possibly code comments/annotations) will mark such cases clearly so that the ownership is understood. The key point is that the _definition_ and _usage_ of the overlay are managed by Gameplay (we know what "hotspot" means and who should read it), even if the actual data is first produced in a physics context. Over time, we might decide to shift more overlay creation into gameplay stages, but only if it can be done without disrupting the simulation logic.

Finally, overlays will remain **append-only** during generation - each narrative stage appends new overlay snapshots corresponding to that phase of world generation [35] [93]. This approach (already in use) means overlays accumulate layers of story (e.g. corridors added before rivers vs after rivers are separate entries in the overlay set). The refactored Gameplay domain will preserve this pattern, as it allows granular debugging and ensures that late stages don't overwrite early narrative information. Each overlay entry is tagged by its stage of origin. Consumers either use the latest or combine them as needed. We mention this to highlight that **Gameplay's stage behavior is iterative and stateful with respect to overlays** - and the refactor will keep that behavior unless a need arises to change it.

## Case Study: Landmass Region ID (Homelands vs Distant Lands)

One specific gameplay concept that underscores the Gameplay domain's responsibilities is the **Landmass Region ID projection**. Civ7 introduces the idea of classifying landmasses into two categories: essentially "home continents" vs "distant continents" for gameplay purposes (tied to its Ages mechanic and how resources or starting positions are handled). In our refactor, **Gameplay will own the generation of Landmass Region IDs**, as it is a purely gameplay-facing categorization built on top of physical landmass data [6].

**How it works:**

After Morphology provides the list of landmasses (continents, islands) and their sizes, Gameplay will run a small routine (likely during the Placement stage's preparation) to decide which landmass is the primary "homeland" and which ones are secondary "distant lands" [7]. Typically this might mark the largest landmass (or the one containing the most start positions) as the "Homeland" (with a specific constant ID), and all others as "Distant Lands" (with a different ID) [91]. The exact criteria can be a policy input (e.g. always largest = homeland, or something configurable). The Gameplay domain then calls an **EngineAdapter method** to set these labels in the engine (for example, adapter.setLandmassRegionId(landmassId, regionType) for each landmass) [7]. This must happen **before placing resources and starts**, because the engine's routines for resource distribution and start bias may query these region IDs [94] [95]. In the base game scripts, there might be a point where they assign these IDs just before resource generation - our pipeline will mirror that timing (the Placement stage is ideal, right before generateResources and assignStartPositions) [96] [97].

**Why Gameplay and not Morphology:**

The landmass identification (size, shape, connectivity) is a geophysical result (Morphology domain finds continents). But deciding which continent is "primary" vs "secondary" is a **gameplay interpretation** on top of that. It doesn't affect terrain or climate; it affects how the game treats those continents for starting positions and perhaps resource balance. That clearly falls under Gameplay's purview: it's about game rules and narrative ("your civ started in the Old World vs the New World"), not about physical simulation. Therefore, we isolate this logic in Gameplay and explicitly forbid Morphology from embedding any such concept into its outputs [98] [99]. Morphology will output landmasses neutrally (just geometry); Gameplay will consume that and produce a mapping of landmass -> region category.

In implementation, this will likely be a small new step in the placement stage or integrated into the existing placement apply step. The **ownership rationale** is clear: it's player-facing and must run at the apply boundary using engine labels [6] [100]. We have added guardrails to ensure we do it correctly (e.g. use engine-provided constants for region IDs rather than inventing our own, ensure no upstream code depends on region IDs before we set them) [91] [101]. This case study exemplifies the kind of responsibility Gameplay takes on in the refactor: bridging a physics result (landmass list) to a gameplay outcome (homeland labels) at the appropriate point in the pipeline [102]. It's a new piece of code we'll introduce as part of the refactor to maintain Civ7 feature parity, and it underscores the theme: **Gameplay domain adds meaning and final tweaks to the world, based on (but separate from) the physical world data**.

## Conclusion

The refactored Gameplay domain will serve as the unifying layer that ties together Civ7's map generation from a gameplay perspective. In **Phase A**, it does so in an "overlay-only" manner: publishing narrative overlays and invoking the game's own placement routines to realize civ placement and content distribution [1] [103]. This approach consolidates all mapgen-time gameplay logic (starts, resources, wonders, narrative context) under one conceptual roof, clarifying boundaries with the simulation domains and ensuring the mod's architecture reflects the actual game's capabilities. The **responsibilities** of Gameplay are clearly defined - board setup, content placement, story overlays - and its **boundaries** are set such that it does not interfere with physics simulation, instead providing high-level directives and context [3] [19].

The **interaction patterns** (stage braid, overlays consumption) remain consistent with the current system to minimize disruption, but now we can point to each narrative or placement stage and say "Gameplay owns that" with confidence [26]. By integrating prior spike research, code inventories, and adapter audits, this unified design ensures that we're grounded in evidence (what Civ7 actually does) [16] [88] and in sync with the existing codebase's wiring [104] [105].

Crucially, this sets the stage for future expansion (Phase B) without overcommitting early. We have a clear list of potential gameplay extensions - direct resource placement, finer rule control, etc. - that we acknowledge but **deliberately defer** [106] [80]. Thus, the Gameplay domain refactor gives us an immediate architectural win (cleaner domain separation, unified logic, easier maintainability) while preserving the option to enrich gameplay shaping down the line. The result will be a more coherent map generation system where one domain - Gameplay - cleanly handles the _game-side logic_ of world creation, in harmony with the physical simulation domains, delivering a map that is not just a realistic world, but also a well-balanced, story-rich board for Civilization gameplay.

**Sources:**

The design described here synthesizes insights and evidence from multiple internal documents and code references, including Civ7 map script analysis [16] [107], engine adapter inventories [88] [59], and draft planning specs [19] [26], to serve as the definitive reference for the Gameplay domain's target architecture.