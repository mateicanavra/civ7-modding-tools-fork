# Gameplay Node Context Packet (Coordination Artifact)

_As part of the Gameplay domain refactor, certain data structures act as **coordination artifacts** – they bundle or carry information through the pipeline to ensure the Gameplay domain can perform its duties at the right time. This document describes the key context “packets” used by Gameplay: the global overlays container and the placement inputs/outputs bundle. Understanding these artifacts is crucial for coordinating gameplay logic both within the pipeline and at the engine boundary._

## Overlays Container Artifact

**Definition:** The **overlays container** is a single artifact (often referenced simply as `overlays`) that holds all **narrative overlay data** produced during map generation. Rather than having separate artifacts for each overlay type, the system uses one container object with multiple typed collections inside (for example: `overlays.hotspots`, `overlays.rifts`, `overlays.corridors`, `overlays.swatches`, etc.). Each collection contains overlay entries of that type (e.g. a list of corridor objects, a list of hotspot markers).

**Lifecycle:** The overlays container is **initialized early** in the pipeline (at the start of the first Gameplay stage, which is typically `narrative-pre`). Throughout the various narrative stages, different steps **append** data to this container:
- In the first narrative stage(s), Gameplay generates geological/story overlays such as tectonic **Hotspots** (e.g. marking island chains or plume centers) and **Rifts** (e.g. divergent plate boundaries or great rift valleys). These are added as `overlays.hotspots`, `overlays.rifts` entries.
- Additional narrative steps add overlays like **Margins** (indicating plate boundaries or coastal margins), **Orogeny** markers (identifying major mountain formation regions), and **Corridors** (paths of low elevation or passes through mountains). For example, a step might compute “mountain corridors” after terrain generation and append them to `overlays.corridors`.
- A special narrative stage often produces **Swatches** – overlay data capturing regional climate zones or biome groupings (for instance, marking an area as an arid belt or a fertile crescent). These would be stored in `overlays.swatches`.
- After rivers are generated by Hydrology, a late narrative step may adjust or add to corridors (e.g. carving river valleys as corridors or updating floodplain-related overlays). These updates also go into the same `overlays.corridors` collection (appending new entries or marking completed ones).

By the end of the narrative sequence, the `overlays` artifact contains a rich “story of the world” – numerous overlays that describe how the world was formed and highlight features of gameplay interest. All overlays remain available in this container for any subsequent processing.

**Consumption:** Downstream steps in various domains can **read from the overlays container** to bias their logic. For example:
- A Morphology step might consult `overlays.margins` to decide where to create cliff-like coastlines (treating plate margins as likely spots for rugged coasts).
- Hydrology or Climate steps might look at `overlays.hotspots` and `overlays.rifts` to adjust rainfall or temperature in those areas (simulating volcanic hotspot climate effects or rift valley aridity).
- Ecology steps might use overlays like `overlays.corridors` (low terrain corridors) or `overlays.swatches` (climate zones) when assigning biomes, to ensure consistency with the world’s “story”.
- The Gameplay placement logic itself does not typically consume overlays as inputs (since Gameplay is the producer of overlays), but it might reference its own overlays in some planning heuristics if needed (for instance, avoiding start positions too close to a certain motif).

It is important to note that in the **refactored design, overlays are a Gameplay-owned contract**. They exist to influence other domains in a controlled way, but they are **not** an input requirement for Gameplay. We maintain the overlays primarily to preserve existing behaviors in other domains (Phase A compatibility). Over time, if we decide a given overlay’s effect is better handled by direct domain interactions, we may phase it out. For Phase A, however, the overlays container and its data are kept **stable** so that legacy consumption patterns (e.g. Ecology reading corridors) continue to work without change.

**Implementation details:**
- In the current implementation, overlays are threaded through the pipeline via the artifact system (e.g. an artifact type `Artifact.Overlays` that contains the container). Each narrative step declares that it **provides** (publishes) this artifact or updates it. This gating ensures that no other step reads overlays before they are produced.
- The container is typically a structured object with arrays or maps for each overlay type. The refactor will ensure it remains a single well-defined structure (likely defined in a schema for the Gameplay domain).
- **Append-only pattern:** Narrative steps should use an append approach – e.g. push new overlay entries – rather than wholesale replacing the container or its sublists. This avoids inadvertently removing overlays from earlier steps. Minor mutations (like annotating an existing overlay entry or merging similar ones) are allowed if necessary, but the default pattern is that each step contributes its piece of the story cumulatively.
- Overlays are **not final game entities** – they don’t directly show up on the map for the player, but they indirectly affect how the map is generated. They are a coordination tool: an in-memory context packet that multiple generation steps agree upon.

**Future outlook:** The architecture envisions overlays eventually becoming a first-class data channel separate from the generic artifact pipeline. In the current phase, we continue to treat them as an artifact for simplicity, but conceptually they form their own category of data (neither a mutable buffer nor a final map field, but a narrative context). The refactor does **not** remove overlays in Phase A; it clarifies their ownership and usage. In Phase B or beyond, we might integrate some overlay concepts directly into domain models or remove the need for certain overlays by strengthening domain contracts. Any such changes will be approached cautiously to avoid breaking the carefully balanced interactions built on the overlay system.

## Placement Planning Packet (Placement Inputs/Outputs)

While overlays handle the **narrative context**, the **Placement** stage handles the execution of final game setup. In the refactored Gameplay domain, the Placement stage works with a structured **planning packet** that encapsulates all decisions made by Gameplay before handing off to the game engine.

**Placement Inputs artifact:** In the pipeline, the final Gameplay stage (often just called `placement`) is split into two conceptual steps:
1. **Planning step** (sometimes called `derive-placement-inputs` in the current setup): This step gathers all the decisions and data required for final placement.
2. **Apply step** (`placement` apply): This step takes the prepared data and calls the engine to apply it to the actual map.

During the planning step, Gameplay collects information into a **PlacementInputs** artifact. This artifact can be thought of as a **context packet for the placement operation**. It typically includes:
- The finalized list of **start positions** for major civilizations. (E.g. an array of coordinates or cell indices where each civ will start, often with civ assignment or an order that maps to players.)
- Definitions of **advanced start regions** for those civs (if the game supports extended starting areas beyond the initial city tile). This could be represented as radius or set of plot indices around each start position designated as that player’s “start region.”
- The planned list of **natural wonders** to place and their chosen locations (if wonders are not entirely left to engine default, the mod might decide which wonder goes where).
- The planned distribution or adjustments for **resources** (if Gameplay influences resource amounts or placement beyond what the engine’s default generator will do). In Phase A, we mostly rely on the engine’s built-in resource generation, but the planning might include parameters or exclusions (e.g. “don’t allow resource X on island tiles”) and possibly a validation pass to ensure engine output will meet certain conditions.
- Any **discoveries (goody huts)** placement plan, if we don’t leave that entirely to the engine. (Civ7’s script had a separate discovery generator; the mod could either let the engine handle a default distribution or plan them explicitly. If explicit, their target positions would be listed here.)
- **Feature adjustments:** For example, a plan for **floodplains** along rivers. In Civ7, floodplains are a special feature on river-adjacent tiles; the planning step may identify all eligible river segments and mark those in the PlacementInputs so that the apply step can call the engine to add floodplain features on those tiles.
- Any other miscellaneous gameplay placements or labels, such as:
  - Tiles identified for removal/replacement of certain resources (e.g. one-tile islands where a strategic resource should be replaced by a different feature – the plan would note the tile and what to do there).
  - Special tile effects like permanent snow (if the design calls for explicitly placing a “snow” effect on certain polar tiles, the plan might list those tiles).

In essence, **PlacementInputs is a comprehensive package of “what to do” for the final map setup**.

The format of PlacementInputs would be defined by a schema (e.g. a TypeScript interface or JSON schema) to ensure the apply step and any debug logging understands it. For example, it might look conceptually like:
```json
{
  "startPositions": [ { "playerIndex": 0, "cell": 12345 }, … ],
  "advancedStartRegions": [ { "playerIndex": 0, "regionCells": [12345, 12346, …] }, … ],
  "wonders": [ { "wonderType": "WonderX", "cell": 67890 }, … ],
  "resourceExclusions": [ { "resourceType": "Oil", "cell": 55555 }, … ],
  "plannedDiscoveries": [ { "cell": 33333 }, … ],
  "floodplains": [ { "riverEdge": [cellA, cellB] }, … ],
  "...": "..." 
}

(The exact structure will be determined during Phase 2 modeling. The above is illustrative.)

Placement Apply (Engine calls and outputs): The apply step takes the PlacementInputs artifact and executes it. Specifically:

It uses the EngineAdapter to call engine functions like assignStartPositions (feeding in the chosen start locations, which the adapter will pass to the game’s Start Positioner system).

It may call an engine method to set up advanced start regions (if available), or the adapter might internally call StartPositioner.setAdvancedStartRegion for each region if that’s how the engine works.

It invokes generateResources (the engine’s routine to distribute resources) with parameters possibly influenced by our plan (for instance, telling the engine which resource rules to use, or running it after marking certain exclusions).

If the plan includes specific placements (like a certain wonder at a certain location), the apply step might call an adapter method to place that wonder (if the engine API allows individual placement) or ensure the engine’s resource generation results align (some engines treat natural wonders as part of resource generation).

For discoveries, similarly, it would call an adapter method (e.g. something equivalent to MapConstructibles.addDiscovery(...) for each planned hut).

Floodplains might be applied by calling an adapter utility that places a Floodplain feature on all designated river edges.

Any labeled effects (like snow impassable tiles) would use an adapter call such as MapPlotEffects.addPlotEffect(...) with the appropriate parameters.

During the apply step, a PlacementOutputs artifact is often produced. This might contain results or diagnostics, such as:

Confirmation of placed starts (which tile each player got, in case any adjustments happened).

A count or list of resources actually placed by the engine (to compare with expectations or for debugging distribution).

Any warnings or errors (for example, if a planned wonder could not be placed).

This artifact is mostly for verification and debugging; it’s not used by further generation (since this is the end of generation).

Engine Adapter boundary: The placement apply phase is where the Game Engine’s logic intersects with our mod’s generation. The EngineAdapter acts as the gatekeeper:

It provides high-level methods that abstract the engine’s native functions. Our Gameplay apply code should call these adapter methods, not engine APIs directly, to maintain portability.

Part of the refactor is to ensure all needed adapter methods exist and are correctly implemented (see the Engine Levers & Triage appendix for specific calls).

Landmass Region ID labeling: One special case coordination task is the assignment of LandmassRegionId (the “homelands vs distant lands” classification for continents). This doesn’t naturally fit into the resource or start placement plan, since it’s a label on landmasses used by engine logic for both starts and resources. In the interim (pre-refactor), this might be done either just before resource generation or as part of the placement stage. In the refactored design, we consider it a Gameplay responsibility to ensure it’s done at the correct time:

Likely, a small step in the placement sequence will take Morphology’s landmass data, determine which landmass is “primary” vs “secondary” (based on size or map script rules), and call adapter.setLandmassRegionId(...) for each land tile accordingly (marking them as homeland or distant land).

This step should occur before the engine generates resources or assigns starts, because those systems might use the region labels to alter behavior.

We treat this labeling as part of the “apply boundary” work: it’s a projection from physical data (landmass index) to a gameplay label (region id) done via the engine interface. (See the dedicated issue for details.)

In summary, the PlacementInputs/Outputs context packet encapsulates all gameplay decisions made in the pipeline so that the final apply step can be simple and deterministic. By the time we call engine methods, everything (who starts where, what content goes where) has been decided or planned by our mod. The engine then simply executes those decisions (within its rules) to produce the final map.

Summary

The overlays container and placement plan packet are the two primary context structures the Gameplay domain manages:

The overlays container carries forward contextual narrative data through the generation process for cross-domain coordination.

The placement plan packet consolidates final gameplay setup decisions for hand-off to the game engine.

Maintaining a clear structure for these artifacts ensures that the Gameplay domain’s influence on world generation is organized and transparent. The refactored domain will explicitly define and document these artifacts (with schemas and JSDoc), making it clear what data is exchanged at each boundary. This not only aids in implementation but also in testing (we can inspect the overlays or placement plan to verify correctness before applying) and future maintenance (other developers can see exactly what Gameplay produces and consumes).

By treating these as first-class artifacts, we uphold the contract-first architecture: other systems see Gameplay’s outputs through well-defined containers rather than implicit side effects. This completes the separation of concerns – Gameplay provides guidance and final actions, and physics domains provide the world canvas, all via clear data contracts.