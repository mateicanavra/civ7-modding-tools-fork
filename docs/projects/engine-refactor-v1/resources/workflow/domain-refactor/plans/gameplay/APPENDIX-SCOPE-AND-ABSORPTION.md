# Appendix: Gameplay Domain Scope and Absorption Plan

*This appendix delineates the **scope** of the Gameplay domain in Civ7 map generation and details how existing logic from the legacy Narrative and Placement domains will be **absorbed or reallocated** in the refactor. It clarifies what the Gameplay domain will own, what remains with other domains, and how responsibilities or data flows will change (or stay the same) as we consolidate gameplay logic under one roof.*

## Gameplay Domain Responsibilities (Scope)

**What Gameplay *owns* in map generation:**

- **Board Setup (Start Positions and Regions):** Gameplay is responsible for placing all player start positions for major civilizations. This includes using leader/civilization start bias rules (preferences for certain terrain, features, etc.) to score potential locations and selecting start plots that satisfy those biases and spacing requirements. Additionally, Gameplay defines **Advanced Start Regions** for each civ – the region around the start plot considered that player’s “starting territory.” (In Civ7, these regions are used to ensure players start on the same landmass or to set aside territory; Gameplay will determine and label these regions via engine calls).
- **Landmass Identification for Starts:** Gameplay will label landmasses with region IDs to distinguish **“Homelands” vs “Distant Lands.”** This concept (new to Civ7) ensures that one continent is the primary spawn area and others are reserved for later exploration. The Gameplay domain computes this classification (typically marking the largest continent or specific continents as homelands) and communicates it to the engine (so that starts and resources abide by it). *(See the LandmassRegionId issue for detailed handling.)*
- **Content Placement (Resources, Wonders, Discoveries):** Gameplay governs the placement of all gameplay-relevant content on the map:
  - **Resources:** It oversees strategic/luxury resource distribution. In Phase A, this means invoking the engine’s resource generation and possibly influencing it via configuration or minor adjustments (ensuring compliance with map-type behaviors, biases like “no oil on one-tile islands,” etc.). Gameplay does not generate terrain resources from scratch, but it ensures the final resource layout meets game design constraints.
  - **Natural Wonders:** Gameplay selects and places natural wonders. Since wonders are special features with big gameplay impact, the domain will decide which wonders to include (respecting map settings like “how many wonders”) and find valid locations for them, then ask the engine to place them.
  - **Discoveries (Goody Huts):** Gameplay handles the distribution of “discoveries” (the Civ7 equivalent of tribal villages or goody huts). It will ensure they are placed in appropriate areas (not too close to starts, in allowable terrains as defined by game data) via either direct placement or guiding the engine’s placement.
  - **Other Special Features:** If there are gameplay-driven feature placements (like certain bonus features or improvements that are placed during mapgen for scenario reasons, e.g. a “volcano” improvement representing an active volcano feature), Gameplay would own those as well. Essentially, anything that’s not part of the base physical world but is added for gameplay interest falls here.
- **Story Overlays and Motifs:** Gameplay defines and produces **narrative overlays** that give context to the map. It owns the concept and schema of these overlays (e.g., what a “corridor” overlay means, what data each overlay entry holds). Gameplay stages generate these overlays (hotspots, rifts, climate swatches, etc.) as described in the narrative stage inventory. These overlays do not directly change the terrain but serve as signals and narrative flavor that influence other generation logic and potentially AI behavior. Gameplay maintains the overlay contract—ensuring that if an overlay is supposed to exist (like “RIFT” lines), it gets created consistently.
- **Gameplay Labels and Effects:** The domain applies any labels or persistent effects required for gameplay at map start:
  - Region IDs on landmasses (as above).
  - Marking tiles with special effects (e.g., permanent snow tiles that reduce yield or movement).
  - Assigning any scenario-specific tags or points of interest (if the map script calls for marking “special regions” or naming areas, Gameplay would handle that since it’s purely cosmetic/game-affecting and not part of world physics).
- **Final Map Validation (Gameplay perspective):** Gameplay is the last check for gameplay quality of the map. If any adjustments are needed purely for game balance or rules (for example, ensuring each player has at least one resource nearby, or ensuring no start is in an isolated tiny landmass unless intended), those checks and fixes are in Gameplay scope. The domain may include logic to swap a start position last-minute or add a missing resource if it’s critical, rather than leaving such issues to chance.

In summary, **Gameplay owns the “last layer” of worldgen – the layer that makes the map ready to play as a game**. It takes the canvas that physics domains create and populates it with civilizations, resources, and story elements according to game design rules.

**What Gameplay does *not* own:**

- **Core World Simulation:** Gameplay does not generate fundamental terrain, climate, or biome outputs. The creation of continents, mountains, rivers, rainfall, temperature, soil and biome distribution – all that is handled by Foundation, Morphology, Hydrology, and Ecology respectively. Gameplay will use those results (and not override them). For example:
  - Terrain elevation and land/ocean placement is determined by Morphology, not by Gameplay.
  - Climate patterns (rainfall, temperature) come from Hydrology/Climate – Gameplay won’t rewrite climate data.
  - Biomes are assigned by Ecology – Gameplay won’t independently assign biome types.
- **Natural Feature Placement:** The placement of **basic natural features** (forests, jungles, marshes, reefs, etc.) is done by Ecology (as part of biome realization). Gameplay does not intervene in ordinary feature placement, except if a feature is re-categorized as a special content (e.g., natural wonders are essentially features but treated as special, hence Gameplay’s realm). A clear boundary exists: standard features that come inherently from biomes remain with Ecology, whereas “designed” features like wonders or uniquely placed items are Gameplay.
- **Physical Metrics Calculation:** Any metrics that are part of simulation – e.g., calculating drainage basins, computing which rivers are navigable, recalculating fertility – these either happen in physics domains or are built into engine calls. Gameplay might trigger a recalculation (like calling an engine function to compute fertility after placing resources), but it doesn’t itself compute those from scratch. It ensures they happen by invoking the right routine at the right time if needed.
- **Alteration of Physics Outputs:** Gameplay in Phase A will not directly alter things like the heightmap, river network, or biome layout. That means if a gameplay concept would traditionally require changing terrain (say, flattening an area for a scenario), we do not do that in this phase. All physical alterations must either have been accounted for upstream or are foregone. (For example, earlier Civ titles sometimes altered terrain for start biases – in this design we avoid that; we place the civ where the terrain is favorable, we don’t change the terrain to fit the civ.)
- **Turn-by-turn gameplay systems:** Obvious but for completeness: after map generation is done, things like Barbarian placement, City-State placement, etc., which might happen at game start or during gameplay, are outside the scope of mapgen Gameplay domain. We only concern ourselves with the static map setup. (The evidence from Civ7 showed barbarians/city-states were *not* placed in mapgen scripts at all, confirming this separation.)

**Interaction with physics domains:**

Gameplay’s influence on other domains is **indirect and controlled**:
- Via overlays: Gameplay provides overlays that physics steps may look at. Importantly, these overlays are suggestions/biases, not commands. If a physics domain (say Ecology) uses a Gameplay overlay (like corridors) to modify its algorithm, that’s by design contract (e.g., “ecology will avoid placing dense forest in a corridor marked by gameplay”). Gameplay doesn’t force it; Ecology chooses to consume that info.
- Via engine inputs: Some gameplay decisions effectively loop back into worldgen by configuring engine behavior. For instance, marking homelands vs distant lands doesn’t change the terrain generation, but it influences how the engine’s resource generator allocates resources (the engine might place fewer resources on distant continents initially). This is a form of influence, but again via defined engine-level rules, not by directly changing data arrays.

If a certain overlay or gameplay concept is fundamentally tied to a physical process (example: an overlay marking “young mountains” which is really just exposing Morphology’s data about mountain age), we treat the **source-of-truth** as the physics domain. In such cases, Gameplay defines the overlay schema, but the physics domain might be the one to calculate and publish it (because it has the data). For example, the **HOTSPOTS** overlay originates from plate tectonics logic in Morphology – rather than Gameplay re-calculating where islands formed, we allow Morphology to emit the hotspots overlay entry (since it “knows” where it created island chains). Gameplay still owns the definition (what a hotspot overlay is), but not necessarily every instance’s generation. This cooperative approach ensures **“truth comes from the source”**.

## Absorption of Legacy Narrative and Placement Code

One of the main tasks in this refactor is to **merge the existing Narrative and Placement domains into the new Gameplay domain**. This involves relocating code, reassigning responsibilities, and in some cases deprecating or splitting functionality. Below is the plan for absorption:

- **Placement domain absorption:** All functionality from the legacy `@mapgen/domain/placement` module will move under Gameplay.
  - The planning operations such as `planStarts`, `planWonders`, `planFloodplains`, etc., become **Gameplay ops**. They will be placed in the Gameplay domain’s ops directory (with appropriate renaming or refactoring to fit the contract-first style). Their schemas (input/output data) will be reviewed and likely formalized as part of Gameplay’s schema.
  - Any placement-specific schemas or types (for example, if there was a `StartPlacementConfig` or similar) will also migrate into Gameplay’s schema definitions.
  - The Placement stage configuration (in the recipe) will now point to Gameplay’s steps. Essentially, instead of a separate “placement” domain, the final stage will be a Gameplay stage. The external behavior (running after ecology, calling engine) remains the same, but internally it’s using Gameplay’s operations.
  - The old Placement module can then be deprecated. We will likely keep it around only as a thin pass-through during transition (or mark it obsolete) until we are confident the Gameplay module fully replaces it.

- **Narrative domain absorption:** The code currently implementing narrative overlays and motifs (likely under a Narrative domain or scattered in mapgen scripts) will be unified under Gameplay:
  - **Overlay definitions and helpers:** If the narrative code has any registry of overlay types or normalization logic (e.g. ensuring an overlay entry has certain fields, merging duplicates), that logic moves into Gameplay. Gameplay will maintain the master list of overlay keys (HOTSPOTS, RIFTS, etc.) and any utility to manipulate the overlays container.
  - **Overlay generation algorithms:** Specific algorithms for generating motifs—tectonic hotspot finder, rift line tracer, mountain corridor finder, climate swatch generator—become Gameplay ops or internal functions. We will decide whether each should be an injectable op or just internal logic within a step; likely, major pieces can be ops for testability (e.g. an op that takes plate data and outputs a list of hotspots).
  - These computations will run in Gameplay-owned stages (the narrative-pre/mid/swatches/post stages now being under Gameplay).
  - **Distinguishing physics vs gameplay parts:** During absorption, we will scrutinize each narrative algorithm:
    - If it’s essentially using physics inputs to create a gameplay-useful annotation (like “mark these lowlands as a corridor for future usage”), it stays in Gameplay.
    - If it’s duplicating a physics calculation or actually affecting physics, we reconsider. For example, the **paleo-rainfall artifact** in narrative was trying to simulate historical climate; this actually changes climate data (a physics concern). Our approach: **do not carry this into Gameplay** as-is. Either:
      - We drop it entirely (if it was a minor flavor that doesn’t impact much).
      - Or we move that concept into Hydrology as part of climate modeling (if it’s deemed important to keep a sense of ancient rain shadows, then Hydrology should simulate that in a physically grounded way).
    - In Phase A, the simplest path is to **disable** such contentious features to preserve the physics/gameplay boundary. (They can be reintroduced properly in Phase B if needed.)
  - After absorbing overlays, the legacy Narrative domain module will be obsolete. Like Placement, we will deprecate it. Any references to it in the code (for example, if other parts of the code import a narrative utility) will be updated to point to Gameplay’s version.

- **Engine Adapter integration:** Both Narrative and Placement code interact with the EngineAdapter (Placement heavily, Narrative perhaps not at all except via overlays influencing engine indirectly). As we absorb these, we ensure the EngineAdapter calls remain accessible:
  - Gameplay will be the new locus from which calls like `EngineAdapter.assignStartPositions` and `EngineAdapter.generateResources` are made. That means our Gameplay steps must import and use the adapter (likely via the context’s dependency injection).
  - If any adapter calls were spread out (for instance, maybe narrative code didn’t use adapter except possibly to log something), that’s fine. But if some needed calls were missing in the legacy flow (for example, perhaps nobody was calling a function to set Landmass IDs before), Gameplay will add those calls in the correct spot.

- **Absorbing data tables and rules:** The legacy code likely relies on some game data (XML/JSON tables for biases, resource distribution rules, etc.). As part of absorption:
  - We will identify what data the placement and narrative logic are using (e.g., reading `GameInfo.StartBiasTerrains` or similar). Gameplay domain should encapsulate that usage cleanly. Possibly via config or via adapter calls to fetch needed constants from the engine.
  - For example, start biases might currently be fetched directly from the game database; in the refactor, we might formalize an interface for that (like passing a structured bias config to the planStarts op).
  - These data-driven aspects remain part of Gameplay’s responsibility (they’re gameplay tuning, not simulation), but we need to ensure accessing them doesn’t break our architecture rules (likely it’s fine to query through an adapter or have them pre-loaded in context).

- **Maintaining overlay contract stability:** As we consolidate, **we will keep the overlay outputs consistent** (at least for Phase A). That means after refactor, the names and structure of overlays produced should match what the rest of the pipeline expects. If Morphology expects an overlay called “RIFT”, Gameplay must still provide “RIFT” overlays. We are free to change *how* they’re generated internally, but not to remove them outright without also updating the consumer. Therefore, part of absorption is ensuring that for each overlay type the old Narrative produced and someone consumed, the new Gameplay produces it in a compatible way (even if we later plan to remove that dependency).

- **Deprecation of legacy domains:** Once Gameplay is implemented:
  - We will remove or archive the `domain/narrative` and `domain/placement` modules. Any code that was in them moves to `domain/gameplay`.
  - The stage definitions will be updated to reference Gameplay. The recipe might still use the stage IDs “narrative-pre” etc. for now (since these might be hardcoded in some configs), but they will be owned by Gameplay and could be renamed in a future cleanup if desired (for example, one could rename “narrative-pre” to “gameplay-story-pre” to make ownership explicit, but this might not be necessary immediately).
  - We ensure no other part of the mod tries to use the old domains. For instance, if Ecology had a conditional like “if Narrative domain exists do X,” that should be cleaned or always true now that Gameplay covers it.

- **Case-by-case decisions:**
  - **Paleo rainfall artifact:** As noted, this is a borderline piece. Decision: it will **not be included in Gameplay Phase A** because it violates the no-physics-mutation rule. We will likely remove it outright. If maintaining that flavor is desired, we would plan it as an enhancement within Hydrology (perhaps as an additional climate variation step) in a separate effort.
  - **Island resource replacement:** This is clearly gameplay-related (ensuring certain resources don’t spawn on tiny islands for balance reasons). The official solution was a bit hacky (removing and placing districts). We have to decide how to handle it:
    - We can implement a simpler rule in Gameplay: after resource generation, check one-tile islands; if a strategic resource spawned on such a tiny island, remove it. (Whether we then place something is optional; Civ7 did a “rural district” as a flavor replacement, but we might skip that if it has no effect on gameplay).
    - This logic will be absorbed as a Gameplay check in the placement phase. Implementation might wait until Phase 3 when we wire engine calls (because we need a way to remove a resource and possibly place an improvement).
    - For Phase A parity, we’ll aim to include it if feasible, but it might be marked as a stretch goal if adapter support is lacking. (We can at least plan for it.)
  - **Start bias application:** Currently, the placement code uses start biases defined in data. We will ensure Gameplay continues to honor those biases. That likely means keeping the logic (score starts by bias categories) as-is but maybe refactoring it for clarity. It’s an absorption of algorithm, not a relocation to physics.
  - **No new mechanics in Phase A:** We will not introduce, for example, a new type of overlay or a new placement rule that wasn’t in the original game’s logic. Our aim is to match Civ7’s known mechanics. Phase B can explore new gameplay mechanics (like user-defined resource distributions or terraforming during mapgen) but those are out of scope now.

## Physics Domain Boundaries After Absorption

After Gameplay absorbs narrative and placement:
- The **Narrative/Playability layer** in the architecture becomes synonymous with Gameplay domain. The architecture documentation will be updated to reflect that “Narrative” is not a separate domain but part of Gameplay’s function. However, the pipeline stages may still be called narrative-* for now; that’s just a naming convention.
- **Morphology/Hydrology/Ecology** will treat Gameplay as any other domain for data exchange:
  - Morphology might publish an overlay (like hotspots) which is conceptually defined by Gameplay — this is acceptable and will be coordinated. (Morphology will effectively be writing into the Gameplay-owned overlays container via the artifact contract.)
  - Hydrology and Ecology will consume overlays from Gameplay as before, but now knowing that those overlays are maintained by Gameplay.
  - Ecology and Gameplay also share one more boundary: **feature placement ownership.** It has been decided previously (see architecture docs) that Ecology handles base feature placement (woods, etc.) and Gameplay handles special ones (wonders, etc.). We will keep this boundary. If any confusion arises (e.g., “who places Floodplains?” – in Civ7, floodplains are a special feature but placed via mapgen script, so we treat it as Gameplay’s job in placement stage).
  - We will ensure that after refactor, **no physics domain code tries to modify or override a gameplay decision**. For instance, Ecology should not randomly remove a resource placed by Gameplay, nor should Hydrology alter start positions. If such things existed (unlikely), they must be removed or flagged.

## Future Extensions (Phase B outlook)

While not in scope for the current refactor, it’s worth noting what **Phase B (post-refactor enhancements)** could allow, to ensure Phase A design doesn’t preclude them:
- In the future, the Gameplay domain might gain the ability to **directly influence terrain or resource placement** beyond the vanilla engine capabilities. For example, Phase B could introduce new adapter methods like `EngineAdapter.setResourceAt(x, y, type)` to explicitly place or move resources. This would let modders or advanced scripts override the engine’s resource distribution with custom logic. Phase A defers this – we rely on `generateResources` – but we design Phase A with the understanding that we might plug in custom resource placement logic later. That means keeping the planning structure flexible (so that if in future we skip `generateResources` and instead use our own algorithm, we can do that without redesigning everything).
- Another Phase B idea could be allowing Gameplay to request minor terrain modifications via the engine (for instance, carving a canal or changing one tile’s terrain type to accommodate a script scenario). Currently, that’s off-limits for separation reasons, but if the game engine exposes safe APIs for it, Gameplay could be extended to use them in a controlled manner. We mention this only to ensure that Phase A code is organized in a way that adding such features later is straightforward (e.g., having a clear spot in the pipeline where one could insert a “Gameplay terrain adjustment” step if ever allowed).
- More **dynamic overlays or emergent narrative** could also be Phase B – like generating entirely new motif types or influencing AI starting tech based on map narrative. Phase A sets the stage by cleaning up and unifying logic, which in turn will make such extensions easier to implement when the time comes.

For now, Phase A’s absorption plan is strictly about consolidating what exists and ensuring a clean separation of concerns. The result will be a single Gameplay domain that clearly **interfaces with physics domains on one side and the game engine on the other**, without muddled responsibilities.

## Conclusion

After absorption:
- The Gameplay domain will be the authoritative owner of all map-generation logic that gives the map its “playable” setup. Legacy distinctions between narrative (story) and placement (mechanics) dissolve, since both serve the same goal of shaping the generated map for gameplay.
- Other domains will have well-defined contracts with Gameplay: they either provide inputs to it or consume outputs from it, but do not share overlapping responsibilities.
- The codebase will be easier to maintain: one place to look for anything related to starts or resources (Gameplay), one container for overlays, and one unified approach to adding new gameplay elements to generation.
- Removing the legacy cruft (like direct climate hacks) will also eliminate potential bugs and unpredictability, yielding a cleaner simulation vs. gameplay delineation.

This scope and absorption plan ensures that by the end of Phase A, we have **not lost any functionality** from Civ7’s map generation (all the same levers are present), but we have gained a much clearer architecture. Gameplay will truly function as the final layer on the world, adding meaning without breaking the world’s underlying simulation integrity.
