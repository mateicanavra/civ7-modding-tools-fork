# Hydrology Domain (Phase 0.5 Greenfield Design)

Hydrology in the Civ7 map generation pipeline encompasses all climate and water systems on the planet. It is an umbrella domain comprising four interrelated subdomains: Oceanography, Climatology, Cryosphere, and Surface Hydrology. Together, these model the planet’s oceans and currents, atmospheric climate patterns, ice and snow dynamics, and surface water flow. Hydrology sits downstream of Morphology (terrain formation) and feeds into Ecology, Narrative, and Placement domains. In this greenfield model, we rebuild Hydrology from first principles of Earth physics, emphasizing causal realism (e.g. climate driven by heat and moisture transport, rivers following terrain) while respecting practical constraints (Voronoi mesh resolution, limited simulation passes). No legacy simplifications (e.g. static latitude-banded climate) are assumed sacred – instead, climate and hydrology emerge from simulated processes. Parameter levers (axial tilt, sea level, etc.) are provided to tune outcomes for gameplay. Below we detail each subdomain’s responsibilities, their staging and causal relationships, required inputs (current vs ideal), outputs for downstream consumers (and needed downstream changes), and the overall causality spine of Hydrology. We conclude with Lookback 0.5 notes on assumptions and areas to validate in Phase 1.

## Subdomains and Causal Structure

Hydrology/Climate domain is subdivided into four focused subdomains, each handling a slice of the overall climate-water system in a logical order. The internal staging is designed so that outputs of earlier subdomains feed into later ones, mirroring real-world causality:

- Oceanography – Simulate oceanic conditions and currents. (Runs first within Hydrology.)
- Climatology – Simulate atmospheric circulation, temperature, and precipitation. (Runs after Oceanography, using its outputs.)
- Cryosphere – Model ice and snow based on climate results, with feedback to climate (albedo, sea level). (Runs after Climatology, minor feedback loop to climate.)
- Surface Hydrology – Simulate surface water routing: rivers, lakes, wetlands, and watersheds. (Runs last, using outputs from morphology, climatology, and cryosphere.)

Each subdomain’s boundary and responsibilities are described below, along with how they interact:

### Oceanography (Ocean Climate Systems)

**Responsibilities:** Oceanography models the planet’s oceans as the primary heat engine regulating climate. It covers sea surface temperature (SST), ocean currents, and related phenomena (e.g. warm/cold currents, upwellings, sea ice formation in polar waters). This subdomain ensures that marine factors like the Gulf Stream effect (warm currents warming higher latitudes) and cold currents cooling subtropics are represented, providing a realistic basis for coastal climates. In prior Civ titles oceans were static “blue zones,” but here we treat them as active climate drivers.

**Staging & Causality:** Oceanography executes after Morphology (so continental layouts and ocean basins are known) and in tandem with Climatology. In an ideal loop, a first pass of basic atmospheric winds informs ocean currents, which then feed back into refined climate patterns. However, to keep things performant, we can either run a single-pass approximation (apply known wind patterns to oceans and assume equilibrium) or a minimal two-pass sequence (basic climate → ocean → adjust climate). Oceanography thus provides initial conditions for atmosphere: SST maps and moisture sources. It also detects connected water bodies (ocean basins vs inland seas) and could classify depth or upwell zones if needed.

**Key Processes:**
- **Basin Identification:** Determine distinct ocean basins and large lakes via flood-fill on the land/ocean mask. This informs current loop patterns (gyres contained by continents).
- **Surface Currents (Gyres):** Compute prevailing surface current vectors using global wind stress and Coriolis effect. Major subtropical gyres rotate clockwise in the northern hemisphere and counter-clockwise in the southern, carrying warm water poleward on the west side of oceans and cold water equatorward on the east side. Continental coastlines deflect currents (currents follow coastlines; e.g. simulated by adding a vector component tangent to land boundaries). Rather than solving fluid dynamics, we use a procedural vector field approach: place notional gyre centers in each basin and generate a rotational flow field, combined with wind-driven drift. This yields a coarse but plausible current map without heavy simulation.
- **Thermohaline Circulation:** Optionally, model deep ocean currents in a simplified way. In reality, cold, salty water sinks at poles and drives a global conveyor belt. For gameplay, a detailed 3D ocean model is too costly, but we can approximate by ensuring some heat transport to polar oceans and possibly influencing where sea ice forms.
- **Temperature Advection:** Use the current vectors to transport heat (SST) across the ocean graph. We start with an initial SST distribution (e.g. based on latitude and insolation – equator oceans warm, polar oceans cold) then advect temperatures along currents to simulate warm currents heating higher latitudes and cold currents cooling lower latitudes. A simple advection-diffusion on the Voronoi graph spreads heat downstream of currents. The result is an SST field where, for example, western Europe’s coastal SST is higher than same-latitude eastern Canada (mirroring Earth’s Gulf Stream effect).
- **Sea Ice Formation:** In frigid regions, mark ocean cells as sea ice if SST falls below freezing threshold. Sea ice coverage is both an output (affecting navigation and visuals) and an input to climate (high albedo reflecting solar energy). We capture its feedback via the Cryosphere stage.

**Inputs:**
- Oceanography needs the land/ocean mask from Morphology (which defines ocean cells and coastline geometry).
- Optionally it uses bathymetry (water depth) if available – deeper oceans might influence thermohaline flow or resource distribution.
- Current state: a land/ocean map exists (terrain elevation with sea level cut-off).
- Bathymetry is not explicitly modeled today (all ocean treated similarly); ideal input delta: include an ocean depth field or at least shallow vs deep distinction for more nuance (shelf seas, deep ocean).
- It also takes global wind field (from Climatology’s initial step) to drive surface currents.
- If current code lacks an explicit wind data pass, we’ll generate wind internally or assume Earth-like belts.
- Axial rotation direction (usually fixed Eastward) is needed to orient gyre rotation (Coriolis direction) – currently assumed Earth-like, but ideally expose as a parameter if we allow e.g. “reverse world” scenarios.

**Outputs:** Oceanography produces key climate inputs:
- **Sea Surface Temperature (SST) Field:** A temperature value for each water cell. This influences evaporation and air temperature in Climatology. (Downstream, SST could also guide marine life in Ecology or naval movement speed if the game uses current/wind mechanics.)
- **Ocean Current Vectors:** Prevailing current direction and magnitude per ocean cell. This may be used by game mechanics (faster ship movement with/against current, drift of debris, etc.) and by Climatology to know where heat is being carried.
- **Sea Ice Extent:** Flags or a mask for cells with sea ice. This output feeds the Cryosphere subdomain to handle albedo and any gameplay effect (e.g. impassable ice tiles, delineation of polar regions).

The staging relationship is that a preliminary global wind pattern (from Climatology’s first step) is used here to compute currents, then the resulting SST is passed back to Climatology to refine temperature and humidity distribution. In practice, we may implement Oceanography and Climatology in the same stage with alternating steps (wind → currents → climate finalize) to avoid full pipeline iteration.

### Climatology (Atmospheric Climate)

**Responsibilities:** Climatology governs the distribution of heat, air pressure, winds, and precipitation across the world. It ensures biomes are emergent from temperature and rainfall patterns rather than hand-painted noise. The goal is to simulate Earth-like atmospheric behavior: global circulation cells, prevailing winds (trade winds, westerlies, jet streams), precipitation from moisture transport and orographic lift, and seasonal variations. This subdomain provides the climate fields (temperature and moisture) that downstream Ecology and Pedology use to derive biomes, soils, and vegetation.

**Staging & Causality:** Climatology runs after Oceanography and Morphology. It requires input from terrain (elevation, mountain locations) and from ocean (SST and moisture supply). The causal order is: the sun heats the planet unevenly → drives atmospheric circulation → winds carry moisture from oceans over land → terrain causes uplift and rain → results in temperature and rainfall maps. Within Hydrology, Climatology is central: it consumes Oceanography outputs and produces climate outputs used by Cryosphere and Surface Hydrology. There is a minor feedback loop: after initial climate computation, Cryosphere (ice/albedo) may adjust temperatures, and Climatology can be refined accordingly (e.g. a second “climate refine” pass akin to current pipeline’s climate-refine step).

**Key Processes:**
- **Insolation & Base Temperature:** Calculate solar heating based on latitude and axial tilt. At equator, sun is direct (max heat); toward poles, incident energy per area is lower. We explicitly avoid a naive latitude = climate rule, but latitude remains a causal input due to sunlight angle. Using a given axial tilt parameter (default ~23.5° Earth-like), we can compute an annual average insolation per latitude and optionally a seasonal variation amplitude. From this, derive a baseline temperature for each cell: start with sea-level temperature from insolation, then apply altitude lapse rate to cool higher elevations (e.g. ~6.5°C drop per km). The result is an initial temperature field (what climate would be with no horizontal heat transport).
- **Air Pressure & Global Wind Belts:** Establish large-scale pressure zones using the three-cell atmospheric model. Equatorial heating causes rising air (low pressure at surface), subtropics (~30°) have descending air (high pressure), mid-latitudes (~60°) another belt of low, poles high pressure. From these pressure patterns, generate prevailing wind vectors: air flows from high to low pressure and is deflected by Coriolis (rotation). This yields trade winds (blowing east-to-west toward the equator in low latitudes) and westerlies (west-to-east in mid-latitudes) as the primary surface winds. We incorporate jet streams as well: in the upper atmosphere at ~30°–60° boundaries, strong west-to-east jets form, which in our model can be represented by stronger westerly influence in the mid-latitude band. To avoid sharp discontinuities, we blend wind directions gradually across latitudinal bands (e.g. using a smooth interpolation rather than hard latitude cutoffs). These prevailing winds are critical for moisture transport. (They also can be exposed for gameplay – e.g., faster sailing downwind, airborne spreading of events – though that’s optional.)
- **Moisture Advection (Water Transport):** Simulate the movement of water vapor from oceans across the map via the wind field. We employ a discrete advection model on the Voronoi graph (“water bucket” model): each cell has a certain moisture capacity. Ocean cells contribute moisture by evaporation – proportional to SST and possibly wind speed (warmer water and strong winds yield more evaporation). That moisture is then pushed to neighboring cells downwind. Essentially, we iterate over cells following wind directions, moving a parcel of moisture stepwise inland. We conserve mass: moisture that falls as rain (see next step) or is retained in soil (if modeling infiltration) is removed from the moving parcel. This simplified transport captures phenomena like wet windward coasts and progressively drying air as it travels inland. It also enables monsoon-like behavior: e.g. a large landmass heating can reverse pressure gradients seasonally – while we might not simulate full season cycles, we can approximate monsoons by giving tropical land areas extra summer moisture import and then distributing it differently in winter. (In a static generation, we might simply ensure that coastal regions leeward of seasonal winds still get some rain at another time of year, balancing overall climate.)
- **Precipitation Formation:** As moist air moves and rises over terrain, determine where it rains. Two primary mechanisms are modeled: cooling to dew point from uplift (orographic precipitation) and possibly frontal or convective rainfall from instability. Orographic rain is explicit: when a moisture-laden air parcel climbs a slope (a cell higher than its upwind neighbor), it cools adiabatically. We calculate an uplift amount (height difference); if positive, the air loses capacity to hold water. We precipitate a fraction of its moisture proportional to the height gain (and a tunable lift efficiency factor). That precipitated water becomes the cell’s rainfall. The parcel’s remaining moisture is reduced accordingly (this creates dry rain shadows on the leeward side: descending air warms and retains the now-limited moisture, yielding arid zones behind mountains). We also account for baseline precipitation in lowland areas: e.g. the Intertropical Convergence Zone (ITCZ) at the equator, where trade winds meet and air rises even without mountains, causing heavy tropical rainfall. This can be approximated by giving equatorial low-pressure zones an initial rainfall boost or by inserting notional “global ascent” at the ITCZ latitude. Additionally, if using a time-stepping approach for moisture advection, whenever the air’s moisture exceeds a saturation threshold (e.g. due to cooling or just carrying too much over a cool region), we trigger convective rain to shed the excess. The outcome is a rainfall field across all land cells (and possibly ocean cells for completeness, though ocean rain doesn’t directly affect gameplay). We explicitly reject a simplistic latitude->rainfall mapping and instead derive rainfall from the above physics, though it will naturally produce wetter tropics and dry subtropics as an emergent effect of the Hadley cell circulation.

- **Temperature Redistribution:** After accounting for heat transport by winds and ocean, we adjust the temperature field. Ocean adjacency will moderate coastal temperatures (e.g. west coasts in mid-latitudes stay milder if warm currents are present). We can simulate basic heat diffusion by blending temperatures among neighboring cells (particularly along wind paths or ocean-land boundaries). Also, after precipitation, we might adjust local temperatures slightly (e.g. heavy cloud cover could reduce daytime temperatures, but such nuance might be beyond scope). The main output is an air temperature map calibrated to reflect realistic climate zones (e.g. higher latitudes and high altitudes are cold, but areas with warm currents or downwind of deserts might be warmer than latitude alone suggests). Seasonal variation can be captured by providing two temperature values per cell (summer and winter averages) or simply a seasonal range indicator. For example, higher latitudes have a greater seasonal swing in temperature, which could affect biome decisions (deciduous vs evergreen forests, etc.). If needed, this can be compressed into a single “seasonality index” output.

**Inputs:**
- Climatology consumes terrain elevation (from Morphology) – critical for lapse rate temperature adjustment and for computing orographic lift.
- It needs the land/ocean map and SST field (from Oceanography) to know where moisture originates and how much.
- It also relies on latitude or equivalent coordinate (from world geometry) to compute insolation; currently, the engine does provide a latitude per tile, so that is an available input.
- However, if the world is on a true sphere or a non-rectangular projection, we should ensure we have a robust way to get solar input per cell. If not present, the ideal upstream addition would be an explicit latitude/longitude value for each cell or a function to compute it (this is an upstream delta: current generation likely uses map rows as latitude implicitly; we should confirm and formalize this).
- Another input is global climate settings (currently there are CLIMATE_DRIVERS and MOISTURE_ADJUSTMENTS configs in legacy code that allow tuning rainfall bands, etc.). In the new model, those persist as tunable parameters (see Parameterization below) rather than fixed legacy values.
- Finally, Climatology might accept narrative inputs like “directionality” or region tags – for example, a narrative script might designate a certain region to be a desert or lush area for story purposes. Current pipeline: “climate refine” step uses env.directionality and story motifs (rifts, hotspots) as biases. In a pure physical model these are not needed, but we acknowledge that ideally the system would produce plausible climates without narrative, and narrative can then overlay changes if required. So narrative inputs are optional upstream influences that can tweak the outcome (e.g. enforce a mystical eternal storm somewhere) – ideally minimized, but we’ll allow their hooks.

**Outputs:** Climatology yields the core climate data layers for the world:

- **Air Temperature Field:** Each cell’s average temperature (and possibly secondary metrics: e.g. an annual temperature range). This can be normalized or in °C as needed. Downstream, Ecology will use this to distinguish cold vs temperate vs tropical biomes, and Pedology could use it for permafrost or soil type (cold climates yield gelisols, etc.). If currently no explicit temperature field exists (likely legacy used latitude zones for biome placement), this is a new output – a downstream delta is that Ecology must now source climate info from this field instead of assuming latitudes.

- **Precipitation (Rainfall) Field:** Each land cell’s annual rainfall or moisture index. This directly drives biome selection (e.g. deserts vs forests). In the refactored pipeline, we already plan a canonical ClimateField artifact to expose rainfall to consumers. The greenfield model solidifies this: fields.rainfall (or a climate artifact containing it) is authoritative. Downstream, Ecology and Narrative will no longer use any legacy GameplayMap.getRainfall() but rather this field. The rainfall output also feeds Surface Hydrology as the source for river flow (water input to watersheds).

- **Wind Vector Field:** Prevailing wind direction per region (likely a coarse representation). This is somewhat optional, but if we output it, Narrative/Placement could use it for flavor (e.g. place wind-dependent features or show weather patterns). Also, if the game has mechanics like unit movement cost affected by wind (sailing ships, aircraft trajectories), having this in the data could be useful. This was not in previous Civs, so it would be a new output. We note it as a potential artifact (e.g. artifacts.windField) for future use, but downstream impact is minimal unless gameplay explicitly uses it.

- **Climate Overlays (optional):** We may also derive qualitative zones as overlays – e.g. identify a “monsoon region” or a “rain shadow” area as named motifs. These could feed Narrative (for themed storytelling, such as naming a great desert that exists due to a rain shadow). However, these are secondary; the primary outputs remain the numeric fields.

- **Realism Improvements:** By deriving climate from physical principles, we ensure no oversimplified latitude bands are blindly applied – e.g. if a normally temperate latitude has a warm ocean current offshore, our model yields a milder climate there (so perhaps deciduous forest instead of boreal). If a region is in the lee of a tall mountain range, it becomes arid (rain shadow desert) regardless of latitude. Jet streams and seasonal tilts create asymmetries (the model isn’t perfectly symmetric across hemispheres or longitudes as pure latitude bands would be). We purposely allow these deviations when causally justified. Dynamic climate aspects like seasonality are captured in the temperature range output; while we do not simulate month-by-month weather, we ensure the climate data accounts for seasonal extremes (which is important for things like deciduous vs evergreen, monsoon vs dry season crops, etc.). This realistic, dynamic approach will likely produce richer maps (for instance, it can generate a scenario like a fertile inland steppe that has rainy summers and dry winters, versus a coastal Mediterranean climate with wet winters and dry summers – distinctions that a simple model would miss).

### Cryosphere (Ice and Snow Systems)

**Responsibilities:** The Cryosphere subdomain handles all forms of permanent or seasonal ice and snow: glaciers and ice sheets on land, snowpack, sea ice, and their climate feedback effects. It determines where conditions are cold enough for ice to accumulate and persist, creates those ice features, and adjusts climate via albedo (reflectivity) and water storage. Essentially, Cryosphere takes the temperature and precipitation outputs from Climatology and identifies the frozen component of the hydrosphere. This yields outputs like which areas are glaciated or permafrost, and modifies things like local temperature (sunlight reflection) and global sea level if large ice sheets are present (though sea level adjustment likely static in our pipeline phase).

**Staging & Causality:** Cryosphere runs after Climatology’s initial output. It needs the temperature map and precipitation to determine ice/snow. The causal chain: climate produces cold regions → those accumulate snow/ice → ice in turn feeds back by reflecting sun and locking water. We incorporate the major feedback loop (albedo): icy areas stay colder because they reflect solar radiation (reinforcing the cold). In the pipeline, we can implement this by having Cryosphere slightly adjust the temperature field in icy regions and then possibly allow Climatology a minor second-pass adjustment using that (or simply directly adjust the final temperature output). Cryosphere also informs Surface Hydrology (glaciers contribute to river sources, seasonal snowmelt, etc.). However, we do not simulate long-term ice age cycles at runtime – this is a snapshot of a quasi-stable climate state appropriate for game start. So Cryosphere’s outputs are treated as static features of the world.

**Key Processes:**
- **Permanent Ice & Snow Coverage:** Using the temperature and precipitation data, classify cells that would have permanent ice or snow. Criteria: if the average temperature is below freezing most of the year and there is sufficient precipitation, we get glaciers or ice caps. For example, high latitude land (near poles) and high mountains above the snow line. We mark those cells as glacier/ice terrain. In game terms, these might correspond to impassable glacier features on mountains or “snow” terrain in polar regions. We also mark permafrost: areas where soil remains frozen (perhaps where average annual temp < 0°C but not enough snow to form a thick glacier). Permafrost might influence Ecology (tundra biome, limited tree growth, unique resources).
- **Sea Ice:** Using the SST and air temperature, determine which ocean cells freeze over (likely those where SST is at or below the freezing point of saltwater). This overlaps with Oceanography’s sea ice output – we consolidate here. The extent of sea ice can be tuned by a salinity/freezing threshold parameter. Sea ice is output as mentioned, but importantly it contributes to albedo feedback: areas of sea ice reflect sunlight, meaning the local air stays cooler. We handle this by adjusting the temperature of sea-ice cells (and perhaps adjacent cells) downward a bit more to simulate the reduced heat absorption.
- **Albedo Feedback:** For each cell with significant ice/snow cover (land or sea), increase its reflectivity effect. In practice, we can implement a simple feedback: e.g. reduce the solar input or temperature in those cells by a percentage. This could be done by a second insolation step or just post-hoc: e.g. “if cell is glaciated, reduce its temperature an extra X degrees to account for albedo.” That ensures cold regions don’t easily un-freeze without cause, reinforcing polar cold and high mountain chill. Because this is a one-way adjustment (making cold places colder), it won’t destabilize the simulation; it just fine-tunes the extremes.
- **Hydrological Storage & Melt:** Cryosphere also determines how the frozen water feeds into hydrology. Glaciers store precipitation as ice – this water will not immediately flow as rivers. However, in warmer periods (or edges of glaciers), meltwater will contribute to rivers, often seasonally. We won’t simulate seasons explicitly, but we incorporate glacier contributions by, for example, increasing the base flow of rivers that originate in glaciated cells. Also, if we mark certain rivers as glacier-fed, we could classify them differently (they might have more consistent flow in summer, etc.). Another aspect: if a large volume of water is locked in ice (like an ice sheet), it would lower global sea level. We likely treat sea level as fixed (a tunable parameter input to Morphology). So instead of dynamically adjusting sea level here (which would retroactively alter the land mask, out of scope in phase 0.5), we assume the world’s sea level was set accounting for whatever ice volume we have (e.g. if an “Ice Age” scenario is wanted, the world gen could use a lower sea level in Morphology stage). We can note this dependency: if a future feature allows dynamic sea level, Cryosphere could output total ice volume to inform that, but for now sea level is an input parameter rather than an outcome.

**Inputs:**
- Cryosphere needs the Temperature field and Precipitation field from Climatology.
- It may also use terrain elevation (for refining snow line – e.g. even if a mountain is in a not-super-cold latitude, high elevation might put it above snow line).
- It might take seasonality into account – e.g. if a cell’s winter temperature is far below freezing even if annual average is slightly above, it might still maintain a permanent snowpack.
- So having seasonal temperature range helps (if not, we estimate based on latitude that higher latitudes likely have winter snow).
- Currently, the game has simple notions of snow terrain (often latitude-based) and perhaps an “ice” feature at poles. Those are legacy approximations.
- Upstream delta: current systems likely do not provide a dedicated cryosphere input except the climate fields themselves. We may have to derive everything from climate outputs.
- That’s fine – no additional upstream data needed beyond climate.
- If anything, an ideal addition would be global sea level and baseline temperature as tunable context (for instance, an “Ice Age” world preset might come with lower temperatures globally, but that can be done via config rather than upstream domain).

**Outputs:**

- **Glacier/Ice Map:** A map (or list) of land cells that have permanent ice/snow. This could be realized as a tile feature (e.g. an “Ice Sheet” feature on a polar land tile, or a “Glacier” feature on a mountain). Downstream, Ecology/Placement need to know these to avoid placing normal biomes or to spawn special resources (maybe ice yields fresh water or a unique resource). This is largely a new output – currently, glaciers might have been implicitly handled by latitude-based terrain (like Civ might tag top row as “snow terrain”). We’ll output it explicitly based on climate. Ecology will need to read this and classify those tiles as tundra/snow biome accordingly (downstream delta: biome assignment logic updates to use our ice mask). Also, Placement might treat glacier tiles as impassable or candidate for certain wonders.

- **Permafrost & Snowpack Indicator:** Possibly a field indicating soil freeze depth or snow cover fraction. For simplicity, we might mark any cell with annual mean below 0°C as having permafrost. Ecology can use that to differentiate tundra vs taiga, etc. If detailed, we might output two boolean fields: permafrost = true/false, permanent snow cover = true/false. These can be folded into the glacier map (glacier vs just frozen ground).

- **Sea Ice Mask:** As noted, which ocean cells are ice-covered. This is consumed by Placement (e.g. to block naval starting positions or shipping routes at game start if relevant) and possibly by Ecology (if there’s any ecological effect, like polar bears on sea ice – probably not in base game, but just in case). It’s mostly a direct engine field (visual/terrain blocker).

- **Albedo-Adjusted Temperature Field:** If we adjusted temperatures due to ice, the final temperature output to downstream should reflect that (so this might not be a separate artifact, just an updated temperature field from what Climatology initially gave). Downstream domains just see the final temp field. The adjustment process is internal to Hydrology domain.

- **Cryosphere Overlays (optional):** We could create overlays like overlays.iceAgeExtent or similar if Narrative or analytics want to note “this world has X% ice coverage” or identify ancient glacial corridors. But at phase 0.5, likely not needed beyond the raw fields.

Cryosphere essentially refines the climate outputs and produces additional signals for Ecology (which biomes are ice/tundra) and Surface Hydrology (glacier-fed rivers).

### Surface Hydrology (Rivers, Lakes, Wetlands)

**Responsibilities:** Surface Hydrology simulates how water from precipitation moves across the land, forming river networks, lakes, wetlands, and drainage basins. It’s the culmination of the hydrological cycle: given rainfall (and snowmelt), determine where water collects, flows, or gets trapped. This subdomain ensures every river valley and lake on the map is a logical consequence of climate and topography, rather than random placement. It provides essential gameplay features: rivers (for irrigation, city adjacency, navigation if applicable), lakes (freshwater sources and natural barriers), marshes/wetlands (difficult terrain, biodiversity hotspots), and informs soil moisture for agriculture.

**Staging & Causality:** Surface Hydrology runs after Climatology and Cryosphere because it needs the finalized precipitation and meltwater inputs, and obviously after Morphology since it relies on the terrain elevation to route water. The causal sequence here: rain (or melting snow) falls on the terrain → water flows downhill following gravity → accumulates into streams and rivers → possibly stops in basins (forming lakes or wetlands) if it cannot reach the sea. There is generally a one-way flow of data: climate provides water input, morphology provides slopes; hydrology computes flow outputs. Feedback from hydrology back to climate is negligible in our static model (in reality, large lakes can locally affect climate, but we consider that effect too small to simulate at this scale). So this is an “end-of-line” physical process feeding mainly into downstream Ecology and Placement.

**Key Processes:**

- **Drainage Network Setup:** First, prepare the terrain for flow routing. Identify any closed basins (depressions) in the heightfield that would trap water. In a realistic model, many terrain depressions fill with water until they overflow or evaporate – we handle this by a depression filling step. Conceptually, for each local minimum in the heightfield that isn’t at the ocean, raise the water level to the lowest point where it would spill out to a lower area. This gives us an effective surface for water flow where every cell can eventually drain out (if there is enough water to fill basins to that spillover). In implementation, we can compute a filled elevation map where pits are filled to brim. Mark the difference between filled vs original elevation – those differences indicate potential lake depth if water accumulates. This step ensures that our river routing algorithm can find a path to an outlet for each basin (or correctly identify it as endorheic if it truly has no outlet at sea even after filling to rim).

- **Flow Direction & Watersheds:** Using the adjusted elevation (or original with awareness of filled basins), compute the flow direction for each cell – typically the direction of steepest descent (the neighbor with lowest elevation). This yields a directed acyclic graph (since we broke any cycles by filling depressions) of water flow downstream. Each cell now knows where its runoff will go. We can also identify watersheds: group of cells that drain to a common outlet. Notably, if a group drains to an inland low point that doesn’t overflow to ocean, that watershed is endorheic (closed basin). We flag those because they produce salt lakes or inland seas (no outlet). If it drains to a coastal outlet, it’s exorheic (open basin). Watershed identification can be done via union-find or traversal from outlets. It’s useful for downstream domains (Ecology might want to know major river basin extents; Placement might avoid putting two major civs in the same basin for diversity, etc., though that’s speculative).

- **Flow Accumulation (Runoff to Rivers):** Simulate rainfall landing and flowing along the directions. We iterate over cells in topological order (starting from sources down to outlets) to compute accumulated flow. Each cell’s flow = its own rainfall contribution + sum of flow from all upstream cells that drain into it. In other words, water volume accumulates downstream. We likely use a unit for water (not necessarily realistic cubic meters, but a relative index). The rainfall field provides the per-cell source (converted to some flow units; glacier melt can be added here too for cells marked as glaciated). This accumulation naturally forms rivers: wherever accumulated flow exceeds certain thresholds, we consider a river to exist. We can define multiple thresholds to classify stream orders (small streams vs rivers vs major rivers). For example, a tiny creek might form at a low threshold, but we might only render a visible “River” on the map once flow > X (tunable river threshold parameter). Major rivers (for navigation or special naming) might require a very high threshold. The accumulation algorithm is efficient (linear in number of cells given a DAG ordering).

- **River Network and Lakes Formation:** Using the accumulation data and depression info, determine where rivers flow and where lakes form. A river exists along a sequence of edges in the flow direction graph where flow >= threshold. We output these as a graph or list of river segments with flow values. Lakes occur in flat depressions: from the depression filling step, any cell whose filled elevation was higher than original is effectively beneath a water line. Those contiguous cells form a lake. If the filled water reached a spill, then that lake will have an outlet (exorheic lake); if not, it’s an endorheic lake (closed basin). We mark endorheic lakes specially – often these are salt lakes or ephemeral salt flats (gameplay-wise, could be resources or simply scenic). Lakes also form at river deltas potentially (if terrain is very flat at sea level, though that’s more of a shallow wetland delta than a separate lake – those might be handled under wetlands). Additionally, any cell that accumulates extreme water but has almost no slope (e.g. large flat floodplains) might be flagged as wetland (swamp/marsh) instead of a deep lake. Wetlands can be treated as very shallow water tables that don’t form an actual lake surface but result in marshy ground. We can define wetlands as areas with high flow accumulation but low slope and not part of a main river channel. These will be important for Ecology to place marsh terrain.

- **Groundwater & Baseflow (Simplified):** In reality, some water infiltrates into the ground and flows slowly (groundwater), feeding rivers even when rain stops. We simulate this conceptually by smoothing out the flow or giving every river a minimum base flow (so that rivers in dry season don’t disappear completely). For our static map, this may not need explicit simulation, but it informs design: for instance, an endorheic basin might not have a continuous river because water sinks and evaporates instead of forming an outflow – we’d reflect that by only having lakes and intermittent streams there. We might also mark springs if needed (places where groundwater emerges, e.g. an oasis – though likely beyond scope now).

**Inputs:**
- Surface Hydrology depends on Elevation data (the heightfield) for flow directions and Precipitation (rainfall) data for water input. These are absolutely required.
- It also can take glacier/ice info (from Cryosphere) to add meltwater contributions in cold regions.
- Another input is the land/ocean mask & sea level – to identify ocean outlet cells and treat those as base level for drainage. Sea level is effectively already accounted for by Morphology (land/ocean division).
- Currently, in the legacy pipeline, river generation likely uses the heightmap and a rainfall heuristic (possibly uniform or based on some latitude moisture). We already have a ClimateField artifact in progress (rainfall) and a basic riverAdjacency mask output. The current system may not fill depressions (leading to some odd lakes placement logic or predetermined lakes).
- Ideal upstream delta: If Morphology provided a precomputed “flow routing index” or partial river network (from erosion simulation), we would take it in – e.g. the research suggests Morphology might output a paleo-river network. In practice though, we should recompute with the new rainfall, so we treat those legacy hints as obsolete. We rely fully on our computed fields.
- One potential upstream consideration: soil or rock permeability from Morphology (if certain rock types cause more runoff vs infiltration). This could modulate how much water becomes surface flow vs sinks. Currently, no such input exists.
- In a greenfield ideal, we might want a “drainage coefficient” map (from Pedology or Morphology) to know if an area tends to swamp (clay soil) or let water percolate (sandy soil).
- For now, we proceed without that – any necessary tweak can be done via tuning (e.g. globally reduce wetland formation by raising thresholds).

**Outputs:** Surface Hydrology produces several critical outputs for downstream use:

- **River Network Artifact:** A structured representation of all rivers. Ideally, this is more than a binary mask – it should include connectivity and flow magnitude. For example, we can output a list of river segments or a graph (each edge having a flow volume). We will at minimum provide a mask of river presence (for quick lookup which cells/edges have rivers), but also consider classifying river order or size (perhaps an ID or just magnitude value). Downstream, Ecology will use the river data to place riverine biomes (floodplain grasslands, gallery forests), and Placement uses it for city placement rules (typically, cities prefer to be next to fresh water). Also, Narrative/Playability might use the network to place bridges, river names, or quests (e.g. “explore the source of the Nile”). A downstream delta here: currently, consumers only had a boolean “adjacent to river” check from the engine. We’re replacing that with an explicit artifact. Code reading GameplayMap.isAdjacentToRivers will be migrated to use artifact:riverNetwork data. Additionally, with richer data we might improve placement logic (e.g. only large rivers count for some purpose).

- **Lakes List/Mask:** All identified lakes, with attributes like area and whether they are endorheic. We might output this as a mask layer (each cell has a lake ID or a boolean lake flag) and a list of lake objects (with size, maybe average depth). Ecology will use this to place lake biomes (e.g. fish resources, marsh around edges if shallow, etc.). Placement may treat large lakes similar to oceans for naval starts or as natural barriers between players. Endorheic lakes might be tagged specially (they could be salt flats if dry season dries them, etc., but that might be too detailed). In Civ6, lakes were just water tiles not connected to ocean; we ensure to explicitly produce them rather than relying on random noise. Downstream delta: ensure any code or data that distinguished ocean vs lake uses our output (e.g. if engine terrain has a “lake” terrain type, we set it via this data).

- **Wetlands/Marsh Areas:** Regions identified as having very high soil moisture or frequent flooding but not deep enough to count as a lake. Likely output as a mask of marshy tiles or a probability. Ecology is actually responsible for placing features like marshes, but it will do so based on signals. The hydrology model should provide a wetland suitability signal – e.g. for each cell, a value or flag if it’s a wetland candidate. This could be derived from long-term water presence (e.g. water table height relative to surface, or simply low slope + high rainfall conditions). We might incorporate it into the soils or biome suggestion artifact. Downstream, Ecology must update to use this signal when placing wetlands (downstream delta: no more random placement of marsh; use hydrology’s output).

- **Drainage Basins / Watershed Overlay:** Optionally, an overlay delineating major watershed boundaries (especially for large rivers). This might not be needed for core gameplay, but could be useful for Narrative (e.g. defining a “Great Basin” region corresponding to an endorheic basin, or naming major river basins). We can produce it if trivial (it’s basically by grouping river network endpoints). For now, consider it a low-priority output.

- **Freshwater Availability Index:** A summary metric per region/tile indicating water availability for ecosystems and humans. This could combine rainfall and proximity to rivers/lakes. For instance, a tile could get a score for irrigation potential. Pedology would use this in determining soil fertility (e.g. river valleys have higher moisture retaining soils) and Placement might use it to ensure starting locations have adequate water. This index is somewhat abstract; we can derive it by, say, taking rainfall plus a bonus if near a river or lake. If not needed explicitly, we can rely on raw data (ecology can combine rainfall + river adjacency themselves). But since legacy code specifically had moves to use artifacts for climate and rivers to stop direct engine calls, we might embed such combined logic in Ecology. So we can leave “freshwater index” conceptual for now.

All the above outputs will be surfaced through the Hydrology domain’s artifacts or fields. Concretely, we anticipate adding to artifacts.hydrology contract:

- climateField (with rainfall and possibly temperature subfields) – already planned.
- riverNetwork (replacing the old riverAdjacency mask with a richer structure).
- lakeMask (or integrate with terrainField to mark lake tiles).
- Optionally, wetlandMask or include that in an Ecology-facing artifact.
- And in engine-facing final fields, we’ll mark tile terrain types accordingly (e.g. ensure lake tiles become water terrain with no coast, marsh tiles get a marsh feature).

## Upstream Inputs and Greenfield Gaps (Upstream Δ)

For Hydrology to function as described, it requires certain inputs from upstream domains (mainly Foundation and Morphology) and global parameters. Below we list each needed input, noting what is currently available in the pipeline versus what would be ideal in a greenfield scenario:

- **Voronoi Mesh & Cell Graph:** Current: The world is already represented as a Voronoi mesh of region cells (from Foundation). This provides the graph structure for all hydrology calculations (adjacencies, neighbor lists). Ideal: Same – we assume this exists. No gap here. The mesh resolution (number of cells) is a constraint; our model must work with that (e.g. we can’t simulate tiny microclimates smaller than a cell).

- **Terrain Elevation Field:** Current: Morphology outputs a heightmap (elevation per cell). This is available and is used for identifying mountains, slopes, land/sea division, etc. Ideal: We require this as-is. (If anything, higher resolution would help river accuracy, but we stay within the given mesh. In Phase 1 we’ll confirm elevation scale and units; we assume it’s consistent and sufficient.)

- **Land–Ocean Mask:** Current: Implicit in elevation (e.g. sea level threshold). We have it from Morphology (likely a binary land/ocean field). Ideal: Same input, though we might prefer an explicit artifact artifacts.morphology.landMask for clarity. No major gap. Possibly bathymetry is the gap: currently all ocean may be treated equally; ideally, a Bathymetry field (ocean depth) would be upstream. If Morphology or Foundation can provide that (perhaps as part of plate model or by tagging shallow continental shelves), it would enhance Oceanography (thermohaline and coastal resource modeling). This is an upstream delta: Bathymetry is likely not present today, so Hydrology will either assume a default deep ocean or derive a simple proxy (e.g. distance from coast as a rough depth indicator) if needed.

- **Latitude / Solar Geometry:** Current: The engine provides a way to get latitude for a tile (in legacy code, GameplayMap.getPlotLatitude exists). This suggests we do have latitude (probably 0 at equator, 90 at poles, for map tiles). However, Civ maps are often cylindrical (no true poles on the playable map if wrapping east-west and maybe not wrapping north-south). Possibly Civ7 uses a cylindrical projection where top row is “polar” region. We need to verify how latitude is computed and if axial tilt is accounted for. Ideal: A robust representation of each cell’s solar latitude (and perhaps hemisphere if tilt doesn’t align with map north). We may want to introduce a config parameter for axial tilt anyway, so ideal upstream would include that parameter (could be in Foundation or a global config). If current pipeline lacks axial tilt (likely assumed Earth-like 23.5° fixed), that’s an upstream gap to fill via config.

- **Plate Tectonic Data:** Current: Foundation outputs plates, crust types, etc. Not directly needed for Hydrology, except possibly indirectly (e.g. to identify volcanic hotspots or rift valleys as special climate influences). The current “narrative motifs” mentions rifts and hotspots – those might originate from Morphology/Foundation. Ideal: We don’t strictly need plate data for climate, but it could be useful: e.g. a volcanic hotspot might warm a local area or create a high-altitude plateau (which Morphology already handles via elevation). A rift valley might be a low-elevation inland basin – Morphology’s heightfield and possibly a tag would reflect that (and climate will naturally make it arid if it’s rain-shadowed or far inland). So while plate data is interesting, Hydrology can operate with just the processed outputs (elevation, etc.). No critical upstream gap here, aside from ensuring if narrative or morphology tagged some regions for special treatment (like an “arid rift” motif), we either reproduce that result physically or allow narrative to nudge climate there.

- **Sediment/Erodibility/Soil Baseline:** Current: Morphology might output a sediment depth or erodibility map. That feeds Ecology for soils. For Hydrology, soil permeability would be the relevant piece (determines runoff vs infiltration). It’s unclear if any current data captures that (maybe not). Ideal: A field indicating soil or rock permeability (e.g. high for sand, low for clay) could modulate river flow (e.g. sandy desert might have water sink quickly, forming underground aquifers instead of surface rivers – resulting in ephemeral rivers only after big storms). Currently, we lack that granularity; Hydrology will assume a generic runoff coefficient. We note this as a potential gap: if Pedology domain (future) or Morphology could provide a “drainage coefficient” map, we’d use it. In Phase 0.5 we proceed without it, but mark it in the upstream delta list as a desirable addition for realism.

- **Environmental Directionality / Legacy Climate Inputs:** Current: There might be some legacy inputs like env.directionality (possibly indicating a global wind direction bias or map orientation). Also configuration values for baseline rainfall by latitude bands, etc. These exist but in greenfield we plan to supersede them with our model. Ideal: We prefer physical parameters (axial tilt, solar constant, etc.) over arbitrary presets. So the delta here is to retire legacy climate “band” inputs. If any upstream code (or map script settings like “rainfall: wet/normal/arid”) exist, we will map those to our parameters. For instance, a map setting “Arid” could translate to a lower global humidity or a reduced ocean evaporation factor. Upstream in pipeline, that likely comes from game options, not another domain. We will treat those game settings as config inputs, which is fine.

- **Narrative Motifs:** Current: Narrative domain can inject motifs that influence climate (e.g. ensure a “blessed land” has higher rainfall, or a cursed wasteland is extra dry). They likely do this in climate refine currently. Ideal: We consider narrative as downstream (it comes after base climate), so in an ideal physical model, we do not count on any upstream narrative input. This means some legacy coupling (where narrative tags might have been checked during climate gen) should be eliminated. Upstream delta: remove narrative from influencing core climate generation; instead, allow narrative to post-adjust if needed.

In summary, upstream deltas (gaps between current and ideal inputs) include: the introduction of axial tilt as a parameter, formalizing latitude input, adding bathymetry, possibly soil permeability, and removing reliance on any non-physical legacy climate inputs. These will be documented for Phase 1 validation – we will see what data is actually available and adjust as needed.

## Downstream Outputs and Integration (Downstream Δ)

The Hydrology domain’s outputs will directly feed several downstream domains: primarily Ecology (which determines biomes, vegetation, and soils), but also Pedology (if separated, for soil details), Narrative (for story elements like named deserts, rivers, etc.), and Placement (for gameplay placements like start positions, natural wonders, and resource distribution). We must define what Hydrology should ideally provide to these consumers, and identify any changes needed for them to use this data (downstream delta – differences from what they consume today).

**Key outputs and their downstream uses/implications:**

- **Rainfall (Moisture) Field:** This is a foundational output consumed by Ecology to allocate biomes. Current: Ecology likely uses either a precomputed rainfall array or simple proxies (latitude, etc.) to decide terrain (desert vs grass vs jungle requires a moisture threshold). We are standardizing this as artifact:climateField.rainfall. Downstream changes: Ecology’s biome classification rules must switch to use this rainfall value. For example, instead of “if tile is in latitude band X, make it desert,” it will be “if rainfall < Y, it’s desert.” This is a significant but straightforward change, aligning biome logic with physical data. Also, downstream Narrative can use rainfall to label regions (e.g. pick the driest large contiguous area to be a named desert, rather than relying on preset coordinates). Pedology (within Ecology or separate) will use rainfall along with temperature to determine soil types (e.g. aridisol in deserts, podzol in wet cold forests). If Pedology was not explicitly separate before, this is an enhancement: new soil classification tables can be driven by these climate fields.

- **Temperature Field:** Current: Possibly not explicitly represented – previous biome logic might infer temperature from latitude/elevation. We will provide artifact:climateField.temperature as an output alongside rainfall. Downstream changes: Ecology should use this for biome decisions (e.g. differentiate tundra vs desert vs tropical forest by both temp and moisture). It also informs where snow terrain or permafrost soils appear – e.g. if temperature < 0, Ecology might classify terrain as permafrost tundra. In the engine, there may be a “TerrainType Snow” or similar – previously assigned by latitude. Now it will be set if temperature is below a threshold. This is a delta in how icy biomes are determined. Also, if the game has a concept of growing seasons or plant suitability, temperature is needed. Placement might also use temperature for certain things (e.g. not placing a tropical luxury in a cold region). In short, adding a temperature field allows many downstream decisions to be data-driven rather than hardcoded by map row. Ecology and Placement will need to incorporate this new data source.

- **River Network Artifact:** Current: Downstream code checks for river adjacency via engine calls (e.g. for placing Floodplains, the game likely checks if a tile is adjacent to a river in desert). We will provide a structured river dataset. Downstream changes: Ecology’s feature placement: Forests might avoid river tiles if floodplain is separate, or wetlands might favor river-adjacent lowlands. Specifically, floodplain features (fertile river valleys in deserts) in Civ are often a special case – currently Placement domain “owns” floodplain placement (as per domain boundaries: Placement handles natural wonders and floodplains). So, Placement will consume the river data: it should mark desert tiles along major rivers as floodplains for bonuses. That logic can be greatly simplified with our outputs (just check riverNetwork for big rivers in Desert biome). Downstream delta: Implement Placement logic to use riverNetwork instead of any legacy method of floodplain tagging. Similarly, if any wonders or scenarios care about rivers (e.g. a “source of Nile” natural wonder), they now have actual river paths to refer to. Narrative might name rivers (we could supply lengths or discharge of each river to help pick the “longest river” for a name). These are new possibilities. Ecology will also use river adjacency: e.g., gallery forests (dense vegetation lining rivers in otherwise arid regions) could be a rule – not previously modeled, but now feasible by checking moisture vs rainfall discrepancy (dry tile but near river). If we choose to implement that, it’s an Ecology addition enabled by our data. Freshwater availability for city placement is improved: Placement can ensure each start position has either a lake or river within reach by consulting our artifacts rather than relying on random map script tuning.

- **Lakes and Wetlands:** Current: Lakes likely appear as a byproduct of the land generation (maybe predefined or simple depression fill in old code). Wetlands (marshes) possibly placed by a noise threshold on moisture. With our outputs: We explicitly output lake locations and wetland-suitability. Downstream changes: Ecology’s feature placement for marsh will now be deterministic: if wetlandMask says true, place a Marsh feature on that tile (assuming biome is appropriate). This means wetlands will appear in logical places (river deltas, rainforest bogs, etc.) and not randomly. A delta is that it might produce more wetlands in some maps and fewer in others compared to legacy – but they’ll make sense (which is desired). Lakes will be explicitly identified; Ecology might decorate large lake shores with certain biomes (e.g. more lush around big lakes). Placement might ensure no starting positions isolated on a small lake island unless intended. If the game has resources like fish or unique lake resources, those can be placed with knowledge of lake size from our data. Pedology: lakes and wetlands influence soil (wetland soils, lake sediments); if pedology modeling is included, it would use these outputs to classify those soils.

- **Snow/Ice Coverage:** Current: Likely determined by preset polar latitude or by terrain type (e.g. “Snow” terrain in Civ6). With our outputs: We provide glacier and permafrost info. Downstream changes: Ecology must create tundra/ice biomes where we marked permanent ice or permafrost. For instance, a tile flagged as glacier in Hydrology should be set to a “Glacier” terrain/feature in game and assigned a suitable biome (tundra or ice). If currently the game just had a “snow terrain” for the top row, this will shift that to more data-driven: some high mountains might get snow even in mid-latitude if high enough, and maybe some far-south (bottom of map) tiles might not if climate is warm (e.g. a warm ocean current might keep a high-latitude area ice-free, analogous to Northern Europe’s mild winters). That’s a change in distribution that Ecology must handle in biome logic. Narrative/Placement likely have few direct ties to snow beyond aesthetic, but if a natural wonder or scenario involved polar ice, the data is there. Placement could avoid starting a player on an ice tile, etc., using our flags.

- **Wind Data and Currents:** Current: Not used (Civ games haven’t modeled wind or currents for gameplay significantly). With our model: We have these as potential outputs. Downstream changes: These are mostly optional; if the game design wants to incorporate them (say, faster ship movement along ocean currents, or a world wonder that gives bonus if placed where trade winds converge), then Placement would consume this data. But absent explicit design, these outputs might not be used directly by any existing system. They could simply remain available for modders or future features. We include them for completeness, but they likely don’t force any immediate downstream changes unless explicitly decided. One exception: Narrative might use wind patterns to add flavor text or visual effects (e.g. clouds always moving east in temperate zones, etc.), but that’s not a data interface in code, more of a presentation aspect.

Overall, the downstream delta primarily involves Ecology and Placement updating their logic to use the new Hydrology outputs instead of legacy placeholders. The contract stability for Ecology and Placement as noted in architecture docs will need updating: where Ecology expected certain inputs, we provide new ones (rainfall, etc.), and we ensure Placement and Narrative get what they need. We anticipate a need to coordinate with Ecology’s refactor to handle soils and biomes (e.g. ensure they remove any now-duplicate computation of climate). Also, because we’re introducing possibly more granularity (e.g. differentiating degrees of river size, continuous moisture values rather than discrete “wet/dry” tags), downstream systems might have to extend their data structures (for example, a biome might not just be “Desert” but could consider “Hot Desert vs Cold Desert” if temperature data is there – though that might be Phase 2+ modeling for Ecology).

One important note: Compatibility – we are effectively proposing new data fields and deprecating old ones. As the plan mandates, we will not keep legacy climate surfaces around; downstream must switch over fully. For example, any direct call to engine rainfall or old tags will be removed (in Phase 3 implementation). If transitional shims are needed (say, if some AI or UI code still expects an old value), those shims would live downstream (marked deprecated) and be slated for removal. But ideally, we cut them entirely by updating all consumers in one go (the vertical slice refactor approach).

## Parameterization and Tunability

While our model is physics-inspired, we maintain gameplay tuning levers so designers can adjust world generation outputs for fun and diversity. Key parameters include:

- **Axial Tilt:** Controls seasonality. Ranges from 0° (no seasons – perpetually mild equator to cold pole gradient) to ~90° (extreme seasonal swings where one pole gets constant sun half the year and none the other half). Default ~23.5° as Earth. Higher tilt produces broader habitable high latitudes in summer and harsher winters, potentially altering biome extents (could be a scenario setting for an “eccentric planet”).

- **Sea Level:** Sets the baseline ocean elevation. Higher sea level means more flooded land (fewer, smaller continents), affecting climate (more ocean area = more moisture, milder climate; less land area for extreme deserts). Lower sea level exposes more land (larger continents, potentially more extreme inland climates). This is a cross-domain parameter (Morphology uses it to determine land mask, and Hydrology just inherits the results, but we list it as it crucially alters hydrology outcomes – e.g. a lower sea level might turn some coastal shallows into inland basins).

- **Global Temperature Scalar (Solar Constant):** A multiplier on solar energy input. This raises or lowers all temperatures globally. Increasing it yields a warmer overall world (smaller ice caps, higher sea levels if dynamic, more tropics); decreasing it yields an “Ice Age” feel (more tundra, glaciers). This can be used for map scripts like “Cold World” or “Hot World.”

- **Global Moisture Scalar (Evaporation/Humidity):** Controls how much water is put into the atmosphere. We can implement via an evaporation factor on ocean moisture generation or directly scaling the rainfall result. High value = a wet world (dense forests, many rivers), low = arid world (more deserts, intermittent streams). This corresponds to Civ’s typical “Rainfall: Wet/Normal/Arid” map setting. Instead of flatly changing terrain distribution, it will physically make more or less rain everywhere. We can also regionalize it (e.g. an “Arid world” might reduce tropical rainfall relatively more than temperate – this can be done by adjusting the evaporation or saturation parameters in tropics).

- **Hadley Cell Extent / Wind Pattern Tuning:** Parameters to adjust how far from equator the tropical rain belt extends, or how strong the subtropical high pressure is. For instance, ITCZ latitude or desert band intensity multipliers. We can expose a parameter like “Hadley cell size = 30° (default)” and if changed, it could push deserts poleward or equatorward. Another could be “Rain shadow severity” which multiplies how dry the leeward side becomes. These allow fine-tuning the climate pattern beyond just global moisture.

- **Orographic Precipitation Factor:** A scalar to tune how efficiently mountains wring out moisture. Higher means extremely wet windward jungles and very stark rain shadows; lower means mountains have a gentler effect (allowing some moisture past). This might be bundled with the above rain shadow parameter.

- **Ocean Heat Transport Efficiency:** How effectively ocean currents equalize temperatures. High means warm currents really warm up the poles (milder winters at high lat, e.g. an “All coasts warm” scenario); low means oceans don’t spread heat much (so coastal areas get cold nearly as soon as you leave the tropics). This can alter climate distribution significantly and could be an interesting knob for scenario variety.

- **River Threshold:** As mentioned, the flow volume needed to draw a river on the map. This tunes river density. Lower threshold = many small rivers (wet environment or just detailed map), higher = only major rivers show (giving broad empty spaces with few waterways, perhaps like an arid continent). Designers can set this per map type.

- **Lake Fill Threshold / Evaporation Rate:** Parameter controlling how readily basins fill to form lakes versus evaporate. A high evaporation rate would mean only the deepest depressions become lakes, shallower ones just evaporate water (possibly leaving salt flats). A lower rate means even shallow depressions accumulate permanent lakes. This can affect how many lakes (especially endorheic ones) dot arid regions. We can expose this indirectly as “Lake density” or tie to climate (e.g. hotter world = higher evaporation by default).

- **Wetland Threshold:** Controls how wet an area must be (and how flat) to count as a marsh. Tune this to get more or fewer wetlands. Useful because too many marshes can impede gameplay movement; the designer may want to dial it down even if physically it would form.

- **Miscellaneous:** Planet rotation direction (affecting wind/Coriolis direction) – presumably fixed (we likely won’t expose this to players, but internally it’s a parameter we considered for completeness). We assume Earth-like rotation (west-to-east) yielding eastward mid-lat winds; flipping it would mirror climate east-west patterns, which is not normally needed. If not exposed, it remains a constant assumption.

All these parameters are implemented in our model in a way that defaults to Earth-like values but can be changed easily. The Data-Driven Task Graph architecture allows these to be part of the input config for the Hydrology domain, and our ops will use them in calculations (with normalization in schema to keep them in safe ranges as needed). For example, axial tilt will influence insolation calculation; global moisture scalar will multiply evaporation in code, etc.

The presence of these tunables ensures that while the system is physics-based, it can still produce a variety of fantastical or gameplay-suited worlds (e.g. an extremely wet world full of jungles, or a freezing world locked in ice) without code changes – just by dialing knobs.

Importantly, these parameters maintain performance feasibility: none of them require fundamentally new simulation loops, they just alter inputs to the existing computations. That keeps us within the allowed snapshot count and complexity.

## Causality Spine within Hydrology

Bringing it all together, the causal sequence of the Hydrology domain can be summarized as follows (each arrow “→” denotes a cause -> effect flow or data dependency):

1. Morphology outputs (elevation, land/ocean layout) → Oceanography: continents shape ocean basins; mountain ranges will later shape winds.
2. Basic Climatology (pressure & winds from solar heating) → Oceanography currents: wind friction drives surface ocean currents.
3. Oceanography outputs (SST, current flow, sea ice) → Climatology refinement: warm oceans add humidity and warmth to air; cold oceans and sea ice cool the air; currents redistribute heat affecting regional climate.
4. Climatology processes: Insolation + elevation → temperature; pressure → wind; wind + SST → moisture transport; moisture + mountains → precipitation.
5. Climatology outputs (temperature map, rainfall map, wind field) → Cryosphere: cold + wet → ice/snow accumulation; define glaciers and sea ice.
6. Cryosphere feedback: ice cover → higher albedo → further cooling of those cells (adjust temperature). (Minor loop: updated temperature could slightly expand or reduce ice extent if done iteratively, but we likely do one pass.)
7. Final climate fields (with cryosphere adjustment) → Surface Hydrology: rainfall (plus seasonal melt) provides water; elevation provides slopes.
8. Surface Hydrology processes: terrain (with filled depressions) → flow directions; rainfall → runoff accumulation; flow + depressions → rivers & lakes; flat wet areas → wetlands.
9. Surface water outputs (river network, lakes, wetlands) – no feedback upstream (one-way to climate, except negligible effects we ignore).

Within this domain, if we were to illustrate as a flowchart: Oceanography and Climatology are tightly linked (with possibly iterative data exchange), then Cryosphere takes Climate outputs to refine them, then Surface Hydrology takes the finalized physical environment to produce hydrological features. In code terms, this might be realized as multiple steps in the Hydrology stage: e.g. climateBaselineOp, oceanCurrentOp, climateFinalizeOp, cryosphereOp, riverRoutingOp, etc., orchestrated in proper order. The “causality spine” ensures each phenomenon is computed only after its causes are in place, matching real-world dependencies, rather than imposing an arbitrary order.

Notably, the Narrative domain can inject at the end: once Hydrology produces its outputs, Narrative (downstream) might adjust or tag certain results (for example, declare one desert to be magically cursed to never rain, which could override our rainfall in a region, or ensure a “river of life” exists even if climate wouldn’t naturally make it – though ideally, our system is flexible enough to produce such features without brute force). These would be handled after Phase 0.5 modeling, as special cases. For the core spine, we assume physical realism first.

All the data produced (artifacts and fields) will be made available at the appropriate snapshot. The pipeline will likely have Hydrology broken into possibly multiple stages (pre, core, post as legacy had), but in the refactor, it could be one stage with multiple fine-grained steps. We ensure that by the end of Hydrology, the artifacts.hydrology (rainfall, temperature, rivers, etc.) are published for Ecology and others.

## Proposed Data Artifacts & Schema Adjustments

To implement this model, we will introduce or modify data surfaces as follows:

- New Artifact: ClimateField (if not already structured) – containing at least rainfall: number[] per cell, and possibly temperature: number[]. If needed, we can split into RainfallField and TemperatureField artifacts, but grouping them as one climate object might be convenient since they are generated together. This artifact is provided by Hydrology and required by Ecology (and Placement/Narrative as needed). We will deprecate any legacy means of accessing rainfall (no more GameplayMap.getRainfall in modern code).
- New Artifact: RiverNetwork – a replacement for the current riverAdjacency mask. Initially, we may implement it simply as riverMask: boolean[] or a Uint8Array marking river edges, but the greenfield design calls for a richer structure (graph of edges with properties like flow volume, perhaps an array of river segment objects). We should define a schema that can later expand. For now, a minimal approach: artifact.rivers: { isRiver[cellA][cellB]: boolean, flowVolume[cellA][cellB]: number } or similar. We might also include a list of river mouth coordinates (outlet points) or an array of basin info. The key is to expose enough for consumers to query “is this cell adjacent to a river?” easily (which the mask covers) and to eventually allow more advanced uses (navigable rivers, named rivers).
- Modified Artifacts: If Morphology or Foundation artifacts are being used (e.g. if land/ocean mask is an artifact), we ensure Hydrology requires them. For example, artifacts.morphology.heightfield (if exists) is input. Also artifacts.foundation.plateData possibly not needed directly. So mostly adding requirements.
- Buffers: We’ll treat things like the working climate grid and flow accumulation array as buffers (mutable during steps). For instance, ClimateFieldBuffer is filled in steps and then published once when stable. We must ensure to publish it at the right point. Similarly, a HydrologyBuffer for flow calc might exist internally. These are implementation details, but we note them: e.g. climateBaseline step publishes initial climate artifact, then climateRefine step mutates it (allowed if treated as buffer). In Phase 0.5 we define conceptually, Phase 3 will detail exactly where snapshots occur.
- Fields (Engine-Facing): By the end of generation, certain data goes into final map fields: likely terrain type (which will reflect things like snow/ice, marsh, lake), feature placements (rivers are typically features placed on edges between tiles in Civ, marsh is a feature on a tile, etc.), and resource placements. Hydrology informs these but doesn’t directly set all – ecology/placement do the final setting. However, one field we might directly set is perhaps a “river terrain index” if the engine uses one (Civ6 had “River” not as a terrain but an overlay). We will coordinate with engine integration – possibly through the TerrainBuilder calls or equivalent. The key schema note: fields like fields.rainfall might not need to be an engine field (the game engine might not require knowing rainfall per tile once biomes are set). It can remain an artifact used by generation logic only. Conversely, fields.terrainType will be set in Ecology based on our outputs. So we might add new codes for terrainType like “Marsh” or “Snow” if not present, or ensure existing ones are utilized correctly. We will document any such codes in the schema if needed (e.g. define a TerrainType.Permafrost if the game has none and we want to differentiate it from regular tundra – though likely not needed; could reuse tundra terrain with an ice feature). These details will solidify in Phase 2 modeling and schema definitions.

Overall, the data contract of Hydrology will expand to include climate and hydrological data as first-class citizens, whereas previously some of these were implicit or absent. All consumers must adapt accordingly (our plan is to handle those adaptations in the same refactor, keeping the pipeline consistent).

## Lookback 0.5

As this is a Phase 0.5 greenfield spike, we have made several assumptions and forward-looking design choices that will need validation and could evolve in Phase 1 and Phase 2. Here we reflect on the assumptions, identify potentially fragile domain boundaries, and note areas to revisit once we gather current-state evidence and deeper prototyping data:

- Assumption: Physically-Plausible Model Will Fit Performance Constraints. We assumed we can perform steps like global moisture advection, ocean current simulation, and flow accumulation on the Voronoi mesh without exceeding runtime or memory limits. This should be checked. For example, computing a global wind/moisture simulation might require iterative relaxation or propagation – if the mesh is very large (say tens of thousands of cells) we need to ensure our approach (which is O(N) or O(N log N) in places) is efficient. We may discover in Phase 1 that the mesh size or snapshot limits push us to simplify some processes further (e.g. using precomputed lookup tables for climate, or limiting iteration count for moisture). Mitigation: if performance is an issue, we might reduce resolution of climate simulation (e.g. compute on a coarser grid and interpolate) or simplify ocean currents to a static effect. These changes would be considered in Phase 2 if needed.
- Assumption: Minimal Narrative Influence Required. We built the model aiming to naturally produce features like deserts, jungles, etc., hoping to eliminate the need for Narrative “handholding.” However, reality might be that game design wants certain scenarios or consistency (for example, always ensure a band of desert at a certain latitude for familiarity, or ensure each player homeland has a mix of biomes). If Phase 1 current-state analysis shows that narrative or hardcoded rules enforce such patterns, we will need to validate if our model can be tuned to achieve them or if we must retain some explicit bias. This domain boundary (physical vs narrative) is a bit fragile – e.g., Narrative is supposed to come after, but in current code it influences climate refine. We’ve chosen to push it truly downstream, which might require careful coordination. Phase 1 will confirm if any critical gameplay requirements would be broken by a purely physical model. We might adjust by Phase 2 to allow some controlled inputs from Narrative (with clearly defined toggles) if absolutely necessary.
- Fragility in Subdomain Separation: We treated Oceanography, Climatology, Cryosphere, Surface Hydrology as separable, but there is coupling. For example, Oceanography and Climatology might be easier implemented as one combined simulation step (since winds and currents interact). We separated for conceptual clarity and modularity. If Phase 1 reveals that code structure or performance would benefit from merging (e.g. doing a joint climate-ocean iteration rather than two distinct steps), we might adjust those boundaries. Similarly, Cryosphere could be merged into Climatology’s refine step (just adjusting climate outputs) instead of a standalone stage. We should remain flexible on whether these are code-separate “ops” or just conceptual groupings. The boundaries drawn here are not rigid in implementation if evidence suggests otherwise.
- Assumption: Current Engine Supports These Fields. We assume we can introduce new data fields (like a continuous rainfall array, temperature values, etc.) and that the rest of the engine (AI, graphics) can handle or ignore them as needed. If Phase 1 uncovers that, say, the engine only allows certain discrete terrain types or has legacy dependencies (for instance, maybe AI expects certain climate patterns or the world builder UI needs a rainfall map), we might need to adjust output granularity. Maybe we’ll quantize rainfall into a few categories to match old patterns for AI familiarity, or ensure new fields are hidden from systems that don’t know them. These are mostly integration concerns. We will list any such issues in Phase 1 once we audit how climate data is used outside of map generation.
- Unknowns in Current River Implementation: We plan a full river network simulation, but if Phase 1 shows the game engine or map format has limitations (e.g. perhaps rivers are not fully flexible because of pathing constraints on the grid, or maybe world generation previously placed some rivers during Morphology erosion), we might need to reconcile. For instance, if Morphology already carved river valleys, our hydrology should ideally follow those rather than create entirely new paths (though if our model is correct it likely will align). We should check how the existing mapgen ensures rivers align with terrain – if any mismatch, adjust our plan. Also, currently they only expose adjacency mask to downstream – maybe they didn’t want a full graph due to memory or complexity. If that remains a concern, we might stick to the mask output in implementation Phase 3, even if conceptually a graph exists, to avoid heavy data passing.
- Balance of Realism vs Gameplay Tuning: In our model, we gave many knobs. We assume we can tune to achieve desired map variety. However, it’s possible that pure physics might still produce “too realistic” outputs that aren’t as fun (e.g. maybe Earth-like climate yields too many jungles and tundras relative to what Civ players expect). Phase 1 will gather feedback from any PRD or design documents (if available) about target biome distributions. If there’s a mismatch, we’ll know to incorporate some biases in Phase 2 (like maybe the designers want more desert for gameplay even if the climate model wouldn’t naturally make as much – we can accommodate via global moisture scalar or by tweaking the Hadley cell parameters). Essentially, we might find some modeling claims need relaxation for gameplay. We’ve kept things tunable to handle this, but it’s a risk if not enough.
- Inter-domain Boundary with Ecology/Pedology: We presumed Ecology will take over tasks like actually placing forests, features (e.g. marsh, ice) using our outputs. There is a boundary decision: do we (Hydrology) directly mark tiles as “marsh” or do we simply provide wetness data and let Ecology do it? We leaned toward the latter (Hydrology provides the physical context, Ecology does the biological/feature placement). This division should be confirmed with current system roles. If current Hydrology stage was already placing some features (maybe not, but if it did e.g. put down ice terrain), we’ll relocate that responsibility. That requires careful coordination in the refactor plan. Phase 1 will enumerate exactly who places what now, so in Phase 2 we’ll adjust accordingly. The fragile part is if something falls through the cracks (e.g. no one places ice because Hydrology expects Ecology to, and vice versa). To mitigate, we must clearly document ownership of each output (we started that above, e.g. Ecology owns actual placement of forests, wetlands, etc., with Hydrology just feeding suggestions).
- Model Calibration Pending Data: Our model includes some empirical parameters (lapse rate, thresholds, etc.) which we set to typical Earth values. Phase 1 might reveal what values the old system used (perhaps in hidden constants or tunables). We should be ready in Phase 2 to calibrate our model so that in default config it produces comparable “balanced” worlds. For example, if Civ7’s designers liked how often deserts appeared in legacy, we ensure our default parameters yield similar frequency (unless legacy was flawed). This might adjust claims like the exact rainfall thresholds or cell extents in the model. We might also refine the step ordering or number of passes after seeing actual results. Nothing in Phase 0.5 is locked – it’s a guide. If initial testing (maybe in Phase 2 spike we’ll do small prototypes) shows, say, that our moisture advection needs multiple sweeps to stabilize, we’ll incorporate that, even if initially we thought one pass sufficed.
- Evidence to Gather in Phase 1: We explicitly will look for: how climate baseline and refine are implemented now (to ensure we capture all intended behaviors, like any special cases for rivers or world wrap handling), how rivers are stored/represented in code (to design our artifact accordingly), any existing config for climate that we need to carry forward or formally deprecate, and performance metrics of current hydrology stages (to gauge how much more complexity we can add). We should also verify the Voronoi mesh topology: does it wrap around (likely yes east-west, possibly not north-south), and how that affects wind simulation at map edges (we might implement symmetry or wrap winds). If the current system had artifacts we didn’t know (like maybe a “wind directionality” constant), we’ll catch it in Phase 1.

In conclusion, this Phase 0.5 greenfield model outlines an ambitious but achievable redesign of Hydrology grounded in Earth physics. We expect to refine it with actual data and constraints in Phase 1 (current-state analysis) and Phase 2 (detailed modeling with evidence). The most uncertain boundaries are between Hydrology and its neighbors (Morphology upstream and Ecology downstream) – ensuring clean handoff of responsibilities without leaving gaps or overlaps. By revisiting those boundaries with real code context, we’ll adjust any fragile points (for instance, if we find that what we call “Cryosphere” might be easier handled in Ecology as a biome, we might simplify Hydrology’s role there). All modeling claims here (e.g. exact three-cell wind structure, necessity of iterative ocean-climate coupling) will be tested; some might change if, say, the simpler approach yields equal results.

The key benefit of this model is creating a source of truth for climate and water in the world that is consistent, tunable, and justified – providing a strong foundation for Ecology and beyond. This document will serve as the guiding reference as we proceed to Phase 1 (where we’ll verify current behaviors against these ideals) and Phase 2 (where we formalize the model with precise specifications and data structures).
