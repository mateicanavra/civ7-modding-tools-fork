Hydrology Vertical Domain Refactor — Phase 3 Implementation Plan
This issue is the Phase 3 output for the Hydrology vertical refactor. It serves as the authoritative implementation and slice plan for refactoring Hydrology/Climate to the canonical contract-first, physics-informed model. All content here is locked for implementation execution.
References: - Phase 0.5 Spike (Greenfield model): [Physics-first design notes] - Phase 1 Spike (Current state): docs/projects/engine-refactor-v1/resources/spike/spike-hydrology-current-state.md - Phase 2 Spike (Authoritative model): docs/projects/engine-refactor-v1/resources/spike/spike-hydrology-modeling.md (includes causality spine & config semantics table) - Domain Plan: docs/projects/engine-refactor-v1/resources/workflow/domain-refactor/plans/HYDROLOGY.md - Workflow: docs/projects/engine-refactor-v1/resources/workflow/domain-refactor/WORKFLOW.md
Scope guardrails: - No model changes here. This plan slices implementation of the locked Phase 2 model; any model drift is forbidden. - Pipeline must stay green after each slice. No dual paths or broken interim states. - No compat in Hydrology. The refactored domain will not carry legacy or projection surfaces; downstream integrations are updated within this refactor.

1. Locked Decisions and Guardrails
Locked model decisions (Phase 2): The Phase 2 authoritative Hydrology model is final. Key domain responsibilities are fixed: Hydrology must turn landforms + latitude + wind into stable climate fields (rainfall, humidity, temperature) and surface-water signals (rivers, lakes, wetness) for consumers[1][2]. The model prioritizes physical plausibility (e.g. latitude-based climate belts, orographic effects, rain shadows, river flow from elevation) but remains a gameplay-oriented approximation (fast, deterministic, tunable)[3]. All climate and hydrology outputs must be explainable via earth-physics reasoning, even if simplified; purely ad-hoc or “magic number” behaviors are disallowed.
Bans (non-negotiable): - No author-painted rivers: Rivers are determined by terrain and simulated flow, never manually pre-defined. The refactor eliminates any hooks for scenario designers or legacy code to “paint” rivers onto the map. - No static latitude bands as final output: Latitude-based climate bands are used as a baseline only. They are never the sole determinant of climate. The model must incorporate dynamic factors (noise variation, map size scaling, elevation (orographic lift), wind patterns, rain shadows, etc.)[4][5]. Fixed climate distributions (e.g. hard-coded bands that never vary) are banned. - No legacy engine globals or hidden state: Downstream domains must consume Hydrology outputs via explicit artifacts, not via engine internals or StandardRuntime flags. Legacy global flags like westContinent/eastContinent or env.directionality are fully retired in this refactor (see guardrails below). - No projections influencing the model: Any projection outputs (e.g. engine-specific IDs or cosmetic overlays) are purely downstream presentations and must not shape Hydrology’s internal representation[6]. For example, Civ7’s LandmassRegionId (homeland/distant land) or any latitude “band names” are external interpretations – they do not feed back into Hydrology algorithms. - No domain config megabag: Each operation (op) in Hydrology will take only the minimal config it needs. We will not pass the entire Hydrology config object into ops – this prevents hidden coupling and enforces config isolation per op[6]. - No silent legacy carry-through: Every existing Hydrology config property, rule, and function is explicitly accounted for in the new model[6]. If it doesn’t fit the physics-first design, it is removed. We do not retain any legacy behavior “just because it was there” – all features either make it into the authoritative model or are cut.
Guardrails (enforced via tests/linters): All locked decisions above will be enforced in implementation: - No compat surfaces: Hydrology will publish no legacy artifacts or flags for compatibility. For example, there will be no hydrology.legacyClimate or similar. A test will grep for any use of forbidden legacy fields or adapter fallbacks inside Hydrology (e.g. no StandardRuntime.westContinent usage)[7][8]. Any attempt to access or set legacy engine fields in Hydrology will fail a guardrail test. - Ops are pure, steps handle side-effects: No Hydrology op will directly call engine APIs, mutate context, or perform I/O. Ops strictly operate on data and return results[8]. A static analysis/lint will ensure no forbidden imports (e.g. engine adapter calls) appear in domain/hydrology/ops/**. All engine interactions happen in steps (see Fix Anchors). - RNG is seed-based: Any randomness in climate simulation (e.g. noise for rainfall variation) uses deterministic seeds passed in config or derived from context. No cross-boundary random callbacks. A guard test will enforce that ops contracts do not accept an RNG object – only numeric seeds[9][10]. Steps will log seeds and use them to instantiate local RNGs inside ops. - Defaults and nulls: All default values for config are defined in the JSON schemas (and/or during a normalization step). No hydrology code will silently assume a default that isn’t in the schema[8]. A unit test will construct minimal config and ensure that normalization populates all required defaults. Similarly, “empty” or null config fields will be handled according to the semantics table (see Config Semantics) – either treated as missing (use default) or as a directive to disable a feature. Tests for each such field will verify this behavior. - No engine state bleeding: The only engine state Hydrology is allowed to depend on is the final heightmap and basic world parameters (dimensions, map wrap). We place a guard that Hydrology must not call Civ7 engine methods except where explicitly allowed (e.g. the one call to generate rivers). For instance, no direct calls to adapter.getRainfall() or similar – all rainfall data must come from our internal model. A test or lint will catch banned calls to engine climate APIs. - Enforce bans with grep if possible: We will add scans for keywords like “paintedRiver” (if such existed) or suspicious strings like “latitudeBandsDefault” or any known legacy hook to ensure they are gone. These guardrail checks are executed in the slice that removes those features and will persist in CI to prevent regressions[11].
Downstream evolution guardrails: Once implemented, certain aspects of the Hydrology model are frozen contracts – they cannot be changed without a full model iteration: - The meaning of each config knob is locked (unless a future Phase 2 revises it). E.g., if climate.refine.orographic.reductionBase means “base rainfall loss in rain shadow (units)”, we will not later repurpose it for a different meaning without deprecating the old field. - Major outputs and their interpretations are fixed. For example, artifact:climateField.rainfall is defined as rainfall intensity per tile (0–200 scale) – downstream systems can rely on that. We won’t later change it to, say, cumulative precipitation without a new artifact. - The ban on internal compat means Hydrology will never reintroduce legacy behavior “temporarily.” If future changes need compatibility, the plan is to handle it downstream or not at all[12]. This is a guardrail for all future Hydrology work: no toggling back on legacy paths once this refactor is done.
These decisions and bans are locked by the Phase 2 model and are non-negotiable in implementation. Each will be backed by concrete enforcement (tests or lint rules) introduced in the slice that implements them. If any drift from these principles is detected during implementation, work stops until alignment is restored (per the Drift Protocol)[13].
2. Config Semantics Reference
The Phase 2 Config Semantics Table (see Phase 2 spike) enumerates every Hydrology config key, detailing its meaning, default value, behavior when omitted or empty, and determinism expectations[14]. It serves as the contract for how the Hydrology config is interpreted. Below is a summary of key points from that table, with policy clarifications:
Config structure: Hydrology config is organized into logical sections:
climate.baseline – Baseline climate parameters (latitude bands, base rainfall, orographic lift, coastal effects, noise)[15][16].
climate.refine – Earthlike refinement parameters (continental wet/dry gradient, rain shadows, river humidity boosts, enclosed basin moisture)[17][18].
climate.story – Narrative-driven climate modifiers:
story.rainfall for motif-based rainfall adjustments (e.g. humidity around rifts or hotspots)[19][20].
story.paleo for optional paleo-hydrology features (relic deltas, fossil rivers, oxbow lakes)[21][22].
climate.swatches – Macro-scale climate overrides (designer “swatches” for broad regional climate bias)[23].
Default values: Every config field is defined with a default in the schema unless noted otherwise. For example, each latitude band has a default rainfall value (e.g. equatorial default 120)[24], rain shadow reduction has defaults (base 8, per-step 6)[25][26], etc. The policy is that omitting a field means the default is used. There are no hidden implicit defaults – if a value isn’t provided, the schema’s default (or a documented normalization rule) applies[8].
Empty vs omitted: In general, “empty” collections or zero values are treated as intentional settings, not as missing. For instance, if story.paleo.maxDeltas = 0, it means “disable delta formation” explicitly. If the entire story.paleo object is omitted, that whole pass is considered off by default (since we don’t default-in paleo settings)[27][28]. Another example: setting swatches.enabled = false cleanly disables the macro swatch step[29]. The semantics table calls out each such case:
For boolean toggles, false means off (and will be honored), whereas omitting the field often means it defaults to true (for instance, swatches.enabled defaults true if not set)[30].
For object subsections (like paleo or rainfall under story), omission means the feature is not applied at all (no defaults will inject it)[28].
Determinism: The hydrology config fully determines the stochastic aspects of generation via seeds. The semantics table specifies where randomness is involved and how it’s controlled. For example, computeWindFields uses a seed derived from map context to produce winds[31][32] – given the same input and seed, it will produce the same wind field every time (ensuring determinism in climate). All random “noise” in rainfall (jitter, variation) is driven by config parameters (like noise.baseSpanSmall) and the map seed, so runs are repeatable. A determinism note is included for each config knob that influences randomness, confirming that two runs with identical config and seeds yield identical climate outcomes.
Exposed tuning knobs: The table also marks which config fields are intended for direct use by scenario authors vs. which are more internal/calibration. In general, high-level knobs like “global rainfall bias” or “rain shadow strength” are exposed for tuning (they have clear descriptions and moderate ranges), whereas very technical parameters might be documented as advanced. However, all config fields are accessible via the config schema. Nothing is hard-coded – even if a value is not commonly changed, it’s still in the config with a default. For instance, the exact latitude band edges and default rainfalls are configurable (with defaults matching Earth-like values)[33][34], so modders could adjust climate zones if desired.
Missing vs null: The Hydrology schema does not generally allow null for numeric fields (using optional instead). Thus “null” as a value typically would fail validation. The semantics table notes that to “remove” an optional sub-config, one should omit it, not set it null. (E.g., do not set story.paleo = null; simply leave it out or set maxDeltas: 0 to disable specific parts.)
Normalization policy: We will implement a HydrologyConfig.normalize() (or equivalent) that fills in defaults and prunes out-of-range values to valid ranges. This will enforce determinism (no random branching on config at runtime)[10]. E.g., if a value is above max, it might be clamped during normalization, rather than in the middle of an op run. The config semantics table doubles as a reference for this normalization: it tells us how to handle edge cases (empty lists, out-of-bounds values, etc.) in a deterministic way.
For full details, see the Phase 2 Hydrology Config Semantics table in the modeling spike[14]. That table is the single source of truth for how each config parameter is interpreted. Any ambiguity raised in code review will be resolved by referring to this table. If needed, we will update the table (and this document) with a “contract clarification” and add tests to lock the intended behavior[35].
3. Fix Anchors and Stable Boundaries
To ensure a durable implementation, we identify stable fix anchors – places in the architecture where changes can be safely made once, with minimal risk of needing rework in subsequent slices. We also define clear domain boundaries (internal vs external) for Hydrology:
Config normalization as a fix anchor: The first anchor is at the config ingestion point. Hydrology will perform comprehensive config validation and normalization up front (at compile time or step start)[8]. This is where defaults are applied and invariants enforced. Fixes that relate to config semantics (e.g. ensuring a value is within range, or that mutually exclusive settings aren’t both enabled) will be done in HydrologyConfig.normalize(). By anchoring these fixes in normalization, we ensure they remain valid across all slices – no matter how the internal logic changes later, the normalized config guarantees certain conditions. For example, if in a later slice we rearrange steps, the config defaults and computed flags will still be handled correctly before any logic runs. Tests will verify that normalization produces a normalized internal form that all ops rely on, preventing later “runtime fix-ups” (none allowed)[8].
Engine integration boundaries: The primary external boundary in Hydrology is the interface with the Civ7 game engine for river generation. In the refactored design, this boundary is isolated to a single step (rivers step in Hydrology Core). That step calls the engine (via context.adapter) to perform the low-level river carving, and then immediately captures the result in a canonical artifact (the river adjacency mask)[36][37]. By confining all engine-dependent behavior to this one step, we create a clear separation: upstream of rivers step, all logic is engine-independent; downstream of it, all river information is consumed from the artifact rather than direct engine calls. This design means future changes to river generation (e.g. replacing the engine algorithm with our own) will be localized – we could swap out the implementation inside that step or behind that contract without affecting climate steps or consumers. A guardrail here is that no other Hydrology step calls adapter methods except those explicitly part of this integration. The rivers step will be treated as a black box that produces the canonical river output from whatever source (currently Civ7 engine, future maybe internal simulation).
Internal state buffers (stable boundaries between steps): Hydrology is buffer-heavy by design[38]. We use mutable buffers (e.g. the climate field array, which holds rainfall/humidity for every tile) that persist through multiple steps. These buffers define stable internal boundaries: one step publishes the buffer (as an artifact) and subsequent steps mutate it in place[39]. For instance, the climateBaseline step publishes the initial climateField artifact (with base rainfall and humidity) and the climateRefine step later modifies that same buffer for rain shadows, etc., without re-publishing a new artifact each time. The anchor here is the initial publish of the buffer artifact – after that point, we consider the buffer’s memory layout and meaning to be fixed, and later slices can safely build on the assumption that, say, climateField.rainfall is a certain length and scale. In implementation, we will validate once (at publish) that the buffer matches schema (correct type, length)[40][41], then subsequent operations can safely assume it’s correct. This prevents needing to re-validate or re-shape data in later steps.
Step contracts as slice anchors: Each slice will introduce or update step contracts with defined inputs/outputs. These contracts form stable boundaries. For example, one slice might introduce a new artifact or op output (say a wetnessIndex), and that becomes an official contract – later slices can rely on it. Conversely, when we remove legacy outputs (like engine effect tags), we do it at a slice boundary and adjust all contracts then and there, so downstream knows exactly when that boundary changed. Once a contract is updated in a given slice, it is treated as stable going forward (we avoid thrashing contracts in multiple slices). This plan explicitly calls out contract changes per slice in section 5.
Domain boundaries to other domains: We clarify how Hydrology interfaces with adjacent domains:
Upstream inputs: Hydrology consumes Morphology outputs (primarily the heightfield and possibly flow routing data) and Foundation context (global latitudes, world wrap info). These come in as artifacts or context data. The boundary is at the recipe level: e.g. artifact:heightfield produced by Morphology is required by Hydrology’s first stage[42][43]. We treat those upstream artifacts as read-only facts (anchors) – Hydrology steps will not recalc fundamental data like land/ocean mask from scratch; they use what’s provided. A stable anchor fix here is ensuring we trust Morphology’s land mask completely. (In fact, slice 1 will include a fix that uses the *landMask from Morphology’s artifact instead of re-deriving continents via stampContinents – see slice plan.)
Downstream outputs: Hydrology publishes climateField and riverAdjacency as its primary outputs (plus any optional ones like lake mask or wetness index). The boundary to consumers (Ecology, Narrative, Placement) is that those domains must read these artifacts rather than their old methods. Each output projects to specific surfaces: e.g., the river adjacency mask projects to anything that needs to know “is there a river near this tile” (Ecology uses for wetlands, Placement for start bias, etc.), and climateField projects to biome selection, etc. These are well-defined: consumers should never bypass them (guardrails in consumer domains will enforce not computing their own rainfall). By establishing these artifacts as the stable boundary, we ensure downstream integration is straightforward: if Hydrology changes how it computes rainfall internally, as long as it still produces climateField in the same format, consumers don’t break.
No hidden dependencies: All cross-domain inputs/outputs are made explicit via artifact contracts. For example, narrative “motifs” overlays (like rifts and hotspots) influence climate refine; this boundary is explicit through an overlays artifact provided by Narrative and required by Hydrology’s refine step[44]. We anchor a fix in the contracts: climateRefine’s contract declares it requires artifact:storyOverlays (the narrative overlays) instead of allowing any implicit global access. This way, if narrative overlays are missing, the pipeline fails clearly at contract resolution, rather than Hydrology quietly doing something else.
In summary, fixes will be placed at points that remain stable: - Config-level fixes go in normalization (runs once, before ops). - External engine calls are isolated to the rivers step (one integration point). - Artifacts mark the boundaries between stages and domains; we fix things at artifact publish points or contract definitions so that those boundaries remain consistent. - No fix will be applied inside an ephemeral context where a later slice would undo or relocate it. We explicitly ask “will this still apply after the next slice?” for each change[45] – if not, we relocate the change to a more stable anchor.
All these boundaries are reflected in our slice plan below. Each slice description will identify the anchors it establishes or relies on (e.g. “Slice X introduces artifact Y at step Z as a new stable boundary,” etc.). This approach ensures the refactor’s changes are durable and don’t need revisiting slice after slice.
4. Step Decomposition Plan
Phase 2 produced the causality spine for Hydrology – an ideal sequence of conceptual operations from inputs to outputs. Phase 3 now maps that spine onto concrete implementation slices, each introducing a set of step changes in a safe order. We decompose the work into 5 slices, each corresponding to a set of closely related step refactors along the spine. The slices are ordered to minimize pipeline breakage and to allow verification at each step (following the pattern used in Morphology[46]).
Below is the plan, slice by slice. For each slice, we list the relevant steps (with domain and subdomain context), their purpose, inputs/outputs, artifacts affected, completion criteria, and which guardrails they cover.
Slice 1 – Hydrology Artifact Contracts & Baseline Publishers (Additive, non-breaking)
Goal: Introduce proper stage-owned artifact contracts for Hydrology and ensure all hydrology outputs are published through those contracts (without changing logic). This makes existing climate and river data officially available to consumers via artifacts, paving the way for downstream migration.
Steps involved: Hydrology (Pre) – climateBaseline (Climate); Hydrology (Core) – rivers (Surface Water); Hydrology (Pre) – lakes (Surface Water, minor).
Purpose: Slice 1 formalizes the data products of Hydrology:
The Climate Field artifact (artifact:climateField) is published in climateBaseline step, containing rainfall and humidity buffers[47][48]. The Wind Field artifact (artifact:windField) is also published from climateBaseline (carrying wind vector data used later)[40][49].
The River Adjacency artifact (artifact:riverAdjacency) is published in the rivers step (as a 0/1 mask for river presence)[50][42].
The lakes step (if currently not publishing anything) will be updated to output any lake-related artifact if needed (e.g. a lakeMask), or at least to assert any changes to the heightfield are reflected in the heightfield artifact.
Canonical inputs: No new inputs introduced – climateBaseline continues to require the final heightfield (from Morphology) and global context (map dimensions, latitude function) as before, and rivers continues to require the heightfield and climateField.
Artifacts created/updated:
Define Hydrology Pre Artifacts object with schemas for climateField and windField (already defined, but ensure schema completeness – rainfall/humidity arrays defined as Uint8Array)[47]. Update climateBaseline to use implementArtifacts to publish to these artifacts (this is already done in current code, we just ensure schema validation is correct)[40][51].
Define Hydrology Core Artifacts with schema for riverAdjacency (change from Type.Any() to a concrete type: an array or TypedArray of length = map tiles) – basically a Uint8Array mask like the design decision locked in Phase 2[52]. Update rivers step to publish to this artifact (already wired, but now with proper typing).
(Optional) If a lakeMask artifact is desired (for future use by Ecology or diagnostics), define it in Hydrology Pre artifacts. In this slice, we might simply publish an empty mask or basic lake info from lakes step, to establish the artifact. (If not needed, we skip adding new outputs to avoid noise.)
Internal logic changes: None (in this slice we do not alter how climate or rivers are calculated). We only add artifact definitions and ensure the data gets funneled through them. For example, if rivers currently marks rivers done via an engine state flag, we now also populate the riverAdjacency artifact from the engine’s data. This does not remove the old flag yet (that’s slice 3).
Gate criteria:
All Hydrology stages have artifacts.ts with schema definitions (no more legacy direct imports of artifacts)[53]. Specifically, hydrology-pre/artifacts.ts and hydrology-core/artifacts.ts exist and export hydrologyPreArtifacts and hydrologyCoreArtifacts respectively with the keys above.
Pipeline runs without errors and all tests pass, especially any new tests that attempt to require these artifacts from a downstream step (we should add a minimal dummy consumer in tests to ensure artifacts are populated). The presence of artifacts should not break anything – since previously steps likely produced similar data internally, now it’s just formalized.
Verify via logs or debug that after climateBaseline, ctx.artifacts.climateField and windField are present, and after rivers, ctx.artifacts.riverAdjacency is present. Also verify they have correct dimensions (we can add assertions in validation functions as in current code[54][55]).
Guardrail coverage: This slice primarily sets up for guardrails in slice 2. However, we implement a basic guardrail here: a test that ensures no consumer is still reading rainfall directly from the engine. For example, simulate an Ecology consumer asking for rainfall – it should now get it from artifact:climateField (we might add a temporary test double). This enforces the “no direct GameplayMap.getRainfall” rule[37][56]. Additionally, by defining schemas, we indirectly enforce type discipline (e.g., if some code tries to put a wrong type into riverAdjacency, the schema validation will catch it).
Notes: This slice is largely complete in the current code (climateField and riverAdjacency artifacts were introduced in an earlier phase[57]). We will review and polish those: e.g., ensure riverAdjacency is indeed a Uint8Array mask as locked (it was decided as 0/1 mask)[52], and not e.g. an object. Any deviations from Phase 2 decisions here are corrected. After this slice, Hydrology’s outputs are formally contracted, but we haven’t removed legacy paths yet. That happens next.
Slice 2 – Consumer Cutover to Artifacts (Effect Tag Removal)
Goal: Migrate all downstream consumers to use the new artifact outputs instead of legacy effect tags or runtime flags. Remove or replace legacy requires/provides tags in Hydrology and related domains to reflect the new contract-first data flow.
Steps involved: This slice affects multiple domains’ steps (migration of consumers), not just Hydrology steps:
Placement (Post) – derive-placement-inputs step (Gameplay domain) currently requires effect:engine.riversModeled[58].
Ecology – any step that waited on riversModeled or fetched climate via engine.
Narrative – if any narrative step had requires: effect:engine.riversModeled (for timing of paleo overlays).
Hydrology (Core) – rivers step provides the effect tag; this will be altered.
Purpose: We eliminate the use of engine effect tags as synchronization for Hydrology outputs, now that artifact contracts exist. This means:
Consumers that depended on effect:engine.riversModeled to know rivers are ready will instead declare a dependency on the riverAdjacency artifact.
The Hydrology rivers step will no longer provide engine.riversModeled (the engine state flag) as a contract tag – the artifact serves as the synchronization point.
Similarly, if any consumer was gating on effect:engine.climateApplied (there isn’t a standard tag for climate in the registry beyond biomesApplied), we update them to expect artifact:climateField presence instead. In practice, since climateField is produced in Hydrology Pre and many consumers in Ecology run much later, this might not have been an explicit tag, but we double-check.
Contract changes:
Placement – In derive-placement-inputs.contract.ts, replace requires: M4_EFFECT_TAGS.engine.riversModeled with requires: hydrologyCoreArtifacts.riverAdjacency[58]. Now the placement input step will not start until the river adjacency artifact is available.
Hydrology – In rivers.contract.ts, remove the provides: effect:engine.riversModeled line[59]. The engine will still internally set that state when its API runs, but it’s no longer exposed as a pipeline contract. (Optionally, we could mark it deprecated or ensure it’s only used in legacy code paths if at all.)
Ecology – Identify any references to engine state for rivers or climate. Possibly the Ecology features step or biome assignment had checks like “if (tile.isAdjacentToRiver)” – those would be using our artifact already (post-M3, artifact:riverAdjacency was introduced[57]). We ensure Ecology’s data source is the artifact and not an engine call. If not already done, update Ecology step contracts to require hydrologyCoreArtifacts.riverAdjacency (for wetlands or floodplains features). Also, if Ecology needed rainfall values (e.g. for biome humidity thresholds) and was calling a function, ensure it now has requires: hydrologyPreArtifacts.climateField.
Narrative – Check narrative timing for “paleo” overlays: since story “paleo” features should run after rivers, it might have been using the effect tag or just stage ordering. If the narrative step storyPaleo exists and had requires: engine.riversModeled, switch it to artifact or simply rely on stage order (if narrative-post is after hydrology-post, we might not need an explicit require). We prefer explicit: define that narrative paleo step (if in Narrative domain) requires artifact:riverAdjacency to ensure it runs after river data ready.
Artifacts involved: No new artifacts, just using the ones from slice 1. The riverAdjacency artifact now officially replaces the engine’s river-done flag as the synchronization token.
Gate criteria:
No stage or step in the pipeline uses effect:engine.riversModeled (or any other hydrology-related engine effect) in its requires or provides. We will grep the codebase for riversModeled to confirm[58]. This includes Hydrology itself and all consumers. Tests should be updated accordingly (any test that injected effect tags needs to inject artifact instead).
The placement pipeline still runs correctly: the placement input step should start only after rivers step is done (now enforced by artifact dependency). We validate this via a pipeline execution trace or ordering test: ensure that in the execution graph, hydrology-core/rivers precedes placement/derive-placement-inputs due to the artifact require.
All downstream references to climate or rivers data are now through artifacts. For example, if an Ecology system function getMoisture(tile) existed that read from engine, it should now read from the climateField artifact (we might implement a helper in context for this). We can add a unit test in Ecology: iterate over some tiles and verify that their moisture correlates with ctx.artifacts.climateField.
No regression in results: Since this slice doesn’t change how data is produced, just how it’s accessed, the map output should be identical. We specifically verify that features like floodplains placement or wetland generation in Ecology still behave the same with the artifact (they should, as it’s the same data).
Guardrail coverage: This slice enforces the “single source of truth” principle for hydrology outputs. We add a guard test that no consumer tries to read ctx.state.engine.riversModeled or use adapter.isAdjacentToRiver() outside Hydrology. The presence of artifact in contracts should naturally cause an error if they attempt to skip it. Also, we implement a lint rule or test to ensure no M4_EFFECT_TAGS.engine.riversModeled remain[58]. This covers the compatibility guardrail: Hydrology is not publishing compat and any downstream hacky reads of engine state should now fail.
Note: We keep the StandardRuntime continent flags removal for next slice (since that’s more of a hidden coupling fix). Slice 2 focuses on formal contract tags. After this slice, the pipeline’s dependency graph is artifact-based for hydrology data and effect tags related to hydrology are fully gone[60].
Slice 3 – Eliminate Hidden Legacy Coupling (Continent Flags & Engine Fallbacks)
Goal: Remove all hidden or implicit legacy data flows in Hydrology. Specifically, drop the use of StandardRuntime.westContinent/eastContinent and any similar legacy global influencing climate, and ensure the model relies on explicit inputs (like the new landmass artifact from Morphology if needed). Also, remove any remaining engine climate fallbacks.
Steps involved: Hydrology (Pre) – climateBaseline (Climate) is the primary focus, as this is where legacy continent logic lives. Also affects Placement and Hydrology (Post) insofar as they used those flags.
Purpose: In the current state, climateBaseline calls context.adapter.stampContinents() and possibly uses env.directionality to adjust rainfall distribution (e.g. making one side of the world drier)[61][62]. This is a legacy behavior that tries to mimic Civ’s notion of “west vs east continent” climate differences. We will remove this and replace it with authoritative model inputs:
Use the new Morphology landmasses artifact if needed to distinguish land clusters instead of relying on engine’s internal IDs. (Morphology Phase 2/3 introduced artifact:morphology.landmasses for connected land components[63][64].)
If the model calls for different climate on different landmasses (e.g. for the LandmassRegionId concept of homelands vs distant lands), we will handle it downstream (Gameplay) rather than in Hydrology. The Phase 2 model explicitly said LandmassRegion is a Gameplay projection, not part of Morphology or Hydrology model[65]. Thus, Hydrology will stop stamping continents entirely.
Changes:
In climateBaseline.run: Remove calls to adapter.stampContinents() and any logic that reads context.env.directionality or uses StandardRuntime.continentIndex for climate. This means climateBaseline will treat the world uniformly unless otherwise specified by config. (Our config does not have a “directionality” knob – global wet/dry bias is handled via baseline.seed.baseRainfall and possibly wind patterns, not a preset east-west bias.)
Verify that removing this doesn’t break anything: Placement used to read those flags for start positions, but Morphology refactor Slice 3 introduced a new LandmassRegionId projection in Gameplay to replace that[65][66]. So by now, placement should no longer require westContinent/eastContinent. We confirm that:
Placement derive-placement-inputs no longer references ctx.state.westContinent (should have been removed by Morphology’s changes)[67]. If not, we remove it here and ensure placement uses the LandmassRegionId assignment done in Gameplay.
Hydrology’s climate algorithms will no longer “re-stamp” continent IDs. This is a cleanup that doesn’t alter data outputs except in subtle ways (it removes any artificial climate tweak that might have been applied along those lines – which likely was minimal or even zero-sum).
Remove any engine fallback for rainfall. E.g., ensure we are not calling adapter.syncClimateField() or similar (the legacy doc noted that was removed in M3[68], but we double-check in code). If any remnants like if no rainfall, call adapter.getRainfall exist, delete them. After this, Hydrology is fully in charge of climate values; missing artifact means failure, not engine fallback.
Inputs and artifacts: If needed, require artifact:morphology.landmasses in climateBaseline (or more likely in placement where LandmassRegion is decided). We decide here: the authoritative model did not include continental differentiation in climate (since that’s more of a gameplay concept), so Hydrology doesn’t need landmass artifact for climate logic. Thus, climateBaseline will simply not use continents at all. (We keep the option noted: if testing shows a large change in climate output, we might consider using landmass info to introduce a subtle bias if needed, but only via config if at all.)
Artifacts affected: None new, but heightfield artifact remains an input. We confirm heightfield includes everything needed (landMask etc.) so that we can derive any needed context (like world wrap info we already have via context.getLatitude).
Gate criteria:
No usage of StandardRuntime.continent flags anywhere in code. We run a grep for westContinent and eastContinent – it should return nothing now[62]. We also grep for directionality – likewise nothing relevant in map generation.
Climate baseline still produces a sensible rainfall distribution. We compare climate output before/after this change to ensure no major regression. (We expect only minor differences; if anything, climate might be more uniform without the old bias – which is acceptable. Phase 2 model did not deem the old bias correct.)
All tests pass. If any tests explicitly checked continent flags (doubtful in unit tests), update or remove them.
Hydrology no longer depends on hidden engine state. To verify this, we can temporarily sabotage the engine continent stamping (make it no-op) and see that our pipeline results do not change – proving we are independent of it.
Downstream placement still works: The removal of continent flags in Hydrology should have no effect on placement because placement is already using LandmassRegionId from Gameplay slices (which is separate).
Guardrail coverage: This slice covers the guardrail “no hidden legacy coupling.” We will add a guard test that scans for any ctx.state. or ctx.env. usage in Hydrology steps that is not explicitly allowed. For example, a test that reflection-inspects climateBaseline.ts to ensure it doesn’t call any adapter methods except those explicitly in our plan (like building elevation, which is fine)[61]. We specifically ban adapter.stampContinents via lint rule. We also enforce the upstream input rule: if Hydrology needs something from Morphology, it should require an artifact. Absence of requires: morphologyArtifacts.landmasses in contract means we’re not using landmass info – which is intentional. We document that explicitly so it’s understood as a decision (the climate model doesn’t need to partition by landmass).
Notes: By removing these couplings, we align with the principle that the model is authoritative over legacy quirks[8]. If QA or design desires a concept of “one continent is typically drier,” that can be reintroduced as a formal config knob later (e.g. a regional climate bias feature), but not as a hardwired legacy behavior. We will note any such change in output as acceptable differences due to model correctness. This slice essentially “frees” Hydrology from legacy anchor points and completes the separation from Civ7’s old climate heuristics.
Slice 4 – Canonical Model Implementation (Ops Refactor & Config Alignment)
Goal: Refactor the internal implementation of Hydrology steps to fully realize the physics-first model defined in Phase 2. This includes breaking monolithic logic into atomic ops, implementing or refining algorithms for wind, rainfall, and water routing, and aligning code with the semantics of the config table. This is the core implementation slice where the new model behaviors are introduced (but with all decisions locked from Phase 2, we are not inventing new model content here).
Steps involved: Hydrology (Pre) – lakes (Surface Water), climateBaseline (Climate); Hydrology (Core) – rivers (Surface Water); Hydrology (Post) – climateRefine (Climate). Potential introduction of new sub-steps if needed (e.g. splitting part of refine).
Purpose: Implement the authoritative Hydrology model:
Lakes: If the Phase 2 model includes handling of lakes (e.g. filling depressions or generating a lake mask), implement it now. This might involve using a simple algorithm for lake formation (e.g. identify inland basins below sea level or with no outlet and mark them as lakes). If an op like computeLakeMask is needed, create it (taking elevation and perhaps moisture threshold). Ensure it populates a lakeMask overlay or artifact (if we decided to have one). This step remains optional/toggleable via config (if no config knob, it’s always on minimal lake filling).
Wind field computation: Ensure the computeWindFields op (introduced in Phase 2) is properly integrated. The op contract (already exists) takes latitude, water mask, etc., and produces wind vectors[69][70]. We double-check its implementation (and complete it if it was stubbed). The wind output should influence climate refine (e.g. wind direction is used to determine rain shadow orientation). In this refactor, ensure wind integration: pass the wind data to climateRefine (we already do, as config.wind in refineClimateEarthlike call[71]) and verify it’s used for orographic shadow (likely yes).
Climate Baseline op: If not already, implement a pure op for baseline climate generation, e.g. applyClimateBaseline is currently a function; we will formalize it as an op under domain/hydrology/ops. It will consume config.baseline and produce initial climate buffers. This op will incorporate:
latitude band targeting (using baseline.bands config)[34][72],
base seed rainfall (baseline.seed.baseRainfall)[73],
orographic lift bonuses (baseline.orographic) for mountains[74][75],
coastal bonuses (baseline.coastal)[76],
noise (baseline.noise) for randomness[77],
map size scaling effects (baseline.sizeScaling for adjusting band intensity on large maps)[78][79]. We ensure each of these uses the config values properly and deterministically. The output is a pair of buffers (rainfall, humidity). Determinism check: Use the deterministic RNG (e.g. context seed) for noise.
Climate Refine op(s): Refine is complex; break it into logical units if needed:
Continental water gradient (distance from ocean adds humidity) using refine.waterGradient config[80][81].
Orographic rain shadow: using wind data and refine.orographic config (scan upwind for mountains, reduce rainfall on leeward side)[82][83].
River corridor humidity: using refine.riverCorridor (increase humidity near rivers)[84][85], which will use the riverAdjacency artifact as input.
Low basin moisture trap: using refine.lowBasin (add humidity in enclosed low areas)[86][87]. Each can be its own op (for testability), or at least clearly delineated sections in one refineClimateEarthlike op. We implement according to model spec and config parameters.
Narrative motif application: Apply story.rainfall modifiers – e.g. riftRadius and riftBoost to increase rainfall around rift features, and hotspot.paradiseDelta or volcanicDelta for hotspot types[88][89]. This requires reading the overlays artifact for positions of rifts and hotspots[44]. We ensure those overlays (structures listing tiles of each motif) are used to map the bonuses onto the climate field. This logic may already exist; we align it to the config values instead of any hardcoded numbers.
The refine step will thus take as inputs: the baseline climate buffers, the wind field, the river adjacency mask, and narrative overlays. All of these are available as artifacts now (windField, riverAdjacency, overlays).
Rivers step (engine integration): No change in algorithm (still call engine via adapter) but we ensure it’s structured as an op call if possible. Possibly wrap the engine call in a small op (for purity) or at least isolate it. More importantly, if Phase 2 specified any additional post-processing on rivers (like classifying river sizes or computing flow accumulation), implement minimal needed pieces:
For example, Phase 2 might have wanted a “wetness index” that combines rainfall and flow accumulation to inform wetlands. If so, we could compute a simple wetness proxy: e.g. wetness = rainfall + (riverAdjacency * bonus). If that was identified as useful, implement an op to produce wetnessIndex buffer, and publish it as an artifact. (This was listed as an optional output in the domain spec[90][2].) If we choose to do this, the op would run either in the rivers step (after adjacency known) or a tiny follow-up step. Given slice content, we can fold it here as part of refining outputs.
Ensure the rivers config handling: Our rivers.contract.ts currently has a schema expecting climate.story.paleo subset[91]. That indicates the rivers step is prepared to handle paleo-hydrology application after engine rivers. Now is the time to implement that if in scope: using story.paleo config:
If maxDeltas > 0, carve up to that many river deltas in coastal areas (fossil deltas in places engine might not make a river).
If maxOxbows > 0, possibly modify the elevation or mark tiles near rivers to simulate oxbow lakes.
If maxFossilChannels > 0, identify where ancient river beds could be (perhaps in now-dry areas) and adjust humidity or terrain accordingly. These are complex and partly narrative-driven. We implement only what’s feasible deterministically and mark the rest as deferred if needed. Possibly we at least generate overlay markers for fossil rivers (for Narrative to visualize), affecting humidity if fossilChannelHumidity is set[92][93]. The key is to ensure these use the config semantics (and produce consistent results for given seeds).
If the paleo features require terrain carving (e.g., cutting canyons), that means modifying the heightfield. That’s a significant change possibly outside scope of this vertical slice – but since config has those knobs (canyonRim, etc.)[94][95], we attempt a minimal implementation: e.g., if enableCanyonRim=true, we lower some tiles to create a canyon visual near certain rivers. Because this crosses into Morphology’s domain (terrain), this may be tricky. We might instead output an overlay of where canyons would be and leave actual carving to an art pass or a later refactor. We clarify that any elevation changes by hydrology will be minimal and purely optional.
Inputs/Outputs:
Inputs: Same artifacts as previous slices (heightfield, windField, riverAdjacency, overlays). Possibly also Morphology routing artifact if available: If Morphology slice introduced artifact:morphology.routing (flow directions), we could use it to inform river placement or wetness. In this implementation, we choose not to integrate it yet (to not change river algorithm). But note it as future improvement.
Outputs: ClimateField (already existing artifact) now becomes fully populated (rainfall & humidity final values). RiverAdjacency remains as is. Potentially new outputs:
If we implement wetnessIndex, define artifact:hydrology.wetnessIndex and publish it (likely in climateRefine or rivers step after combining data).
If lakeMask was introduced, ensure it’s filled properly now (with actual lake data).
Possibly an updated heightfield if paleo carving occurs (we’d republish heightfield artifact or mutate it if needed).
Overlays: If hydrology is to output any overlays (e.g. fossil river overlays for narrative), we would publish them via the overlays system. However, per rules, new overlays should be owned by Narrative domain ideally. So perhaps hydrology just signals something and Narrative picks it up. We likely defer this: mark in documentation that paleo features would be better handled as narrative overlays in the future. So no new overlay artifact from Hydrology (to avoid breaking domain ownership rule).
Gate criteria:
All unit tests for the new ops pass with expected behaviors (we’ll write dedicated tests for each op: baseline generation, refine sub-parts, etc., using synthetic inputs).
The overall climate output matches the Phase 2 model expectations. We likely have a “golden path” example from Phase 2 (a known scenario with expected climate patterns) – run the pipeline on it and compare the outcome to the conceptual model. It should show, e.g., rain shadow behind a mountain, more humidity near coasts and rivers, etc., consistent with design. Differences from pre-refactor climate are acceptable if they are explainable by the improved model (we document any such changes).
No performance regressions beyond acceptable range: adding ops and more complex calcs could slow generation. We profile the steps to ensure they remain within tolerances (the design expects a fast, coarse simulation[3]).
No monolithic step rule upheld: After refactor, each op is a small, focused unit, and each step is orchestration. Check that climateBaseline and climateRefine are not doing ad-hoc heavy logic themselves but calling ops. For instance, ensure climateRefine.ts simply gathers inputs then calls something like refineClimateEarthlike() which internally calls smaller helper ops or functions for each effect, rather than giant inlined code. If any step is still too large, consider splitting (but since steps correspond to stage structure, splitting would mean adding a new stage or splitting stage – we likely avoid that now per architecture[36]).
All config options are now actively used in the code or explicitly flagged as “not implemented (legacy)”. For example, if paleo.maxDeltas is in config, we either implemented delta carving or clearly comment that paleo features are stubbed and will be a no-op (and ideally warn if config tries to use them). Essentially, Phase 2 config semantics table items should map to code. We tick off each one during implementation.
Guardrail coverage: This slice implements numerous locked decisions, so we add corresponding guardrails:
Trace and RNG: Confirm that no cross-boundary trace or RNG issues exist – e.g. all RNG seeds come through data. A test can inject a custom RNG seed and verify determinism of climate outputs.
Defaults usage: Add tests that if a config field is removed, the result equals using the default. For instance, run climate with a custom orographic config vs. none and see that “none” yields exactly default effect.
Schema-derived types: Check that no manual typing deviates from schema (perhaps generate a TypeScript type from the schema and ensure our function signatures match).
No step collapse: Ensure we did not merge steps or logic across the stage boundaries defined. The stage order remains hydrology-pre → hydrology-core → hydrology-post[96], with the same step names (plus possibly one new step if absolutely needed for something like wetness). We validate that structure via a snapshot of recipe definition.
Locked model guard: Now that the model is implemented, we lock it with deterministic tests. For example, pick a fixed seed and config, run the pipeline, and snapshot the climate field array output. This acts as a regression test so that any inadvertent future change to the model triggers a test failure, enforcing model stability.
Notes: This is the largest slice. It should ideally be done in small sub-PRs (one per major op) but all within the same issue slice to keep the pipeline integrated. After this slice, the Hydrology domain will be functionally refactored: producing physically grounded climate and water outputs in the new structure. We expect possibly minor differences in game outcomes (e.g., biome distribution might shift if rainfall patterns changed slightly), but these are intentional improvements. We will document these differences for Lookback.
Slice 5 – Ruthless Cleanup and Documentation
Goal: Final cleanup of any straggling TODOs, removal of deprecated code paths, and full documentation of the refactored Hydrology domain. This slice ensures no “dust” remains and that maintainers have clear guidance going forward.
Steps involved: All hydrology steps (for final review), plus any downstream code that had temporary shims. No new functional changes, just deletions and docs.
Purpose: Now that the new implementation is in place and tested, remove any remaining dead code or compatibility shims and write all the documentation and tests required:
Delete any legacy functions that are no longer used (e.g., if there was an old Climate.computeRainfallLegacy() left around, remove it).
Remove or mark as deprecated any config fields that Phase 2 rejected. For instance, if MapGenSettings had an old “RainfallBias” separate from our config, ensure it’s removed or mapped to the new config (with deprecation warning).
Search the code for DEPRECATED or legacy notes left during development and address them. For example, if in slice 4 we stubbed out a paleo feature or left a narrative integration for later, clearly mark it and perhaps open a follow-up issue (and list it in docs).
Consolidate test coverage: write any missing tests for edge cases (e.g., 0% land maps, all-land maps, small map extremes, etc. to ensure no divide-by-zero or array overruns).
Documentation pass:
Update the Hydrology domain docs (docs/system/libs/mapgen/hydrology.md) with the new model description (if Phase 2 spike hasn’t already)[97][98]. This includes documenting the new ops, new artifacts, and how they relate (essentially the content of this plan, distilled for docs).
Update schema and JSDoc: Every config schema item gets a description (many already have it in code) – ensure they reflect final behavior (e.g., if we changed default or interpretation of something, update description accordingly). Add JSDoc comments in code for each op and step describing what it does, the meaning of parameters, and any determinism notes. For buffers, document their coordinate system (row-major, etc.) and ranges.
Ensure READMEs or guide for modders reflect new config. If there is a user-facing configuration guide for map generation, incorporate the new hydrology config fields.
Assign any follow-up work: For example, if we deferred a complex paleo implementation or decided not to implement “wetnessIndex” fully, create a triage ticket for it so it’s not forgotten[99]. We also note any new downstream deprecations introduced (e.g., if we had to add a shim in Ecology to temporarily adjust to new moisture values, list its removal in triage).
Artifacts and outputs: Nothing new introduced. Possibly remove artifacts that ended up unused – e.g., if we added lakeMask but then saw no consumer and no clear value, we might remove it to avoid bloat (since removing in the same version is fine).
Gate criteria:
All tests green and coverage acceptable. At this point, test coverage for Hydrology domain should be near 100% for critical functions. We run the full test suite and perhaps a few full pipeline runs on sample maps to compare before/after more thoroughly.
No TODO/DEPRECATED without tracking. The codebase should either have fully implemented a feature or clearly marked it deprecated with a reference to either removal or a future issue. We don’t leave ambiguous comments.
Documentation completed: This is a deliverable – we will not close the refactor until documentation is reviewed and approved by peers. The Phase 3 issue (this document) is updated with any lookback notes. Also, any in-code docs for tricky algorithms (like how exactly we compute rain shadows) are added so future maintainers can understand without referencing the spike.
Consistency checks: Lint the project for any violation of the new architecture. For example, run REFRACTOR_DOMAINS="hydrology" ./scripts/lint/lint-domain-refactor-guardrails.sh which likely contains hydrology-specific assertions (similar to morphology’s)[11]. This should pass with 0 warnings. If our guardrails script doesn’t cover Hydrology yet, we add entries for it in this slice.
Guardrail coverage: This slice finalizes guardrails:
Add a test to ensure each locked decision is covered by some test. Essentially a meta-guard: our test suite should fail if someone reintroduces a banned pattern. For example, if someone tries to use an effect tag in Hydrology, or access a removed config, ideally a test will catch it (via grep or behavior). We ensure those tests are in place now.
Confirm that the verification-and-guardrails.md reference is satisfied for Hydrology (if such a checklist exists) – tick off each item for Hydrology domain.
Notes: Once this slice is done, Hydrology refactor is code-complete. We then perform Lookback 3 (review Phase 3 outcomes vs plan) and Lookback 4 (post-implementation review) as per workflow, documenting any lessons or required adjustments to the model (if, say, something turned out underperforming or overly complex, we note it for future Phase 2 revisits).

5. Consumer Migration Matrix
The table below summarizes how each known consumer of Hydrology data is affected, mapping current interfaces to the new ones introduced by our slices. It indicates in which slice the breaking change occurs and how we address it (fix or temporary shim). This matrix ensures no downstream dependency is forgotten during the refactor.

(Table Legend: “Breaks when” indicates the slice at which the current contract will break if not addressed. “Fix” describes how we resolve it in that same slice. “Shim” indicates a temporary compatibility layer downstream if we cannot fully update a consumer in-line, marked for later removal.)
All consumer fixes are applied within this refactor’s slices, so by the end of Phase 3 the new contracts are fully adopted. Notably, no upstream domain requires changes due to Hydrology (Morphology and Foundation changes were handled in their refactors). Downstream domains (Ecology, Narrative, Placement) are the focus, as listed. Each fix has been assigned to a slice above. No permanent shims in Hydrology – any temporary downstream workaround is explicitly deprecated and tracked for cleanup[99].
6. Downstream Changes and Assignments
Beyond the interface changes captured in the matrix, this refactor entails a few broader downstream adjustments. We list them here along with responsibility and in which slice/PR they will be executed:
Ecology model adjustments: Because the climate moisture distribution may change slightly (more nuanced rain shadows, etc.), the thresholds for biomes in Ecology might need recalibration. Assignment: Ecology team will run regression tests on biome outcomes after Slice 4. If needed, they will adjust biome definitions (e.g. what range of humidity constitutes “desert” vs “plains”) to maintain balance. These changes are outside the core refactor slices but should be done before final verification. We will coordinate this during Slice 4 testing (not as a separate slice, but parallel).
Ecology “features” step: Ensure the wetlands and floodplain logic in Ecology uses the new wetness signals. If we introduced wetnessIndex artifact, assignment: update Ecology’s feature placement to use it (e.g. placing marshes where wetnessIndex high). If we did not introduce it, ecology might still use a combination of river adjacency + rainfall. No code removal, just ensure it’s correct. This is done in Slice 4 as part of integration testing.
Narrative integration: After refactor, Narrative owns HOTSPOTS overlay (moved in Morphology refactor) and possibly Rifts, etc. Assignment: Narrative team to verify their generation of these overlays still aligns with Hydrology’s usage. Specifically, Hydrology now treats hotspots.paradise and hotspots.volcanic differently for rainfall[89][103]. Narrative might decide to adjust how it places those motifs (e.g. size or frequency) to get desired climate outcomes. This is not a code change in Hydrology, but a tuning discussion. We will flag this in Lookback – Narrative to review climate outcomes after Slice 4 and adjust motif placement if necessary (outside this immediate implementation, but tracked).
Removal of deprecated pathways in Placement: The Placement domain had legacy logic for start sectors (east/west) and possibly used a notion of “climate zones” for resource distribution. After refactor, some of those might be redundant. E.g., if placement had special handling for extreme desert starts that relied on latitude, it could now use actual temperature from climateField. Assignment: Placement maintainers to consider using climate data for any start biasing (if desired). This is an enhancement, not required, so we note it as a follow-up idea (document in triage).
Testing & Tuning harness: We will update the automated map generation tests in our pipeline (if any) to use the new system. If Civ7’s QA uses certain scripts to generate reference maps, those need update to use config properly. Assignment: QA or engine team to update any such harness to provide the full Hydrology config (especially if new fields like refine.riverCorridor were not present before). This is simply ensuring our test JSON configs are up-to-date (we will do it in Slice 4 or 5).
Documentation & Training for content designers: Because this refactor changes authoring surfaces (new config options, different behavior), the team responsible for documentation or tool support must be informed. Assignment: As part of Slice 5, we produce a summary of changes for designers (e.g. “Rainfall now follows a latitude+noise model; you can adjust X, Y in config. Do not expect the old hardcoded patterns.”). This could be a Confluence page or part of an official modding guide. It’s not code, but it’s a deliverable to ensure smooth adoption.
All these downstream changes are either executed within the slices (for code changes) or have explicit owners and are documented for follow-up. We will add any items that cannot be done immediately to docs/projects/engine-refactor-v1/triage.md with appropriate owners[99]. For instance, if the paleo carving is only partially done, we’ll log a follow-up task for Narrative or Engine team to finalize it.
Finally, we assign ownership of cleanup: any temporary deprecation warnings or shims introduced (e.g., if GameplayMap.getRainfall() now calls our artifact but is marked deprecated) will be listed with responsible team (most likely Engine or Gameplay) to remove them in a future milestone once mods have adapted. Since we aimed to remove all such shims within this refactor, ideally there are none – but we double-check in Lookback and assign if any remain.

Authoritative Plan Approval: This document serves as the authoritative slice plan for the Hydrology domain vertical refactor (Phase 3). It has been structured according to the standard workflow references[104] and incorporates the locked model from Phase 2. All team members and downstream owners should treat this as the contract for implementation. Subsequent Lookback 3 will capture any deviations or learnings, but the plan is now locked.
With this plan, we proceed to Phase 4: implementing each slice in sequence, keeping the pipeline green, and adhering to these guardrails throughout. Let the refactor begin!