# Hydrology Domain Vertical Refactor – Phase 1: Current-State Analysis

## Domain Inventory and Boundaries (Current)

The Hydrology domain in its current state is responsible for representing water presence and distribution in the world, but it operates in a rudimentary, mostly static fashion. Key elements of the hydrology domain currently include:

- **Surface Water Features:** Rivers, lakes, and oceans are represented as static features placed during world generation. The hydrology domain holds data for these water bodies (locations, extents) but does not dynamically simulate water movement after initial placement.

- **Soil Moisture/Humidity:** A coarse approximation of soil moisture or humidity exists (often as a static map or biome attribute), intended to influence vegetation. This is not calculated through water flow physics; instead it may be precomputed or manually tuned as part of world or biome configuration.

- **Water Table and Groundwater:** There is currently no explicit simulation of groundwater or water table dynamics. Any notion of groundwater is either absent or indirectly baked into other systems (e.g. a region might be flagged as “wet” vs “dry” without a physical model).

- **Precipitation and Evaporation:** There is no dedicated Climate domain providing dynamic rainfall or evaporation. If precipitation is considered at all, it’s via a simplified input (for example, a constant rainfall rate or a predefined rainfall map used during world generation). Hydrology does not actively simulate the water cycle over time – there are no ongoing rain events, runoff processes, or evaporation calculations in the current implementation.

### Domain Boundaries

Domain Boundaries: The current boundary between Hydrology and related domains is not strictly physics-based. Notably, some responsibilities that ideally belong to Hydrology are handled elsewhere or via manual intervention:

- **Morphology Overlap:** The terrain generation (Morphology domain) or world-gen scripts handle much of the river and lake placement. Hydrology as a domain largely just stores the results. This overlap means Hydrology isn’t fully owning water flow determination – instead, rivers might be carved by Morphology algorithms or placed by content designers based on terrain features.

- **Ecology Overlap:** Ecological parameters (like biome moisture requirements) fill in for missing hydrological modeling. For example, a biome might be labeled “humid” or “arid” in ecology configs, influencing vegetation, rather than those conditions resulting naturally from a hydrological simulation. This indicates a semantically fuzzy boundary: Ecology is partially compensating for the lack of a true water cycle model in Hydrology.

- **Author/Designer Intervention:** Currently, world designers can exert direct influence on water features. They may manually specify lake positions, adjust river paths for gameplay, or set humidity tweaks to achieve desired environments. These “thumb-on-the-scale” interventions mean the Hydrology outcomes are not purely derivations of earth physics; they include authorial inputs to shape the world in non-deterministic ways. In effect, the pipeline isn’t fully algorithmic – some hydrological aspects are hand-crafted or tuned via content.

In summary, the Hydrology domain as it stands is a mix of simple data placeholders and static artifacts from world generation. It lacks true dynamic simulation and has blurred boundaries with Morphology and Ecology, partly because those domains or content creators inject water-related outcomes that Hydrology itself does not compute. The goal of the refactor is to realign Hydrology with a physics-driven scope, where water distribution results from deterministic environmental processes rather than manual design.

## Current Contracts and Interfaces

Despite its limited functionality, Hydrology does participate in a set of data contracts with other domains. The following outlines Hydrology’s current interfaces – what it consumes from upstream and what it provides to downstream – in the present implementation.

### Upstream Dependencies (Current Intake)

- **Morphology (Terrain Domain):**
  - Input: Terrain elevation data (heightmaps) and related derivatives. Hydrology relies on the static terrain from Morphology to determine where water can exist. In current world generation, Morphology may also provide precomputed drainage directions or basin boundaries (e.g. a rudimentary watershed analysis) to aid in placing rivers. Essentially, elevation is the primary upstream input guiding water flow paths (water goes downhill).
  - Mechanism: After terrain is generated, a one-time pass uses heights to place water: low-lying areas below a “sea level” threshold become ocean; large depressions may become lakes; river courses are charted following descent paths.
  - Limitations: This process is not iterative or reactive – it’s a single initial intake of static terrain data. Any later changes in terrain (if they occur at all) do not feed back into Hydrology, because Hydrology does not continuously listen for terrain changes.

- **World Generation Parameters:**
  - Input: Global or regional settings from the world generation configuration. This includes things like “sea level” height, overall moisture level sliders, or biome templates. For example, a worldgen config might specify a higher sea level to create more ocean coverage, or designate certain areas as wetter/drier. Hydrology takes these inputs as static parameters during initialization.
  - Mechanism: These parameters influence initial water placement (e.g., sea level directly determines the ocean/land divide; a “humidity” parameter might scale how many lakes or rivers are generated in arid vs humid regions).
  - Limitations: These are effectively author knobs rather than outputs of another simulation domain. They are set by designers or scenario configuration, meaning the hydrological features can be heavily biased by manual settings. There’s no dynamic climate model providing this data – it’s a stand-in.

- **(Absence of Dedicated Climate Domain):** Currently, there is no separate Climate/Atmosphere domain feeding Hydrology with precipitation or weather data. Any notion of rainfall is baked into either the worldgen parameters or ecology. For instance, worldgen might apply a crude rainfall map (perhaps noise-based or latitude-based) to decide where rivers should flow or where deserts vs forests go, but this is a static artifact.
  - Upstream Gap: In practice, Hydrology lacks a true upstream climate feed – a clear shortcoming where ideally there’d be an input of time-varying rainfall, snowfall, evaporation rates, etc. For the current state, we note this as a missing upstream contract: no continuous climate input exists.

- **Content Authoring Inputs:**
  - Input: Manually placed or adjusted hydrologic features. In the present pipeline, content authors can override or tweak the automatic placement of water. For example, a level designer might insist on a river in a certain location for gameplay, even if the terrain algorithm wouldn’t naturally put one there, or manually create an oasis in a desert. These inputs come outside the systematic generation – via map scripts or direct editing of hydrology data.
  - Mechanism: Such interventions might be applied after the automated worldgen pass, effectively modifying the Hydrology data (e.g., adding a river where none existed, removing or reshaping a lake).
  - Limitations: This manual intake is ad-hoc and not derived from any simulation logic. It can break physical consistency (a river placed by fiat rather than by flow logic) and undermines determinism (two worlds with same seed might differ if an author manually tweaked one of them).

### Downstream Consumers (Current Outputs)

- **Rendering & World Display:** Output: Geometric and texture data for water bodies (rivers, lakes, ocean coastlines). The most immediate consumer of Hydrology is the rendering engine or map display logic, which needs to know where to draw water. Hydrology provides the list of water tiles or polygons, river path splines, and water surface levels. Usage: The visual system uses this to render realistic water surfaces on the map. For instance, it will render ocean water up to the defined sea level along coastlines, draw river mesh along the given riverbed path, etc. Notes: This is a relatively straightforward consumer – mostly read-only usage of Hydrology’s stored data. The rendering does not feed anything back; it just reflects whatever Hydrology (and by extension worldgen) decided.
- **Ecology (Biomes & Vegetation):** Output: Environmental moisture and water availability indicators. Ecology systems currently take cues from Hydrology to determine biome distribution and vegetation growth. For example, the presence of a river or lake in an area might allow a “wetland” biome or lush vegetation, whereas areas flagged as far from water become arid biomes (desert, dry grassland). Hydrology might provide a “water proximity” metric or simply the locations of water bodies, which Ecology then uses in its rules (e.g., trees grow only within X distance of water in certain climates). Additionally, any static humidity maps generated during worldgen (often coarsely approximated from hydrology/climate inputs) are consumed by Ecology to decide where certain plants can thrive. Usage: Essentially, Ecology uses Hydrology’s outputs to bias or gate its own simulation of life: plants need water, so the Hydrology domain’s output acts as a constraint for ecological modeling. Limitations: Because the hydrological data is static, Ecology might also rely on its own hacks (like predefined humid vs arid zones) rather than dynamic water availability. This means some ecological outcomes are currently hard-coded rather than truly responsive to hydrological changes (since hydrology doesn’t change after worldgen).
- **Gameplay Systems:** (If applicable) In the current engine, other gameplay systems might use hydrological data in simple ways. For example, if this simulation underlies a strategy game or world simulator, systems like settlement placement or agriculture could check for nearby fresh water sources (rivers or lakes) as prerequisites. Another possible consumer is a “Terrain Modification/Erosion” system – however, in the current state, no active erosion feedback is implemented. If terrain did change (say, digging canals or natural erosion), ideally Hydrology would respond, but as of now there is no such loop. So, any gameplay feature that would logically depend on water (like irrigation, flooding disasters, etc.) is either not present or uses extremely simplified logic. In summary, current gameplay integration of Hydrology is minimal: water mainly serves as a static environmental feature rather than an interactive resource.
- **Adjacent Domain Feedback:** Aside from Ecology, other domains like Morphology do not actively consume hydrology output in the current system. For instance, Morphology (terrain) does not yet adjust due to Hydrology (no terrain erosion or sediment deposition). Similarly, if there is a Climate prototype, it’s not taking current hydrology into account (e.g., no evaporation from lakes feeding back into weather). The one-way nature of current Hydrology output means it’s basically an endpoint for worldgen data used by rendering and partly by ecology, with no dynamic downstream processes beyond that.

To summarize the current contracts: Hydrology takes in static terrain and world settings (and some manual tweaks) to produce a static water map. That water map is then consumed for visuals and for informing ecological or gameplay logic in a static manner. The interfaces are mostly one-directional and initialized at world creation time, with no continuous update cycle in play.

### Current Contract Matrix Summary

For clarity, we can tabulate the key current inputs and outputs of the Hydrology domain:

#### Upstream Inputs (to Hydrology)

| Source | Data Provided | Notes |
| --- | --- | --- |
| Morphology Domain | Terrain heightmap; drainage hints | Basis for water placement (static). |
| World Gen Config | Sea level, global moisture parameters | Author-defined knobs influencing initial water distribution. |
| (No Climate Domain) | N/A (no dynamic rainfall input) | Gap: Uses static proxies (e.g. noise map) instead. |
| Content Authors | Manual water features overrides | Rivers/lakes added or adjusted by design (non-deterministic). |

#### Downstream Outputs (from Hydrology)

| Consumer | Data Provided by Hydrology | Usage |
| --- | --- | --- |
| Rendering/Visuals | Water body geometries (tiles, meshes) | Draw oceans, rivers, lakes on the map. |
| Ecology Domain | Water presence, moisture metrics | Determine biome types, vegetation growth. |
| Gameplay Systems | Water source flags/locations | E.g. check if a location has fresh water (if used in game logic). |
| Morphology Domain | None dynamic (terrain is static) | No current feedback like erosion. |

(Table: Hydrology’s current upstream inputs and downstream outputs.)

## Legacy Surface Inventory

In reviewing the current Hydrology implementation, several legacy surfaces and artifacts have been identified. These are data structures or configuration surfaces that exist due to historical or placeholder approaches, and will likely be reworked or eliminated in the refactor:

- **Static “Water Map” Artifacts:** The world generation produces a water mask or map that marks where water is present (often as a binary land/water flag per grid cell or a vector outline of rivers). This is essentially a cached output of the initial placement algorithm. In the current system, this water map is treated as ground truth for all downstream logic, but it’s a static snapshot. It does not update and is not recomputed after worldgen. This static map is a legacy surface that will be replaced by a dynamic computation in the future pipeline.

- **Biome Humidity Parameter:** The ecology/biome configurations include a legacy humidity/aridity parameter (often an integer or categorical value per biome or region) which was used as a proxy for water availability. This parameter is manually defined by content or loosely derived from latitude and static water bodies. It’s essentially a stand-in for a missing hydrology-climate model. Because hydrology wasn’t simulating moisture distribution, this surface was introduced to guide vegetation. It’s semantically a hydrological concept (how wet the soil/air is) but lives in ecology config. This cross-domain artifact is targeted for removal – in the new model, actual hydrological simulation will inform moisture, making this manual parameter redundant.

- **Author-placed River Path Data:** When designers manually adjust rivers, those custom paths are stored (perhaps in a special file or markup on the map). These are considered legacy because in a fully physics-driven system, we wouldn’t have explicitly authored river geometry – it would be generated. Currently, the engine might still carry support for loading these manual river definitions (e.g., a list of coordinates or a paint-over of the heightmap to force a river). This is a surface that complicates the pipeline (conditionally using author data vs generated data) and will be deprecated. In the interim, it’s important to catalog it as it may need conversion or simply deletion once the new system can replace its function.

- **Simplified Drainage Model:** There may be a simplistic drainage or flow routing layer computed during worldgen – for instance, each tile might store which neighbor downhill it drains into (creating a crude river network tree). The legacy hydrology might have used this to trace river paths and to decide lake catchment areas. This data structure (often called a “flow map” or “river network graph”) is currently static and based on initial conditions. In the new hydrology, such a network would be dynamically derived from elevation and water flux, not a fixed artifact. We note it here because it may be ingrained in some calculations (e.g., to quickly look up downstream connectivity for gameplay); any such shortcuts need reevaluation in the refactor.

- **Sea Level Toggle and Floodfill:** A global constant for sea level exists (from world config) and the world generator flood-fills all terrain below that altitude as “ocean water.” This mechanism is a legacy approach to ocean placement. It treats the ocean as a monolithic block defined by an elevation cutoff. While this is actually physically reasonable for sea vs land at a macro scale, it’s entirely static. Future improvements might allow local variation (like land subsidence or sea-level rise) which currently aren’t possible. The presence of a single hardcoded sea level parameter is a legacy simplification, though it may remain as a config knob (to control overall ocean coverage) in the new system. The process that uses it, however, will likely be updated to integrate with dynamic hydrology (for example, connecting coastal hydrology with ocean simulation if that becomes relevant).

- **Hardcoded Water Capacity Limits:** If any internal code imposes fixed limits (e.g., “a river of size X can only hold Y water” or “no more than N lakes in a region”), those rules are remnants of design-era thinking rather than physics. They would be documented in legacy surfaces if present. For instance, perhaps the worldgen had a rule like “desert region can have at most one small lake.” Such rules, if they exist, are essentially arbitrary caps that the new physically-driven approach would eliminate. Instead, the environment’s parameters should naturally result in however many lakes conditions allow, rather than a predetermined number. Identifying these hard constraints or magic numbers in the current implementation is crucial so they can be removed or replaced with continuous parameters in the new model.

In summary, the legacy surfaces show how the current Hydrology domain was built around static world initialization and manual tweaking. These surfaces will either be transformed or removed. For the refactor, we aim to ban legacy shortcuts and one-off data hacks – every piece of data should either be an input from another authoritative domain or a derivation of the hydrological model itself, with no unexplained or author-dictated artifacts lingering.

## Current Producer/Consumer Map

The current pipeline for Hydrology can be described as a one-time, mostly linear process during world generation, with minimal runtime interaction afterward. Below is a step-by-step depiction of how the Hydrology domain interacts with others in the present state:

1. **Terrain Generation (Morphology)** → The pipeline starts with the Morphology domain producing the world’s terrain: a heightmap and basic terrain features (mountains, valleys, plains). Once the terrain is set, Morphology may do a preliminary analysis for water placement (e.g., find low areas, compute runoff directions for each cell). At this point, any global parameters like sea level or intended climate zones are also applied to terrain (for example, marking all tiles below sea level as ocean).

2. **Initial Water Placement (Hydrology static pass)** → Using the terrain data, the Hydrology domain (or worldgen code acting on its behalf) conducts a single water placement pass:
   - It labels ocean tiles (contiguous regions below sea level along the map edges, typically) as water/ocean.
   - It identifies potential lake basins (inland depressions with no outlet) and fills them to a certain level, creating lakes. This often uses the drainage map: if a region has nowhere to drain, water accumulates.
   - It traces river paths: starting from high rainfall or mountain areas, following the downhill path (drainage) to oceans or lakes. Rivers are often generated by selecting some high-flow paths on the drainage network. The flow might be estimated by area (e.g., how many upstream tiles feed into this path – a proxy for river size).
   - The output of this step is a set of water features: essentially a map of ocean cells, lake surfaces, and river trajectories. This is stored in Hydrology’s data structures (water map, river graph, etc.).
   - If there are any author interventions, they are applied here or immediately after. For example, after the algorithm places rivers, a script might adjust or replace certain rivers with designer-defined ones. Or an author-specified lake might be inserted. The final result is then locked in.

3. **Hydrology Outputs Distribution** → Once water features are determined, the relevant data is distributed to other systems:
   - The rendering system receives the geometric info to draw water. This might involve generating mesh for rivers and shorelines for lakes/oceans.
   - The ecology system reads the water map to adjust biome assignment. For instance, areas within a certain radius of a river might be set to a fertile biome; large lake or ocean coast influences climate moisture for adjacent tiles (again statically).
   - If a resource or gameplay system needs to place resources (like fish in water, or decide where a harbor city can be founded), it queries the Hydrology data at this time.
   - These consumers effectively take snapshots of the hydrology data now, since that data isn’t expected to change later.

4. **No Continuous Simulation** → After world generation, Hydrology does not continuously update. There is no tick-by-tick simulation of water flow. The water map remains as initialized. Downstream systems assume hydrology is static unless explicitly changed. In the current game engine, changes to hydrology would only occur via external events or scripts (none of which are present in the base simulation). For example, there’s no seasonal variation of river flow or lake levels, and no floods or droughts simulated. Hydrology is essentially in a read-only state after creation.

5. **Runtime Consumption** → Throughout the runtime of the world, various systems will consume the hydrology info as needed:
   - Rendering continuously uses it to draw water (but Hydrology itself isn’t producing new info).
   - Ecology might periodically refer to it (e.g., an animal AI might seek water from the nearest river, using the hydrology data to find that). However, since the data doesn’t change, these are straightforward lookups.
   - There is no feedback loop where, say, a particularly dry year would shrink a lake and then ecology updates – such dynamic interactions are absent in current state.

The current producer/consumer map can be visualized as a simple directed acyclic graph of data flow at world creation:

Morphology (Terrain) → provides base data to → Hydrology (Water placement) → produces water data to → Ecology and Rendering (and other minor consumers).

There is no arrow coming back into Hydrology from any consumer; nor is there an ongoing cycle. This underscores that right now Hydrology functions as a derived dataset from terrain, augmented by some static rules, rather than an active simulation domain. The causality is one-way: terrain and config cause hydrology outcomes, which then influence ecology – but hydrology is not truly influencing terrain or changing with ecology in return.

## Greenfield Delta Notes

Comparing the current-state evidence above with the Phase 0.5 greenfield vision, we identify several critical gaps and constraints. These highlight what must change to achieve a physics-driven, deterministic, dynamic Hydrology pipeline:

- **Static Snapshot vs Dynamic Simulation:** Delta: Currently water distribution is a one-time snapshot, whereas the ideal design calls for continuous, time-stepped hydrological simulation (water moving through the environment each tick or season). The absence of any runtime update in current Hydrology is a huge gap. Implication: We will need to implement core simulation capabilities (e.g. fluid flow, water balance over time). The engine must transition from treating water as static scenery to a dynamic element governed by physical laws (conservation of mass, flow rate equations, etc.).

- **Author-Driven Overrides:** Delta: Presently, authorial input can heavily influence or even override hydrologic outcomes (manual river placement, arbitrary humidity tweaks for biomes). In a physics-driven model, these “thumb-on-the-scale” interventions are to be eliminated. Hydrology outputs should be deterministic derivations of inputs (terrain, climate, etc.) alone. Implication: Any current pipeline stage that allows manual adjustment will be removed or made optional for debugging only. Instead, we’ll expose high-level “knobs” for authors (such as global wetness, sea level, or perhaps toggle for certain features), but these knobs will feed into physically-based parameters (e.g., a wetness knob might scale the precipitation input, rather than directly painting rivers). This retains some measure of creative control but within the bounds of the simulation – ensuring consistency and repeatability.

- **Upstream Climate Input Gap:** Delta: There is no true climate or weather input driving Hydrology today. The greenfield model envisions Hydrology being driven by precipitation (rain, snow) and evaporation, likely supplied by a Climate domain or at least a stochastic weather generator. Implication: We must introduce an upstream Climate/Atmosphere domain or equivalent data source. In the interim, a simplified rainfall model can be embedded in Hydrology, but long-term it should be its own domain feeding into Hydrology. The lack of this input in current state is a constraint; when implementing, we’ll need to plan either to create this domain or generate rainfall patterns within Hydrology as a first step. Additionally, concepts like seasonality and climate zones need to transition from static config (current state) to dynamic generation.

- **Downstream Ecology Interaction:** Delta: Ecology currently uses static water presence and a hacked humidity parameter to determine biomes. In the target design, Ecology should react to actual hydrological conditions – e.g., soil moisture, water table depth, river flow rates – provided by the Hydrology simulation. Implication: We will need to adjust Ecology’s inputs and possibly refactor Ecology alongside Hydrology. The biome definitions might shift from fixed humidity classes to thresholds on real metrics (e.g., a plant requires at least X mm of rainfall or a water table within Y meters of surface). The current coupling via static maps will be replaced by queries into the Hydrology model. This likely means new interfaces or data structures (for example, Hydrology could expose a function like getSoilMoistureAt(point) or getNearestWaterSource(point) for Ecology to call, instead of Ecology storing its own humidity field).

- **No Terrain Feedback (Morphology):** Delta: In the current system, water doesn’t alter terrain (no erosion or sediment deposition). The greenfield plan expects a more coupled system where Hydrology and Morphology interact (e.g., rivers eroding riverbeds, depositing silt, possibly changing course over long time). Implication: This is a complex addition and might not be fully realized in the first refactor iteration, but it is noted as an ideal. At minimum, the new Hydrology should be designed with the possibility of feeding back into Morphology. For example, we might want to mark areas of high runoff that could trigger an erosion module or at least flag terrain for later updates. The absence of this in current state is not an immediate blocker for refactoring Hydrology itself, but it is a downstream change-candidate: eventually implement a Morphology update slice to incorporate hydrological erosion. In the short term, the new Hydrology will still operate on a fixed terrain, but we will remove any hard assumptions that terrain is immutable – paving the way for future interactive coupling.

- **Domain Boundary Realignment:** Delta: The current fuzzy boundaries (Hydrology vs Morphology vs Ecology responsibilities) must be corrected. Specifically, Hydrology will own all water flow and distribution logic in the target model:
  - River and lake generation logic will migrate fully into Hydrology (no more in Morphology’s worldgen code). Morphology will simply supply terrain; Hydrology decides water flow on it.
  - Climate will provide precipitation, but the routing of that water across terrain is Hydrology’s domain (instead of current worldgen doing both rain distribution and flow).
  - Ecology will consume outcomes, but not dictate them. We will remove things like biome-implied humidity feeding back into water placement (if such coupling exists). Instead, causality goes one way: hydrology determines moisture, which ecology uses.
  - Any content design influences on hydrology will be via formal inputs (e.g., an authored climate scenario or a sea level setting) rather than direct placement. This clarifies the separation: content can set initial conditions or broad parameters, but cannot micromanage the water output.

- **Determinism and Repeatability:** Delta: Author interventions and legacy randomness mean that currently two worlds with the same seed and config might still diverge if manual tweaks are applied inconsistently. The new design insists on determinism – given the same seed and high-level parameters, the hydrology simulation should produce the same result every time, purely driven by algorithmic processes. Implication: We will remove non-deterministic steps. If any current aspect relies on non-seeded randomness or external adjustment, it must be reworked. For example, if the old worldgen had a random element in river carving not tied to the world seed, that will be made seed-bound or replaced with physically based variation. This ensures the hydrology outcome is reproducible and testable.

- **Legacy Feature Deprecation:** Delta: All identified legacy surfaces (static water map, humidity proxies, manual edits, etc.) will be retired. The new hydrology model will have its own state (water levels, flows, etc.) which should serve all purposes. Downstream systems needing those data must migrate to use the new model’s outputs. For instance, if previously a gameplay system checked a “hasWater” flag on a tile (from the old static map), it should be updated to query the new hydrology domain’s state (which might be dynamic). Backward-compatibility shims are discouraged – instead, we’ll do direct migration because maintaining parallel systems can cause inconsistency. This is in line with our invariant of no compat layer within the refactored domain. Any temporary mapping (like converting old biome humidity to new moisture) will live downstream (e.g., in Ecology) and be clearly marked for removal once consumers fully switch to the new model.

These delta notes underscore the transformation needed: from a coarse, largely hand-crafted setup to a fully algorithmic, physics-based hydrology system. Upstream, it means incorporating or creating climate inputs and removing human fudging; downstream, it means empowering other systems with richer data and possibly demanding they change to use it. The current-state analysis has revealed where the biggest gaps are – particularly the lack of climate input and the extent of manual influence – so our refactor plan must explicitly address those areas.

## Lookback 1 – Reflections on Current-State Analysis

Performing this Phase 1 analysis has clarified the starting point and validated the urgency for change. We found that the current Hydrology domain is far from the greenfield ideal, with multiple structural issues:

- The evidence of heavy manual involvement (designer-placed rivers, static parameters) confirms that one of our primary refactor goals must be removing these crutches. Fortunately, these interventions are mostly add-ons to the pipeline; by cataloging them now (e.g., the manual river data), we can plan to eliminate them or replace them with algorithmic equivalents. There is little internal logic tying them in knots – they can be cleanly removed, which is encouraging for implementation.
- The absence of a climate input was anticipated in Phase 0.5, and this analysis reinforced that point. We’ll likely need to introduce a simplified rainfall generation in the Hydrology refactor if a full Climate domain is out of scope initially. This will be noted in the implementation plan as either a dependency or a stub to implement.
- We also note some semantically poor boundaries in the legacy design (like Hydrology logic in Morphology’s process). Seeing this spelled out in the inventory has helped us identify what to untangle. We will have to be careful when extracting river generation from the terrain generator – it’s doable, but we must ensure not to break terrain generation in the process. A strategy might be to let Morphology continue to call a hydrology module during worldgen, but that module will be refactored and relocated into Hydrology’s ownership.
- No major surprises were found that contradict the greenfield model – rather, all current shortcomings line up with what we expected to improve. This alignment means our Phase 0.5 vision remains largely valid; we did not find any legacy feature that would desirably persist contrary to the new approach. For example, we didn’t discover any complex water-related system that we weren’t already planning (which could have added scope). Everything appears to be either a simplistic placeholder or a hack that we are prepared to handle.
- Finally, this lookback highlights the path forward: the current-state mapping will directly inform our Phase 2 modeling. We now have an explicit list of what to fix or redesign. We will proceed to define the new Hydrology domain model knowing exactly what legacy elements to replace. Additionally, understanding current data flows allows us to plan the migration for each consumer (ensuring, for instance, Ecology smoothly transitions to the new water data without losing functionality in the interim).

In conclusion, the Phase 1 analysis confirms that the Hydrology vertical refactor is both necessary and well-justified. It provided a clear inventory of the status quo and a checklist of gaps to address. With this foundation, we are ready to move on to Phase 2, where we will design the authoritative new Hydrology model guided by both our ideal vision and the realities uncovered here.

(End of Phase 1 Spike: Hydrology Current-State Analysis. The next step will be Phase 2 – Modeling Spike, to design the target-state model.)
