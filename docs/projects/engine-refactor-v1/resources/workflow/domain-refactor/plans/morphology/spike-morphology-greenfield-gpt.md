# Morphology Domain Refactor — Phase 0.5 Greenfield Pre-Work Spike

> **HISTORICAL SPIKE / NOT CANONICAL**
> This is Phase 0.5 exploratory greenfield thinking. Canonical Phase 2 spec surfaces live in `plans/morphology/spec/` and win on conflict.

**Purpose**: Do earth-physics-first, greenfield Morphology thinking before current-state mapping (Phase 1) or target-state modeling (Phase 2), so those later phases are not biased by legacy implementation shapes.
This spike treats Morphology as the canonical owner of Earth-derived “shape truth.” It focuses on how tectonic forces and geophysical processes create landforms, coasts, and seafloors, independent of legacy code or narrative overlays. Morphology’s domain is purely physical terrain formation (land and underwater), excluding climate, biomes, or gameplay/story overlays.

## References:

- Workflow & templates (canonical): `resources/workflow/domain-refactor/WORKFLOW.md`[1][2]; Phase 0.5 template: `resources/workflow/domain-refactor/references/phase-0-greenfield-prework.md`[3]
- Domain architecture (canonical): `docs/system/libs/mapgen/architecture.md`[4][5]
- Morphology domain definition (canonical): `docs/system/libs/mapgen/morphology.md` (conceptual model and current outputs)
- Earth-physics modeling posture: `resources/workflow/domain-refactor/references/earth-physics-and-domain-specs.md`
## Scope guardrails (do not violate):
- No current-state mapping here. Do not inventory legacy files or describe how current code works – that is Phase 1’s job. This document is unconstrained by existing implementation.
- No contract or schema locking here. Do not commit to specific artifact names, data schemas, or how many stages/steps the Morphology pipeline will have. We capture the conceptual outputs and causal structure; concrete contracts come in Phase 2/3.
- Phase 2 is up for grabs. We are imagining the ideal Morphology model from scratch. Legacy behavior is not authoritative. The goal is to identify what Morphology should do in a physics-first world, even if it means changing upstream or downstream expectations.
- No narrative overlays. Treat any “story” or narrative terrain modifications as legacy-only. Morphology will not produce or consume narrative overlay artifacts[6]. Any legacy coupling to “story” concepts must be identified for removal or replacement with canonical physical signals.

## Authority stack (for this spike)
### Canonical sources (internal):
- MapGen architecture – domain boundaries and causal order[4][5]
- Morphology domain spec – (if available) domain’s intended meaning and surfaces
- Foundation domain spec – upstream tectonic model (plate tectonics generation)
### External references (earth-physics background & algorithm research):
- National Geographic: Basics of mountain formation at convergent boundaries[7][8]
- Red Blob Games: Procedural planet generation (Voronoi plates, simple plate tectonics)[9][10]
- LeatherBee Games blog: Hybrid plate tectonics + noise approach for continents and coasts[11][12]
- D’Andrea (GitHub): “Three Ways of Generating Terrain with Erosion Features” – comparative analysis of fractal noise vs. simulation vs. ML[13][14]
- (Above external sources are for inspiration and validation; they are not treated as prescriptive requirements.)

## Greenfield domain narrative (earth-physics-first; unconstrained by existing code)
Morphology’s north star is a tectonics-driven, erosion-refined world terrain model that produces a believable, geologically consistent planet surface. In a greenfield design, Morphology would generate terrain features through the same fundamental processes that shape Earth’s surface over eons: continental drift, mountain uplift, volcanic activity, and erosion. The result should be a deterministic, tunable heightfield that exhibits realistic continents, oceans, and landforms – explained by underlying plate interactions and surface processes, not arbitrary noise.
### Key capabilities and qualities of a physics-first Morphology:
- Plate-aware landform generation: Major landforms like mountain ranges, island arcs, rift valleys, plateaus, basins and trenches emerge from plate tectonic interactions. For example, converging plates form extensive mountain chains (orogeny)[7], subducting oceanic plates create volcanic arcs and deep ocean trenches, diverging continental plates form rift valleys or new ocean basins, and diverging oceanic plates form mid-ocean ridges. Morphology should capture these patterns (spatial placement and orientation of ranges, ridges, trenches) in a plausible way[9][10].
- Elevation structure & relief: The domain produces a full elevation map (heightfield) with appropriate large-scale relief: continents that stand above ocean basins due to buoyant crust, high mountain ranges where crustal compression occurs, broad plateaus or shields in stable continental interiors, and detailed local relief shaped by erosion. It must also include bathymetry – the underwater terrain – such as continental shelves (shallow coastal seas around landmasses) and abyssal ocean plains with trenches at subduction zones[15]. The land/ocean boundary (coastline) emerges from this elevation model by applying a sea level threshold. The shape of coasts should be irregular and varied (not purely noise, but influenced by geology and sea-level changes), including features like bays, peninsulas, and archipelagos that result from partial flooding of low-elevation areas and sculpting by erosion.
- Geomorphic lifecycle and realism: Morphology simulates not just instantaneous formation but the lifecycle of terrain. Mountains should have varying ages – e.g. young ranges steep and jagged, older ranges worn down – reflecting erosion over time. Volcanoes and volcanic landforms (calderas, lava plateaus, island chains) appear in logical places: at subduction zones (e.g. ring of fire volcanoes) or hotspots (intraplate island chains). Large igneous provinces or plateaus can result from sustained volcanism. Over millions of years, uplift and subsidence alternate: e.g. collision causes uplift, while long-term erosion and crustal cooling cause subsidence of basins and continental margins. Morphology’s output should implicitly encode these histories in the shapes (e.g. presence of alluvial plains or sediment-filled basins adjacent to ranges suggests long erosion). Even though the generator doesn’t simulate time per se, it should produce features consistent with having a geological history.
- Erosion and deposition: Unlike purely “raw” height generation, Morphology incorporates erosional processes to shape terrain. Water and gravity gradually wear down mountains and transport sediment to lowlands and coasts. This yields realistic river valleys, deltas, and smooth rolling hills in contrast to unweathered peaks[14][16]. The terrain model should show dendritic drainage patterns (branching river networks carving valleys) and deposition in basins (filling in lakes or inland seas with sediment)[16]. The presence of broad floodplains, gentle coastal plains, and endorheic basins (inland drainage with salt flats) are desirable outcomes. Overall, the heightfield after erosion is more self-similar and fractal (small-scale variability emerges from the erosion process), avoiding the “all scales look the same” boredom of pure fractal noise[13][17].
- Deterministic and tunable: Given the same input seed and config, Morphology produces the same terrain every time (deterministic generation). However, it exposes semantic knobs (controlled random variations) that map to meaningful changes in the world: e.g. number and size of tectonic plates (affects continent count and mountain distribution), global “mountainousness” or relief intensity, sea level height (fraction of land vs ocean), and erosion intensity (how rugged vs smooth terrain is). These knobs allow authors or game settings to influence the terrain style in intuitive ways (e.g. “very mountainous world” vs “low-lying world”) without breaking physical consistency. Morphology will not offer direct “paint a mountain here” overrides – terrain emerges from simulation parameters, not hand-placed features, to maintain causal consistency. In short, authors influence initial conditions and global biases, not specific outcomes[18].
- Explainable terrain (no “black-box magic”): Every major feature in the generated landscape should have an explainable cause in the model. If a huge mountain range exists, it should be traceable to a convergent plate boundary or hotspot uplift in the model. If a desert basin sits below sea level, it might be an enclosed basin with high evaporation and no outlet (endorheic, possibly climate-driven but formed by subsidence). Downstream domains (Climate, Ecology, Narrative) should not have to treat terrain as arbitrary – they can rely on Morphology’s outputs and metadata to know why a region is high or low, rugged or flat. This also means eliminating any hidden “story” interventions: e.g. legacy MapGen might have added “narrative” height tweaks (like a pre-made canyon for a story) – those must be removed. Instead, if gameplay needs a canyon, it should either emerge from natural river erosion or be handled explicitly downstream in a controlled way. Morphology’s truth must be canonical physical truth, not a blend of story-driven adjustments[6].
- In summary, the ideal Morphology is Earth-like terrain generation: continents and oceans shaped by plate tectonics, refined by erosion, and output as a clean set of physical data layers for the rest of the pipeline. This unlocks credible downstream behavior (realistic climate patterns responding to mountains and oceans, logical biome distributions, etc.) and removes the need for ad-hoc adjustments later. The anti-pattern to avoid is using pure Perlin/fractal noise as a surrogate for geology – instead, we strive for an appearance judged by physical plausibility, not just “looking random enough”[11][17]. Morphology should be where raw planetary physics is translated into a playable map’s shape.
## Executive vision (pipeline capability unlocked)
If Morphology is redesigned in this physics-first way, it becomes the bedrock for all other world simulation domains. Downstream systems will, for the first time, trust that the terrain is physically meaningful and stable, rather than having to add their own corrections. A canonical Morphology unlocks:
- Consistent climate modeling: Hydrology/Climate can rely on proper topography and coastlines – e.g. mountains are where they should be relative to plate collisions, meaning the climate model will naturally produce rain shadows and orographic rainfall in the right places[7]. Also, including bathymetry enables realistic ocean current simulation (shallow continental shelves and deep ocean trenches influence currents)[19]. No more guessing or globally tweaking rainfall because terrain is “noisy” – the terrain itself carries the causal signals for climate to read (e.g. elevation gradients, distances from ocean, etc.).
- Richer biome and resource logic: Ecology can derive soil and biome patterns from Morphology’s outputs. Fertile plains vs rocky highlands can be determined by sediment depth and erosion factors produced by Morphology, rather than static altitude or latitude alone. Resources (e.g. minerals, river fish, mountain passes) can be allocated based on real landform types. The pipeline can achieve finer differentiation (e.g. distinguishing a high plateau vs. a coastal plain vs. a young volcanic island) because Morphology provides the data behind those distinctions.
- Elimination of legacy narrative hacks: In legacy systems, if designers wanted a dramatic feature (say a “giant rift valley” for story), they might have had to manually impose it or rely on a random chance. With Morphology’s tectonic basis, such features will exist naturally when conditions warrant (e.g. divergent plate boundaries create rift zones). Narrative and placement systems can then discover and utilize these features, instead of injecting them artificially. This reduces the need for special-case code or post-generation modifications to terrain for the sake of story. In effect, the world comes pre-loaded with interesting realistic motifs – mountain ranges, island arcs, fertile deltas, etc. – that narrative can build upon in a controlled way (tagging or highlighting them), rather than inventing them from scratch.
- Simplified downstream contracts: A canonical Morphology means downstream consumers (like Hydrology, Ecology) can simplify or remove their own terrain-processing code. For example, if Morphology outputs a ready-made flow routing network (or at least the elevation and slope needed to compute it), the hydrology domain doesn’t have to redundantly compute water flow from scratch. If Morphology provides a continental shelf mask, a narrative domain might not need separate logic to find shallow seas for coral reef stories. In general, more data reuse and less recomputation becomes possible, as Morphology’s products become the single source of truth for anything related to terrain shape.
In short, a physics-grounded Morphology domain unlocks the pipeline’s full potential to simulate an Earth-like world. It provides a stable foundation so that climate behaves believably, biomes make sense, and even gameplay scenarios (like starting positions or “natural wonder” placements) can be aligned with real geography rather than arbitrary map quirks.

## Boundary sketch (ownership vs. neighbors)
Morphology is one layer in the broader map generation causal chain. This section clarifies what Morphology owns versus what its neighboring domains own, in a greenfield (ideal) architecture. It also shows what Morphology produces as outputs and what it consumes as inputs, relative to others. (Bold indicates this domain.)

- Morphology–Foundation boundary: Foundation provides the tectonic blueprint (plates and forces), while Morphology provides the realized topography. Foundation does not output actual heightmaps – it gives the abstract inputs (where and how crust should be uplifted or thinned), and Morphology uses that to construct terrain. For instance, Foundation might mark a boundary as “convergent with X amount of compression”; Morphology then creates a mountain range along that boundary. Foundation might label a plate as “oceanic, young” vs “continental, old”; Morphology uses that to set a lower baseline elevation for ocean crust (since older, cooler oceanic plates sit lower in the asthenosphere). In the target design, Foundation and Morphology are decoupled but sequential – Foundation doesn’t “call” Morphology, it just publishes data that Morphology reads. Morphology’s outputs in turn should not feed back into Foundation (no circular dependency).
- Morphology–Hydrology boundary: Morphology provides immutable terrain; Hydrology must take it as given (no altering elevation, except possibly a future minor feedback like glacier carving which would be an explicit two-way model outside this refactor’s scope). This means Hydrology’s job is to simulate water and climate on the terrain. If rivers carve canyons or deposit sediment over geological time, that is conceptually Morphology’s domain (the outcome of erosion). In practice, this refactor will treat fluvial erosion as mostly handled in Morphology’s generation of the heightfield. Hydrology may still compute river paths and possibly adjust river channels, but it shouldn’t be altering the base elevation significantly – any such adjustments (e.g. carving a river valley) should be minimal or fed back in later if needed. We therefore have to decide clearly which domain owns routing geometry (the flow directions and basins). Option 1: Morphology outputs a flow network (based purely on topography), and Hydrology uses it to route water and classify river sizes. Option 2: Hydrology generates the flow network itself from the heightfield (and thus implicitly might identify any needed carving). In the ideal model, double-computation is wasteful, so one domain should own routing. We’ll address this in the design (see Upstream/Downstream diff). Aside from routing, Hydrology will consume things like Morphology’s slope steepness (for orographic rainfall, runoff rates) and land/sea distribution (for ocean vs land climate). Conversely, Morphology will not consume climate data – e.g. desert dunes or glaciers forming is downstream’s concern; Morphology might create a high plateau but doesn’t decide it’s a desert, that’s Hydrology/Ecology.
- Morphology–Ecology boundary: Ecology cares about substrate and terrain only to the extent it influences life. Morphology should provide any abiotic substrate characteristics that matter for life. In greenfield terms, Morphology would output something like a soils/erodibility map: e.g. areas of deep fertile sediment vs bare rock. Ecology would use this along with climate to determine biomes (e.g. distinguishing a rocky highlands vs a fertile valley even if both get similar rainfall). Currently, Ecology might be misusing raw elevation or slope as a proxy for soil (e.g. assuming low-lying = fertile by default). In the new model, we prefer to give a more direct signal. However, Ecology itself will classify biomes and place vegetation – Morphology does not output any “biome” or vegetation info. Also, Morphology’s outputs like elevation can indirectly affect Ecology (for instance, Ecology might have altitude-based biome transitions – e.g. alpine tundra above a certain height – which it can compute from the elevation field). We ensure Morphology provides the needed raw data, and Ecology remains a pure consumer of it.
- Morphology–Narrative boundary: In the target state, Morphology does not recognize narratives at all. Any current entanglement (like a “story overlay” that requires Morphology to shape terrain in a particular way) must be removed. Narrative can still do things after Morphology – e.g. tag a particular mountain range as “The Spine of the World” in lore – but Morphology isn’t aware of that. If the legacy system had any backdoor where a narrative element could force a terrain change (for example, a game scenario that demands a pass through mountains and thus flattens a tile), that must be routed differently (perhaps as a Placement override or a separate step outside core Morphology). For this refactor’s scope, we treat narrative overlays as forbidden influences[6]. We will identify any such couplings in Phase 1 current-state and plan their removal or replacement. The only output Morphology might share that narrative cares about is some form of diagnostic overlay or metadata describing the terrain (like “this chain of mountains forms a continuous corridor of length X”). But even that should ideally be formalized as a physical metric (e.g. length of continuous ridge) rather than a narrative label. Likely, narrative will compute its motifs from Morphology outputs on its own.

## Ideal subdomain decomposition + causality spine (internal structure of Morphology)
Even though Morphology remains a single domain (single stage in the pipeline), internally we can think of it as a sequence of sub-processes that follow the causal logic of planet formation. The causal spine for Morphology might be broken down as follows (each sub-bullet is an internal “submodule” or step):
- Initial Crust & Baseline Elevation – Using Foundation’s inputs, Morphology starts by establishing a baseline elevation for each tectonic plate or region. This includes distinguishing continental vs oceanic crust. For example, assign continental crust regions a higher base elevation (perhaps even above sea level, creating landmasses) and oceanic crust a lower base (below sea level) because oceanic plates are denser/thinner and “sit lower” in the mantle (isostasy). Foundation likely provides a crust age or type signal: e.g. plates marked as older might sink more[20]. This step could involve generating an initial smooth heightfield per plate: e.g., each plate is given a random average elevation based on type (continents ~1 km above datum, oceans ~ -4 km, with some randomness). This sets up broad continents and ocean basins before any detailed features. We may incorporate long-wavelength noise or gradients here to avoid perfectly flat plates, but the key is that this stage respects plate boundaries (no blending across them yet). Essentially, think of it as generating “hills and basins” at a planetary scale – continents vs oceans – aligning with the plate map.
- Tectonic Uplift & Depression (Orogenesis) – Next, apply the tectonic forces from Foundation to modify the elevation, focusing on plate boundaries and hotspots:
- Convergent Boundaries (Collision Zones): For each convergent plate boundary (where plates push together), raise mountain ranges. The model might allocate an uplift amount proportional to the convergence rate and the types of crust colliding. Continental–continental collisions produce the tallest, broadest ranges (like the Himalayas)[8][21]. Oceanic–continental collisions produce coastal ranges with volcanic peaks (e.g. Andes), plus a trench offshore where the oceanic plate subducts. Oceanic–oceanic convergence forms island arcs (curving chains of volcanic islands) and trenches. We create these features by adding elevation along the boundary line (e.g. a ridge of high elevation) and possibly slightly inwards on one or both sides (for broad crustal deformation). We also carve a trench if appropriate (a narrow steep depression at the subduction line, possibly making adjacent ocean very deep). This step yields continuous mountain belts at collisions.
- Divergent Boundaries (Rifting Zones): For separating plates, lower the elevation at continental rifts or raise it for mid-ocean ridges. Divergent continental plates can form rift valleys or even new oceans: we simulate this by creating a linear valley or series of graben (long narrow depressions) along the boundary. Divergent oceanic plates (mid-ocean ridges) get a submarine mountain range due to magma upwelling – a ridge that might be just below sea level (or even above in rare cases). So we add a modest elevation bump along divergent ocean boundaries. In both cases, divergent boundaries also tend to thin crust – so around continental rifts, terrain might sag forming basins. We ensure any new ocean basin has a shallow shelf near edges (proto-continental margins).
- Transform Boundaries: Where plates slide past each other, there is less vertical motion. We don’t add much elevation; maybe some local linear depressions or shear valleys could be introduced for realism (like the Dead Sea Rift or transform fault valleys), but this can be minimal or omitted at this conceptual stage.
- Hotspots & Intraplate Uplift: Not all mountains come from plate edges. Hotspots (fixed magma plumes) can create volcanic island chains (e.g. Hawaii) or continental flood basalts. We incorporate a randomized set of hotspot uplifts: e.g., take a few random locations (perhaps seeded by Foundation or just by global config) and create a volcanic center (raise a mountain/volcano there). If on oceanic crust, it may form an island (or island chain if the plate moves – we might emulate an age progression, e.g. a line of seamounts decreasing in elevation away from the current hotspot). If under continental crust, it might form a volcanic plateau or a cluster of volcanoes. This adds isolated peaks or small ranges that are not on plate boundaries, diversifying terrain.
- Regional Deformation & Plate Interiors: Also consider broad warping of plates: e.g., far from boundaries, plates could bend due to distant stresses or thermal subsidence. For instance, interiors of very large plates might be slightly bowl-shaped (basins) or dome-shaped (epeirogenic uplift). We might apply a gentle warping noise or a few large-scale up/down features beyond the explicit boundaries, to avoid completely uniform plate interiors. Foundation’s “tectonic force field” could include hints like areas of uplift or subsidence within plates (though usually major effects happen at boundaries).
- By the end of this step, we have a heightfield with all major tectonic landforms: mountain ranges, plateaus, rift valleys, ridges, trenches, etc., placed logically according to the plate map. The planet now has the “bones” of its terrain.
- Surface Shaping & Erosion Simulation: With tectonic heightfield in place, Morphology then simulates erosional processes to refine and sculpt the landscape. This is crucial for realism – it carves river valleys, creates deltas, smooths overly sharp features, and produces sediment deposits[14][16]. This subdomain can be further broken down:
- Hydraulic Erosion (Water Flow): Simulate rainfall and runoff over the terrain. Conceptually, water flows downhill, eroding soil/rock from high ground and depositing sediment in low areas. We can use a simplified rainfall-runoff model: e.g., drop a notional uniform rain over the map, compute flow directions (down the gradient) and water accumulation. As water flows, remove a bit of material (erosion) where flow is strong (steep + high volume) and deposit where flow slows (flat areas or where rivers meet oceans). This could be done via iterative simulation[22][23] or a procedural approximation (e.g., calculate flow accumulation and erode proportionally to (slope * flow)). The effect is that river channels incise into mountains (creating valleys and drainage basins) and sediment builds up in valleys and deltas (raising those areas slightly or flattening them). Over many iterations or a strong single pass, this yields realistic networks of valleys and gently sloping floodplains branching into larger rivers[16]. We must be careful not to overdo it – we want to retain major mountain height but carve out the details.
- Coastal Erosion & Sediment Redistribution: Apply special attention to coasts. Waves and tides erode cliffs and spread sediment along coasts. In simulation, this can be approximated by smoothing out very sharp coastal gradients and creating continental shelves: shallow coastal sea floors around continents. We could implement a rule where shallow ocean cells (within a certain distance of land) are raised or lowered to create a gentle slope (e.g., everything within, say, 50 km of coast goes linearly from 0 at shoreline down to -200m at shelf edge, before dropping to deep ocean). This yields a realistic sharp drop-off at the shelf break[15]. Sediment from rivers often accumulates at river mouths, forming deltas or coastal plains. We simulate that by slightly elevating terrain at major river outlets (or extending the coastline outward locally). Similarly, we might fill in small incised areas below sea level that should realistically be coastal estuaries rather than deep pits.
- Thermal Erosion (Slope Relaxation): Simulate the effect of gravity on rock: steep slopes gradually collapse (landslides, rockfalls), making sharp peaks more rounded over time. Implementation: identify slopes beyond a certain steepness and reduce the slope (move material from steep cliffs to the base). In practice, one can iterate: if any cell has a slope above threshold, redistribute some height from that cell to its lower neighbors. This smooths jagged peaks and ridges, turning them into more natural shapes. It also widens mountain bases with talus slopes. We should preserve the highest summits but rid them of unrealistic needle-like spikes or pits.
- Karst/Subsurface (optional): This would be things like sinkholes or cave systems from chemical erosion – probably too fine-scale for our scope. We likely ignore this except perhaps generating a few random depressions in limestone regions if we had geology types (out of scope).
- Deposition & Soil Formation: After erosion, lowlands and basins often accumulate thick layers of sediment, which become fertile soils. We model a sediment depth or “substrate thickness” layer. Essentially track how much material was deposited in each cell. In simulation, every eroded unit from mountains goes somewhere – ideally to a downstream cell or ocean. So we can accumulate sediment in flats. This yields a map of sediment depth (thick in river valleys, deltas, lake beds; thin on mountain tops). We will output this as it’s useful to Ecology (for fertility) and also to Morphology itself (for knowing erodibility in the next iteration – more sediment yields faster erosion vs hard bedrock is resistant). In a simple approach, we might assume mountains have near-zero sediment (exposed bedrock), and any deposition from the water simulation is our sediment map.
This erosion phase can be computationally heavy (repeated iterations over the map) but is vital. The outcome is a heightfield that looks “aged”: mountain ranges are dissected by valleys, volcanoes might have carved calderas and surrounding aprons of ash, and large flat plains exist where sediment settled (often at continental interiors or downstream of mountains). The fractal nature of real terrain largely comes from this network of erosion-created features[14]. We effectively overlay the tectonic “bones” with erosion “flesh”, achieving a balance between structure and randomness.
- Coastal & Oceanic Refinement: After main erosion, ensure coastal consistency. Adjust the land/sea boundary if needed: e.g., ensure all enclosed depressions below sea level are either filled with water (if endorheic basin, maybe we leave a salt lake) or raised if not desired. Likewise, remove any tiny isolated one-tile oceans within land (likely fill them as lakes or land). Essentially, do a flood fill check: what is connected to the global ocean vs what is inland water? Mark inland water bodies (lakes) separately from the sea mask. This yields a cleaner land/sea mask with identified lakes. Also finalize the continental shelves as mentioned (we might do the BFS smoothing of coastal ocean to create nice shelves[24] if not fully handled in erosion). This stage might also generate or finalize archipelagos: small island groups near coasts or hotspots. Erosion might have turned some coastal mountains into islands if sea level inundated around them; we ensure those look reasonable (maybe add a bit of noise to island heights to differentiate them).
- Microterrain & Noise Details: Finally, apply a controlled amount of small-scale noise or fractal detail to avoid the terrain looking too smooth or too “generated” in obvious ways. While major features are physics-driven, nature also has randomness at smaller scales (local variations in rock hardness, past glaciations scouring some valleys, etc.). We can add high-frequency perturbations to the heightfield (e.g. Perlin noise with a small amplitude, or domain-warped noise to emulate local chaotic features)[25]. The key is to ensure this does not upset any physical invariants. We would avoid introducing any new local minima that would trap water incorrectly, for example. Possibly apply noise before the erosion step so that erosion can naturally incorporate it (this might already be done implicitly if we seeded initial elevation with some noise). In any case, final detail passes can break up perfectly smooth surfaces (like large flat plains can have gentle undulations, etc.) and also help hide any grid artifacts.
- These submodules reflect the causality: crust age influences initial height, which combined with plate interactions gives raw mountains and basins, which then undergo erosion to yield the final landscape. In implementation, Morphology might not literally have separate code modules for each – some could be combined or iterative (e.g., one could simulate plates and erosion together in small increments). But logically, any design we choose must address all these components in some way to reach the target outcome.
- To highlight: the causal spine is Foundation → [Morphology builds base continents/oceans] → [Morphology raises mountains (orogeny), forms rifts and trenches] → [Morphology erodes and smooths] → finalize. This ensures every step’s output is physically plausible for the next. For instance, we wouldn’t do erosion before mountains exist, and we wouldn’t finalize coasts before erosion, etc.
## Candidate algorithmic strategies (terrain shaping approaches & tradeoffs)
There are multiple possible approaches to implement the above subdomains. At this greenfield stage, we do not commit to one; instead, we catalog the leading strategies and discuss their trade-offs:
- A. Full Physics Simulation (High-Fidelity, Time-Stepped): We could attempt to literally simulate plate tectonics and erosion over (simulated) time. For example, initialize a random plate configuration and then iterate: move plates gradually, apply collisions incrementally raising terrain, run erosion continuously in parallel (with some rainfall model). Given enough iteration steps, mountains and basins organically form and rivers naturally carve terrain. This approach has the highest realism – features “emerge” from physical rules rather than being explicitly designed[26]. However, it’s computationally very expensive. Simulating even a simplified plate tectonic process on a grid or mesh requires many time steps (it’s essentially an O(N³) or worse problem: N steps for N-wide map to propagate effects across the world)[27]. Parameter tuning is also extremely complex (“parameter hell”)[28] – dozens of physical constants (friction, viscosity, rainfall rates, etc.) need calibration, and small changes can yield very different outcomes. The unpredictability can be a downside for a game generator where we want control. This method may be more scientifically satisfying but likely overkill for our needs and too slow for generating many maps. Still, lessons from it are useful – e.g., understanding that mountain chains and realistic river networks will require iterative refinement, not one-pass arithmetic.
- B. Rule-Based Procedural Generation (Empirical/Analytical): This is almost the opposite of A: use a series of algorithmic rules and noise functions to directly “paint” the world, ensuring the rules encode our desired physics. For example, define an analytical function for mountain height along plate boundaries (maybe a Gaussian ridge where plates collide)[29][30], add random perturbations to mimic complexity, then carve rivers by a deterministic drainage algorithm (e.g., choose outlets and route water). This approach gives a lot of direct control: we can design each feature type separately to look good. Classic procedural terrain often sums fractal noise for overall shape then applies heuristic adjustments for things like ridges or valleys[25][31]. The LeatherBee approach is an example: hard-code the structural bones, then overlay noise[12]. Trade-offs: It’s computationally cheap (no iterative sim; mostly arithmetic and maybe a few BFS passes) and easy to tune specific aspects (we can tweak a formula for mountain height directly). The downside is ensuring consistency among all these rules – one can end up with terrain that looks realistic but has no deep consistency (the “pile of patches” problem[32]). Empirical methods may need many special cases to avoid unnatural results. For instance, you might manually ensure that every convergent boundary on an oceanic plate also gets a trench and an island arc – doable, but it’s up to the code to enforce all such correlations, whereas a sim would naturally produce them. There’s also a risk that heavy use of noise (to hide patterns) can reintroduce the very arbitrariness we want to avoid. In summary, rule-based generation can achieve a good approximation of physical landscapes with far less computation, but it requires careful design and might still miss some emergent phenomena (like the subtle integrated drainage patterns).
- C. Hybrid Approach (Simulated Backbone + Procedural Refinement): Likely the sweet spot for us is a hybrid. We let simulation handle the most critical interdependent processes on a coarse scale, then use procedural methods to refine detail. For example, we could simulate plate tectonics in a simplified manner: treat each plate as a rigid body, push them for a few iterations to accumulate large-scale deformation. One known approach is using a Voronoi graph for plates and a simple overlap calculation for mountains[33][34] – essentially “if plates overlap, lift terrain” (some implementations exist, like Viitanen 2012). This can yield a first-order mountain heightmap at boundaries. We’d stop short of a full physics sim – just a basic approximation. Then, for erosion, we might run a limited iterative water flow simulation for, say, a few hundred iterations on a smaller height grid (or multi-resolution: coarse simulation to shape big rivers, then refine). This would produce major river basins and some realistic erosion forms without needing geologic time scales. After that, we apply procedural enhancements: add fractal noise to create fine detail on slopes, do analytic adjustments for coastal shelves (like LeatherBee’s BFS smoothing for coasts[24]), etc. The hybrid aims to capture the best of both worlds: ensure the broad structures (mountain ranges, continents, main rivers) are consistent via simulation, but fill in the micro-structure and exact shapes with faster algorithms. The trade-off here is complexity – we need to implement multiple techniques and make sure they blend seamlessly. We also must avoid double-counting processes (e.g., not eroding away all the mountains our plate simulation raised). If done well, this could yield very authentic results and keep generation time reasonable. Tuning might be easier than full sim since we constrain the sim part and then can tweak the procedural part.
- D. Data-Driven or Machine-Learned Terrain Generation: Although less traditional in deterministic game pipelines, one could imagine training a GAN or other model on real-world elevation data and using it to generate terrain[35][36]. This approach (some research has done it) can produce extremely realistic-looking terrain patches[37]. However, it’s not easily controllable – it might be hard to enforce that the generated map has a specific number of continents or a mountain exactly where you want. It’s also expensive to train and not easily explainable (we wouldn’t have explicit “plate” data to share downstream – it’s all implicit). Given our need for explainability and stable contracts, ML-based generation is likely not appropriate for Morphology at this time. It’s worth noting as an idea, but we will likely not pursue it for the engine (it could perhaps help in a research context to validate terrain features, but not as the deterministic method in production).
- E. Existing Libraries/Algorithms: There are also existing algorithms like the diamond-square for quick fractal terrain (not realistic enough alone), or specialized algorithms like river-first carving (generate river networks then shape terrain around them)[38][39]. River-first is an interesting alternative strategy: decide where rivers go (maybe by randomly generating a tree graph) and then elevate land such that those rivers make sense (ensuring mountains between river basins). This ensures good water flow but might sacrifice tectonic realism. It could be combined with plate approach (i.e., use plates to place mountains, then adjust slightly so that realistic rivers form). We keep such options in mind but they’re variations on the above themes.
For now, no selection is made – but the likely path is a hybrid (C) leaning on simpler plate sim + erosion, with carefully added noise. The Phase 2 modeling spike will delve deeper into which combo to implement. We will maintain an emphasis on approaches that yield explainable, parameterized outputs (so strategy B and C are favored over a pure black-box sim or ML). We’ll also consider performance: e.g., if erosion sim is too slow at full resolution, maybe run it on a downscaled heightfield to get general patterns, then upsample with noise (this can drastically speed up runtime while preserving large rivers).
Trade-off summary: Simulation (A) gives realism but is slow and hard to control; Procedural (B) is fast and controllable but risks physical incoherence; Hybrid (C) tries to balance them, likely the best route. We’ll validate this in modeling. It’s important that whichever approach we choose, it honors the domain boundaries (only uses Foundation inputs, only produces Morphology outputs, no cheating with hand-drawn templates or hidden overlays).
## Parameterization posture (config knobs vs. forbidden overrides)
In the new Morphology design, all configuration should be semantic and physically grounded, not arbitrary tweaks to outputs. This domain will likely have two layers of configuration:
Advanced Config (internal, typed settings): These are detailed parameters that have default values based on geophysics. Examples: number of tectonic plates, or distribution of plate sizes; global sea level (or percentage of world that is ocean); target elevation range (min/max height extremes); erosion aggressiveness; mountain “ruggedness” factor (perhaps controlling how jagged vs smooth ranges are); maybe toggles for certain processes (enable volcano hotspots or not, etc.). These are not meant for casual scenario tweaking in normal gameplay – they are more for map generation presets or variant world types. They would appear in config schemas with defaults, and we’d document their meanings (e.g. “plates: 20” means roughly 20 plates will be created). These advanced configs shape the simulation behavior in a physically interpretable way. We ensure each has a default that yields an Earth-like balance, so authors don’t have to set any of them if they just want a standard world.
High-Level Knobs (author-facing): These are simpler controls that map to combinations of advanced parameters in a meaningful way. For instance, an author slider “World Mountains” could internally scale the uplift factors or adjust how high mountains can get. A “World Erosion” slider could increase/decrease the erosion iteration count. “Landmass Count” knob might influence number of plates and perhaps ensure that many small plates = many continents vs fewer big plates. The key is these knobs do not directly edit the output (they don’t say “place mountain at (x,y)”), they adjust the generation parameters. The knobs should be orthogonal and semantic: adjusting one should have a predictable thematic effect without bizarre side-effects.
What is forbidden is any sort of authored outcome override that bypasses physics. For example, giving the map maker the ability to force a specific tile to a certain height (“I want a peak here, regardless of plates”) is not allowed in the core generation. That would break the model’s consistency and is akin to old narrative overlays. If absolutely needed for a scenario, that might be done after generation or via a narrative domain injection, but Morphology itself won’t support “pinning” or manual edits. Another forbidden concept: preset “biome templates” that alter terrain (like making an area flat because it’s supposed to be a desert) – climate should handle desertification, not Morphology.
We also avoid mixing concerns: e.g., no climate parameters here. A user shouldn’t find a “Rainfall” setting in Morphology config – that belongs in Hydrology. Morphology’s parameters strictly relate to terrain shape generation.
In practice, we might implement this posture by having Morphology’s ConfigSchema contain mostly physical parameters (plateCount, seaLevel, erosionRate, etc.) with documented defaults. Then in game setup UI, only a subset of them (or combinations) are exposed as simple options. Importantly, the defaults should produce a believable Earth-like world without needing any user tweaks. The knobs are there to explore variety (e.g. “Low Sea Level world” or “Archipelago world” etc.) and for modders to create special world types.
One more aspect: random seed usage. The random seed of the map gen should drive unpredictable variation, but we ensure it only influences things within the physical model’s scope. For example, the random seed will randomize plate configurations, hotspot locations, noise perturbations, etc., but it won’t bypass physics. Two different seeds yield two different worlds, both following the same rules. This means we should avoid using randomness to do something like “randomly decide to ignore erosion this time” – that would break invariants. Instead, randomness just provides initial conditions variety.
Finally, traceability: because no overrides are allowed, any difference between two worlds is explainable by either different seeds or different config. There is no hidden “fudge factor” that one world had triggered and another didn’t. This clarity will help phase 2 modeling and testers to verify that if, say, an author says “I want more mountains”, we can point them to increasing the mountain knob, rather than them discovering a mysterious constant in code to tweak.
## Upstream inventory (current): what exists today that Morphology can consume
(This is an “outside view” of currently available inputs, which Phase 1 will verify and detail. It lists known or likely upstream outputs that Morphology uses. We assume these from documentation and architecture, but will confirm actual code in Phase 1.)
- From Foundation domain (tectonics provider): Today, Foundation provides some or all of the following artifacts and data to Morphology:
- Plate partition map: An identifier for each tectonic plate per region (e.g., a foundation.plates artifact). Morphology uses this to know which regions move together. Likely represented as an array mapping each cell to a plate ID.
- Plate motion vectors or “dynamics”: Foundation likely outputs information about plate movement directions and speeds (perhaps a foundation.dynamics artifact). This could be per-plate or even per-region. Morphology might use this to infer boundary types (if neighboring cells belong to different plates and their vectors are toward each other, it’s convergent, etc.). Legacy code mentions a “directionality” concept; possibly this is an encoded form of plate motion.
- Boundary identification: There may not be a formal artifact listing plate boundaries yet (in legacy, Morphology might deduce boundaries by scanning the plate map). But possibly Foundation or some interim step produces overlay tags for boundaries (e.g., a list of boundary segments or an overlay artifact marking fault lines). We will have to generate this if it’s not given.
- Crust type or age signals: It’s not clear if current Foundation explicitly labels plates as oceanic vs continental or provides crust age. The architecture doc suggests Foundation produces “crust/material signals” and “plate kinematics”[4]. Possibly there is a foundation.crust artifact planned (in refactor slices) for crust properties. In current state, Morphology might be using some heuristic (like plate size or random assignment) to decide which plates become continents. There is likely an internal default like “largest plates become continents” or a random seeding.
- Region mesh and global constants: Foundation is responsible for the basic map geometry: the graph of regions (likely a Voronoi-like mesh or hex grid) and global parameters like world wrap (is it a wrapped globe or not), map size, etc. Morphology obviously uses the mesh to propagate heights and identify neighbors for erosion. Also, things like the world’s circumference or area scale (to interpret distances) come from upstream. We assume these are available via context or base artifacts.
- Large-scale invariant signals: From architecture[40] and hydrology docs, Foundation might output some “large-scale drivers” such as latitude (the y-coordinate on planet) or a tilt or orientation. Morphology may not directly need latitude, but it might indirectly if, for example, we want to set sea level based on ice caps or something (though likely not). Generally, those are more for climate.
- Legacy narrative/overlay surfaces: Upstream domains might have provided some overlay info that Morphology could consume or ignore. For instance, if Foundation had any concept of “preferred elevation” or a narrative seed (like a pre-defined idea of a special region), Morphology might have hooks. We suspect not – narrative overlays usually come later. Morphology should treat any such inputs as non-authoritative. If current code uses something like ctx.artifacts.get('story/someOverlay') from Foundation, that’s a red flag to remove. We’ll document them in Phase 1 if found.
- From docs/system/libs/mapgen/architecture.md (which outlines intended pipeline surfaces) we gather: Foundation outputs region mesh, plate partition, crust hardness/age signals, tectonic force fields[4]. We believe currently the force fields might not be fully realized as data – it could be partly hardcoded or implicit (like code directly raising mountains where plates meet, rather than passing a “force” field). So Morphology likely computes some of this itself today. For example, legacy Morphology might loop over edges of plates to create mountains (meaning Foundation didn’t explicitly say “mountain here” except via plate map).
- From pipeline-wide context (not a domain per se, but base system): The architecture doc and hydrology spike mention region adjacency graph, latitude and wrap as globally available[41]. Morphology will use adjacency heavily (for erosion simulation, flow calcs). It likely calls into core utilities for neighbor lookups. We consider those as given (they are not domain outputs but base data). Additionally, an “overlays container” exists globally for story overlays, but Morphology’s physics model does not consume overlays (it should ignore that)[41].
### In summary, today Morphology can consume:
Plate IDs per cell (from Foundation).
Plate motion info (some form of vectors or boundary classifications, if available).
Possibly plate boundary type enumerations (if Foundation provides a BOUNDARY_TYPE stable contract as planned[42] – not sure if implemented yet).
Basic world mesh and neighbor connectivity (from core).
- Possibly an initial coarse height or crust thickness map (if any exists – likely not, Morphology probably starts heights itself).
Possibly some substrate initial conditions (foundation might hint at crust thickness which correlates to isostatic height).
Phase 1 will check the actual Morphology code to see how it determines continents and mountains currently – whether it uses direct Foundation outputs or its own random decisions. Any gaps we find will inform our “requirements (ideal)” below.
(One note: The Hydrology Phase 0.5 document listed an “Upstream inventory” from Morphology. It included things like “topography buffers (elevation, land/sea mask, optional bathymetry)” and “routing geometry” as outputs of Morphology that Hydrology could consume[43]. It also mentioned Foundation provides “tectonic/relief hints and crust properties” mainly used by Morphology[44]. That aligns with our understanding here: foundation has tectonic hints, Morphology does the heavy lifting of relief creation.)

## Upstream requirements (ideal): what Morphology would want from upstream in a greenfield world
In the ideal scenario, Foundation (and any upstream system) would provide everything Morphology needs to generate terrain without workarounds or guesswork. While Morphology can compute a lot internally, certain upstream data would dramatically improve realism and reduce duplication. Key needs:
Explicit plate boundary and motion data: Instead of Morphology deducing boundary types from scratch, Foundation should ideally output a structured description of plate boundaries. For example, a list of boundary segments or adjacency pairs with attributes: convergent/divergent/transform, relative speed, and which side is subducting (for conv.)[45]. This would let Morphology directly know where to create mountains vs trenches vs rifts, and how intense. If not a list, at least a per-edge or per-cell field like foundation.tectonics that encodes convergence magnitude or similar. Currently, Morphology might calculate this by comparing plate velocity vectors; having it precomputed is simpler and avoids inconsistency.
Crust classification map: A field that marks regions (or plates) as “continental” or “oceanic”, and possibly a numeric crust thickness or density. This can guide initial elevation and also how a collision is handled (continental vs oceanic collisions differ). It could be part of foundation.crust. If not binary, then an “age” or “thickness” value per region suffices (older crust = thicker/colder = more likely continental, though geology is complex). The ideal is that Morphology doesn’t have to randomly choose which plates are continents; Foundation (or initial config) determines it based on plate age or a parameter. In an Earth-like scenario, some plates start with continental cores. In procedural, maybe Foundation can simply assign randomly with probabilities or based on plate size. We want that decision exposed rather than hidden.
Uplift driver fields: Instead of Morphology computing something like “convergence force”, Foundation could simulate a coarse tectonic stress field. For example, a grid of “uplift rate” and “subsidence rate” across the map, computed from plate motions. Morphology would then just apply that as a displacement on the heightfield. This is conceptually ideal – Foundation handles physics, Morphology executes shape. However, implementing that might be as hard as Morphology doing it internally. Perhaps more feasible: Foundation can output point forces – e.g. “at this boundary line, apply X uplift”. In any case, some representation of tectonic force distribution upstream would prevent duplicating the plate mechanics inside Morphology.
Plate age and temperature context: If available, a value like plate age could allow Morphology to calculate isostatic height differences. (As mentioned, ocean floor depth relates to age due to cooling – older ocean plates ride deeper, creating abyssal plains, younger near ridges are shallower[20].) If Foundation provided each plate’s age or each region’s time since creation, we could use the actual empirical age-depth curve rather than arbitrary values. Similarly, if any notion of mantle plume/hotspot potential is given (maybe foundation marks 1-2 hotspot locations), Morphology can raise volcanoes there deterministically.
Base sea level or water volume: This might come from a higher-level config rather than Foundation per se, but Morphology ideally should know the intended sea level. In a perfect world, upstream could specify something like “sea level = 0 (units), which should result in 71% water coverage” (if Earth-like). If not provided, Morphology might have to decide sea level itself to hit a target ocean fraction or use a default. Perhaps it should be a pipeline constant or from game settings. We list it here as required input: either upstream (foundation or global) provides sea level or desired ocean fraction.
Planet size and resolution details: Confirmed as needed (foundation already gives mesh, but just to note: if the pipeline supports different world sizes, foundation must generate appropriate mesh resolution. Morphology needs to know scale to calibrate features – e.g., on a smaller map, might reduce plate count or mountain width accordingly). Possibly an explicit “map scale” parameter.
Stable IDs or references for plates and boundaries: If Morphology is to produce outputs like “mountain range associated with plate A-B collision”, it would help if plates have stable IDs and boundaries have identifiers. Not strictly needed for the generation itself, but useful for traceability or if we want to keep track of features by their tectonic origin. Upstream could thus give each boundary segment an ID (like “boundary 5: Plate 2 vs Plate 7, convergent”). This is more a nice-to-have for debugging/story.
In essence, Morphology needs upstream to hand off the “tectonic design” of the world: the geometry of plates, their motions, and what kind of crust they carry. Today’s upstream likely gives some but not all of this, requiring Morphology to assume or guess (for instance, legacy might guess ocean vs land). Greenfield stance: push as much of that as reasonable into upstream so Morphology can focus on terrain per se.
Additionally, one upstream issue from Hydrology’s perspective: bathymetry availability. Technically, bathymetry is Morphology’s output (terrain underwater), but hydrology listed it as an upstream need for them[19]. To ensure that, Morphology either must generate bathymetry or Foundation could provide an initial one. More logically, Morphology will generate it. So perhaps the upstream requirement is: foundation should allow negative elevations (sea floor) and treat them consistently. E.g., ensure the mesh supports below-zero altitude and that subsequent domains won’t crash if elevation is negative. Possibly in current state, some parts might assume elevation = 0 at ocean tiles. The requirement is to remove any such assumption upstream or in core.
One more ideal upstream thing: No legacy overlay coupling. Upstream (especially Foundation or core code) should not impose any narrative constructs on Morphology. For example, if the old system had a concept of “directionality” or “world age” that indirectly influenced Morphology, we need clarity. Actually, the Foundation refactor acceptance criteria included removing “directionality” coupling[46]. That suggests previously Foundation might have had a global flag or context that changed how Morphology behaved (maybe making terrain different on poles vs equator artificially?). We want upstream to be clean and just give physical data, not story cues.
### Hard dependencies (ideal upstream):
- Plate boundary dataset: Morphology requires a clear data structure for tectonic boundaries (types and intensities of convergence/divergence) so it doesn’t reinvent plate interactions.
- Crust type/age map: So that base elevation and isostatic differences can be correctly applied (continents vs oceans).
- Plate motion vectors: Ideally already given per plate or per boundary, to avoid recomputing relative motion from scratch.
- Sea level parameter: Provided by upstream config or foundation (if foundation sets a default hydrosphere volume for world). This ensures consistent land/ocean ratio as designed.
- Foundation outputs accessible via stable contracts: No reaching into Foundation internals – everything Morphology needs should be on a defined interface (e.g., deps.artifacts.foundation.plateGraph, foundation.tectonics, etc., per the plan to add artifacts like mesh, plateGraph, etc.[47]).
### High-value (but maybe optional) upstream helpers:
- Pre-computed distance-to-coast or landmass identification: If Foundation or core can compute the connected components of land after Morphology sets land, that’s more downstream. Actually, Morphology would compute that since it determines land/sea. So not upstream.
- Global constants: Already given (mesh, etc.).
Perhaps *foundation could pre-mark certain regions as “initial mountains” like if a microplate exists? But that’s essentially the boundary data.
If these ideal inputs aren’t currently available, they represent gaps that justify upstream changes in the refactor. We will enumerate them in the next section.

## Upstream diff (greenfield gaps → upstream change candidates)
These are potential upstream changes (in Foundation or core systems) identified from the above “wants vs haves”. They are not immediate commitments but will be considered in the overall refactor plan. Each addresses a gap between what Morphology ideally needs and what the current pipeline likely provides:
- Provide a structured tectonic boundary data artifact: If not already present, add an output in Foundation such as foundation.tectonics or foundation.plateBoundaries that lists all plate boundary segments with their type (conv/div/trans) and a measure of relative velocity or convergence rate. This would greatly simplify Morphology’s task of locating where and how much to uplift[48]. (If providing a full structure is too complex, at least provide per-cell or per-edge flags for boundary type and an intensity scalar.)
- Add crustal property output (if missing): Ensure Foundation publishes something like foundation.crust which encodes crust type (oceanic vs continental) or thickness for each region. Morphology will use this to set base elevations and to determine which side subducts in ocean-continent collisions (usually oceanic plate subducts under continental). If current logic is implicit, making it explicit will avoid hardcoding assumptions in Morphology.
- Expose plate motion vectors or forces: Ensure that Morphology can get plate motion info easily – e.g., foundation.plates might include a velocity vector for each plate. Or a foundation.velocityField giving each region’s motion (which is basically the same info). If not, Morphology has to calculate it from scratch, which is duplication. Also, define clearly the coordinate system (so Morphology knows how to interpret these vectors on the map projection).
- Define a stable sea level input: Decide where the sea level is set. One approach: as part of world config, a parameter seaLevelOffset is given to Morphology (e.g., 0 means default Earth-like). Alternatively, base it on an intended percentage of water. If currently the generator doesn’t formally manage sea level (it might just mark whatever is below height=0 as water), consider introducing a config that upstream passes. This would allow scenarios (like “Waterworld” with high sea level or “Pangaea” with low sea level) in a controlled way. The change is to treat sea level as an explicit input rather than a hardcoded constant.
- Upstream fix for double routing computation: Not exactly upstream to Foundation, but a pipeline decision: decide if Foundation or Morphology should compute any initial water drainage. Possibly Foundation could compute drainage basins off a coarse topo for geology (some plate models do that to simulate sediment movement). If Foundation isn’t doing that, then the duplication is between Morphology and Hydrology. This is more of a cross-domain decision than a pure upstream change, but from Morphology’s perspective, the gap is “we both might be computing river networks”. We list it to ensure Phase 2 addresses it (see downstream diff as well).
- Ensure foundation outputs are accessible contract-first: Currently, Morphology (legacy) might reach into foundation’s internals for needed data (e.g., using ctx.artifacts.get('artifact:foundation.something') directly in code, as indicated by Foundation refactor removing that[49]). The change needed is to formalize those as contract artifacts. This mostly is being handled by the Foundation refactor slice: e.g. after that, Morphology would access deps.artifacts.foundation.mesh etc. Our note here is simply that if we identify any such hidden coupling in Phase 1, we must rely on upstream to expose it properly. For instance, if Morphology currently calls a foundation function to get neighbor lists or such, that should become an artifact or utility.
- In summary, the biggest upstream gap is data richness: we need Foundation to output richer tectonic context (boundary classifications, crust types). The refactor plan for Foundation (which likely runs in parallel) should incorporate these as new artifacts (and indeed, the Foundation slice plan does mention new artifacts like foundation.mesh, foundation.crust, foundation.plateGraph, foundation.tectonics[47][50], which aligns perfectly with these needs). We will coordinate with that to ensure Morphology gets what it needs.

## Downstream outputs (ideal): what Morphology should provide downstream
(Conceptual list of Morphology’s outputs in the target design. No specific data schemas yet, just the content and purpose. These outputs form the contracts that downstream domains (Hydrology, Ecology, etc.) will consume. Note we separate public vs internal surfaces in the next section.)
### Core Terrain Outputs (authoritative):
- Elevation Field (Heightmap): The fundamental output – a scalar elevation value for every map region (or grid cell). This is likely a buffer that’s also published as an artifact (so others can read it). It includes both positive (land above sea) and negative (below sea level) values, or a separate depth field for oceans. Elevation is the primary input for climate (e.g. temperature lapse rates, orographic rainfall) and for any pathfinding or gameplay that depends on terrain height. It must be consistent (no NaNs, etc.), typically in meters or a normalized unit. This field essentially encodes mountains, hills, plains, ocean floors, etc.
- Land/Sea Mask: A boolean or categorical field distinguishing land vs water for each region. While this can be derived from elevation (elevation > 0 = land, if we set sea level = 0), it’s useful to output explicitly for clarity and for any code that treats it as a separate artifact. This mask helps Hydrology (to know where to generate ocean currents vs land climate, to identify coastlines), Ecology (to restrict biomes – e.g., no forest in ocean cells), and Placement (e.g., to place only naval resources in sea). If the world has lakes, the mask might have categories: e.g. 0 = ocean water, 1 = land, 2 = inland water (lake) – or lakes could be included as “land” or “sea” depending on usage. Ideally, we might output a water mask that marks all water bodies, and perhaps label which are ocean vs lake if needed.
- Bathymetry/Depth Field: If we decide to keep elevation as a unified field (with negative values), a separate depth may be redundant. But some systems might prefer a separate “depth” artifact for oceans (positive depth value or absolute value of negative elevation). The hydrology domain explicitly requested bathymetry for ocean modeling[19]. So likely we’ll provide it. Possibly as part of a combined artifact (e.g. a single ElevationGrid where positive is height and negative is depth) or two artifacts (land heightmap and ocean depth map). Implementation aside, the effect is that downstream gets to know how deep each ocean cell is – crucial for calculating ocean currents and also for placement (e.g., certain features might only spawn in shallow water vs deep ocean).
- Slope and Aspect (Derived from elevation): We can output fields like slope magnitude (steepness) and aspect (direction of slope) for each cell. Slope can be computed from the elevation field and mesh geometry. Hydrology might use slope to compute runoff or orographic lift, Ecology might use it for soil retention (steep slopes = thin soil). If not as standalone artifacts, these could be embedded in some terrain metadata artifact.
- Flow Direction and Flow Accumulation (Drainage Network): If Morphology is to own routing, it will provide a map of where water would flow. Typically:
- Flow direction grid: each cell points to one of its neighbors (the downhill direction where water flows out).
- Flow accumulation: for each cell, how many upstream cells drain through it (a proxy for river size). These can be encoded as arrays (flowDir maybe an int coded neighbor index; flowAccum an integer or float count). If Hydrology decides to own routing, these become internal (Morphology wouldn’t publish them). But in an ideal one-owner scenario, having Morphology publish them is efficient. A stable drainage network means hydrology can just take it and assign river volumes based on precipitation. Alternatively, if Hydrology is to recompute, Morphology might still provide hints like a preliminary river network (maybe as an overlay or diagnostic). But for clarity, in ideal outputs we lean one way to avoid duplication. Let’s assume Morphology does provide routing geometry (since architecture doc listed “slope/flow routing intermediates” as Morphology outputs)[5]. This includes:
- River network overlay/graph (if more advanced): potentially identify connected river paths and outlets. This might be more detail than needed, as Hydrology can derive from flow directions anyway.
### Terrain Metadata Indices: These are ancillary outputs to help downstream categorize terrain:
- Landmass ID map: Label each connected land region with an ID (1,2,3...). E.g., all contiguous land cells form a continent or large island cluster. This helps Ecology and Narrative: e.g., Ecology might treat large isolated landmasses differently for species distribution, Narrative might ensure each continent gets a certain story or check that all civs don’t start on one continent (that might be Placement though).
- Distance-to-Coast field: For every cell (especially land cells), compute shortest distance to an ocean (or large water). Hydrology flagged this as useful for climate (continentality index)[51]. Ecology might use it for biome (coastal vs interior biomes), Narrative might use it to find inland empires etc. If it’s expensive to recompute repeatedly, providing it once here is helpful.
- Terrain Ruggedness or Roughness: A measure of local elevation variability (e.g., standard deviation of elevation in a neighborhood). Ecology could use that to decide e.g. “mountainous terrain” vs flat for certain biomes or animal distributions. Narrative might use it to find broad “mountainous regions”. If not used immediately, it can still be a nice diagnostic (e.g. to classify terrain types).
- Basins and depressions identification: Identify any endorheic basins (inland depressions with no outlet). This could be an index or list of cells that are local minima. Hydrology upstream suggestions included a “basin/valley index from Morphology’s depression fill analysis”[52]. If Morphology runs a fill algorithm to ensure no spurious pits, it can mark those pits. This helps Hydrology know e.g. where internal lakes might form (or where to not expect a river to reach ocean). Possibly a binary mask “endorheic = yes/no” per cell or a list of basin regions.
- Volcanic/Geologic feature markers: Not strictly needed as a separate output, because downstream can infer from context (like if a peak is at a subduction zone, narrative might call it a volcano). But we might output a list of coordinates for major volcano peaks or geothermal zones (if our model generated them), as part of an overlay or artifact. Ecology might use that for soil richness (volcanic soil) or Narrative for placing a “volcano” wonder, etc. This is borderline narrative, but could be considered canonical if it’s purely physical (volcano = a mountain with certain shape perhaps).
- Overlay of mountain ranges or other formations: This drifts into narrative territory, but if done systematically it can be part of Morphology diagnostics. E.g., an algorithm to group contiguous high elevation cells into “ranges” and output their centerline or bounding box. While narrative can compute it themselves, having it here ensures they all use the same definition of a “range” or “valley”.
- The above metadata should be considered diagnostic or secondary – the primary needed outputs remain the heightfield, masks, and routing for physical behavior. But including some of these can greatly help downstream without them needing to reinvent logic (e.g., every domain computing distance-to-coast independently is wasteful).
### Substrate & Material Outputs:
- Sediment Depth / Soil Layer Map: A grid of how much sediment or soil covers each location. After our erosion simulation, we have this information. We output it as, say, a float or integer (maybe in meters of sediment, or a relative scale 0-1 for “rocky vs deep soil”). Ecology will use this as a basis for vegetation productivity (deep soils = fertile, thin soils = sparse vegetation). Hydrology might use it for infiltration (areas with thick sediment might absorb more rain before runoff, for example). It also could inform where wetlands form (thick sediment flats might become swamps if wet). This output links geology to ecology.
- Rock Hardness / Erodibility Map: Possibly related to the above, but could be separate: an estimate of the underlying rock strength or erodibility at each cell. For example, maybe Morphology knows that a certain region is made of granite (hard) vs another of sandstone (soft) if we had geology layers. In absence of detailed geology, we might approximate erodibility from context (mountain cores = hard, sediment plains = soft). We could output an erodibility coefficient that hydrology uses in river modeling (so water flows faster through soft alluvium but not through hard rock easily). However, if we lack explicit geology domain, this may be too fine. Alternatively, treat this as “soil vs bedrock” binary from sediment depth (thick sediment implies soft surface, zero sediment implies exposed bedrock/hard).
- Terrain “tags” for special geomorphs: E.g., mark volcano locations, karst regions, etc., if we have that info. Possibly out-of-scope to formalize, but if Morphology generates volcano peaks, tagging them helps (for placement of volcano-specific features like geothermal resources or narrative events).
### Explainability/Diagnostic Outputs (for downstream introspection):
- Downstream domains, especially Narrative and Placement, might not only need the data but also some “reasons” to latch onto. While not formal requirements, Morphology can produce explainability artifacts that aren’t strictly needed for simulation but are helpful: - For example, a “why high” factor: for each high mountain cell, a breakdown: X% of its height came from tectonic uplift vs Y% remains because not eroded fully, etc. That might be overkill, but more simply, we could categorize mountains by origin: e.g., tag some as “collision range”, others as “volcanic peak”. Narrative might then treat them differently (collision ranges are long corridors, volcano peaks are isolated wonders). This is speculative – might be done in narrative domain by analyzing outputs instead.
- However, one explicitly mentioned in Hydrology’s outputs was “why factors” like rain-shadow factor etc. Those are more climate. Morphology’s version could be a “ridge orientation factor” or a “coastal influence factor” per cell – but those bleed into climate too.
- For now, we’ll keep Morphology’s outputs mostly quantitative. Downstream domains can combine them to get their needed signals.
- Note: We will carefully separate which of these outputs are public (for other domains) and which are internal in the next section.

## Public surface vs internal-only (ideal): classification of Morphology’s outputs
Morphology in target state will produce a variety of data, but not all should be exposed as stable contracts to other domains. Some are purely intermediate or for debugging. Here we classify the outputs listed above:
- Public (stable, consumed by downstream domains): These are part of Morphology’s official API – other domains rely on them: - Elevation heightfield – Public. Consumed by Hydrology (climate & rivers), Ecology (biome altitudinal effects), Placement (terrain analysis), etc. This is a core artifact (e.g., artifact:morphology.elevation). - Land/sea mask – Public. Consumed by Hydrology (ocean vs land climate), Ecology (no biomes in sea), Placement (where to put naval starts, etc.). Could be implicit via elevation sign, but likely an explicit artifact:morphology.landMask (e.g., a boolean map). - Bathymetry/depth – Public. Consumed by Hydrology for ocean currents and ice formation[19], possibly by Placement (for differentiating shallow vs deep water resources). Provided as artifact:morphology.bathymetry or combined with elevation. - Flow routing network – Public (if Morphology owns routing). If we decide Morphology provides flowDir/flowAccum, those become consumed by Hydrology (so it doesn’t have to recompute rivers), and possibly by Narrative (for motifs like “great river”). This would be artifacts like morphology.flowDirection, morphology.flowAccumulation. If we decide Hydrology will compute its own, then Morphology would not publish these (they remain internal or are not computed at all here). The decision will be locked in Phase 2. For now, we assume one path or the other – if not public, they are internal. - Sediment/soil map – Public. Primarily for Ecology (to determine soil richness for biomes, e.g., rainforest want deep soils, etc.), possibly Hydrology (groundwater or infiltration in future). Published as artifact:morphology.sedimentDepth or similar. - Erodibility/hardness map – Public if we provide it separately and if downstream uses it. Possibly could be merged with sediment map (e.g., low sediment implies hard bedrock). If it’s distinct (like if geology domain existed, but it doesn’t), it might be less needed. If included, hydrology might use for river modeling. - Landmass IDs & distance-to-coast – Public. These are not strictly required for simulation but extremely useful for consumers (Hydrology, Ecology, Narrative). Hydrology explicitly wants distance-to-coast if not computing it itself[51]. Ecology might use landmass size to influence biodiversity (island biogeography). Narrative can use both for stories (e.g. “inland empire far from coasts”). So likely provide as artifacts: e.g., morphology.landmassIndex (each cell has an ID for which landmass), and morphology.distanceToOcean (a numeric field). - Terrain ruggedness index – Public if needed by Ecology or Narrative. Could be computed by them from elevation, but providing it saves effort. Not critical, but we may include it. - Basins/endorheic mask – Public. Hydrology would definitely use if provided (to know where to place inland lakes or how to close water budgets). If Morphology knows which areas have no outlet, giving that info (e.g., a boolean per cell “endorheic basin”) is useful for hydrology and maybe narrative (like great salt flats motif). - Volcano locations – Possibly Public. If Morphology generates volcano mountain peaks, we might output a list or mask for them. Ecology could use to place volcanic soil or rare resources, Narrative to mark them as wonders. Alternatively, Narrative can infer by finding the highest isolated peaks or from plate boundary context. Making it public is only needed if it’s not obvious from other data.
- Internal-only (not intended for other domains to consume directly): - Intermediate water flow simulation data: If Morphology runs an erosion sim, it might internally have water level or temporary sediment transport arrays per iteration. These aren’t to be published; only the final results (like updated elevation or sediment) are output. - Temporary buffers like “pre-erosion elevation”: Morphology might keep the original tectonic heightmap before erosion for its own reference or debugging, but downstream shouldn’t use that (they only care about final elevation). So that stays internal (or at most in an internal doc or for testing). - Diagnostic overlays for dev/debug: e.g., an overlay of where uplift was applied, or a heatmap of erosion rates. These are for internal analysis and Phase 2 modeling validation, not for consumption by other domains in production. - Micro feature markers not needed outside: e.g., if Morphology algorithm identifies a particular peak to apply noise, it might label it internally, but no need to output that. - Alternate representations of same data: If we store something in a convenient form internally (say a list of river path polylines for erosion calculation), we likely convert it to a grid output for public use. The list itself might remain internal. - Buffers that are only used within Morphology’s multi-step process: e.g., a buffer for water flow or for sediment at intermediate time steps. These should be treated like “private variables”. According to architecture, such buffers might still route through artifact system during refactor for gating, but conceptually they are internal (with namespacing to ensure other domains don’t accidentally depend). If we do route them (due to current engine limitations) we will mark them as not stable and not to be consumed outside Morphology.
- In short, public outputs are those needed by Foundation’s downstream (Hydrology, Ecology, Narrative, Placement) to do their jobs without duplicating Morphology logic. Everything else stays internal to Morphology. This separation ensures a clean contract.
- One area to clarify: Narrative overlays are strictly not to be produced as public outputs in this refactor phase[6]. So Morphology will not output anything like “overlay: mountainCorridorStory” or such. If any such coupling existed, we remove it. Morphology’s public outputs might indirectly assist narrative (e.g., a corridor overlay could be generated by Narrative by looking at a continuous mountain chain in the elevation data). But Morphology itself only outputs physical truth.
- Thus, for example: - Instead of an overlay overlays.corridors marking a “great mountain range” for story, Morphology provides the physical range (continuous high elevation region) and perhaps a length metric as diagnostic. Narrative can derive the story overlay if needed. - Instead of overlays.riftValley from Morphology, we have a rift valley as a physical low elevation band which narrative or ecology can notice (maybe ecology notices it as a distinct biome due to local climate difference).
### Intended consumers of each public output:
- To make it explicit: - Elevation, landmask, bathymetry: consumed by Hydrology (for climate & sea currents), Ecology (for altitude effects, mountain vs lowland biomes), Narrative (for identifying geographic features), Placement (for accessibility, e.g. can a starting settler traverse or blocked by mountain). - Flow network (if public): consumed by Hydrology (to place rivers and calculate flow volume), Narrative (they might designate a “major river corridor”), Placement (spawn civilizations near rivers). - Sediment/soil: consumed by Ecology (soil fertility for biomes, e.g. rainforest on deep soils, barren on rocky), possibly Hydrology (for infiltration / wetlands). - Landmass ID & distance-to-coast: Hydrology (distance-to-coast influences climate humidity), Ecology (coastal vs inland biome differences, island biogeography), Narrative (continent-based stories, e.g. “Old World vs New World” narrative needs to know continents), Placement (ensuring players are distributed across continents maybe). - Basins (endorheic): Hydrology (to decide that rainfall in that basin doesn’t reach ocean -> forms a salt lake or internal drainage biome), Ecology (endorheic basins often deserts or salt flats, e.g. could influence biome), Narrative (could place a “mysterious inland sea” story). - Ruggedness: Ecology (fauna/flora distribution might differ in rugged areas), Placement (maybe avoid starting positions on extremely rugged terrain unless desired). - Volcano tags: Ecology (special volcanic soil biome maybe?), Narrative (natural wonder like “Mt. Doom”), Placement (maybe avoid starting too close to active volcano? if that’s a concept).
- Ensuring others don’t misuse internal stuff: We will clearly document which artifacts are official. In code, we might keep internal ones within Morphology module scope. If some internal buffer must be published (for technical gating reasons), we should name it in a way or put in a namespace that discourages external use, and not list it in contract documentation. Also, our Phase 3 plans can include guardrails (linting) to ensure no other domain imports Morphology internals beyond the contract artifacts.
Finally, as part of refactor, any current surfaces that downstream is using but shouldn’t might be revealed. For example, if currently Ecology directly reads Morphology’s height via a global context instead of via an official artifact, that’s a misuse we need to correct by making sure Ecology uses the new contract. Or if Narrative historically waited for Morphology to produce an overlay, we’ll guide them to use physical outputs instead.
We will note any such cases in Phase 1 consumer inventory and plan to rectify them.

## Downstream enablement (what these outputs unlock for others)
- With the ideal outputs above, downstream domains can achieve improvements:
- Hydrology/Climate: - Gains accurate topographic inputs: The elevation map (with realistic slopes and ranges) allows hydrology to model orographic precipitation properly (wet windward, dry leeward)[53][54]. Complex landforms (e.g. enclosed basins, plateaus) will create more interesting climate patterns (monsoons, rain shadows) that the climate model can simulate because the terrain now provides the triggers. - The inclusion of bathymetry unlocks realistic ocean dynamics: shallow continental shelves vs deep ocean influence water heating and currents, enabling features like warm/cold currents and coastal upwelling that were previously approximated[19]. - Stable drainage network (if provided by Morphology) means Hydrology doesn’t have to guess river paths. It can directly take flow accumulation to decide where major rivers are and assign them flow volumes based on precipitation. This ensures that water flow in climate is consistent with how terrain was shaped (since that network came from morphological erosion). It eliminates the previous duplication or mismatch where Hydrology might have generated rivers differently from how terrain was eroded. - Distance-to-coast index from Morphology helps Hydrology’s climate model produce continental interior dryness properly[51], because it knows how far moisture has to travel from the ocean. - Endorheic basin info allows Hydrology to handle those specially: e.g., no rivers leaving, so any rain that falls there could form a salt lake or just evaporate, which the climate model can incorporate (affecting humidity and biome). - Slope/roughness can be used to modulate runoff: steep terrain might cause faster runoff (less infiltration), which hydrology can integrate into flood modeling or soil wetness calculations. - Ultimately, Hydrology can produce more believable climates: e.g., interior deserts beyond high mountains, monsoon rains on coasts, etc., without adding artificial hacks, because Morphology’s outputs contain the needed cues.
- Ecology: - Better substrate information means Ecology can assign biomes with more confidence. For example, previously it might only use rainfall and temperature, which might mis-classify a high-altitude desert vs a low-altitude desert. Now, with sediment depth and soil data, Ecology can differentiate a rocky desert (thin soil, maybe sparse life) from a loamy plains desert (maybe a former lakebed with salt). Similarly, fertile floodplains (thick alluvial soil + water) can be distinguished from rocky plateaus even if climate is similar. This enables biome placement that reflects both climate and geologic substrate. - Altitude and relief from Morphology allows Ecology to incorporate vertical zonation – e.g., mountaintops might have alpine tundra even in tropics due to altitude. With a precise elevation field, this can be calculated reliably (which in legacy might have been approximated or ignored if elevation was less physically based). - Landmass identification helps Ecology in distributing species and biome variety. Large continents support more biome diversity and can have interior climates significantly different from coasts. Small islands likely have more uniform climate and limited biome ranges. Ecology can use the landmass size to apply, for instance, island biogeography principles (maybe fewer species on smaller islands, or certain biome types not appearing on tiny islands because of insufficient area). - Hydrology’s improvements (enabled by Morphology) also feed into Ecology – e.g., if Hydrology now produces realistic river networks and wetlands due to good terrain, Ecology can place gallery forests along big rivers, mangroves in delta shallows, etc., in the right places. Without Morphology’s contributions, those might have been random or omitted. - Also, erodibility/hardness could tie into where forests vs grasslands grow (deep soil tends to forest, shallow rocky soil might favor scrub). - Volcanic soil fertility: If volcano tags or substrate from recent volcanism are known, Ecology could treat those areas as fertile (volcanic soils are often rich) – enabling special biomes or high-yield tiles. - In summary, Ecology will stop treating terrain as a generic backdrop and start incorporating geophysical context (leading to, say, realistic placement of deserts behind mountains, lush areas downstream of highlands, tundra on high mountains, etc., in a more emergent way).
- Narrative/Playability: - With Morphology producing coherent large-scale features, Narrative design can shift from “injection” to “interpretation”. For instance, if the world gen naturally has a long mountain range spanning a continent, the Narrative system can detect that ridge (using elevation and perhaps landmass continuity data) and designate it as “The Great Divide” with a story. In legacy, if such a ridge wasn’t guaranteed, narrative might have forced it via overlay. Now it can rely on Morphology’s output and just add flavor text or minor adjustments. - Motifs and corridors: The narrative domain often deals with motifs like corridors (paths through mountains, or river valleys that serve as cradles of civilization). With Morphology’s proper rivers and mountain ranges, those motifs exist to be exploited: e.g., a major river valley from mountains to sea can be tagged as a “river civilization corridor” in narrative overlays, giving a gameplay bonus or story. A mountain pass can be identified if Morphology’s data shows a saddle in a mountain range (narrative could scan for lower elevation points along a ridge line). - Natural Wonders & Landmarks: Placement of iconic features (like a giant canyon, a massive volcano, a coral reef) can now piggyback on actual terrain. E.g., if Morphology’s river network has carved a deep canyon in an arid region, the narrative/placement system can recognize that by the combination of high slope, low elevation, arid biome and designate it “Grand Canyon” wonder. If Morphology tags volcanoes, narrative can directly label one as “Mt. Something, legendary volcano”. This reduces the need for random wonder placement or contradictory ones (like previously a “Grand Canyon” might be plopped arbitrarily even if no river exists; now it will only be placed if a real canyon is present). - Balanced Start Locations: Placement domain uses Morphology outputs to ensure fairness – e.g., measure how much fertile land (flat with deep soils) is near each potential start, or how isolated by mountains a start is. With more detailed substrate and landform data, placement can do smarter allocation (like not put one civ completely hemmed by mountains unless that’s intended). It can also intentionally leverage features: spawn a civ in a rich river valley, another near a mountain pass, to create strategic diversity – because those features are definitely there to use. - No negative surprises: With a canonical terrain, narrative and placement won’t encounter as many cases of “feature X is missing”. For example, if a scenario expects at least one large continent or one big desert, Morphology’s processes (with enough randomness and parameter space) likely produce those consistently or allow controlling them. So narrative can rely on “there will be some big desert if climate is arid in interior, we can set a story there” rather than forcibly making one.
In short, Morphology’s outputs give the narrative layer actual geography to tell stories with instead of having to fabricate geography. This should improve immersion and variety of map-based stories.
- Placement (Game starts & resources): - With clearer delineation of terrain types (mountains, plains, valleys, coasts), the placement algorithm can ensure each starting position has a balanced mix (e.g., access to some rivers, some coast, some mountains for defense, etc., depending on civ preferences). - Resource placement often depends on terrain: e.g., certain minerals might be more common in young mountains (morphology can indirectly inform that via rock hardness or volcanic tags). Resources like fish go in shallow waters (with shelf info, we know shallow tiles), etc. The improved physical model thus enables more logical resource distribution (no more fish in a 5km deep trench tile, for example, if we account for bathymetry). - If the game has natural disasters or hazards (volcano eruptions, floods), linking those to Morphology outputs is easier: volcano hazard at identified volcanoes, flood hazard in low-lying basins near big rivers, etc. So placement or simulation of those events becomes plausible.
- One caveat: Downstream domains will need to adapt to using these new outputs and possibly drop old assumptions. For example, if previously Ecology assumed any tile above certain latitude and high altitude is automatically tundra, now it can instead check actual temperature from Hydrology plus altitude; if previously Narrative had a routine “if no long mountain chain, create one via overlay”, that can be removed and replaced with scanning Morphology’s elevation for a chain. We will highlight such needed downstream changes in the next section.

## Downstream diff (implied changes outside Morphology)
- Adopting this new Morphology model implies adjustments in downstream domains. These are changes in how those domains work or what they expect, to align with the canonical Morphology outputs:
- Hydrology must consume bathymetry and ocean geometry instead of assuming a flat ocean. Legacy climate might have treated all ocean tiles uniformly; with bathymetry, hydrology should use it (e.g., for differentiating shallow warm seas vs deep ocean currents). If the current hydrology code doesn’t accept underwater depth input, it needs modification to do so[55]. This might include updating ocean current models to factor depth or adjusting how coastal upwelling is calculated (needing shelf vs open ocean distinction).
- Routing ownership resolution: As discussed, either Morphology or Hydrology will exclusively own river network calc. The diff: whichever domain yields, the other must delete their version. If we decide Morphology owns routing, then Hydrology must delete any duplicate flow calculation. It would instead take Morphology’s provided network and just simulate water volume. If vice-versa (Hydrology owns routing), then Morphology will drop publishing flow artifacts and treat flow purely internal (or not compute it at all beyond erosion). In that case, Hydrology might need to enhance its routing to ensure it matches Morphology’s expectations – e.g., if Morphology’s erosion assumed some drainage that Hydrology must replicate to keep terrain and rivers consistent. This is a coordination issue: we will likely pick one path. The implied change is deletion of one of the two’s routing algorithms and possibly refactoring to use the other’s output[55].
- Ecology should shift from using raw elevation to using climate outputs (which include alt effects) and substrate outputs. For instance, if Ecology currently derives temperature purely from latitude and elevation itself, it should instead rely on Hydrology’s temperature field (which now accounts for orographic cooling explicitly)[56]. And if Ecology has any hard-coded logic like “if tile is mountain (height > X) then biome = tundra”, that should be re-evaluated – climate domain should handle temperature, and we have explicit outputs like freeze index. So the change: Ecology consumes new signals such as:
  - Seasonality, aridity, freeze index from Hydrology (some of which depend on Morphology)[57].
  - Sediment/soil richness from Morphology rather than guessing from flatness. Ecology might also remove any “rainfall re-derivation” – e.g., if it used elevation to reduce rainfall in interior (rain shadow hack) but now Hydrology already gives correct rainfall distribution, Ecology must not override it. In summary, align Ecology’s inputs to the more nuanced ones provided by upstream (which are possible thanks to Morphology). This is more of a Phase 2 for Ecology.
- Narrative must stop injecting terrain changes and instead adapt to reading Morphology’s output for story triggers. Any legacy system where narrative overlays directly altered height (like raising a “story mountain” or carving a canyon for a scenario) needs to be either scrapped or moved to Placement (the final step) as a clearly non-physical tweak. Ideally, in the refactor narrative does zero height modifications and only tags. So the change: remove any coupling like ctx.artifacts.get('morphology.height').set(some pattern) from narrative. If narrative relied on signals that are now gone (like if they looked for a “directionality” field or a legacy artifact that is removed), narrative logic must update to use the new equivalent or drop the concept. For example, if narrative used to check storyOverlaysMargins to place some motif and we eliminate storyOverlaysMargins, narrative should either compute margin from region mesh or not do that motif. Probably just rely on physical signals.
- Placement changes: If new Morphology outputs supply more info, placement algorithms might change criteria. For example, if previously placement forbade starts within X tiles of a legacy “impassable mountain cluster” tag, now it can dynamically evaluate based on elevation and passability from Morphology’s map (maybe we need to define what constitutes impassable more systematically). Or if wonders were placed randomly, they might now be placed at specific morphological features (like highest peak, largest lake, etc.), meaning placement code needs to gather that info from Morphology/Hydrology. So placement’s diff is less removing something and more enhancing: incorporate Morphology’s data as filters/criteria for distributing starts and wonders. One thing to remove might be any compensation code that tried to “balance terrain” – e.g., flattening some area if a civ start was too mountain-locked. With Morphology generating varied terrain and if we handle start distribution better, we might drop those flattening measures, or at least we do them in a more controlled upstream manner.
- Downstream assumption adjustments: If any domain assumed certain ranges of values or did simple thresholds (like altitude categories) these might need recalibration because the new terrain might have different distribution (e.g., possibly higher peaks if we allow more extreme values, or deeper oceans). For example, if Ecology had a hardcoded “if elevation > 8 then it’s snow” (in some normalized scheme), and now elevation scale changed, that threshold might be off. So likely require recalibration of any such constants in Hydrology/Ecology.
- Documentation and consumer contracts: Downstream teams (or code maintainers) must be informed of the new contracts. E.g., “Height is now signed with 0 = sea level; negative means underwater depth up to -Y; do not assume negative means no data.” If legacy code treated negative elevation as absence or clipped it, that must change. Also, if we drop artifacts like legacyHeightWithoutErosion or ctx.artifacts.directionality, any references to those in downstream domain code or tests need removal.
Many of these changes align with points noted in the Hydrology spike’s downstream changes section (like expecting Ecology to use aridity & seasonality indices etc. instead of doing its own)[58], which is indirectly caused by Morphology enabling a better climate.
- To encapsulate: - Downstream will pivot from compensating for terrain limitations to leveraging terrain data. - We will track each needed change (in Phase 1 consumer inventory and Phase 3 planning) to ensure nothing is forgotten. For example, ensure Narrative devs know to remove their hack X, etc. - Some changes might be deferrals if too broad (e.g., fully overhauling Ecology might be beyond Morphology refactor’s immediate scope, but we at least note it).

## Performance + memory reality (what must be bounded in implementation)
Designing a perfect physical model is moot if it can’t run efficiently within our constraints. We identify performance and memory considerations for Morphology:
- Map Size and Resolution: We need clarity on target map resolution (number of regions/cells). Suppose it’s on the order of 10^4 cells (typical Civ map) up to maybe 10^5 for very large maps. The algorithms must handle that within acceptable time (a few seconds ideally, tens of seconds at most for generation). Simulation-heavy steps (erosion, plate movement) often scale poorly (erosion simulation O(N³) as noted)[27]. We must bound iterations. E.g., instead of iterating erosion until equilibrium, pick a fixed small number of passes (just enough to carve main features). We might also run expensive steps on a downsampled grid and interpolate results (sacrifice some micro detail to gain speed).
- Memory for buffers: Each output field (height, flow, sediment, etc.) is often a large array of size ~N (number of cells). If N is, say, 50k, that’s fine (50k floats). If N is 1e6 (maybe extreme huge map), then multiple float arrays might be several MB each (still fine) – modern memory can handle that. But we might have many fields. The crucial part: ephemeral buffers during sim, like if doing water simulation we might allocate waterVolume[N], sediment[N], etc. Those should be freed or reused after use. We should consider reusing arrays to avoid large overhead (e.g., use the same array for water at each iteration, or reuse the memory of a buffer we no longer need, since JS/TS memory might not free immediately). Possibly allow some things to be computed on the fly (like not storing aspect if not needed explicitly).
- Fixed-pass loops: As above, choose fixed small iteration counts for simulation aspects. For instance, decide “perform 100 erosion iterations” rather than simulate 1000 years realistically. Tune that so results are adequate but time is capped.
- Discretized time or space: Possibly treat the map in chunks for heavy calcs (like do erosion in tiles or use multi-resolution layering). Or discretize values (maybe use integer elevation units so calculations are cheaper? Unlikely needed, floats are fine).
- Parallelization / Multi-threading: If the engine supports multi-core, maybe we can parallelize some loops (erosion can be vectorized or run on GPU?). But likely we keep it single-threaded within generation. We can consider vectorized operations (using efficient libraries or algorithms). The “three ways to erosion” article noted ease of vectorizing the simulation approach[59]; if we can leverage data-parallel operations (maybe if the language supports, or break it into tasks for WebWorkers if allowed).
- Memory of final artifacts: We should consider which outputs really need to persist through the pipeline vs can be recomputed on demand. For example, distance-to-coast could be recomputed by Hydrology if needed, but if we have it, storing one float per cell is trivial memory. Something bigger: the actual geometry of river paths (if we store as vectors) might be heavy; but we can let Hydrology derive that as needed from flow grid rather than storing polylines.
- Operating within engine constraints: If the environment is JavaScript/TypeScript (given mention of mods/mod-swooper-maps, likely TS), heavy computation in JS might be slower than ideal. We might consider moving some math to WASM if needed or do optimizations in algorithmic complexity. We should avoid extremely heavy use of recursion or large dynamic allocations in tight loops, etc.
- No infinite loops or unpredictable recursion: Ensure that any iterative algorithm has a hard bound or convergence criteria. E.g., when flooding to create lakes or adjusting coasts, guarantee it finishes quickly.
- Precision vs performance trade: possibly use lower precision (Float32 vs 64) for large arrays to save memory and maybe speed. Many of these fields don’t need double precision.
- Memory of erosion history if needed: If we considered storing multi-layer terrain (like how nickmcd’s article suggests multiple layers for sediment etc. for modeling deposition)[60], we must weigh if that’s needed or if a single combined elevation suffices. Probably we’ll integrate all layers into final outputs to avoid needing layered data ongoing.
- One specific to call: The environment might impose that all domain outputs get duplicated or sanitized for injection. For example, pushing a 100k-length Float64Array through an artifact might have overhead. But probably fine. We should perhaps compress any boolean masks (like land mask can be bit-packed or stored as e.g. Int8 to save space, but given map sizes, difference is minor, only do if needed).
- In summary: We will set explicit bounds for any algorithm: - e.g., “Run plate relaxation for at most 20 iterations or until max movement < threshold” - “Limit river erosion to at most remove X% of total elevation (don’t try to flatten entire world)” - Use heuristics to stop erosion early if terrain stabilizes enough.
- We will also note global usage: after Morphology, some data might not be needed in memory. For example, if no one needs the full erosion simulation history, don’t carry it beyond generation.
We might record such performance notes as comments or doc for Phase 3 to implement accordingly.
- A question to consider (open for Phase 2): do we allow authors to tweak performance via config? e.g., an “erosionDetailLevel” knob (fast vs detailed). Possibly not exposed to normal users, but maybe as a hidden config for debugging or if AI mapgen scenario wants quicker gen at cost of detail. This is secondary but worth noting.

## Open questions + research backlog (for Phase 1/2 validation)
During this greenfield thought exercise, some questions have arisen that we cannot fully answer without further research or current-state evidence. We list them here to guide Phase 1 (current state analysis) and Phase 2 (modeling choices):
- Plate count vs map scale: What is the ideal number of tectonic plates for a given map size to produce interesting variety without too much fragmentation? We’ll need to experiment or see legacy settings. (E.g., Earth analog on a standard map might use ~12 plates; do fewer or more yield better gameplay? This ties to config defaults.)
- Plate modeling simplification: Can we find a minimal algorithm to assign realistic plate movements that yields good mountains? We should investigate existing approaches like Gainey’s method (Voronoi + random plate vectors) and Viitanen’s overlap method[33], to see if they produce plausible mountain distributions quickly. Possibly implement a prototype in Phase 2 to test quality vs speed.
- Erosion: how many iterations is enough? We need to quantify how simulation length affects look. For instance, 100 iterations might carve main rivers, 1000 might flatten mountains too much. We’ll likely test incremental steps to find a sweet spot where terrain looks natural but not eroded to death. Also, is a single-pass “fast” erosion algorithm (like using empirically derived formulas or solving a flow equation once) sufficient instead of iterating? There are known approaches (e.g., generating river networks by down-cutting from random stream seeds) that could be faster than cell-by-cell droplet sim. We might research that (some mention in references about a theoretical approach[61] and a specialized algorithm by Cordonnier et al. – possibly the hal.inria.fr paper referenced).
- River integration with climate: Should Hydrology’s rainfall feed back into erosion? In this refactor phase, likely not (no two-way feedback). So Morphology’s erosion will assume some nominal rainfall distribution. The question: What rainfall or water distribution do we assume for erosion? Uniform? Or proportional to a guess (maybe more rain near coasts)? This choice could imprint biases (like if we erode too much in one region that climate ends up not that rainy, could be inconsistent). Perhaps in Phase 2 we decide to just assume uniform rainfall for erosion simulation and let Hydrology adjust river flows afterwards. Or we coordinate such that Hydrology and Morphology share a base climate distribution for erosion. This could be refined later if needed (maybe a follow-up to feed climate back into terrain – likely out of scope now).
- Routing ownership final decision: We keep raising it – we need to pick in modeling Phase 2 after analyzing current code and complexity. Perhaps Morphology keeping routing is logical because it uses it for erosion anyway. But if Hydrology already has a robust river algorithm, maybe better to unify on that. This is an open design decision to resolve.
- Sea level determination: Will the system enforce a particular sea level to meet a target (like exactly 70% ocean)? Possibly we need an algorithm to adjust sea level after initial height gen to match a config target water fraction. That means after Morphology builds height, count how many cells <0, adjust threshold. But adjusting might flood some areas unpredictably. We might consider doing that or just let config define seaLevel and accept resulting ratio. We should check how legacy did it (did it have a “target land %” slider?). Open item to confirm and ensure our approach aligns with game expectations.
- Integration with tilt/axial specifics: If the world has a concept of axial tilt (for climate seasons) but that doesn’t directly affect Morphology, then no issue. But if, say, we want ice caps or glacial erosion near poles, do we consider that in Morphology? Probably not now (ice-related terrain changes such as glacial valleys might be beyond scope). But we note: should glacial carving be a factor? Hydrology open question asked if glacial carving potential should be output to Morphology[62]. We lean that’s future; currently, we assume no explicit glacial erosion in Morphology (though the erosion sim will carve mountains in general, which implicitly includes glacial shapes maybe if at high altitude if climate did so). But not modeling it distinctly. So if asked: Should cryosphere’s glacial carving be accounted now? – we likely defer to future (note as out-of-scope for this phase, possibly a future improvement after basic refactor).
- Tectonic RNG vs determinism: How deterministic should the tectonic layout be given a seed? Are we comfortable with mostly random plate configurations, or do we want some preset patterns for variety (like an option for a Pangaea single-plate scenario)? We might allow config to specify number of plates or even plate arrangement seeds. Possibly consider offering some patterns (maybe an advanced feature: if user wants one supercontinent, they set plates=1 or cluster them). This is more a design question for config options.
- Performance target confirmation: We should confirm what generation time is acceptable. If it’s a few seconds in native, maybe up to, say, 500ms per domain in JS if possible. If it’s larger, maybe asynchronous background generation is fine. We’ll have to see how current MapGen pipeline is structured (maybe it’s offline generation, not per-frame). This will be clearer after analyzing current engine constraints.
- Validation with known maps: If possible, we might want to test our approach by attempting to reproduce known real-world patterns. Perhaps part of Phase 2 could include: “Given these input parameters, does it roughly produce an Earth-like distribution of mountain ranges and climate zones?” That could confirm model fidelity. If not easily done, at least some qualitative check: e.g., ensure mountains mostly line up with plate boundaries as expected (no random lone huge mountain in middle of stable plate, unless a hotspot – which should be rare and obvious).
- Edge cases and continuity: Because the world likely wraps (east-west wrap, maybe not north-south if it’s a cylindrical map?), we must ensure no discontinuity at map wrap boundaries. E.g., if a plate boundary crosses the wrap, our logic should handle it seamlessly. We must test those edge conditions.
- Coordinate system specifics: If using a Voronoi mesh, computing distances and neighbors has geometric considerations (some distortion etc.). We might need research on how best to compute accurate distances for things like distance-to-coast or flow on a spherical mesh. Possibly fine with graph distances for our scale, but consider if accuracy matters.
All these questions will feed into Phase 1 (to gather evidence from current code how they approached some of these) and Phase 2 (to design experiments or choose algorithms accordingly).

## Lookback 0.5 (greenfield pre-work retrospective)
What changed in our understanding during this research, and what does that mean for the next phases?
- Physics first reveals hidden gaps: By stepping back from the legacy code and focusing on Earth physics, we realized some critical data flows that probably were missing. For example, we now see clearly that plate boundary typing and crust data are prerequisite for meaningful terrain. Legacy likely fudged this (maybe random mountains). This understanding means in Phase 1 we should specifically look for where legacy Morphology lacked inputs and how it compensated (did it assume fixed continents? did it randomize mountains?). We anticipate needing to persuade the pipeline to provide those missing inputs.
- The importance of erosion emerged strongly: Initially, one might think plate tectonics alone shape terrain, but our research underlined that erosion is the key to realistic fractal detail[14]. This changed our emphasis: Morphology isn’t just “make mountains”, it’s also “carve valleys”. We need to validate in Phase 1 how erosion was handled (if at all) in legacy. If it was minimal, we will be introducing a big new component. We’ll have to test if it’s feasible performance-wise. The takeaway: Phase 2 must allocate significant effort to designing the erosion algorithm because it’s crucial for quality, not a side effect.
- Legacy “narrative overlay” concept is truly obsolete in this model: We were aware of a rule “no narrative overlays”, but after designing a physics-grounded pipeline, it’s evident that narrative overlays not only are unnecessary but actively harmful to the consistency. We identified a few conceptual couplings (like possibly forced wonders or corridors) that should become natural outputs instead. This realization confirms that in Phase 1 we should inventory all instances of narrative influencing Morphology or vice versa, and plan to cut them. It also assures us that doing so won’t leave a void – because our model will provide physical alternatives (like real mountain ranges to replace “story mountains”). We should document these replacements to help narrative designers transition.

## Risks / failure modes to guard against in Phase 2 modeling:
- Risk: Over-engineering vs performance. We have a grand vision, but there’s a real danger of an unacceptably slow generator if we try to simulate too much. For Phase 2, we must be ruthless in simplifying models (e.g., maybe skip minor tectonic nuances or do fewer erosion passes) until we hit performance targets. We’ll need to prototype small and measure.
- Risk: Parameter overfitting. With many new parameters (plate count, erosion rate, etc.), testing combinations might be complex. We should guard against “parameter hell” where slight changes produce unpredictable terrain[28]. Our strategy will be to choose sane defaults and limit parameter ranges to avoid weird extremes. Possibly lock some complexity away from users.
- Risk: Downstream misalignment. If we deliver a perfect terrain but downstream domains aren’t ready to use it, it could cause temporary regressions (e.g., climate might not immediately utilize bathymetry and thus give odd results, or ecology might place biomes incorrectly because it needs updates). We should mitigate by coordinating with those refactors. For example, ensure hydrology Phase 2 (when it happens) explicitly uses Morphology’s new outputs. In Phase 3 (implementation plan), include transitional shims if necessary so nothing breaks (perhaps produce some legacy-like outputs in parallel for compatibility until downstream is refactored).
- Risk: Edge-case worlds. The model might do well for Earth-like configurations, but what about extremes? If an author sets plateCount=1 (single plate world), does our model handle it (should produce one supercontinent and a ring of ocean trenches)? If plateCount is very high (lots of microplates), do we degrade gracefully or produce chaotic tiny islands everywhere? We might need to impose sensible limits and test edge cases in Phase 2.
- Risk: User perception and gameplay. Realistic terrain can sometimes be “too realistic” in ways that hamper gameplay (e.g., extremely rugged terrain making expansion hard). We need to watch for any such outcomes and ensure gameplay fun is maintained (via config knobs or slight “unphysical” tweaks if absolutely needed, though ideally none). We’ll likely rely on playtest feedback after implementation, but it’s flagged now to keep an eye on, especially in Phase 2 modeling decisions (we might choose a slightly toned-down mountain height if extreme realism makes map too untraversable, for instance).
## Next steps alignment: This Phase 0.5 gave us a clear ideal model. The immediate next step (Phase 1 current-state spike) will gather evidence of how far the current system is from this ideal – specifically:
- What does current Morphology actually do for plates and mountains? (Likely much simpler, maybe noise-based continents.)
- What hacks exist for story or climate (e.g., any evidence of “latitude bands” for terrain? We want to replace that with actual climate response).
- Inventory of all Morphology outputs currently in use (some might be leftover or not needed anymore).
- Where current code might struggle if we introduce these changes (e.g., any hardcoded assumptions like “max height=10” would conflict with our plan if we allow higher resolution).
- This will inform how we transition from current to target. The lookback learning is that the refactor will be significant – but it confirms the value: the pipeline stands to gain a big realism and coherence boost.
- With this vision established, we proceed to Phase 1 to confront reality and then Phase 2 to reconcile the two (greenfield intent vs actual evidence)[3][63], adjusting any parts of the plan that meet insurmountable issues in practice. The greenfield ideals here will serve as the north star throughout that process.

## Reference links
- [1] [2] [6] WORKFLOW.md
- https://github.com/mateicanavra/civ7-modding-tools-fork/blob/3092cf42017cb5c603f8cf8ac3cab07d43fe7f76/docs/projects/engine-refactor-v1/resources/workflow/domain-refactor/WORKFLOW.md
- [3] [63] phase-0-greenfield-prework.md
- https://github.com/mateicanavra/civ7-modding-tools-fork/blob/3092cf42017cb5c603f8cf8ac3cab07d43fe7f76/docs/projects/engine-refactor-v1/resources/workflow/domain-refactor/references/phase-0-greenfield-prework.md
- [4] [5] [40] [45] [48] architecture.md
- https://github.com/mateicanavra/civ7-modding-tools-fork/blob/b1aaa0b9fe0b308651086b29f7a169e942fb633b/docs/system/libs/mapgen/architecture.md
- [7] [8] [21] Fold Mountain
- https://education.nationalgeographic.org/resource/fold-mountain/
- [9] [10] Procedural map generation on a sphere
- https://www.redblobgames.com/x/1843-planet-generation/
- [11] [12] [15] [17] [18] [20] [24] [32] Terrain Generation 4: Plates, Continents, Coasts – LeatherBee Games
- https://leatherbee.org/index.php/2018/10/28/terrain-generation-4-plates-continents-coasts/
- [13] [14] [16] [22] [23] [25] [26] [27] [28] [31] [35] [36] [37] [38] [39] [59] [61] GitHub - dandrino/terrain-erosion-3-ways: Three Ways of Generating Terrain with Erosion Features
- https://github.com/dandrino/terrain-erosion-3-ways
- [19] [41] [43] [44] [51] [52] [53] [54] [55] [56] [57] [58] [62] spike-hydrology-greenfield.md
- https://github.com/mateicanavra/civ7-modding-tools-fork/blob/3092cf42017cb5c603f8cf8ac3cab07d43fe7f76/docs/projects/engine-refactor-v1/resources/workflow/domain-refactor/plans/hydrology/spike-hydrology-greenfield.md
- [29] [30] [33] [34] CG_final_paper.docx
- https://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S13/final_projects/benedetti_minto.pdf
- [42] [46] [47] [49] [50] LOCAL-TBD-M8-U21-foundation-vertical-domain-refactor.md
- https://github.com/mateicanavra/civ7-modding-tools-fork/blob/3092cf42017cb5c603f8cf8ac3cab07d43fe7f76/docs/projects/engine-refactor-v1/issues/LOCAL-TBD-M8-U21-foundation-vertical-domain-refactor.md
- [60] An Efficient Data Structure for 3D Multi-Layer Terrain and Erosion ...
- https://nickmcd.me/2022/04/15/soilmachine/
