Some of the repo bundles/files you uploaded earlier have expired on my side (the tooling surfaced an expiration notice). I can still do what you asked here using the two critique blocks and your clarified brief. If you want me to also ground the revised steps/recipes proposal in exact legacy callsites and file paths, you’ll need to re-upload any expired bundles you want referenced.

---

## Extracted core thread from your two critique blocks

Only the concerns/questions/recommendations that apply to the shared design space (steps/recipes architecture, contract-first composition, settings/runtime separation), excluding anything tied to another agent’s local mistakes:

### A. Step authoring DX and type inference must match ops/strategies

* `createStep` should be as type-safe and inference-friendly as op authoring (contract-first contextual typing).
* Step authors should not have to:

  * import a large “settings type” everywhere,
  * restate config/settings types in `resolveConfig` params,
  * thread verbose generics through common cases.
* The “happy path” needs to be declarative and low-friction, not a distributed import/annotation exercise.

### B. Step config should be contract-first, declarative, and compositional

* Step config must be a **first-class contract** (TypeBox schema + metadata), analogous to op contracts.
* The map author’s final config should be **mechanically composable** upward:

  * op/strategy contracts → step contracts → (optional) stage contracts → recipe contract → final “map file” contract.
* Avoid “re-encoding” strategy behavior or defaults at the step layer.

  * Step contracts should *compose* op contracts, not restate them.

### C. Step-level `resolveConfig` should not be the default mechanism

* Default stance: steps should not require a `resolveConfig` layer.
* If any step-level config translation exists, it should be **opt-in**, clearly motivated, and framed as a facade/translation mechanism (author-friendly config → internal canonical config).
* Multi-layer config resolution (step + op + strategy) is confusing unless:

  * the layers are sharply separated,
  * and the default workflow doesn’t require authors to manually wire them together.

### D. Defaults must not be re-stated across layers

* The architecture must avoid the “re-doing it 15 times” feel:

  * defaults should be derived once (from contracts) and propagated mechanically.
* If a step contract sets defaults, those defaults must be sourced directly from op contracts (not retyped/duplicated), or generated by helpers.

### E. Hard separation: compile-time authoring config vs runtime game parameters

* Compile-time config (map/mod author edits) must be contract-driven and statically knowable.
* Runtime parameters (seed, map size, players/civs, etc.) must be modeled separately:

  * chosen by the player/game at runtime,
  * not authored by the map designer,
  * not “global knobs” in the authoring config.
* The architecture must keep these two worlds distinct in types, schemas, and flow.

### F. Stages are optional and must justify their existence

* Steps are the executable graph nodes.
* Stages are acceptable only as a composition/organization layer (especially for config), not as mandatory runtime entities.
* Avoid introducing a layer that doesn’t materially simplify contracts/composition.

---

## Revised architecture: Contract-first Steps/Stages/Recipes with declarative config composition and explicit runtime separation

### 1) Canonical terms

To avoid conflating concepts:

* **Authoring config**: the compile-time, contract-driven configuration a modder edits in the final map file.

  * Contains *knobs* (domain/recipe/global authoring knobs) and *pipeline config* (step configs, which embed op configs).
* **Runtime parameters**: game-provided, runtime-only inputs (seed, map size, players, civs, etc.).

  * Not part of the authoring config contract.
  * Provided at execution time to steps via the runtime context.

I will use:

* `Knobs` for compile-time “global knobs / domain knobs / recipe knobs”
* `RuntimeParams` for runtime-only game parameters

### 2) High-level flow

1. **Authoring time**: recipe exports a **Map File Contract** (TypeBox schema + TypeScript type).
2. Modder writes a map file that conforms to that contract.
3. **Compilation time (still before execution)**:

   * map file is normalized via schema defaults
   * optional step facades are expanded (opt-in)
   * op-level compile-time normalization is applied mechanically (strategy/op `resolveConfig` where relevant)
   * result: an **Execution Plan** with fully resolved step internal configs
4. **Runtime execution**:

   * engine executes steps using:

     * resolved step config (compile-time)
     * `RuntimeParams` (runtime-only) inside `ctx.runtime`

Critically:

* runtime execution does **not** read knobs directly (unless an advanced step opts into it explicitly; discouraged and linted)
* runtime-only parameters never appear in the map file schema

---

## 3) Contracts vs implementation modules (clear mapping)

### Operation

* **Contract**: `OpContract` (schemas + ids + settings-slice schema)
* **Implementation**: assembled op with strategies (`createOp(contract, { strategies })`)
* **Config exposure upward**: op exposes an **envelope schema** `{strategy, config}` and a **default envelope value** derived from the contract

### Strategy

* **Contract surface**: strategy config schemas live in the op contract
* **Implementation**: `createStrategy(contract, id, impl)`
* **Config exposure upward**: included via op envelope

### Step

* **Contract**: `StepContract`

  * author-facing config schema (what map file contains)
  * internal config schema (what runtime step `run` receives)
  * op bindings (which ops are embedded in internal config, and where their knobs come from)
  * requires/provides/phase metadata
* **Implementation**: `createStep(contract, impl)`

  * `run(ctx, internalConfig)`
  * optional `expandConfig(publicConfig, knobs)` for facade translation (opt-in only)

### Stage (optional)

* **Contract**: `StageContract`

  * purely organizational/config composition layer
  * composes step contracts into a nested schema namespace
* **Implementation**: none at runtime (or a thin module that exports the contract + step modules list)

### Recipe

* **Contract**: `RecipeContract`

  * composes:

    * knobs schema (authoring knobs)
    * pipeline schema (from stages/steps)
  * exports the final **Map File Contract**
* **Implementation**: recipe module

  * instantiates the step graph (usually static)
  * compiles map file → execution plan
  * runs execution plan with runtime params

---

## 4) The core design decision: Step-level `resolveConfig`

### Position

* **Step-level `resolveConfig` is not required and is not the default.**
* Instead:

  1. Step contracts are declarative and compositional by default.
  2. Compilation performs mechanical normalization:

     * schema defaults
     * op-level config resolution (`op.resolveConfig(...)`) applied automatically
  3. Step-level translation exists only as **opt-in facade expansion** (`expandConfig`).

### What this buys you (concretely)

* No “per-step forwarding boilerplate” just to pipe settings/knobs into ops.
* No confusion about “step strategies”—ops own strategy selection; steps just *contain op configs*.
* No duplicated defaults—defaults are derived once from op contracts and applied mechanically.

---

## 5) Concrete API shape and code

Below is a coherent “new pass” on the steps/recipes side. I’m keeping the op/strategy world compatible with the contract-first approach we already established, but changing the steps/recipes mechanics so they meet your constraints.

### 5.1 Shared primitives: knobs, runtime, defaults

```ts
import { Type, type Static, type TObject, type TSchema } from "typebox";
import { Value } from "typebox/value";

export function applySchemaDefaults<T extends TSchema>(schema: T, input: unknown): Static<T> {
  const converted = Value.Convert(schema, input);
  const cleaned = Value.Clean(schema, converted);
  const defaulted = Value.Default(schema, cleaned);
  return defaulted as Static<T>;
}

/** Compile-time authoring knobs (NOT runtime game params). */
export type KnobsShape = Readonly<{
  global: Record<string, unknown>;
  domains: Record<string, unknown>;
  recipe: Record<string, unknown>;
}>;

/** Runtime-only parameters (game-provided). */
export type RuntimeParams = Readonly<{
  seed: number;
  mapSize: { width: number; height: number };
  players: readonly { playerId: number; civId: string }[];
}>;
```

---

### 5.2 Step contracts are first-class (purely declarative)

A step contract describes the author-facing config surface and how it composes underlying op configs.

**Key canonical convention**: internal step config contains an `ops` namespace so it’s always obvious that “strategy selection” lives inside op config, not the step.

```ts
import type { OpContract } from "../op/contract"; // contract-only import
import { Type, type Static, type TObject } from "typebox";

/** Contract-level description of an op bound into a step config. */
export type StepOpBinding<C extends OpContract<any, any, any, any, any, any>> = Readonly<{
  /** Stable key inside step config under `ops.<key>` */
  key: string;

  /** Op contract reference (pure data) */
  contract: C;

  /** Where to source knobs for op-level resolveConfig (usually the owning domain id) */
  knobsDomain: string;
}>;

export type StepContract<
  StepId extends string,
  Phase extends string,
  PublicSchema extends TObject,
  InternalSchema extends TObject,
  Ops extends ReadonlyArray<StepOpBinding<any>>,
> = Readonly<{
  id: StepId;
  phase: Phase;
  requires: readonly string[];
  provides: readonly string[];

  /** What the map author writes for this step. */
  publicSchema: PublicSchema;

  /** What the step runtime implementation receives. Defaults to publicSchema. */
  internalSchema: InternalSchema;

  /** Declarative list of op bindings contained in internal config. */
  ops: Ops;

  meta?: Readonly<{ title?: string; description?: string }>;
}>;

export function defineStep<
  const StepId extends string,
  const Phase extends string,
  const PublicSchema extends TObject,
  const InternalSchema extends TObject = PublicSchema,
  const Ops extends ReadonlyArray<StepOpBinding<any>> = readonly [],
>(def: {
  id: StepId;
  phase: Phase;
  requires: readonly string[];
  provides: readonly string[];
  publicSchema: PublicSchema;
  internalSchema?: InternalSchema;
  ops?: Ops;
  meta?: StepContract<StepId, Phase, PublicSchema, InternalSchema, Ops>["meta"];
}): StepContract<StepId, Phase, PublicSchema, InternalSchema, Ops> {
  return {
    ...def,
    internalSchema: (def.internalSchema ?? def.publicSchema) as InternalSchema,
    ops: (def.ops ?? ([] as unknown as Ops)) as Ops,
  };
}

export type StepPublicConfigOf<C extends StepContract<any, any, any, any, any>> = Static<C["publicSchema"]>;
export type StepInternalConfigOf<C extends StepContract<any, any, any, any, any>> = Static<C["internalSchema"]>;
```

---

### 5.3 Step config composition from op contracts (no duplicated defaults)

We need two helper functions that operate on **op contracts only**:

* `opEnvelopeSchema(contract)`: union schema for `{ strategy, config }`
* `defaultOpEnvelope(contract)`: value derived from the contract’s default strategy schema

```ts
import { Type, type Static, type TSchema } from "typebox";
import type { OpContract } from "../op/contract";
import { applySchemaDefaults } from "../schema-defaults";

export function opEnvelopeSchema<C extends OpContract<any, any, any, any, any, any>>(contract: C): TSchema {
  const variants = Object.entries(contract.strategies).map(([strategyId, cfgSchema]) =>
    Type.Object(
      { strategy: Type.Literal(strategyId), config: cfgSchema as any },
      { additionalProperties: false }
    )
  );
  return Type.Union(variants);
}

export function defaultOpEnvelope<C extends OpContract<any, any, any, any, any, any>>(contract: C) {
  const inner = applySchemaDefaults(contract.strategies.default, undefined);
  return { strategy: "default", config: inner } as const;
}

/**
 * Canonical schema for an op config field in a step contract:
 * - uses envelope schema from op contract
 * - injects default value derived from op contract (no restating)
 */
export function opConfigField<C extends OpContract<any, any, any, any, any, any>>(contract: C) {
  return Type.Optional(opEnvelopeSchema(contract) as any, { default: defaultOpEnvelope(contract) });
}
```

This directly addresses:

* “why is the step default restating op defaults?”
* “is the step baking in strategies?”
* “why do we have to redo defaults everywhere?”

The step contract is purely composing contract-derived artifacts.

---

### 5.4 Step implementation module: `createStep` with automatic op-level compilation

The step implementation:

* never imports a global “settings type”
* does not implement `resolveConfig` by default
* can optionally implement `expandConfig` for facade translation

```ts
import type { DomainOp } from "../op/create";
import type { StepContract, StepPublicConfigOf, StepInternalConfigOf } from "./step-contract";
import { applySchemaDefaults } from "../schema-defaults";

export type StepContext<TArtifacts, TRuntime extends RuntimeParams> = Readonly<{
  runtime: TRuntime;
  artifacts: TArtifacts;
}>;

export type StepModule<
  C extends StepContract<any, any, any, any, any>,
  TArtifacts,
  TRuntime extends RuntimeParams,
> = Readonly<{
  contract: C;

  /**
   * Runtime op implementations keyed by the binding key.
   * These are used at runtime (run) and at compile time (op.resolveConfig).
   */
  ops: Record<string, DomainOp<any>>;

  /**
   * Compile-time: public config -> internal config.
   * - apply defaults
   * - optional facade expansion
   * - apply op.resolveConfig mechanically for bound ops
   */
  compileConfig: (public: StepPublicConfigOf<C>, knobs: KnobsShape) => StepInternalConfigOf<C>;

  /** Runtime execution (no knobs). */
  run: (ctx: StepContext<TArtifacts, TRuntime>, config: StepInternalConfigOf<C>) => void | Promise<void>;
}>;

export function createStep<
  C extends StepContract<any, any, any, any, any>,
  TArtifacts,
  TRuntime extends RuntimeParams,
>(contract: C, impl: {
  ops: Record<string, DomainOp<any>>;
  run: StepModule<C, TArtifacts, TRuntime>["run"];

  /**
   * Optional facade translation:
   * public config (map file) -> internal config (what run receives).
   * This is the ONLY reason a step needs “resolution”-like logic by default.
   */
  expandConfig?: (public: StepPublicConfigOf<C>, knobs: KnobsShape) => unknown;
}): StepModule<C, TArtifacts, TRuntime> {
  function compileConfig(public: StepPublicConfigOf<C>, knobs: KnobsShape): StepInternalConfigOf<C> {
    // 1) Normalize public config
    const publicNorm = applySchemaDefaults(contract.publicSchema, public);

    // 2) Optional facade expansion
    const internalCandidate = impl.expandConfig ? impl.expandConfig(publicNorm, knobs) : publicNorm;

    // 3) Normalize internal config
    const internalNorm = applySchemaDefaults(contract.internalSchema, internalCandidate) as any;

    // 4) Mechanical op-level config resolution (no per-step boilerplate)
    // Convention: internal config contains `ops: Record<bindingKey, opConfigEnvelope>`
    if (contract.ops?.length) {
      internalNorm.ops = internalNorm.ops ?? {};
      for (const binding of contract.ops) {
        const opImpl = impl.ops[binding.key];
        if (!opImpl) {
          throw new Error(`Step ${contract.id} missing op implementation for binding '${binding.key}'`);
        }

        const domainKnobs = knobs.domains[binding.knobsDomain];
        const opKnobs = applySchemaDefaults(opImpl.contract.settings, domainKnobs);

        const currentCfg = internalNorm.ops[binding.key];
        internalNorm.ops[binding.key] = opImpl.resolveConfig(currentCfg, opKnobs);
      }
    }

    return internalNorm as StepInternalConfigOf<C>;
  }

  return {
    contract,
    ops: impl.ops,
    compileConfig,
    run: impl.run,
  };
}
```

This is the critical DX improvement:

* step authors do not write “forward resolveConfig” layers
* op/strategy config resolution still exists (where needed), but it’s applied automatically and uniformly

---

## 6) Example: a step with purely declarative, compositional config (no facade)

### Contract module (declarative)

```ts
import { Type } from "typebox";
import { defineStep } from "@mapgen/authoring/step/step-contract";
import { opConfigField } from "@mapgen/authoring/step/op-config-field";
import { ecologyContracts } from "@mapgen/domain/ecology/contracts";

export const BiomesStepContract = defineStep({
  id: "ecology:biomes",
  phase: "ecology",
  requires: ["artifact:elevationField"],
  provides: ["artifact:biomeIds"],

  // Declarative op binding list for mechanical compileConfig
  ops: [
    { key: "classifyBiomes", contract: ecologyContracts.classifyBiomes, knobsDomain: "ecology" },
  ] as const,

  publicSchema: Type.Object(
    {
      ops: Type.Object(
        {
          classifyBiomes: opConfigField(ecologyContracts.classifyBiomes),
        },
        { additionalProperties: false, default: {} }
      ),
    },
    { additionalProperties: false, default: {} }
  ),
});
```

### Implementation module (no resolve)

```ts
import { createStep } from "@mapgen/authoring/step/create-step";
import { BiomesStepContract } from "./contract";
import { ecologyOps } from "@mapgen/domain/ecology/ops";

export const biomesStep = createStep(BiomesStepContract, {
  ops: {
    classifyBiomes: ecologyOps.classifyBiomes,
  },

  run: async (ctx, config) => {
    const { width, height } = ctx.runtime.mapSize;
    const elevation = ctx.artifacts.get("artifact:elevationField");

    const out = ecologyOps.classifyBiomes.run(
      { width, height, elevation },
      config.ops.classifyBiomes
    );

    ctx.artifacts.set("artifact:biomeIds", out.biomeIds);
  },
});
```

No imported settings types. No restated defaults. No step resolve.

---

## 7) Example: step facade (opt-in translation only)

Author wants a simplified interface:

* public config: `{ quality: "fast" | "accurate" }`
* Internal config: `ops.classifyBiomes = { strategy, config }`

### Contract with separate author/internal schemas

```ts
import { Type } from "typebox";
import { defineStep } from "@mapgen/authoring/step/step-contract";
import { opConfigField } from "@mapgen/authoring/step/op-config-field";
import { ecologyContracts } from "@mapgen/domain/ecology/contracts";

export const BiomesFacadeStepContract = defineStep({
  id: "ecology:biomes",
  phase: "ecology",
  requires: ["artifact:elevationField"],
  provides: ["artifact:biomeIds"],

  ops: [
    { key: "classifyBiomes", contract: ecologyContracts.classifyBiomes, knobsDomain: "ecology" },
  ] as const,

  // Author-facing
  publicSchema: Type.Object(
    {
      quality: Type.Union([Type.Literal("fast"), Type.Literal("accurate")], { default: "fast" }),
    },
    { additionalProperties: false, default: {} }
  ),

  // Internal canonical config used by runtime
  internalSchema: Type.Object(
    {
      ops: Type.Object(
        {
          classifyBiomes: opConfigField(ecologyContracts.classifyBiomes),
        },
        { additionalProperties: false, default: {} }
      ),
    },
    { additionalProperties: false, default: {} }
  ),
});
```

### Implementation with `expandConfig` (the only “resolve” logic)

```ts
import { createStep } from "@mapgen/authoring/step/create-step";
import { BiomesFacadeStepContract } from "./contract";
import { ecologyOps } from "@mapgen/domain/ecology/ops";

export const biomesStep = createStep(BiomesFacadeStepContract, {
  ops: { classifyBiomes: ecologyOps.classifyBiomes },

  expandConfig: (public, _knobs) => {
    return {
      ops: {
        classifyBiomes:
          public.quality === "accurate"
            ? { strategy: "accurate", config: {} }
            : { strategy: "default", config: {} },
      },
    };
  },

  run: async (ctx, config) => {
    const { width, height } = ctx.runtime.mapSize;
    const elevation = ctx.artifacts.get("artifact:elevationField");
    const out = ecologyOps.classifyBiomes.run({ width, height, elevation }, config.ops.classifyBiomes);
    ctx.artifacts.set("artifact:biomeIds", out.biomeIds);
  },
});
```

This satisfies:

* facade translation is opt-in and explicit
* the default architecture remains purely compositional

---

## 8) Stages: optional composition/namespace only

Stages exist only to:

* group steps for readability
* create nested config namespaces
* allow recipe contracts to compose config in meaningful chunks

They do not need runtime existence.

### Stage contract helper

```ts
import { Type, type TObject } from "typebox";
import type { StepContract } from "@mapgen/authoring/step/step-contract";

export type StageContract<Id extends string, Steps extends Record<string, StepContract<any, any, any, any, any>>> =
  Readonly<{
    id: Id;
    steps: Steps;
    schema: TObject; // composed author schemas
  }>;

export function defineStage<const Id extends string, const Steps extends Record<string, StepContract<any, any, any, any, any>>>(
  id: Id,
  steps: Steps
): StageContract<Id, Steps> {
  // Compose author schemas, keyed by step id (or local keys if you prefer)
  const shape: Record<string, TObject> = {};
  for (const [k, s] of Object.entries(steps)) shape[k] = s.publicSchema;

  return {
    id,
    steps,
    schema: Type.Object(shape, { additionalProperties: false, default: {} }),
  };
}
```

If stages don’t pull their weight for your repo, delete them. The rest of the system still works with a flat `steps` namespace.

---

## 9) Recipe contracts: final map file is fully declarative and typed

A recipe contract defines the final map file schema:

* `knobs`: authoring knobs (compile-time)
* `pipeline`: composed step configs (compile-time)

Runtime params are not here.

```ts
import { Type, type Static, type TObject } from "typebox";
import { applySchemaDefaults } from "@mapgen/authoring/schema-defaults";
import type { StepModule } from "@mapgen/authoring/step/create-step";
import type { RuntimeParams, KnobsShape } from "@mapgen/authoring/runtime";

export function defineKnobsSchema(args: {
  global: TObject;
  domains: Record<string, TObject>;
  recipe: TObject;
}) {
  return Type.Object(
    {
      global: args.global,
      domains: Type.Object(args.domains, { additionalProperties: false, default: {} }),
      recipe: args.recipe,
    },
    { additionalProperties: false, default: {} }
  );
}

export function definePipelineSchema(steps: Record<string, TObject>) {
  return Type.Object(steps, { additionalProperties: false, default: {} });
}

export function defineMapFileSchema(knobs: TObject, pipeline: TObject) {
  return Type.Object(
    { knobs, pipeline },
    { additionalProperties: false, default: {} }
  );
}

export type RecipeModule<TArtifacts, TRuntime extends RuntimeParams> = Readonly<{
  id: string;

  mapFileSchema: TObject;
  normalizeMapFile: (input: unknown) => any;

  steps: ReadonlyArray<StepModule<any, TArtifacts, TRuntime>>;

  compile: (mapFile: unknown) => Readonly<{
    knobs: KnobsShape;
    stepConfigs: Record<string, unknown>; // internal configs keyed by step id
    // plus whatever the engine needs for dependency compilation
  }>;

  run: (ctx: { runtime: TRuntime; artifacts: TArtifacts }, mapFile: unknown) => void | Promise<void>;
}>;
```

### Compilation is where op-level resolution happens mechanically

Recipe compile:

* normalizes map file
* for each step:

  * grabs public config
  * calls `step.compileConfig(publicConfig, knobs)` (which applies op.resolveConfig automatically)
* produces internal step configs for execution

**No engine-owned settings type. No runtime parameters in map file.**

---

## 10) How this resolves the “multiple layers of config resolution” confusion

In this architecture there are only two meaningful compile-time transformations:

1. **Schema normalization** (defaults/cleaning) for:

   * map file
   * step public config
   * step internal config
   * (optionally) op settings slices

2. **Optional facade expansion** at step level:

   * only when a step chooses to present a simpler author surface

Op/strategy `resolveConfig` still exists (because it is a legitimate compile-time normalization hook), but:

* it is applied mechanically, not manually
* it does not require per-step boilerplate
* it is not exposed as a “step must resolve config” concept

That removes the “step resolve + op resolve + strategy resolve” mental overhead for the default case.

---

## 11) Explicit separation of compile-time knobs vs runtime-only parameters

### Compile-time (map author edits)

* `mapFile.knobs`: domain knobs + recipe knobs + author-global knobs
* `mapFile.pipeline`: step configs composed from op contracts

### Runtime-only (player/game decides)

* `ctx.runtime`: map size, players, seed, etc.
* not part of the map file schema
* never imported into domain/contract layers

If you later decide you want authoring config that’s conditional on runtime (e.g., “for small maps, do X”), you can still keep separation by making it **declarative** in authoring config (a mapping keyed by map size category), and selecting at runtime based on `ctx.runtime`.

---

## 12) Conceptual implementation impact (what changes in the codebase shape)

At a high level, adopting this revised architecture introduces:

### New/updated types & helpers

* `StepContract` + `defineStep`
* `createStep` producing:

  * `compileConfig` (automatic op resolution; facade optional)
  * `run`
* Op-contract-based helpers for step schema composition:

  * `opEnvelopeSchema(contract)`
  * `defaultOpEnvelope(contract)`
  * `opConfigField(contract)` (injects default without restating)

### Recipe contract becomes a first-class “map file contract”

* Recipes export:

  * `mapFileSchema`
  * `normalizeMapFile`
  * `compile(mapFile) -> internal configs + plan inputs`
  * `run(ctx, mapFile, runtimeParams)`

### Engine simplification (on the steps/recipes axis)

* Engine does not need to call `step.resolveConfig`.
* Engine executes resolved configs produced by recipe compilation.
* Runtime params live in context; engine can remain generic.

### Why DX becomes simpler and more declarative

* Step authors:

  * primarily write contracts + runtime `run`
  * do not write config-forwarding plumbing
  * do not import global settings types
* Modders:

  * edit a single, fully typed map file schema
  * see pipeline config as a contract-composed structure
* Defaults:

  * come from op contracts (derived) and are injected mechanically; no retyping

---

## Bottom line

This revised steps/recipes architecture is contract-first in the same sense as ops/strategies/domains, but it deliberately **refuses** a resolve-heavy step model as the default. Instead:

* **Steps are declarative contracts by default** (composed from op contracts).
* **Step translation is opt-in** (facade expansion only).
* **Op-level compile-time resolution is applied automatically**, eliminating the “forwarding resolveConfig” boilerplate and default duplication.
* **Runtime-only parameters are explicitly separated** in context, never conflated with authoring knobs.

If you re-upload any expired bundles, I can follow this with a concrete mapping onto the current repo surface (where steps/recipes live today, what types to replace, and how to migrate mechanically).
