## What you are receiving

You are receiving a single XML-ish “repo pack” generated by **Repomix** from a subset of the `civ7-modding-tools` repository. The pack includes:
- Canonical target-architecture docs for **domains / operations / strategies / rules / steps**.
- The current **ecology** domain implementation (domain ops + standard recipe step wiring).
- The relevant **authoring SDK** and execution-plan compilation code that defines how ops/steps are authored and how config is canonicalized.
- Ecology-focused tests + the guardrail script used to enforce boundary rules.

Treat the repomix output as read-only; you should implement changes in the original files in the repository.

## Mission

Re-implement / reorganize the **ecology** domain so it becomes the **canonical reference implementation** of our target domain architecture. Ecology already “works”, but it is not easy to inspect, test, or extend. Your job is to make it the exemplar we will follow when refactoring every other domain.

Primary exemplar focus (must be “perfect” in the strict model):
- Operation: `mods/mod-swooper-maps/src/domain/ops/ecology/plan-feature-placements/**`
- Step wiring: `mods/mod-swooper-maps/src/recipes/standard/stages/ecology/steps/features/**`

## Canonical architecture (do not improvise)

Use these files as the authority (in this order):
1) `docs/projects/engine-refactor-v1/resources/spec/SPEC-step-domain-operation-modules.md`
2) `docs/projects/engine-refactor-v1/resources/workflow/domain-refactor/WORKFLOW.md`
3) `docs/projects/engine-refactor-v1/resources/workflow/domain-refactor/references/*`
4) ADRs:
   - `docs/projects/engine-refactor-v1/resources/spec/adr/adr-er1-030-operation-inputs-policy.md`
   - `docs/projects/engine-refactor-v1/resources/spec/adr/adr-er1-034-operation-kind-semantics.md`
   - `docs/projects/engine-refactor-v1/resources/spec/adr/adr-er1-035-config-normalization-and-derived-defaults.md`
   - `docs/projects/engine-refactor-v1/resources/spec/adr/adr-er1-036-strategy-required-createop-sequencing.md`

Also read the local issue context:
- `docs/projects/engine-refactor-v1/issues/LOCAL-TBD-M7-U15-post-u14-canonical-exemplar-and-domain-op-decomposition.md`

### Core concepts you must implement correctly

**Operations (domain ops)**
- The public, step-callable contract units: `run(inputs, config) -> output`.
- Must be schema-backed, deterministic, and easy to unit-test.
- Must be decomposable and inspectable: if the system derives a meaningful intermediate (e.g. an aridity index), strongly prefer making it its own op with its own output that can be validated and (optionally) published as an artifact by a step.

**Strategies**
- Each operation is strategy-backed and must include a `"default"` strategy.
- Plan-truth config encoding is **always** the explicit envelope:
  - `{ strategy: "<strategyId>", config: <innerConfig> }`
- Strategy-specific compile-time normalization lives in `strategy.resolveConfig(innerConfig, settings) -> innerConfig`.
- Steps do not import strategy modules directly; steps only select via config and call the operation contract.

**Rules**
- Small, pure, policy snippets used *inside a strategy* to implement the operation.
- Rules are not step-callable contracts. They must not reach into runtime context/adapter or artifacts.
- Rules should be verb-forward and narrowly scoped.

**Steps**
- The runtime orchestration units: build inputs from runtime + artifacts → call domain ops → apply/publish results.
- Steps own adapter/engine IO and artifact publication; domains do not.
- Compile-time config canonicalization happens in `step.resolveConfig(config, settings)` during execution-plan compilation.
  - See `packages/mapgen-core/src/engine/execution-plan.ts`.

## Hard constraints (non-negotiable)

### 1) Boundary discipline
- Ops must not import or depend on recipe wiring, steps, adapters, engine IDs, or artifact publishers.
- Ops consume and return plain data (POJOs + typed arrays); no callback “views” in op contracts.
- Engine bindings (symbol → engine ID) stay in the step layer.

### 2) Config “plan is truth”
- Runtime code must not “fix up” config (`?? {}`, `Value.Default(...)`, deep merges) inside ops or steps.
- Schema defaults belong in TypeBox schemas; settings-derived defaults belong in `resolveConfig`.
- Composite steps must fan out to `op.resolveConfig(...)` for each op config, then recombine.

### 3) Strategy-required authoring model
- All operations must be authored via `createOp({ kind, id, input, output, strategies: { ... } })` with a required `"default"` strategy.
- Single-strategy ops still use the strategy envelope config shape.

### 4) Validation + determinism
- Ops must be deterministic for fixed inputs/config.
- Steps and tests call ops via `op.runValidated(...)`; tests should use `{ validateOutput: true }` at least once for the op contract.
- Typed arrays must be validated consistently (see `TypedArraySchemas.*` and the validation surface in `packages/mapgen-core/src/authoring/**`).

### 5) Layout discipline
- Ops are directory modules under `mods/mod-swooper-maps/src/domain/ops/ecology/<op>/` with:
  - `schema.ts`
  - `index.ts`
  - `rules/` (even if empty initially)
  - `strategies/` (even if empty initially)
- Steps are directory modules under `mods/mod-swooper-maps/src/recipes/standard/stages/ecology/steps/<step>/` with:
  - `index.ts` (orchestration only)
  - `inputs.ts` (runtime binding → POJOs)
  - `apply.ts` (runtime writes + artifact publication)

### 6) Use core SDK utilities (don’t duplicate)
- Prefer the shared utilities under `packages/mapgen-core/src/lib/**` (math, RNG, sampling, helpers) instead of re-implementing ad-hoc utilities inside domain ops or steps.

## What to change (ecology canonical refactor)

1) Make ecology’s operation surface reflect the target architecture:
   - Split oversized responsibilities into multiple ops where the intermediate is meaningful, testable, and/or publishable.
   - Use strategies only for genuine algorithmic optionality that preserves the op’s input/output contract.

2) Make the **plan-feature-placements** operation a “perfect” thick op with rules decomposition:
   - `plan.ts` (or equivalent) is orchestration-only: it composes results by calling verb-forward rules modules.
   - Feature-specific logic lives under `rules/**`; no “feature switchboard” blobs in `plan.ts`.
   - Rules remain internal helpers; the op contract is the only step-callable export.

3) Make the ecology **features** step a canonical composite step:
   - Step schema imports each op’s `config` and defaults to each op’s `defaultConfig` (no re-authored wrappers).
   - `step.resolveConfig(...)` calls each op’s derived `resolveConfig(...)` and recomposes the step config.
   - Step run stays orchestration-only (build inputs → call ops → apply/publish).

## Required verification (must be green)

Run:
- `REFRACTOR_DOMAINS="ecology" ./scripts/lint/lint-domain-refactor-guardrails.sh`
- `pnpm -C packages/mapgen-core check`
- `pnpm -C packages/mapgen-core test`
- `pnpm -C mods/mod-swooper-maps check`
- `pnpm -C mods/mod-swooper-maps test`
- `pnpm -C mods/mod-swooper-maps build`

## Deliverables

1) Updated ecology domain code and step wiring satisfying the constraints above.
2) Tests:
   - at least one **op contract** test using `runValidated(..., { validateOutput: true })`
   - at least one **thin integration edge** test covering the step boundary (recipe → step → op → apply edge), using existing patterns in `mods/mod-swooper-maps/test/**`
3) If you change a public contract (artifact shape, requires/provides keys, op config shape), update the adjacent docs in the pack that describe that contract.
