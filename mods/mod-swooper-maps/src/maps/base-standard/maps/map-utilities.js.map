{"version":3,"file":"map-utilities.js","sources":["../../../modules/base-standard/maps/map-utilities.ts"],"sourcesContent":["import * as globals from \"#base/maps/map-globals.js\";\r\n\r\nexport const EAST_LAND_MASS_ID = 0;\r\nexport const WEST_LAND_MASS_ID = 1;\r\nexport const AVAILABLE_ON_ALL_LANDMASSES_ID = 2;\r\n\r\nexport function needHumanNearEquator() {\r\n\tconst uiMapSize = GameplayMap.getMapSize();\r\n\tconst mapInfo = GameInfo.Maps.lookup(uiMapSize);\r\n\tlet iPlayerCount = 0;\r\n\tif (mapInfo) iPlayerCount = mapInfo.PlayersLandmass1 + mapInfo.PlayersLandmass2;\r\n\r\n\tfor (let iPlay = 0; iPlay < iPlayerCount; iPlay++) {\r\n\t\tif (Players.getEverAlive()[iPlay] && Players.getEverAlive()[iPlay].isHuman) {\r\n\t\t\t// \tFind their total bias (Leader + Civ) for each Biome and for Navigable Rivers\r\n\t\t\tconst uiCivType: CivilizationType = Players.getEverAlive()[iPlay].civilizationType;\r\n\t\t\tconst uiLeaderType: LeaderType = Players.getEverAlive()[iPlay].leaderType;\r\n\r\n\t\t\tfor (let startBiomeIdx = 0; startBiomeIdx < GameInfo.StartBiasBiomes.length; startBiomeIdx++) {\r\n\t\t\t\tconst civString = GameInfo.StartBiasBiomes[startBiomeIdx]?.CivilizationType;\r\n\t\t\t\tconst ldrString = GameInfo.StartBiasBiomes[startBiomeIdx]?.LeaderType;\r\n\t\t\t\tlet civHash = 0;\r\n\t\t\t\tlet ldrHash = 0;\r\n\t\t\t\tif (civString != null && GameInfo.Civilizations.lookup(civString) != null) {\r\n\t\t\t\t\tconst civObj = GameInfo.Civilizations.lookup(civString);\r\n\t\t\t\t\tif (civObj) {\r\n\t\t\t\t\t\tcivHash = civObj.$hash;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (ldrString != null && GameInfo.Leaders.lookup(ldrString) != null) {\r\n\t\t\t\t\tconst ldrObj = GameInfo.Leaders.lookup(ldrString);\r\n\t\t\t\t\tif (ldrObj) {\r\n\t\t\t\t\t\tldrHash = ldrObj.$hash;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (civHash == uiCivType || ldrHash == uiLeaderType) {\r\n\t\t\t\t\tconst szBiome: string = GameInfo.StartBiasBiomes[startBiomeIdx].BiomeType;\r\n\t\t\t\t\tconsole.log(szBiome);\r\n\t\t\t\t\tif (szBiome == \"BIOME_TROPICAL\") {\r\n\t\t\t\t\t\tconsole.log(\"Human player needing a Tropical start.\");\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nexport function getMinimumResourcePlacementModifier() {\r\n\tconst mapSizeInfo = GameInfo.Maps.lookup(GameplayMap.getMapSize());\r\n\tif (mapSizeInfo == null) return;\r\n\tlet iMapMinimumModifer = 0;\r\n\tconst mapType = Configuration.getMapValue(\"Name\");\r\n\tfor (const option of GameInfo.MapResourceMinimumAmountModifier) {\r\n\t\tif (option.MapType === mapType && option.MapSizeType == mapSizeInfo.MapSizeType) {\r\n\t\t\tiMapMinimumModifer = option.Amount;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t//If we didn't find a matching map type, use the default per map size\r\n\tif (iMapMinimumModifer == 0) {\r\n\t\tfor (const option of GameInfo.MapResourceMinimumAmountModifier) {\r\n\t\t\tif (option.MapType === \"DEFAULT\" && option.MapSizeType == mapSizeInfo.MapSizeType) {\r\n\t\t\t\tiMapMinimumModifer = option.Amount;\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t\"Using default map size for resuource placemtn, please update the table for this map type. Modifer is \" +\r\n\t\t\t\t\t\tiMapMinimumModifer +\r\n\t\t\t\t\t\t\" by default.\",\r\n\t\t\t\t);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn iMapMinimumModifer;\r\n}\r\n\r\nexport function getDistanceFromContinentCenter(\r\n\tiX: number,\r\n\tiY: number,\r\n\tiContinentBottomRow: number,\r\n\tiContinentTopRow: number,\r\n\tiWestContinentLeftCol: number,\r\n\tiWestContinentRightCol: number,\r\n\tiEastContinentLeftCol: number,\r\n\tiEastContinentRightCol: number,\r\n): number {\r\n\tlet iContinentLeftEdge: number = iWestContinentLeftCol;\r\n\tlet iContinentRightEdge: number = iWestContinentRightCol;\r\n\tif (iX >= iEastContinentLeftCol) {\r\n\t\tiContinentLeftEdge = iEastContinentLeftCol;\r\n\t\tiContinentRightEdge = iEastContinentRightCol;\r\n\t}\r\n\r\n\tconst iContinentHeight: number = iContinentTopRow - iContinentBottomRow;\r\n\tconst iContinentWidth: number = iContinentRightEdge - iContinentLeftEdge;\r\n\tconst iContinentCenterX: number = iContinentLeftEdge + iContinentWidth / 2;\r\n\tconst iContinentCenterY: number = iContinentBottomRow + iContinentHeight / 2;\r\n\r\n\tconst iDistance: number = GameplayMap.getPlotDistance(iX, iY, iContinentCenterX, iContinentCenterY);\r\n\treturn iDistance;\r\n}\r\n\r\nexport function getMaxDistanceFromContinentCenter(\r\n\tiX: number,\r\n\tiContinentBottomRow: number,\r\n\tiContinentTopRow: number,\r\n\tiWestContinentLeftCol: number,\r\n\tiWestContinentRightCol: number,\r\n\tiEastContinentLeftCol: number,\r\n\tiEastContinentRightCol: number,\r\n): number {\r\n\tlet iContinentLeftEdge: number = iWestContinentLeftCol;\r\n\tlet iContinentRightEdge: number = iWestContinentRightCol;\r\n\tif (iX >= iEastContinentLeftCol) {\r\n\t\tiContinentLeftEdge = iEastContinentLeftCol;\r\n\t\tiContinentRightEdge = iEastContinentRightCol;\r\n\t}\r\n\r\n\tconst iContinentHeight: number = iContinentTopRow - iContinentBottomRow;\r\n\tconst iContinentWidth: number = iContinentRightEdge - iContinentLeftEdge;\r\n\tconst iContinentCenterX: number = iContinentLeftEdge + iContinentWidth / 2;\r\n\tconst iContinentCenterY: number = iContinentBottomRow + iContinentHeight / 2;\r\n\r\n\tconst iDistance: number = GameplayMap.getPlotDistance(\r\n\t\tiContinentLeftEdge,\r\n\t\tiContinentBottomRow,\r\n\t\tiContinentCenterX,\r\n\t\tiContinentCenterY,\r\n\t);\r\n\treturn iDistance;\r\n}\r\n\r\nexport function getSector(\r\n\tiX: number,\r\n\tiY: number,\r\n\tiRows: number,\r\n\tiCols: number,\r\n\tiContinentBottomRow: number,\r\n\tiContinentTopRow: number,\r\n\tiWestContinentLeftCol: number,\r\n\tiWestContinentRightCol: number,\r\n\tiEastContinentLeftCol: number,\r\n): number {\r\n\tlet iContinentBase = 0;\r\n\tif (iX >= iEastContinentLeftCol) {\r\n\t\tiContinentBase += iRows * iCols;\r\n\t\tiX = iX - iEastContinentLeftCol + iWestContinentLeftCol;\r\n\t}\r\n\r\n\tconst iXSector: number = Math.floor(\r\n\t\t(iX - iWestContinentLeftCol) / ((iWestContinentRightCol - iWestContinentLeftCol) / iCols),\r\n\t);\r\n\tconst iYSector: number = Math.floor(\r\n\t\t(iY - iContinentBottomRow) / ((iContinentTopRow - iContinentBottomRow) / iRows),\r\n\t);\r\n\tconst iSector: number = iYSector * iCols + iXSector;\r\n\tconst iReturnValue: number = iContinentBase + iSector;\r\n\r\n\treturn iReturnValue;\r\n}\r\n\r\nexport function getSectorRegion(\r\n\tiSector: number,\r\n\tiRows: number,\r\n\tiCols: number,\r\n\tiContinentBottomRow: number,\r\n\tiContinentTopRow: number,\r\n\tiWestContinentLeftCol: number,\r\n\tiWestContinentRightCol: number,\r\n\tiEastContinentLeftCol: number,\r\n): ContinentBoundary {\r\n\tconst region: ContinentBoundary = { west: 0, east: 0, south: 0, north: 0, continent: 0 };\r\n\r\n\tif (iCols == 0) return region; // Safety check\r\n\r\n\tconst bIsEastContinent: boolean = iSector >= iRows * iCols;\r\n\tlet iSectorAdjust = 0;\r\n\tif (bIsEastContinent) {\r\n\t\tiSectorAdjust = iRows * iCols;\r\n\t}\r\n\tconst row: number = Math.floor((iSector - iSectorAdjust) / iCols);\r\n\tconst col: number = Math.floor(iSector - iSectorAdjust - row * iCols);\r\n\tconst iSectorWidth = (iWestContinentRightCol - iWestContinentLeftCol) / iCols;\r\n\tconst iSectorHeight = (iContinentTopRow - iContinentBottomRow) / iRows;\r\n\r\n\tlet iXAdjust = iWestContinentLeftCol;\r\n\tif (bIsEastContinent) {\r\n\t\tiXAdjust = iEastContinentLeftCol;\r\n\t}\r\n\tregion.west = Math.floor(iXAdjust + iSectorWidth * col);\r\n\tregion.east = Math.floor(iXAdjust + iSectorWidth * (col + 1));\r\n\tregion.south = Math.floor(iContinentBottomRow + iSectorHeight * row);\r\n\tregion.north = Math.floor(iContinentBottomRow + iSectorHeight * (row + 1));\r\n\tregion.continent = -1; // ignore continent check\r\n\r\n\treturn region;\r\n}\r\n\r\nexport function getHeightAdjustingForStartSector(\r\n\tiX: number,\r\n\tiY: number,\r\n\tiWaterHeight: number,\r\n\tiFractalWeight: number,\r\n\tiCenterWeight: number,\r\n\tiStartSectorWeight: number,\r\n\tcontinent1: ContinentBoundary,\r\n\tcontinent2: ContinentBoundary,\r\n\tiStartSectorRows: number,\r\n\tiStartSectorCols: number,\r\n\tstartSectors: boolean[],\r\n): number {\r\n\t// Get the value from the fractal\r\n\tlet iPlotHeight: number = FractalBuilder.getHeight(globals.g_LandmassFractal, iX, iY);\r\n\tiPlotHeight *= iFractalWeight;\r\n\r\n\t// Adjust based on distance from center of the continent\r\n\tconst iDistanceFromCenter: number = getDistanceFromContinentCenter(\r\n\t\tiX,\r\n\t\tiY,\r\n\t\tcontinent1.south,\r\n\t\tcontinent1.north,\r\n\t\tcontinent1.west,\r\n\t\tcontinent1.east,\r\n\t\tcontinent2.west,\r\n\t\tcontinent2.east,\r\n\t);\r\n\tconst iMaxDistanceFromCenter: number = getMaxDistanceFromContinentCenter(\r\n\t\tiX,\r\n\t\tcontinent1.south,\r\n\t\tcontinent1.north,\r\n\t\tcontinent1.west,\r\n\t\tcontinent1.east,\r\n\t\tcontinent2.west,\r\n\t\tcontinent2.east,\r\n\t);\r\n\tconst iPercentFromCenter: number = Math.min((100 * iDistanceFromCenter) / iMaxDistanceFromCenter, 100);\r\n\tiPlotHeight +=\r\n\t\tiCenterWeight * Math.pow((iWaterHeight * (100 - iPercentFromCenter)) / 100, globals.g_CenterExponent);\r\n\r\n\t// Adjust based on whether or not the plot is near a start location (unless very far from center)\r\n\tif (iPercentFromCenter < globals.g_IgnoreStartSectorPctFromCtr) {\r\n\t\tconst iSector: number = getSector(\r\n\t\t\tiX,\r\n\t\t\tiY,\r\n\t\t\tiStartSectorRows,\r\n\t\t\tiStartSectorCols,\r\n\t\t\tcontinent1.south,\r\n\t\t\tcontinent1.north,\r\n\t\t\tcontinent1.west,\r\n\t\t\tcontinent1.east,\r\n\t\t\tcontinent2.west,\r\n\t\t);\r\n\t\tif (startSectors[iSector]) {\r\n\t\t\t// Start sector, increase chance we include it\r\n\t\t\tconst sectorCenterX = (continent1.west + continent1.east) / 2;\r\n\t\t\tconst sectorCenterY = (continent1.south + continent1.north) / 2;\r\n\t\t\tconst distanceToSectorCenter = Math.sqrt((iX - sectorCenterX) ** 2 + (iY - sectorCenterY) ** 2);\r\n\t\t\tconst maxSectorRadius =\r\n\t\t\t\tMath.min(continent1.east - continent1.west, continent1.north - continent1.south) / 3;\r\n\r\n\t\t\tconst sectorBoostFactor = 1 - Math.pow(Math.min(distanceToSectorCenter / maxSectorRadius, 1), 1.5);\r\n\t\t\tiPlotHeight += iStartSectorWeight * iWaterHeight * sectorBoostFactor;\r\n\r\n\t\t\t// Start sector and less than 2/3rds of full distance from center, add that amount again\r\n\t\t\tif (iPercentFromCenter < (globals.g_IgnoreStartSectorPctFromCtr * 2) / 3) {\r\n\t\t\t\tiPlotHeight += iStartSectorWeight * iWaterHeight;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Interior sector that isn't a start sector? Give it the center bias\r\n\t\tif (iStartSectorCols > 2 && iStartSectorRows > 2) {\r\n\t\t\tlet iTestSector = iSector;\r\n\t\t\tif (iTestSector >= iStartSectorRows * iStartSectorCols) {\r\n\t\t\t\tiTestSector = iSector - iStartSectorRows * iStartSectorCols;\r\n\t\t\t}\r\n\t\t\tif (iTestSector % iStartSectorCols > 0 && iTestSector % iStartSectorCols < iStartSectorCols - 1) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tiTestSector >= iStartSectorCols &&\r\n\t\t\t\t\tiTestSector < iStartSectorRows * iStartSectorCols - iStartSectorCols\r\n\t\t\t\t) {\r\n\t\t\t\t\tiPlotHeight += iCenterWeight * iWaterHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn iPlotHeight;\r\n}\r\n\r\nexport function createIslands(\r\n\tiWidth: number,\r\n\tiHeight: number,\r\n\tcontinent1: ContinentBoundary,\r\n\tcontinent2: ContinentBoundary,\r\n\tiSize: number,\r\n) {\r\n\tFractalBuilder.create(globals.g_LandmassFractal, iWidth, iHeight, iSize, 0);\r\n\tconst iwater_percent = 50 /*Special Water Percent for Archipelago */ + iSize * 7;\r\n\tconst iWaterHeight: number = FractalBuilder.getHeightFromPercent(globals.g_LandmassFractal, iwater_percent);\r\n\tconst iBuffer: number = Math.floor(iWidth / 24.0);\r\n\tconst terrain: TerrainType = globals.g_FlatTerrain;\r\n\r\n\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\tconst iRandom: number = TerrainBuilder.getRandomNumber(iBuffer, \"Random Top/Bottom Edges\");\r\n\t\t\tif (\r\n\t\t\t\tiY >= continent1.south + iRandom &&\r\n\t\t\t\tiY <= continent1.north - iRandom &&\r\n\t\t\t\t((iX >= continent1.west && iX <= continent1.east) || (iX >= continent2.west && iX <= continent2.east))\r\n\t\t\t) {\r\n\t\t\t\tconst iPlotHeight: number = FractalBuilder.getHeight(globals.g_LandmassFractal, iX, iY);\r\n\t\t\t\tif (iPlotHeight > iWaterHeight) {\r\n\t\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, terrain);\r\n\t\t\t\t\tTerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);\r\n\t\t\t\t\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function applyCoastalErosion(\r\n\tcontinent: ContinentBoundary,\r\n\tstrength: number,\r\n\tfalloff: number,\r\n\tminRadiusFactor: number,\r\n\tverticalOnly: boolean,\r\n) {\r\n\tconsole.log(\r\n\t\t`Applying Coastal Erosion with strength ${strength} to continent at (${continent.west}, ${continent.east})`,\r\n\t);\r\n\r\n\tconst centerX = (continent.west + continent.east) / 2;\r\n\tconst centerY = (continent.south + continent.north) / 2;\r\n\tconst maxRadiusY = (continent.north - continent.south) / 2;\r\n\tconst maxRadius = verticalOnly\r\n\t\t? maxRadiusY\r\n\t\t: Math.min(continent.east - continent.west, continent.north - continent.south) / 2;\r\n\tconst minRadius = maxRadius * minRadiusFactor;\r\n\r\n\tconst erosionTiles: { x: number; y: number }[] = [];\r\n\r\n\tfor (let iY = continent.south; iY <= continent.north; iY++) {\r\n\t\tfor (let iX = continent.west; iX <= continent.east; iX++) {\r\n\t\t\tconst terrain = GameplayMap.getTerrainType(iX, iY);\r\n\t\t\tif (terrain == globals.g_OceanTerrain) continue;\r\n\r\n\t\t\tlet distance = 0;\r\n\t\t\tif (verticalOnly) {\r\n\t\t\t\tdistance = Math.abs(iY - (continent.south + continent.north) / 2);\r\n\t\t\t} else {\r\n\t\t\t\tdistance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);\r\n\t\t\t}\r\n\r\n\t\t\tif (distance <= minRadius) continue;\r\n\r\n\t\t\tconst erosionFactor =\r\n\t\t\t\tdistance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;\r\n\t\t\tconst erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;\r\n\t\t\tconst randomChance = TerrainBuilder.getRandomNumber(100, \"Coastal Erosion\") / 100.0;\r\n\r\n\t\t\tif (randomChance < erosionThreshold) {\r\n\t\t\t\terosionTiles.push({ x: iX, y: iY });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Expand erosion from selected tiles for more natural clusters\r\n\tconst expandedErosion = new Set<string>();\r\n\r\n\tfunction addErosionTile(x: number, y: number) {\r\n\t\tconst key = `${x},${y}`;\r\n\t\tif (!expandedErosion.has(key)) {\r\n\t\t\texpandedErosion.add(key);\r\n\t\t\tTerrainBuilder.setTerrainType(x, y, globals.g_OceanTerrain);\r\n\t\t\tTerrainBuilder.setPlotTag(x, y, PlotTags.PLOT_TAG_WATER);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (const tile of erosionTiles) {\r\n\t\taddErosionTile(tile.x, tile.y);\r\n\r\n\t\tconst expansionChance = TerrainBuilder.getRandomNumber(100, \"Erosion Expansion\") / 100.0;\r\n\t\tif (expansionChance < 0.7) {\r\n\t\t\tconst neighbors = [\r\n\t\t\t\t{ x: tile.x + 1, y: tile.y },\r\n\t\t\t\t{ x: tile.x - 1, y: tile.y },\r\n\t\t\t\t{ x: tile.x, y: tile.y + 1 },\r\n\t\t\t\t{ x: tile.x, y: tile.y - 1 },\r\n\t\t\t];\r\n\t\t\tfor (const neighbor of neighbors) {\r\n\t\t\t\tif (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== globals.g_OceanTerrain) {\r\n\t\t\t\t\taddErosionTile(neighbor.x, neighbor.y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconsole.log(\"Coastal Erosion Applied.\");\r\n}\r\n\r\nexport function applyCoastalErosionAdjustingForStartSectors(\r\n\tcontinent1: ContinentBoundary,\r\n\tcontinent2: ContinentBoundary,\r\n\tstrength: number,\r\n\tfalloff: number,\r\n\tminRadiusFactor: number,\r\n\tiStartSectorRows: number,\r\n\tiStartSectorCols: number,\r\n\tstartSectors: boolean[],\r\n) {\r\n\tconsole.log(\r\n\t\t`Applying Coastal Erosion Ajdusting for Start Sectors with strength ${strength} to continent at (${continent1.west}, ${continent1.east})`,\r\n\t);\r\n\r\n\tconst centerX = (continent1.west + continent1.east) / 2;\r\n\tconst centerY = (continent1.south + continent1.north) / 2;\r\n\tconst maxRadius = Math.min(continent1.east - continent1.west, continent1.north - continent1.south) / 2;\r\n\tconst minRadius = maxRadius * minRadiusFactor;\r\n\r\n\tconst erosionTiles: { x: number; y: number }[] = [];\r\n\r\n\tfor (let iY = continent1.south; iY <= continent1.north; iY++) {\r\n\t\tfor (let iX = continent1.west; iX <= continent1.east; iX++) {\r\n\t\t\tconst terrain = GameplayMap.getTerrainType(iX, iY);\r\n\t\t\tif (terrain == globals.g_OceanTerrain) continue;\r\n\r\n\t\t\tlet distance = 0;\r\n\t\t\tdistance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);\r\n\r\n\t\t\tif (distance <= minRadius) continue;\r\n\r\n\t\t\tconst erosionFactor =\r\n\t\t\t\tdistance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;\r\n\t\t\tlet erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;\r\n\t\t\tconst randomChance = TerrainBuilder.getRandomNumber(100, \"Coastal Erosion\") / 100.0;\r\n\r\n\t\t\tconst iSector: number = getSector(\r\n\t\t\t\tiX,\r\n\t\t\t\tiY,\r\n\t\t\t\tiStartSectorRows,\r\n\t\t\t\tiStartSectorCols,\r\n\t\t\t\tcontinent1.south,\r\n\t\t\t\tcontinent1.north,\r\n\t\t\t\tcontinent1.west,\r\n\t\t\t\tcontinent1.east,\r\n\t\t\t\tcontinent2.west,\r\n\t\t\t);\r\n\t\t\tif (startSectors[iSector]) {\r\n\t\t\t\t// Start sector, decrease chance of erosion unless we are at boundry corners\r\n\t\t\t\tif (!isNearContinentCorner(iX, iY, continent1, 0.1)) {\r\n\t\t\t\t\terosionThreshold = erosionThreshold / 10;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (randomChance < erosionThreshold) {\r\n\t\t\t\terosionTiles.push({ x: iX, y: iY });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Checks if a tile is near the corner of a continent's boundaries\r\n\tfunction isNearContinentCorner(iX: number, iY: number, continent: ContinentBoundary, bufferScale: number): boolean {\r\n\t\tconst continentWidth = continent.east - continent.west;\r\n\t\tconst continentHeight = continent.north - continent.south;\r\n\r\n\t\tconst bufferX = Math.max(2, Math.min(Math.floor(continentWidth * bufferScale), 10));\r\n\t\tconst bufferY = Math.max(2, Math.min(Math.floor(continentHeight * bufferScale), 10));\r\n\r\n\t\tconst topLeft = { x: continent.west, y: continent.north };\r\n\t\tconst topRight = { x: continent.east, y: continent.north };\r\n\t\tconst bottomLeft = { x: continent.west, y: continent.south };\r\n\t\tconst bottomRight = { x: continent.east, y: continent.south };\r\n\r\n\t\tfunction isNearCorner(cornerX: number, cornerY: number) {\r\n\t\t\treturn Math.abs(iX - cornerX) <= bufferX && Math.abs(iY - cornerY) <= bufferY;\r\n\t\t}\r\n\r\n\t\treturn (\r\n\t\t\tisNearCorner(topLeft.x, topLeft.y) ||\r\n\t\t\tisNearCorner(topRight.x, topRight.y) ||\r\n\t\t\tisNearCorner(bottomLeft.x, bottomLeft.y) ||\r\n\t\t\tisNearCorner(bottomRight.x, bottomRight.y)\r\n\t\t);\r\n\t}\r\n\r\n\t// Expand erosion from selected tiles for more natural clusters\r\n\tconst expandedErosion = new Set<string>();\r\n\r\n\tfunction addErosionTile(x: number, y: number) {\r\n\t\tconst key = `${x},${y}`;\r\n\t\tif (!expandedErosion.has(key)) {\r\n\t\t\texpandedErosion.add(key);\r\n\t\t\tTerrainBuilder.setTerrainType(x, y, globals.g_OceanTerrain);\r\n\t\t\tTerrainBuilder.setPlotTag(x, y, PlotTags.PLOT_TAG_WATER);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (const tile of erosionTiles) {\r\n\t\taddErosionTile(tile.x, tile.y);\r\n\r\n\t\tconst expansionChance = TerrainBuilder.getRandomNumber(100, \"Erosion Expansion\") / 100.0;\r\n\t\tif (expansionChance < 0.7) {\r\n\t\t\tconst neighbors = [\r\n\t\t\t\t{ x: tile.x + 1, y: tile.y },\r\n\t\t\t\t{ x: tile.x - 1, y: tile.y },\r\n\t\t\t\t{ x: tile.x, y: tile.y + 1 },\r\n\t\t\t\t{ x: tile.x, y: tile.y - 1 },\r\n\t\t\t];\r\n\t\t\tfor (const neighbor of neighbors) {\r\n\t\t\t\tif (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== globals.g_OceanTerrain) {\r\n\t\t\t\t\taddErosionTile(neighbor.x, neighbor.y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconsole.log(\"Coastal Erosion Applied.\");\r\n}\r\n\r\nexport function shuffle(array: number[]) {\r\n\tlet currentIndex = array.length,\r\n\t\ttemporaryValue,\r\n\t\trandomIndex;\r\n\r\n\t// While there remain elements to shuffle...\r\n\twhile (0 !== currentIndex) {\r\n\t\t// Pick a remaining element...\r\n\t\trandomIndex = TerrainBuilder.getRandomNumber(currentIndex, \"Array Shuffle\");\r\n\t\tcurrentIndex -= 1;\r\n\r\n\t\t// And swap it with the current element.\r\n\t\ttemporaryValue = array[currentIndex];\r\n\t\tarray[currentIndex] = array[randomIndex];\r\n\t\tarray[randomIndex] = temporaryValue;\r\n\t}\r\n\r\n\treturn array;\r\n}\r\n\r\nexport function getContinentEdgeHeightBump(iX: number, iY: number): number {\r\n\tif (GameplayMap.findSecondContinent(iX, iY, 1)) {\r\n\t\treturn 100;\r\n\t} else if (GameplayMap.findSecondContinent(iX, iY, 2)) {\r\n\t\treturn 40;\r\n\t} else if (GameplayMap.findSecondContinent(iX, iY, 3)) {\r\n\t\treturn 20;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nexport function getDistanceToClosestStart(\r\n\tiX: number,\r\n\tiY: number,\r\n\tnumFoundEarlier: number,\r\n\tstartPositions: number[],\r\n): number {\r\n\tlet minDistance = 32768;\r\n\r\n\tfor (let iStart = 0; iStart < numFoundEarlier; iStart++) {\r\n\t\tconst startPlotIndex = startPositions[iStart];\r\n\t\tconst iStartX = startPlotIndex % GameplayMap.getGridWidth();\r\n\t\tconst iStartY = Math.floor(startPlotIndex / GameplayMap.getGridWidth());\r\n\t\tconst distance: number = GameplayMap.getPlotDistance(iX, iY, iStartX, iStartY);\r\n\t\tif (distance < minDistance) {\r\n\t\t\tminDistance = distance;\r\n\t\t}\r\n\t}\r\n\t//console.log(\"Distance to Closest start: \", minDistance)\r\n\treturn minDistance;\r\n}\r\n\r\nexport function addLandmassPlotTags(iX: number, iY: number, iEastContinentLeftCol: number): void {\r\n\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_LANDMASS);\r\n\tif (iX >= iEastContinentLeftCol) {\r\n\t\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_LANDMASS);\r\n\t} else {\r\n\t\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_LANDMASS);\r\n\t}\r\n}\r\nexport function addWaterPlotTags(iX: number, iY: number, iEastContinentLeftCol: number): void {\r\n\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);\r\n\tif (iX >= iEastContinentLeftCol - 1) {\r\n\t\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);\r\n\t} else {\r\n\t\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);\r\n\t}\r\n}\r\n\r\nexport function adjustOceanPlotTags(bWestSide: boolean): void {\r\n\tconst iWidth = GameplayMap.getGridWidth();\r\n\tconst iHeight = GameplayMap.getGridHeight();\r\n\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\tconst terrain: TerrainType = GameplayMap.getTerrainType(iX, iY);\r\n\t\t\tif (terrain == globals.g_OceanTerrain) {\r\n\t\t\t\t//console.log(\"ocean\");\r\n\t\t\t\tTerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);\r\n\t\t\t\tif (bWestSide) {\r\n\t\t\t\t\t//console.log(\"East\");\r\n\t\t\t\t\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//console.log(\"West\");\r\n\t\t\t\t\tTerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function adjustLakePlotTags(region: ContinentBoundary, bWestSide: boolean): void {\r\n\tfor (let iY = region.south; iY <= region.north; iY++) {\r\n\t\tfor (let iX = region.west; iX <= region.east; iX++) {\r\n\t\t\tconst terrain: TerrainType = GameplayMap.getTerrainType(iX, iY);\r\n\t\t\tif (terrain == globals.g_CoastTerrain) {\r\n\t\t\t\tTerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);\r\n\t\t\t\tTerrainBuilder.addPlotTag(\r\n\t\t\t\t\tiX,\r\n\t\t\t\t\tiY,\r\n\t\t\t\t\tbWestSide ? PlotTags.PLOT_TAG_WEST_WATER : PlotTags.PLOT_TAG_EAST_WATER,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isAdjacentToNaturalWonder(iX: number, iY: number): boolean {\r\n\tfor (let iDirection: DirectionTypes = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {\r\n\t\tconst iIndex: number = GameplayMap.getIndexFromXY(iX, iY);\r\n\t\tconst iLocation: PlotCoord = GameplayMap.getLocationFromIndex(iIndex);\r\n\t\tconst iAdjacentX: number = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;\r\n\t\tconst iAdjacentY: number = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;\r\n\t\tif (GameplayMap.isNaturalWonder(iAdjacentX, iAdjacentY)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nexport function isCliff(iX: number, iY: number): boolean {\r\n\tfor (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {\r\n\t\tif (GameplayMap.isCliffCrossing(iX, iY, iDirection) == false) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nexport function isOceanAccess(iX: number, iY: number): boolean {\r\n\tfor (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {\r\n\t\tconst iIndex: number = GameplayMap.getIndexFromXY(iX, iY);\r\n\t\tconst iLocation: PlotCoord = GameplayMap.getLocationFromIndex(iIndex);\r\n\t\tconst iAdjacentX: number = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;\r\n\t\tconst iAdjacentY: number = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;\r\n\t\tconst iAdjacentIndex: number = GameplayMap.getIndexFromXY(iAdjacentX, iAdjacentY);\r\n\t\tif (\r\n\t\t\tGameplayMap.getRiverType(iAdjacentX, iAdjacentY) == RiverTypes.RIVER_NAVIGABLE &&\r\n\t\t\tMapRivers.isRiverConnectedToOcean(iAdjacentIndex)\r\n\t\t) {\r\n\t\t\t//console.log(\"River connected to ocean\");\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\tGameplayMap.getAreaId(iAdjacentX, iAdjacentY) > -1 &&\r\n\t\t\tGameplayMap.getAreaIsWater(iAdjacentX, iAdjacentY) &&\r\n\t\t\tAreaBuilder.isAreaConnectedToOcean(GameplayMap.getAreaId(iAdjacentX, iAdjacentY))\r\n\t\t) {\r\n\t\t\t//console.log(\"Area connected to ocean\");\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nexport function removeRuralDistrict(iX: number, iY: number) {\r\n\tconst districtID = MapCities.getDistrict(iX, iY);\r\n\tif (districtID != null) {\r\n\t\tconst cityID = MapCities.getCity(iX, iY);\r\n\t\tif (cityID != null) {\r\n\t\t\tconst city: City | null = Cities.get(cityID);\r\n\t\t\tif (city != null) {\r\n\t\t\t\t// Don't remove the district if it is the CITY_CENTER district\r\n\t\t\t\tif (city.location.x != iX || city.location.y != iY) {\r\n\t\t\t\t\tconsole.log(\"Removed district at (\" + iX + \", \" + iY + \")\");\r\n\t\t\t\t\tcity.Districts?.removeDistrict(districtID);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function placeRuralDistrict(iX: number, iY: number) {\r\n\tconst cityID = MapCities.getCity(iX, iY);\r\n\tif (cityID != null) {\r\n\t\tconst city: City | null = Cities.get(cityID);\r\n\t\tif (city != null) {\r\n\t\t\tif (city.location.x != iX || city.location.y != iY) {\r\n\t\t\t\tconsole.log(\"Placed district at (\" + iX + \", \" + iY + \")\");\r\n\t\t\t\tcity.Growth?.claimPlot({ x: iX, y: iY });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function replaceIslandResources(iWidth: number, iHeight: number, zResourceClassType: string) {\r\n\t//Get all treasure resources\r\n\tconst resourceRunningWeight: number[] = new Array(GameInfo.Resources.length);\r\n\tconst resourceWeight: number[] = new Array(GameInfo.Resources.length);\r\n\tconst resources: number[] = [];\r\n\tfor (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {\r\n\t\tconst resourceInfo = GameInfo.Resources.lookup(resourceIdx);\r\n\t\tif (resourceInfo && resourceInfo.Tradeable) {\r\n\t\t\tif (GameInfo.Resources.lookup(resourceIdx)?.ResourceClassType == zResourceClassType) {\r\n\t\t\t\tresources.push(resourceIdx);\r\n\t\t\t}\r\n\t\t\tresourceWeight[resourceInfo.$index] = resourceInfo.Weight;\r\n\t\t}\r\n\t\tresourceRunningWeight[resourceIdx] = 0;\r\n\t}\r\n\r\n\tfor (let iY: number = iHeight - 1; iY >= 0; iY--) {\r\n\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\tif (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {\r\n\t\t\t\tconst resourceAtLocation = GameplayMap.getResourceType(iX, iY);\r\n\t\t\t\tif (resourceAtLocation != ResourceTypes.NO_RESOURCE) {\r\n\t\t\t\t\tif (resources.length > 0) {\r\n\t\t\t\t\t\tlet resourceChosen: ResourceType = ResourceTypes.NO_RESOURCE;\r\n\t\t\t\t\t\tlet resourceChosenIndex = 0;\r\n\t\t\t\t\t\tfor (let iI = 0; iI < resources.length; iI++) {\r\n\t\t\t\t\t\t\tif ((resources[iI] as ResourceType) != resourceAtLocation) {\r\n\t\t\t\t\t\t\t\tif (ResourceBuilder.canHaveResource(iX, iY, resources[iI], true)) {\r\n\t\t\t\t\t\t\t\t\tif (resourceChosen == ResourceTypes.NO_RESOURCE) {\r\n\t\t\t\t\t\t\t\t\t\tresourceChosen = resources[iI];\r\n\t\t\t\t\t\t\t\t\t\tresourceChosenIndex = resources[iI];\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\tresourceRunningWeight[resources[iI]] >\r\n\t\t\t\t\t\t\t\t\t\t\tresourceRunningWeight[resourceChosenIndex]\r\n\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tresourceChosen = resources[iI];\r\n\t\t\t\t\t\t\t\t\t\t\tresourceChosenIndex = resources[iI];\r\n\t\t\t\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\t\t\t\tresourceRunningWeight[resources[iI]] ==\r\n\t\t\t\t\t\t\t\t\t\t\tresourceRunningWeight[resourceChosenIndex]\r\n\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tconst iRoll = TerrainBuilder.getRandomNumber(2, \"Resource Scatter\");\r\n\t\t\t\t\t\t\t\t\t\t\tif (iRoll >= 1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tresourceChosen = resources[iI];\r\n\t\t\t\t\t\t\t\t\t\t\t\tresourceChosenIndex = resources[iI];\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//Place the selected resource\r\n\t\t\t\t\t\tif (resourceChosen != ResourceTypes.NO_RESOURCE) {\r\n\t\t\t\t\t\t\tconst iResourcePlotIndex: number = GameplayMap.getIndexFromXY(iX, iY);\r\n\t\t\t\t\t\t\tif (iResourcePlotIndex != -1) {\r\n\t\t\t\t\t\t\t\tremoveRuralDistrict(iX, iY);\r\n\t\t\t\t\t\t\t\tResourceBuilder.setResourceType(iX, iY, ResourceTypes.NO_RESOURCE);\r\n\t\t\t\t\t\t\t\tResourceBuilder.setResourceType(iX, iY, resourceChosen);\r\n\t\t\t\t\t\t\t\tplaceRuralDistrict(iX, iY);\r\n\t\t\t\t\t\t\t\tresourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];\r\n\t\t\t\t\t\t\t\tconst oldName: any = GameInfo.Resources.lookup(resourceAtLocation)?.Name;\r\n\t\t\t\t\t\t\t\tconst name: any = GameInfo.Resources.lookup(resourceChosenIndex)?.Name;\r\n\t\t\t\t\t\t\t\tconsole.log(\"Replaced \" + Locale.compose(oldName) + \" at (\" + iX + \", \" + iY + \")\");\r\n\t\t\t\t\t\t\t\tconsole.log(\"Placed \" + Locale.compose(name) + \" at (\" + iX + \", \" + iY + \")\");\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tconsole.log(\"Resource Index Failure\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tconsole.log(\"No valid resource replacement\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function isAdjacentToLand(iX: number, iY: number): boolean {\r\n\tif (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {\r\n\t\t//console.log(\"Island \" + \" X: \" + iX + \" Y: \" + iY);\r\n\t\treturn true;\r\n\t} else {\r\n\t\tfor (let iDirection: DirectionTypes = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {\r\n\t\t\tconst iIndex: number = GameplayMap.getIndexFromXY(iX, iY);\r\n\t\t\tconst iLocation: PlotCoord = GameplayMap.getLocationFromIndex(iIndex);\r\n\t\t\tconst iAdjacentX: number = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;\r\n\t\t\tconst iAdjacentY: number = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;\r\n\t\t\tif (GameplayMap.hasPlotTag(iAdjacentX, iAdjacentY, PlotTags.PLOT_TAG_ISLAND)) {\r\n\t\t\t\t//console.log(\"Island2 \" + \" X: \" + iX + \" Y: \" + iY);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n//-------------------------------------------------------------------------------------------\r\n//-- FUNCTIONS TO SHIFT LANDMASSES (i.e. to better center them)\r\n//-------------------------------------------------------------------------------------------\r\nexport function shiftTerrain(iWidth: number, iHeight: number) {\r\n\tlet shift_x = 0;\r\n\tlet shift_y = 0;\r\n\r\n\tshift_x = determineXShift(iWidth, iHeight);\r\n\tshift_y = determineYShift(iWidth, iHeight);\r\n\r\n\tconsole.log(\"shift_x: \" + shift_x);\r\n\tconsole.log(\"shift_y: \", shift_y);\r\n\r\n\tshiftPlotTypesBy(iWidth, iHeight, shift_x, shift_y);\r\n}\r\n// -------------------------------------------------------------------------------------------\r\nexport function shiftPlotTypesBy(iWidth: number, iHeight: number, xshift: number, yshift: number) {\r\n\tif (xshift > 0 || yshift > 0) {\r\n\t\t// Copy all info into a temp array\r\n\t\tconst iTempTerrainArray = Array(iWidth)\r\n\t\t\t.fill(globals.g_OceanTerrain)\r\n\t\t\t.map((_) => Array(iHeight));\r\n\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\t\t\tiTempTerrainArray[iX][iY] = GameplayMap.getTerrainType(iX, iY);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set them with the shifts applied\r\n\t\tfor (let iDestX = 0; iDestX < iWidth; iDestX++) {\r\n\t\t\tfor (let iDestY = 0; iDestY < iHeight; iDestY++) {\r\n\t\t\t\tconst iSourceX = (iDestX + xshift) % iWidth;\r\n\t\t\t\tconst iSourceY = (iDestY + yshift) % iHeight;\r\n\t\t\t\tconst iTerrain = iTempTerrainArray[iSourceX][iSourceY];\r\n\t\t\t\tTerrainBuilder.setTerrainType(iDestX, iDestY, iTerrain);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n// -------------------------------------------------------------------------------------------\r\nexport function determineXShift(iWidth: number, iHeight: number) {\r\n\t/* This function will align the most water-heavy vertical portion of the map with the \r\n\tvertical map edge. This is a form of centering the landmasses, but it emphasizes the\r\n\tedge not the middle. If there are columns completely empty of land, these will tend to\r\n\tbe chosen as the new map edge, but it is possible for a narrow column between two large \r\n\tcontinents to be passed over in favor of the thinnest section of a continent, because\r\n\tthe operation looks at a group of columns not just a single column, then picks the \r\n\tcenter of the most water heavy group of columns to be the new vertical map edge. */\r\n\r\n\t// First loop through the map columns and record land plots in each column.\r\n\tconst waterTotals: number[] = [];\r\n\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\tlet colWaterCount = 0;\r\n\t\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\t\tif (GameplayMap.getTerrainType(iX, iY) == globals.g_OceanTerrain) {\r\n\t\t\t\tcolWaterCount = colWaterCount + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\twaterTotals.push(colWaterCount);\r\n\t}\r\n\r\n\t// Now evaluate column groups, each record applying to the center column of the group.\r\n\tconst columnGroups: number[] = [];\r\n\r\n\t// Determine the group size in relation to map width.\r\n\tconst groupRadius = Math.floor(iWidth / 10);\r\n\r\n\t// Measure the groups.\r\n\tfor (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {\r\n\t\tlet currentGroupTotal = 0;\r\n\t\tfor (\r\n\t\t\tlet currentCol: number = columnIndex - groupRadius;\r\n\t\t\tcurrentCol <= columnIndex + groupRadius;\r\n\t\t\tcurrentCol++\r\n\t\t) {\r\n\t\t\tconst currentIdx = (currentCol + iWidth) % iWidth;\r\n\t\t\tcurrentGroupTotal = currentGroupTotal + waterTotals[currentIdx];\r\n\t\t}\r\n\t\tcolumnGroups.push(currentGroupTotal);\r\n\t}\r\n\r\n\t// Identify the group with the most water in it.\r\n\tlet bestValue = 0; // Set initial value to lowest possible.\r\n\tlet bestGroup = 0; // Set initial best group as current map edge.\r\n\r\n\tfor (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {\r\n\t\tif (columnGroups[columnIndex] > bestValue) {\r\n\t\t\tbestValue = columnGroups[columnIndex];\r\n\t\t\tbestGroup = columnIndex;\r\n\t\t}\r\n\t}\r\n\r\n\t// Determine X Shift\r\n\tconst x_shift = bestGroup;\r\n\treturn x_shift;\r\n}\r\n// -------------------------------------------------------------------------------------------\r\nexport function determineYShift(iWidth: number, iHeight: number) {\r\n\t// Counterpart to determineXShift()\r\n\r\n\t// First loop through the map rows and record water plots in each row\r\n\tconst waterTotals: number[] = [];\r\n\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\tlet rowWaterCount = 0;\r\n\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\tif (GameplayMap.getTerrainType(iX, iY) == globals.g_OceanTerrain) {\r\n\t\t\t\trowWaterCount = rowWaterCount + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\twaterTotals.push(rowWaterCount);\r\n\t}\r\n\r\n\t// Now evaluate row groups, each record applying to the center row of the group.\r\n\tconst rowGroups: number[] = [];\r\n\r\n\t// Determine the group size in relation to map height.\r\n\tconst groupRadius = Math.floor(iHeight / 15);\r\n\r\n\t// Measure the groups.\r\n\tfor (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {\r\n\t\tlet currentGroupTotal = 0;\r\n\t\tfor (let currentRow: number = rowIndex - groupRadius; currentRow <= rowIndex + groupRadius; currentRow++) {\r\n\t\t\tconst currentIdx = (currentRow + iHeight) % iHeight;\r\n\t\t\tcurrentGroupTotal = currentGroupTotal + waterTotals[currentIdx];\r\n\t\t}\r\n\t\trowGroups.push(currentGroupTotal);\r\n\t}\r\n\r\n\t// Identify the group with the most water in it.\r\n\tlet bestValue = 0; // Set initial value to lowest possible.\r\n\tlet bestGroup = 0; // Set initial best group as current map edge.\r\n\r\n\tfor (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {\r\n\t\tif (rowGroups[rowIndex] > bestValue) {\r\n\t\t\tbestValue = rowGroups[rowIndex];\r\n\t\t\tbestGroup = rowIndex;\r\n\t\t}\r\n\t}\r\n\r\n\t// Determine X Shift\r\n\tconst y_shift = bestGroup;\r\n\treturn y_shift;\r\n}\r\n\r\n//-------------------------------------------------------------------------------------------\r\n//-- FUNCTIONS TO SHIFT LANDMASSES (i.e. to better center them)\r\n//-------------------------------------------------------------------------------------------\r\nexport function createOrganicLandmasses(\r\n\tiWidth: number,\r\n\tiHeight: number,\r\n\tcontinent1: ContinentBoundary,\r\n\tcontinent2: ContinentBoundary,\r\n\tiFractalGrain: number,\r\n\tiWaterPercent: number,\r\n\tiLargestContinentPercent: number,\r\n) {\r\n\tlet bLargeEnoughFound = false;\r\n\r\n\twhile (!bLargeEnoughFound) {\r\n\t\tlet iFlags = 0;\r\n\t\tiFlags = 1; // FRAC_WRAP_X\r\n\t\tiFlags += 2; // FRAC_WRAP_Y\r\n\t\tFractalBuilder.create(globals.g_LandmassFractal, iWidth, iHeight, iFractalGrain, iFlags);\r\n\t\tconst iWaterHeight: number = FractalBuilder.getHeightFromPercent(globals.g_LandmassFractal, iWaterPercent);\r\n\r\n\t\t// Apply the fractal as is\r\n\t\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\t\tlet terrain: TerrainType = globals.g_OceanTerrain;\r\n\t\t\t\tconst iPlotHeight: number = FractalBuilder.getHeight(globals.g_LandmassFractal, iX, iY);\r\n\t\t\t\tif (iPlotHeight >= iWaterHeight) {\r\n\t\t\t\t\tterrain = globals.g_FlatTerrain;\r\n\t\t\t\t}\r\n\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, terrain);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Shift it vertically and horizontally so the most water-filled rows & columns are where\r\n\t\t// we want them\r\n\t\tshiftTerrain(iWidth, iHeight);\r\n\r\n\t\t// Add the gutters at the top of the map and along the world wrap\r\n\t\tlet iTilesChoppedInGutter = 0;\r\n\t\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\t\tif (GameplayMap.getTerrainType(iX, iY) != globals.g_OceanTerrain) {\r\n\t\t\t\t\t// Top and bottom\r\n\t\t\t\t\tif (iY < continent1.south || iY >= continent1.north) {\r\n\t\t\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, globals.g_OceanTerrain);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Random feathering\r\n\t\t\t\t\telse if (iY == continent1.south || iY == continent1.north - 1) {\r\n\t\t\t\t\t\tif (TerrainBuilder.getRandomNumber(2, \"Feather hard edges\") == 0) {\r\n\t\t\t\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, globals.g_OceanTerrain);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Now gutter along world wrap\r\n\t\t\t\t\tif (iX < continent1.west || iX > continent2.east - 1) {\r\n\t\t\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, globals.g_OceanTerrain);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Random feathering\r\n\t\t\t\t\telse if (iX == continent1.west || iX == continent2.east - 1) {\r\n\t\t\t\t\t\tif (TerrainBuilder.getRandomNumber(2, \"Feather hard edges\") == 0) {\r\n\t\t\t\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, globals.g_OceanTerrain);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Finally gutter between hemispheres\r\n\t\t\t\t\tif (iX > continent1.east - 1 && iX < continent2.west) {\r\n\t\t\t\t\t\tiTilesChoppedInGutter = iTilesChoppedInGutter + 1;\r\n\t\t\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, globals.g_OceanTerrain);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Random feathering\r\n\t\t\t\t\telse if (iX == continent1.east - 1 || iX == continent2.west) {\r\n\t\t\t\t\t\tif (TerrainBuilder.getRandomNumber(2, \"Feather hard edges\") == 0) {\r\n\t\t\t\t\t\t\tTerrainBuilder.setTerrainType(iX, iY, globals.g_OceanTerrain);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Keep trying if we just had to chop a LOT of tiles down the gutter (which leads to long, straight lines)\r\n\t\tconsole.log(\"Tiles in Center Gutter:\" + iTilesChoppedInGutter);\r\n\t\tconst iMaxTilesToChop = (iHeight * (continent2.west - continent1.east)) / 2;\r\n\t\tconsole.log(\"Max Tiles to Chop: \" + iMaxTilesToChop);\r\n\t\tif (iTilesChoppedInGutter >= iMaxTilesToChop) {\r\n\t\t\tconsole.log(\"Fail. Too many tiles lost in center gutter\");\r\n\t\t} else {\r\n\t\t\t// Now check that largest continent is big enough\r\n\t\t\tAreaBuilder.recalculateAreas();\r\n\t\t\tconst iAreaID = AreaBuilder.findBiggestArea(false);\r\n\t\t\tconst iPlotCount = AreaBuilder.getPlotCount(iAreaID);\r\n\t\t\tconsole.log(\"Plots in Largest Landmass:\" + iPlotCount);\r\n\t\t\tconst iPlotsNeeded = (iWidth * iHeight * iLargestContinentPercent) / 100;\r\n\t\t\tconsole.log(\"Plots Needed:\" + iPlotsNeeded);\r\n\r\n\t\t\tif (iPlotCount >= iPlotsNeeded) {\r\n\t\t\t\tconsole.log(\"Useable continent found\");\r\n\t\t\t\tbLargeEnoughFound = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function addPlotTags(iHeight: number, iWidth: number, iEastContinentLeftCol: number) {\r\n\tfor (let iY = 0; iY < iHeight; iY++) {\r\n\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\tTerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);\r\n\t\t\tconst terrain: TerrainType = GameplayMap.getTerrainType(iX, iY);\r\n\t\t\tif (terrain != globals.g_OceanTerrain && terrain != globals.g_CoastTerrain) {\r\n\t\t\t\taddLandmassPlotTags(iX, iY, iEastContinentLeftCol);\r\n\t\t\t} else {\r\n\t\t\t\taddWaterPlotTags(iX, iY, iEastContinentLeftCol);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function clearContinent(continent1: ContinentBoundary) {\r\n\tfor (let iY: number = continent1.south; iY <= continent1.north; iY++) {\r\n\t\tfor (let iX: number = continent1.west; iX <= continent1.east; iX++) {\r\n\t\t\tconst terrain: TerrainType = globals.g_OceanTerrain;\r\n\t\t\tTerrainBuilder.setTerrainType(iX, iY, terrain);\r\n\t\t}\r\n\t}\r\n}\r\n"],"names":["globals.g_LandmassFractal","globals.g_CenterExponent","globals.g_IgnoreStartSectorPctFromCtr","globals.g_FlatTerrain","globals.g_OceanTerrain","globals.g_CoastTerrain"],"mappings":"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"}