{"version":3,"file":"assign-advanced-start-region.js","sources":["../../../modules/base-standard/maps/assign-advanced-start-region.ts"],"sourcesContent":["import * as globals from \"#base/maps/map-globals.js\";\r\nconst g_StartingScore = 20;\r\nconst g_BadTerrainScore = 1;\r\nconst g_GoodTerrainScore = 10;\r\nconst g_TooCloseToOtherPlayerPenalty = -3;\r\nconst g_TooCloseDistance = 10;\r\n\r\nclass AdvancedStartRegion {\r\n\tplayer: PlayerId;\r\n\tclaimedPlots: number[] = [];\r\n\tpotentialPlots: Map<number, number>;\r\n\tstartPlot: float2;\r\n\tconstructor(inPlayer: PlayerId) {\r\n\t\tthis.player = inPlayer;\r\n\t\tthis.startPlot = { x: -1, y: -1 };\r\n\t\tthis.potentialPlots = new Map<number, number>();\r\n\t}\r\n}\r\n\r\nexport function assignAdvancedStartRegions(): void {\r\n\tconst playerIds = Players.getAliveIds();\r\n\tconst playerRegions: AdvancedStartRegion[] = [];\r\n\tconst playerStartPositions: float2[] = [];\r\n\tfor (const playerId of playerIds) {\r\n\t\tconst region: AdvancedStartRegion = new AdvancedStartRegion(playerId);\r\n\t\tinitializeRegion(region);\r\n\t\tplayerStartPositions.push(region.startPlot);\r\n\t\tplayerRegions.push(region);\r\n\t}\r\n\r\n\tlet maxRegionSize = 0;\r\n\tconst advStartParams = GameInfo.AdvancedStartParameters.lookup(Game.age);\r\n\tif (advStartParams !== null) {\r\n\t\tmaxRegionSize = advStartParams.MaxRegionPlots;\r\n\t}\r\n\r\n\tlet minRange = 3;\r\n\tconst minRangeDef: GlobalParameterDefinition | null = GameInfo.GlobalParameters.lookup(\"CITY_MIN_RANGE\");\r\n\tif (minRangeDef !== null) {\r\n\t\tminRange = parseInt(minRangeDef.Value);\r\n\t}\r\n\r\n\tfor (let plotCount = 0; plotCount < maxRegionSize; plotCount++) {\r\n\t\t// Claim plots one player at a time, so all regions get a fair chance\r\n\t\tfor (let i = 0; i < playerRegions.length; i++) {\r\n\t\t\t// Claim the next plot\r\n\t\t\tconst plotIndex: number = claimPlot(playerRegions[i], playerStartPositions);\r\n\t\t\tif (plotIndex !== -1) {\r\n\t\t\t\t// Let other player regions know this plot is no longer available, and also anything within X tiles of it, depending on how close you can settle (normally 3)\r\n\t\t\t\tconst plot: float2 = GameplayMap.getLocationFromIndex(plotIndex);\r\n\t\t\t\tconst claimedPlots: number[] = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, minRange);\r\n\t\t\t\tfor (let j = 0; j < playerRegions.length; j++) {\r\n\t\t\t\t\tif (i !== j) {\r\n\t\t\t\t\t\tfor (const claimedPlot of claimedPlots) {\r\n\t\t\t\t\t\t\tplayerRegions[j].potentialPlots.set(claimedPlot, -1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (let i = 0; i < playerRegions.length; i++) {\r\n\t\tStartPositioner.setAdvancedStartRegion(playerRegions[i].player, playerRegions[i].claimedPlots);\r\n\t}\r\n\r\n\tdumpAdvancedStartRegions(playerRegions);\r\n}\r\n\r\nfunction initializeRegion(region: AdvancedStartRegion) {\r\n\tconst startPosition: number = StartPositioner.getStartPosition(region.player);\r\n\tif (startPosition === -1) {\r\n\t\treturn;\r\n\t}\r\n\tregion.startPlot = GameplayMap.getLocationFromIndex(startPosition);\r\n\tregion.potentialPlots.set(startPosition, g_StartingScore + g_GoodTerrainScore);\r\n}\r\n\r\nfunction claimPlot(region: AdvancedStartRegion, playerStartPositions: float2[]): number {\r\n\t// Find the best plot to include\r\n\tlet chosenPlot = -1;\r\n\tlet maxScore = -1;\r\n\tfor (const [potentialPlot, score] of region.potentialPlots.entries()) {\r\n\t\tif (score > maxScore) {\r\n\t\t\tmaxScore = score;\r\n\t\t\tchosenPlot = potentialPlot;\r\n\t\t}\r\n\t}\r\n\r\n\tif (chosenPlot !== -1) {\r\n\t\t// First, include this in our region\r\n\t\tregion.claimedPlots.push(chosenPlot);\r\n\t\t// Second, set the score of this plot to -1 to indicate it is no longer a valid choice\r\n\t\tregion.potentialPlots.set(chosenPlot, -1);\r\n\t\t// Lastly, adjust the score of surrounding plots, or add them as potential plots\r\n\t\tconst plot: float2 = GameplayMap.getLocationFromIndex(chosenPlot);\r\n\t\tconst adjacentPlots: number[] = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, 1);\r\n\t\tfor (let i = 0; i < adjacentPlots.length; i++) {\r\n\t\t\tconst adjacentPlotIndex = adjacentPlots[i];\r\n\t\t\tif (region.potentialPlots.has(adjacentPlotIndex) == false) {\r\n\t\t\t\t// This is a new plot. Initialize it based on terrain type\r\n\t\t\t\tconst adjPlot: float2 = GameplayMap.getLocationFromIndex(adjacentPlotIndex);\r\n\t\t\t\tconst terrainType: TerrainType = GameplayMap.getTerrainType(adjPlot.x, adjPlot.y);\r\n\t\t\t\tif (terrainType == globals.g_OceanTerrain) {\r\n\t\t\t\t\t// No ocean\r\n\t\t\t\t\tregion.potentialPlots.set(adjacentPlotIndex, -1);\r\n\t\t\t\t} else if (terrainType == globals.g_MountainTerrain || terrainType == globals.g_CoastTerrain) {\r\n\t\t\t\t\t// Mountains and coasts are not ideal as you cannot actually settle there, so we would like to only include them if we have to get to the other side\r\n\t\t\t\t\tregion.potentialPlots.set(adjacentPlotIndex, g_BadTerrainScore);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// This should be fine terrain to include. Even if this is a river we can't settle on, we want to include it in the settlement area\r\n\t\t\t\t\tregion.potentialPlots.set(adjacentPlotIndex, g_GoodTerrainScore);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If we are including this plot as a potential, weight it based on how far it is away from the start position\r\n\t\t\t\tlet score = region.potentialPlots.get(adjacentPlotIndex);\r\n\t\t\t\tif (score) {\r\n\t\t\t\t\t// We just set it above, but test it anyway\r\n\t\t\t\t\tif (score > 0) {\r\n\t\t\t\t\t\tlet distScore: number =\r\n\t\t\t\t\t\t\tg_StartingScore -\r\n\t\t\t\t\t\t\tGameplayMap.getPlotDistance(region.startPlot.x, region.startPlot.y, adjPlot.x, adjPlot.y);\r\n\t\t\t\t\t\tif (distScore < 0) {\r\n\t\t\t\t\t\t\tdistScore = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tscore += distScore;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Bias the player away from being too close to another player unless they can't help it. Should help with locations where the start locations are too close, and should spred away from each other instead.\r\n\t\t\t\t\tfor (const playerPos of playerStartPositions) {\r\n\t\t\t\t\t\tconst dist = GameplayMap.getPlotDistance(playerPos.x, playerPos.y, adjPlot.x, adjPlot.y);\r\n\t\t\t\t\t\tif (dist < g_TooCloseDistance) {\r\n\t\t\t\t\t\t\tscore += g_TooCloseToOtherPlayerPenalty;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tregion.potentialPlots.set(adjacentPlotIndex, score);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst score = region.potentialPlots.get(adjacentPlotIndex);\r\n\t\t\t\tif (score && score > 0) {\r\n\t\t\t\t\t// As long as we haven't ruled out this tile already, increase it's score for having an included surrounding tile\r\n\t\t\t\t\tregion.potentialPlots.set(adjacentPlotIndex, score + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn chosenPlot;\r\n}\r\n\r\nfunction dumpAdvancedStartRegions(playerRegions: AdvancedStartRegion[]) {\r\n\tconsole.log(\"AdvancedStartRegions\");\r\n\tconst iHeight = GameplayMap.getGridHeight();\r\n\tconst iWidth = GameplayMap.getGridWidth();\r\n\tfor (let iY: number = iHeight - 1; iY >= 0; iY--) {\r\n\t\tlet str = \"\";\r\n\t\tif (iY % 2 == 1) {\r\n\t\t\tstr += \" \";\r\n\t\t}\r\n\t\tfor (let iX = 0; iX < iWidth; iX++) {\r\n\t\t\tconst terrain: TerrainType = GameplayMap.getTerrainType(iX, iY);\r\n\t\t\tlet terrainString = \" \";\r\n\t\t\tif (terrain == globals.g_FlatTerrain) {\r\n\t\t\t\tterrainString = \".\";\r\n\t\t\t} else if (terrain == globals.g_HillTerrain) {\r\n\t\t\t\tterrainString = \"^\";\r\n\t\t\t} else if (terrain == globals.g_MountainTerrain) {\r\n\t\t\t\tterrainString = \"M\";\r\n\t\t\t} else if (terrain == globals.g_OceanTerrain) {\r\n\t\t\t\tterrainString = \"~\";\r\n\t\t\t}\r\n\t\t\tstr += terrainString;\r\n\r\n\t\t\tconst plotIndex: number = GameplayMap.getIndexFromXY(iX, iY);\r\n\t\t\tconst player = findPlotOwner(playerRegions, plotIndex);\r\n\t\t\tif (player !== -1) {\r\n\t\t\t\tstr += player;\r\n\t\t\t} else {\r\n\t\t\t\tstr += \" \";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log(str);\r\n\t}\r\n}\r\n\r\nfunction findPlotOwner(playerRegions: AdvancedStartRegion[], plot: number): PlayerId {\r\n\tfor (let player = 0; player < playerRegions.length; player++) {\r\n\t\tif (playerRegions[player].claimedPlots.indexOf(plot) !== -1) {\r\n\t\t\treturn player;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n// function debugPrint(playerRegions: AdvancedStartRegion[], player: PlayerId) {\r\n// \tconsole.log(playerRegions[player].claimedPlots.toString());\r\n// \tlet iHeight = GameplayMap.getGridHeight();\r\n// \tlet iWidth = GameplayMap.getGridWidth();\r\n// \tfor (let iY: number = iHeight - 1; iY >= 0; iY--) {\r\n// \t\tlet str: string = '';\r\n// \t\tif (iY % 2 == 1) {\r\n// \t\t\tstr += ' ';\r\n// \t\t}\r\n// \t\tfor (let iX: number = 0; iX < iWidth; iX++) {\r\n// \t\t\tconst plotIndex: number = GameplayMap.getIndexFromXY(iX, iY);\r\n// \t\t\tconst plotScore: number = playerRegions[player].potentialPlots[plotIndex];\r\n// \t\t\tif (plotScore !== undefined) {\r\n// \t\t\t\tif (plotScore >= 0 && plotScore < 10) {\r\n// \t\t\t\t\tstr += ' ';\r\n// \t\t\t\t}\r\n// \t\t\t\tstr += plotScore;\r\n// \t\t\t}\r\n// \t\t\telse {\r\n// \t\t\t\tstr += \"  \";\r\n// \t\t\t}\r\n// \t\t}\r\n\r\n// \t\tconsole.log(str);\r\n// \t}\r\n// }\r\n"],"names":["globals.g_OceanTerrain","globals.g_MountainTerrain","globals.g_CoastTerrain","globals.g_FlatTerrain","globals.g_HillTerrain"],"mappings":"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"}