This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
mod/
  config/
    config.xml
  maps/
    base-standard/
      maps/
        archipelago.js
        assign-advanced-start-region.js
        assign-starting-plots.js
        continents-plus.js
        continents-voronoi.js
        continents.js
        discovery-generator.js
        elevation-terrain-generator.js
        feature-biome-generator.js
        fractal.js
        index.d.js
        map-debug-helpers.js
        map-globals.js
        map-utilities.js
        natural-wonder-generator.js
        pangaea-plus.js
        pangaea-voronoi.js
        resource-generator.js
        shuffle.js
        snow-generator.js
        terra-incognita.js
        volcano-generator.js
      scripts/
        voronoi_generators/
          continent-generator.js
          map-generator.js
        voronoi_maps/
          continents.js
          map-common.js
          pangaea.js
        voronoi_rules/
          avoid-edge.js
          avoid-other-regions.js
          cell-area.js
          near-map-center.js
          near-neighbor.js
          near-plate-boundary.js
          near-region-seed.js
          neighbors-in-region.js
          prefer-latitude.js
          rules-base.js
        age-transition-post-load.js
        heap.js
        index.d.js
        kd-tree.js
        quadtree.js
        random-pcg-32.js
        voronoi-builder.js
        voronoi-hex.js
        voronoi-plate.js
        voronoi-region.js
        voronoi-utils.js
      base-standard.modinfo
    bootstrap/
      defaults/
        base.js
      presets/
        classic.js
        temperate.js
      climate-tunables.js
      dev.js
      entry.js
      foundation-tunables.js
      map_config.types.js
      resolved.js
      runtime.js
      tunables.js
    core/
      adapters.js
      plot_tags.js
      types.js
      utils.js
    layers/
      biomes.js
      climate-engine.js
      coastlines.js
      features.js
      islands.js
      landmass_plate.js
      landmass_utils.js
      mountains.js
      placement.js
      volcanoes.js
    story/
      corridors.js
      overlays.js
      tagging.js
      tags.js
    world/
      model.js
      plate_seed.js
      plates.js
    map_orchestrator.js
    swooper-desert-mountains.js
  text/
    en_us/
      MapText.xml
      ModuleText.xml
  swooper-maps.modinfo
repomix-mod-package.xml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="mod/config/config.xml">
<?xml version="1.0" encoding="utf-8"?>
<Database>
	<Maps>
		<!-- Base variant - Classic preset -->
		<Row
			File="{swooper-maps}/maps/swooper-desert-mountains.js"
			Name="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_NAME"
			Description="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_DESCRIPTION"
			SortIndex="500"
		/>
	</Maps>
</Database>
</file>

<file path="mod/maps/base-standard/maps/archipelago.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoasts, addMountains, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_CoastTerrain, g_NavigableRiverTerrain, g_OceanTerrain, g_LandmassFractal, g_FlatTerrain } from './map-globals.js';
import { needHumanNearEquator, addPlotTags, adjustOceanPlotTags, isAdjacentToLand, getSector, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script Archipelago.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = g_OceanWaterColumns;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
  } else {
    console.log("Standard Map");
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoasts(iWidth, iHeight);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iWidth / 2 < iX) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
        }
      }
    }
  }
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 70, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
  const PlayerList = Players.getAlive();
  for (let i = 0; i < PlayerList.length; ++i) {
    if (PlayerList[i].isValid && PlayerList[i].isMajor && PlayerList[i].isAI) {
      const playerAI = PlayerList[i].AI;
      playerAI?.scaleAiPreference("PseudoYieldBiases", "PSEUDOYIELD_STANDING_NAVY_UNIT", 200);
    }
  }
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded Archipelago.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
    }
  }
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    3
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    4
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    5
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    6
  );
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.removePlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function generateFractalLayerWithoutHills(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iCenterWeight = 0;
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain || GameplayMap.getTerrainType(iX, iY) == g_CoastTerrain) {
        let terrain = g_FlatTerrain;
        const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
        const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
        if (isAdjacentToLand(iX, iY)) {
          continue;
        } else if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
          continue;
        } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
          terrain = g_OceanTerrain;
        } else {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          let iStartSectorWeight = 0;
          let iFractalWeight = 1;
          if (iStartSectorRows > 0 && iStartSectorCols > 0 && startSectors[iSector]) {
            iStartSectorWeight = 0.5;
            iFractalWeight = 0.55;
          }
          const iPlotHeight = getHeightAdjustingForStartSector(
            iX,
            iY,
            iWaterHeight,
            iFractalWeight,
            iCenterWeight,
            iStartSectorWeight,
            continent1,
            continent2,
            iStartSectorRows,
            iStartSectorCols,
            startSectors
          );
          if (iPlotHeight < iWaterHeight) {
            continue;
          }
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
//# sourceMappingURL=archipelago.js.map
</file>

<file path="mod/maps/base-standard/maps/assign-advanced-start-region.js">
import { g_OceanTerrain, g_MountainTerrain, g_CoastTerrain, g_FlatTerrain, g_HillTerrain } from './map-globals.js';

const g_StartingScore = 20;
const g_BadTerrainScore = 1;
const g_GoodTerrainScore = 10;
const g_TooCloseToOtherPlayerPenalty = -3;
const g_TooCloseDistance = 10;
class AdvancedStartRegion {
  player;
  claimedPlots = [];
  potentialPlots;
  startPlot;
  constructor(inPlayer) {
    this.player = inPlayer;
    this.startPlot = { x: -1, y: -1 };
    this.potentialPlots = /* @__PURE__ */ new Map();
  }
}
function assignAdvancedStartRegions() {
  const playerIds = Players.getAliveIds();
  const playerRegions = [];
  const playerStartPositions = [];
  for (const playerId of playerIds) {
    const region = new AdvancedStartRegion(playerId);
    initializeRegion(region);
    playerStartPositions.push(region.startPlot);
    playerRegions.push(region);
  }
  let maxRegionSize = 0;
  const advStartParams = GameInfo.AdvancedStartParameters.lookup(Game.age);
  if (advStartParams !== null) {
    maxRegionSize = advStartParams.MaxRegionPlots;
  }
  let minRange = 3;
  const minRangeDef = GameInfo.GlobalParameters.lookup("CITY_MIN_RANGE");
  if (minRangeDef !== null) {
    minRange = parseInt(minRangeDef.Value);
  }
  for (let plotCount = 0; plotCount < maxRegionSize; plotCount++) {
    for (let i = 0; i < playerRegions.length; i++) {
      const plotIndex = claimPlot(playerRegions[i], playerStartPositions);
      if (plotIndex !== -1) {
        const plot = GameplayMap.getLocationFromIndex(plotIndex);
        const claimedPlots = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, minRange);
        for (let j = 0; j < playerRegions.length; j++) {
          if (i !== j) {
            for (const claimedPlot of claimedPlots) {
              playerRegions[j].potentialPlots.set(claimedPlot, -1);
            }
          }
        }
      }
    }
  }
  for (let i = 0; i < playerRegions.length; i++) {
    StartPositioner.setAdvancedStartRegion(playerRegions[i].player, playerRegions[i].claimedPlots);
  }
  dumpAdvancedStartRegions(playerRegions);
}
function initializeRegion(region) {
  const startPosition = StartPositioner.getStartPosition(region.player);
  if (startPosition === -1) {
    return;
  }
  region.startPlot = GameplayMap.getLocationFromIndex(startPosition);
  region.potentialPlots.set(startPosition, g_StartingScore + g_GoodTerrainScore);
}
function claimPlot(region, playerStartPositions) {
  let chosenPlot = -1;
  let maxScore = -1;
  for (const [potentialPlot, score] of region.potentialPlots.entries()) {
    if (score > maxScore) {
      maxScore = score;
      chosenPlot = potentialPlot;
    }
  }
  if (chosenPlot !== -1) {
    region.claimedPlots.push(chosenPlot);
    region.potentialPlots.set(chosenPlot, -1);
    const plot = GameplayMap.getLocationFromIndex(chosenPlot);
    const adjacentPlots = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, 1);
    for (let i = 0; i < adjacentPlots.length; i++) {
      const adjacentPlotIndex = adjacentPlots[i];
      if (region.potentialPlots.has(adjacentPlotIndex) == false) {
        const adjPlot = GameplayMap.getLocationFromIndex(adjacentPlotIndex);
        const terrainType = GameplayMap.getTerrainType(adjPlot.x, adjPlot.y);
        if (terrainType == g_OceanTerrain) {
          region.potentialPlots.set(adjacentPlotIndex, -1);
        } else if (terrainType == g_MountainTerrain || terrainType == g_CoastTerrain) {
          region.potentialPlots.set(adjacentPlotIndex, g_BadTerrainScore);
        } else {
          region.potentialPlots.set(adjacentPlotIndex, g_GoodTerrainScore);
        }
        let score = region.potentialPlots.get(adjacentPlotIndex);
        if (score) {
          if (score > 0) {
            let distScore = g_StartingScore - GameplayMap.getPlotDistance(region.startPlot.x, region.startPlot.y, adjPlot.x, adjPlot.y);
            if (distScore < 0) {
              distScore = 0;
            }
            score += distScore;
          }
          for (const playerPos of playerStartPositions) {
            const dist = GameplayMap.getPlotDistance(playerPos.x, playerPos.y, adjPlot.x, adjPlot.y);
            if (dist < g_TooCloseDistance) {
              score += g_TooCloseToOtherPlayerPenalty;
            }
          }
          region.potentialPlots.set(adjacentPlotIndex, score);
        }
      } else {
        const score = region.potentialPlots.get(adjacentPlotIndex);
        if (score && score > 0) {
          region.potentialPlots.set(adjacentPlotIndex, score + 1);
        }
      }
    }
  }
  return chosenPlot;
}
function dumpAdvancedStartRegions(playerRegions) {
  console.log("AdvancedStartRegions");
  const iHeight = GameplayMap.getGridHeight();
  const iWidth = GameplayMap.getGridWidth();
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      let terrainString = " ";
      if (terrain == g_FlatTerrain) {
        terrainString = ".";
      } else if (terrain == g_HillTerrain) {
        terrainString = "^";
      } else if (terrain == g_MountainTerrain) {
        terrainString = "M";
      } else if (terrain == g_OceanTerrain) {
        terrainString = "~";
      }
      str += terrainString;
      const plotIndex = GameplayMap.getIndexFromXY(iX, iY);
      const player = findPlotOwner(playerRegions, plotIndex);
      if (player !== -1) {
        str += player;
      } else {
        str += " ";
      }
    }
    console.log(str);
  }
}
function findPlotOwner(playerRegions, plot) {
  for (let player = 0; player < playerRegions.length; player++) {
    if (playerRegions[player].claimedPlots.indexOf(plot) !== -1) {
      return player;
    }
  }
  return -1;
}

export { assignAdvancedStartRegions };
//# sourceMappingURL=assign-advanced-start-region.js.map
</file>

<file path="mod/maps/base-standard/maps/assign-starting-plots.js">
import { g_DesiredBufferBetweenMajorStarts, g_RequiredBufferBetweenMajorStarts } from './map-globals.js';
import { getSectorRegion, shuffle, isOceanAccess } from './map-utilities.js';

class PlayerRegion {
  tiles = [];
  landmassId = 0;
  regionId = 0;
  toString() {
    return `[PlayerRegion] landmassId: ${this.landmassId}, regionId: ${this.regionId}, tile count: ${this.tiles.length}`;
  }
}
class PlayerRegionScores {
  scores = [];
  totalBias = 0;
  playerId = 0;
  playerIndex = 0;
  toString() {
    return `[PlayerRegionScores] playerId: ${this.playerId} (Index: ${this.playerIndex}), totalBias: ${this.totalBias}, scores: ${this.scores}`;
  }
}
function chooseStartSectors(iNumPlayersLandmass1, iNumPlayersLandmass2, iRows, iCols, bHumanNearEquator) {
  const returnValue = [];
  const iSectorsPerContinent = iRows * iCols;
  let iPlayersWestContinent = iNumPlayersLandmass1;
  let iPlayersEastContinent = iNumPlayersLandmass2;
  let iMaxNumMajors = 0;
  iMaxNumMajors = iPlayersWestContinent + iPlayersEastContinent;
  const aliveMajorIds = Players.getAliveMajorIds();
  const humanPlayers = [];
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
      humanPlayers.push(iMajorIndex);
    }
  }
  const numHumans = humanPlayers.length;
  const maxSide = Math.max(iPlayersWestContinent, iPlayersEastContinent);
  if (numHumans > maxSide) {
    const half = Math.floor(iMaxNumMajors / 2);
    iPlayersWestContinent = half;
    iPlayersEastContinent = iMaxNumMajors - half;
    iNumPlayersLandmass1 = iPlayersWestContinent;
    iNumPlayersLandmass2 = iPlayersEastContinent;
  }
  if (iNumPlayersLandmass1 == 1 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [[0], [1], [2], [3], [4], [5]];
    var validConfigs2 = [
      [0, 3, 4],
      [1, 2, 5]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 1) {
    var validConfigs1 = [
      [0, 3, 4],
      [1, 2, 5]
    ];
    var validConfigs2 = [[0], [1], [2], [3], [4], [5]];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 2) {
    var validConfigs1 = [
      [0, 2, 6, 8],
      [1, 3, 5, 7]
    ];
    var validConfigs2 = [
      [0, 8],
      [2, 6]
    ];
  } else if (iNumPlayersLandmass1 == 2 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 8],
      [2, 6]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8],
      [1, 3, 5, 7]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6, 8]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [3, 5, 7],
      [4, 6, 8]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 5) {
    var validConfigs1 = [
      [3, 5, 7],
      [4, 6, 8]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
    var validConfigs2 = [
      [1, 3, 5, 7],
      [4, 6, 8, 10]
    ];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 6) {
    var validConfigs1 = [
      [1, 3, 5, 7],
      [4, 6, 8, 10]
    ];
    var validConfigs2 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 2 && iNumPlayersLandmass2 == 2) {
    var validConfigs1 = [
      [0, 5],
      [1, 4]
    ];
    var validConfigs2 = [
      [0, 5],
      [1, 4]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [
      [0, 2, 7],
      [1, 6, 8]
    ];
    var validConfigs2 = [
      [0, 2, 7],
      [1, 6, 8]
    ];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 2, 6, 8],
      [3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8],
      [3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 5) {
    var validConfigs1 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 6) {
    var validConfigs1 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 8 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6, 8, 9, 11]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6]];
    var validConfigs2 = [[]];
  } else {
    console.log("THIS SHOULD NOT BE HIT IN STARTING POSITION");
    var validConfigs1 = [[0], [1], [2], [3], [4], [5]];
    var validConfigs2 = [
      [0, 2, 4],
      [1, 3, 5]
    ];
  }
  let iWestContinentConfig = validConfigs1.length - 1;
  if (!bHumanNearEquator)
    iWestContinentConfig = TerrainBuilder.getRandomNumber(validConfigs1.length, "West Continent Start Positions");
  for (let i = 0; i < iSectorsPerContinent; i++) {
    let bFoundIt = false;
    for (let j = 0; j < iPlayersWestContinent; j++) {
      if (i == validConfigs1[iWestContinentConfig][j]) {
        bFoundIt = true;
        break;
      }
    }
    returnValue[i] = bFoundIt;
  }
  let iEastContinentConfig = validConfigs2.length - 1;
  if (!bHumanNearEquator)
    iEastContinentConfig = TerrainBuilder.getRandomNumber(validConfigs2.length, "East Continent Start Positions");
  for (let i = 0; i < iSectorsPerContinent; i++) {
    let bFoundIt = false;
    for (let j = 0; j < iPlayersEastContinent; j++) {
      if (i == validConfigs2[iEastContinentConfig][j]) {
        bFoundIt = true;
        break;
      }
    }
    returnValue[i + iSectorsPerContinent] = bFoundIt;
  }
  return returnValue;
}
function assignStartPositions(iNumWest, iNumEast, west, east, iStartSectorRows, iStartSectorCols, sectors) {
  console.log("Assigning Starting Positions");
  const startPositions = [];
  console.log("iStartSectorRows: " + iStartSectorRows);
  console.log("iStartSectorCols: " + iStartSectorCols);
  console.log("iNumWest: " + iNumWest);
  console.log("iNumEast: " + iNumEast);
  let iMaxNumMajors = 0;
  iMaxNumMajors = iNumWest + iNumEast;
  console.log("iMaxNumMajors: " + iMaxNumMajors);
  let bEastBias = false;
  if (iNumEast > iNumWest) {
    console.log("EastSide");
    bEastBias = true;
  }
  const aliveMajorIds = Players.getAliveMajorIds();
  if (iMaxNumMajors < aliveMajorIds.length) {
    console.log("The input total is less than the total alive majors: " + aliveMajorIds.length);
  }
  const humanPlayers = [];
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
      humanPlayers.push(iMajorIndex);
    }
  }
  let iNumberHomelands = 0;
  let bHumansLargestLandmass = GameInfo.Ages.lookup(Game.age).HumanPlayersPrimaryHemisphere;
  if (bEastBias && iNumEast < humanPlayers.length) {
    bHumansLargestLandmass = false;
  } else if (!bEastBias && iNumWest < humanPlayers.length) {
    bHumansLargestLandmass = false;
  }
  if (bHumansLargestLandmass) {
    if (bEastBias) {
      iNumberHomelands = iNumEast;
    } else {
      iNumberHomelands = iNumWest;
    }
  } else {
    iNumberHomelands = (iNumWest + iNumEast) / 2;
  }
  const [iHomelandTag, iDistantLandTag] = bEastBias ? [PlotTags.PLOT_TAG_EAST_LANDMASS, PlotTags.PLOT_TAG_WEST_LANDMASS] : [PlotTags.PLOT_TAG_WEST_LANDMASS, PlotTags.PLOT_TAG_EAST_LANDMASS];
  const homelandStartRegions = [];
  const distantStartRegions = [];
  let bAssignStartPositionsBySector = true;
  if (iStartSectorRows == 0 || iStartSectorCols == 0) {
    bAssignStartPositionsBySector = false;
  } else {
    bAssignStartPositionsBySector = checkStartSectorsViable(
      west,
      east,
      iStartSectorRows,
      iStartSectorCols,
      sectors
    );
  }
  if (bAssignStartPositionsBySector) {
    console.log("Using Sector-based Assignments");
    for (let iSector = 0; iSector < sectors.length; iSector++) {
      if (sectors[iSector] == true) {
        const region = getSectorRegion(
          iSector,
          iStartSectorRows,
          iStartSectorCols,
          east.south,
          east.north,
          west.west,
          west.east,
          east.west
        );
        const bEastHemis = iSector >= sectors.length / 2;
        let szHeading;
        if (bEastHemis == bEastBias) {
          homelandStartRegions.push(region);
          szHeading = "HOMELAND START REGION:";
        } else {
          distantStartRegions.push(region);
          szHeading = "DISTANT START REGION:";
        }
        console.log(szHeading);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("Start Sector: " + iSector);
      }
    }
  } else {
    console.log("Using Areas of Equal Fertility");
    const iMinMajorFertility = 25;
    const iMinMinorFertility = 5;
    {
      const iLeftCol = bEastBias ? east.west : west.west;
      const iRightCol = bEastBias ? east.east : west.east;
      StartPositioner.initializeValues();
      StartPositioner.divideMapIntoMajorRegions(
        iNumberHomelands,
        iMinMajorFertility,
        iMinMinorFertility,
        iLeftCol,
        iRightCol,
        iHomelandTag
      );
      console.log("Divided map into major regions for Homelands");
      for (let iRegion = 0; iRegion < iNumberHomelands; iRegion++) {
        homelandStartRegions[iRegion] = StartPositioner.getMajorStartRegion(iRegion);
        console.log("HOMELAND START REGION: " + iRegion);
        console.log("West: " + homelandStartRegions[iRegion].west);
        console.log("East: " + homelandStartRegions[iRegion].east);
        console.log("North: " + homelandStartRegions[iRegion].north);
        console.log("South: " + homelandStartRegions[iRegion].south);
        console.log("Continent: " + homelandStartRegions[iRegion].continent);
      }
    }
    {
      const iLeftCol = bEastBias ? west.west : east.west;
      const iRightCol = bEastBias ? west.east : east.east;
      StartPositioner.initializeValues();
      StartPositioner.divideMapIntoMajorRegions(
        iMaxNumMajors - iNumberHomelands,
        iMinMajorFertility,
        iMinMinorFertility,
        iLeftCol,
        iRightCol,
        iDistantLandTag
      );
      console.log("Divided map into major regions for Distant Lands");
      for (let iRegion = 0; iRegion < iMaxNumMajors - iNumberHomelands; iRegion++) {
        distantStartRegions[iRegion] = StartPositioner.getMajorStartRegion(iRegion);
        console.log("DISTANT START REGION: " + iRegion);
        console.log("West: " + distantStartRegions[iRegion].west);
        console.log("East: " + distantStartRegions[iRegion].east);
        console.log("North: " + distantStartRegions[iRegion].north);
        console.log("South: " + distantStartRegions[iRegion].south);
        console.log("Continent: " + distantStartRegions[iRegion].continent);
      }
    }
  }
  const homelandPlayers = [];
  const distantPlayers = [];
  if (bHumansLargestLandmass) {
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
        homelandPlayers.push(iMajorIndex);
      }
    }
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length && Players.isAI(aliveMajorIds[iMajorIndex])) {
        if (homelandPlayers.length < iNumberHomelands) {
          homelandPlayers.push(iMajorIndex);
        } else {
          distantPlayers.push(iMajorIndex);
        }
      }
    }
    shuffle(homelandPlayers);
    shuffle(distantPlayers);
  } else {
    const tempPlayers = [];
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length) {
        console.log("Found real major at: " + aliveMajorIds[iMajorIndex]);
        tempPlayers.push(iMajorIndex);
      }
    }
    shuffle(tempPlayers);
    for (let i = 0; i < tempPlayers.length; i++) {
      if (homelandPlayers.length < iNumberHomelands) {
        homelandPlayers.push(tempPlayers[i]);
      } else {
        distantPlayers.push(tempPlayers[i]);
      }
    }
  }
  console.log("homelandPlayers: " + homelandPlayers.length);
  console.log("homelandStartRegions: " + homelandStartRegions.length);
  console.log("distantPlayers: " + distantPlayers.length);
  console.log("distantStartRegions: " + distantStartRegions.length);
  console.log("Update homelandPlayers:");
  updateRegionsForStartBias(homelandPlayers, homelandStartRegions);
  console.log("Update distantPlayers:");
  updateRegionsForStartBias(distantPlayers, distantStartRegions);
  for (let i = 0; i < homelandPlayers.length; i++) {
    const iStartPosition = homelandPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    const plotIndex = pickStartPlot(
      homelandStartRegions[i],
      i,
      playerId,
      false,
      startPositions,
      iHomelandTag
    );
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  for (let i = 0; i < distantPlayers.length; i++) {
    const iStartPosition = distantPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    const plotIndex = pickStartPlot(
      distantStartRegions[i],
      i + homelandPlayers.length,
      playerId,
      false,
      startPositions,
      iDistantLandTag
    );
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  return startPositions;
}
function assignStartPositionsFromTiles(playerRegions) {
  console.log("Assigning Starting Positions");
  if (playerRegions.length === 0) {
    console.error("empty array passed to assignStartPositionsFromTiles()");
    return [];
  }
  const landmassRegions = /* @__PURE__ */ new Map();
  for (const region of playerRegions) {
    let regions = landmassRegions.get(region.landmassId) ?? [];
    regions.push(region.regionId);
    landmassRegions.set(region.landmassId, regions);
  }
  let largestLandmassId = -1;
  let largestTileCount = 0;
  for (const [id, lr] of landmassRegions) {
    const lrTileCount = lr.reduce((sum, regionId) => sum + playerRegions[regionId].tiles.length, 0);
    if (lrTileCount > largestTileCount) {
      largestTileCount = lrTileCount;
      largestLandmassId = id;
    }
  }
  const totalPlayers = playerRegions.length;
  console.log(
    `Largest landmass is region ${largestLandmassId} with ${landmassRegions.get(largestLandmassId).length} players and ${largestTileCount} total tiles.`
  );
  console.log(`Total players: ${totalPlayers}`);
  const aliveMajorIds = Players.getAliveMajorIds();
  let aliveMajorIndices = [...aliveMajorIds.keys()];
  if (totalPlayers !== aliveMajorIds.length) {
    console.log(`The input player total ${totalPlayers} is not equal to the alive majors: ${aliveMajorIds.length}`);
  }
  const regionGetter = {
    count: playerRegions.length,
    getTileCoords: function* (regionId) {
      for (const tile of playerRegions[regionId].tiles) yield [tile.x, tile.y];
    }
  };
  const playerRegionScores = getRegionScoresPerPlayer(aliveMajorIndices, regionGetter);
  console.log("Player region scores:");
  playerRegionScores.forEach((prs) => console.log(prs));
  const humanPlayerIndices = aliveMajorIndices.filter((index) => Players.isHuman(aliveMajorIds[index]));
  let bHumansTogether = humanPlayerIndices.length > 1 && GameInfo.Ages.lookup(Game.age).HumanPlayersPrimaryHemisphere && humanPlayerIndices.length <= landmassRegions.get(largestLandmassId).length;
  let regionPlayerBias = new Array(playerRegions.length).fill(-1);
  const assignPlayerBiases = (playerIndices, regions) => {
    for (const playerIndex of playerIndices) {
      let bestId = -1;
      let bestScore = -1;
      for (const regionId of regions) {
        const regionScore = playerRegionScores[playerIndex].scores[regionId];
        if (regionScore > bestScore && regionPlayerBias[regionId] == -1) {
          bestId = regionId;
          bestScore = regionScore;
        }
      }
      regionPlayerBias[bestId] = playerIndex;
    }
  };
  if (bHumansTogether) {
    console.log("Placing humans on same landmass.");
    aliveMajorIndices = aliveMajorIndices.filter((index) => !Players.isHuman(aliveMajorIds[index]));
    const regionsOnLargestLandmass = landmassRegions.get(largestLandmassId);
    humanPlayerIndices.sort((a, b) => playerRegionScores[b].totalBias - playerRegionScores[a].totalBias);
    assignPlayerBiases(humanPlayerIndices, regionsOnLargestLandmass);
  }
  aliveMajorIndices.sort((a, b) => playerRegionScores[b].totalBias - playerRegionScores[a].totalBias);
  console.log(`Sorted indices: ${aliveMajorIndices}`);
  assignPlayerBiases(
    aliveMajorIndices,
    playerRegions.map((v) => v.regionId)
  );
  console.log(`Player region biases:`);
  for (const [regionId, playerIndex] of regionPlayerBias.entries()) {
    const bestScore = playerRegionScores[playerIndex].scores.reduce((best, cur) => Math.max(best, cur), -1);
    const playerId = playerRegionScores[playerIndex].playerId;
    console.log(
      `  Player Id ${playerId} assigned to region ${regionId} with score ${playerRegionScores[playerIndex].scores[regionId]} (best score possible is ${bestScore})`
    );
  }
  let found = 0;
  let startPositions = new Array(regionPlayerBias.length);
  for (const [regionId, playerIndex] of regionPlayerBias.entries()) {
    const playerId = aliveMajorIds[playerIndex];
    const playerTiles = playerRegions[regionId].tiles;
    console.log(
      `Searching ${playerTiles.length} tiles in region ${regionId} (landmass ${playerRegions[regionId].landmassId}) for player ${playerId} (${Players.isHuman(playerId) ? "human" : "ai"})`
    );
    const plotIndex = pickStartPlotByTile(playerTiles, -1, found, playerId, false, startPositions);
    ++found;
    if (plotIndex >= 0) {
      startPositions[playerId] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  return startPositions;
}
function assignSingleContinentStartPositions(iNumPlayers, primaryLandmass, iStartSectorRows, iStartSectorCols, sectors, uiPlotTagFilter = 4294967295) {
  console.log("Assigning Starting Positions");
  const startPositions = [];
  console.log("iStartSectorRows: " + iStartSectorRows);
  console.log("iStartSectorCols: " + iStartSectorCols);
  let iMaxNumMajors = 0;
  iMaxNumMajors = iNumPlayers;
  console.log("iMaxNumMajors: " + iMaxNumMajors);
  const aliveMajorIds = Players.getAliveMajorIds();
  if (iMaxNumMajors < aliveMajorIds.length) {
    console.log("The input total is less than the total alive majors: " + aliveMajorIds.length);
  }
  const homelandPlayers = [];
  const homelandStartRegions = [];
  let bAssignStartPositionsBySector = true;
  if (iStartSectorRows == 0 || iStartSectorCols == 0) {
    bAssignStartPositionsBySector = false;
  } else {
    bAssignStartPositionsBySector = checkStartSectorsViable(
      primaryLandmass,
      primaryLandmass,
      iStartSectorRows,
      iStartSectorCols,
      sectors
    );
  }
  if (bAssignStartPositionsBySector) {
    console.log("Using Sector-based Assignments");
    for (let iSector = 0; iSector < sectors.length; iSector++) {
      if (sectors[iSector] == true) {
        const region = getSectorRegion(
          iSector,
          iStartSectorRows,
          iStartSectorCols,
          primaryLandmass.south,
          primaryLandmass.north,
          primaryLandmass.west,
          primaryLandmass.east,
          primaryLandmass.west
        );
        let szHeading;
        homelandStartRegions.push(region);
        szHeading = "HOMELAND START REGION:";
        console.log(szHeading);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("Start Sector: " + iSector);
      }
    }
  } else {
    console.log("Assigning Starting Positions Across a Single Continent with Equal Fertility");
    const iMinMajorFertility = 25;
    const iMinMinorFertility = 5;
    StartPositioner.initializeValues();
    StartPositioner.divideMapIntoMajorRegions(
      iNumPlayers,
      iMinMajorFertility,
      iMinMinorFertility,
      primaryLandmass.west,
      primaryLandmass.east,
      uiPlotTagFilter
    );
    const potentialRegions = [];
    for (let i = 0; i < iNumPlayers; i++) {
      const region = StartPositioner.getMajorStartRegion(i);
      if (region && region.east > primaryLandmass.west && region.west < primaryLandmass.east) {
        potentialRegions.push(region);
      }
    }
    potentialRegions.sort(
      (a, b) => (b.east - b.west) * (b.north - b.south) - (a.east - a.west) * (a.north - a.south)
    );
    for (const region of potentialRegions) {
      if (homelandStartRegions.length < iNumPlayers) {
        homelandStartRegions.push(region);
      }
    }
    if (homelandStartRegions.length < iNumPlayers) {
      console.log("WARNING: Not enough fertile regions found within the selected continent.");
    }
  }
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length) {
      homelandPlayers.push(iMajorIndex);
    }
  }
  shuffle(homelandPlayers);
  console.log("homelandPlayers: " + homelandPlayers.length);
  console.log("homelandStartRegions: " + homelandStartRegions.length);
  console.log("Update homelandPlayers:");
  updateRegionsForStartBias(homelandPlayers, homelandStartRegions);
  for (let i = 0; i < homelandPlayers.length; i++) {
    const iStartPosition = homelandPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    let plotIndex = pickStartPlot(homelandStartRegions[i], i, playerId, false, startPositions);
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId + " - Retrying with alternative regions.");
      for (const retryRegion of homelandStartRegions) {
        plotIndex = pickStartPlot(retryRegion, i, playerId, false, startPositions);
        if (plotIndex >= 0) {
          startPositions[iStartPosition] = plotIndex;
          StartPositioner.setStartPosition(plotIndex, playerId);
          console.log("Successfully found an alternative start position for " + playerId);
          break;
        }
      }
      if (plotIndex < 0) {
        console.log("FAILED AGAIN - NO VALID LOCATION FOUND FOR: " + playerId);
      }
    }
  }
  return startPositions;
}
function checkStartSectorsViable(west, east, iStartSectorRows, iStartSectorCols, sectors) {
  const tempStartPositions = [];
  for (let iSector = 0; iSector < sectors.length; iSector++) {
    if (sectors[iSector] == true) {
      const region = getSectorRegion(
        iSector,
        iStartSectorRows,
        iStartSectorCols,
        east.south,
        east.north,
        west.west,
        west.east,
        east.west
      );
      const startPlot = pickStartPlot(region, 0, 0, true, tempStartPositions);
      if (startPlot == -1) {
        console.log("LOW FERTILITY START SECTOR: " + iSector);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("ABORTING - Falling back to Civ VI start position assignment algorithm");
        return false;
      }
    }
  }
  return true;
}
function getRegionScoresPerPlayer(majorGroup, startRegions) {
  const biomeBiases = Array.from(
    { length: majorGroup.length },
    () => new Array(GameInfo.Biomes.length).fill(0)
  );
  const navRiverBias = new Array(majorGroup.length).fill(0);
  const NWBias = new Array(majorGroup.length).fill(0);
  const aliveMajorIds = Players.getAliveMajorIds();
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const playerId = aliveMajorIds[majorGroup[iMajorGroup]];
    const player = Players.get(playerId);
    if (player == null) {
      continue;
    }
    const uiCivType = player.civilizationType;
    const uiLeaderType = player.leaderType;
    console.log("Player Id:" + playerId + ", " + player.civilizationName + ", " + player.leaderName);
    for (let startBiomeIdx = 0; startBiomeIdx < GameInfo.StartBiasBiomes.length; startBiomeIdx++) {
      const startBiomeDef = GameInfo.StartBiasBiomes[startBiomeIdx];
      if (startBiomeDef) {
        const civString = startBiomeDef.CivilizationType;
        const ldrString = startBiomeDef.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          const biomeDef = GameInfo.Biomes.lookup(startBiomeDef.BiomeType);
          if (biomeDef) {
            const biomeIndex = biomeDef.$index;
            console.log("biomeIndex: " + biomeIndex + ", Score: " + startBiomeDef.Score);
            biomeBiases[iMajorGroup][biomeIndex] += startBiomeDef.Score;
          }
        }
      }
    }
    for (let startRiverIdx = 0; startRiverIdx < GameInfo.StartBiasTerrains.length; startRiverIdx++) {
      const startBiasTerrainDef = GameInfo.StartBiasTerrains[startRiverIdx];
      if (startBiasTerrainDef) {
        if (startBiasTerrainDef.TerrainType == "TERRAIN_NAVIGABLE_RIVER") {
          const civString = startBiasTerrainDef.CivilizationType;
          const ldrString = startBiasTerrainDef.LeaderType;
          let civHash = 0;
          let ldrHash = 0;
          if (civString != null) {
            const civObj = GameInfo.Civilizations.lookup(civString);
            if (civObj) {
              civHash = civObj.$hash;
            }
          }
          if (ldrString != null) {
            const ldrObj = GameInfo.Leaders.lookup(ldrString);
            if (ldrObj) {
              ldrHash = ldrObj.$hash;
            }
          }
          if (civHash == uiCivType || ldrHash == uiLeaderType) {
            navRiverBias[iMajorGroup] += startBiasTerrainDef.Score;
          }
        }
      }
    }
    for (let startNWIdx = 0; startNWIdx < GameInfo.StartBiasNaturalWonders.length; startNWIdx++) {
      const startBiasNWDef = GameInfo.StartBiasNaturalWonders[startNWIdx];
      if (startBiasNWDef) {
        const civString = startBiasNWDef.CivilizationType;
        const ldrString = startBiasNWDef.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          NWBias[iMajorGroup] += startBiasNWDef.Score;
        }
      }
    }
  }
  console.log("biomeBiases " + biomeBiases);
  console.log("navRiverBias " + navRiverBias);
  console.log("NWBias " + NWBias);
  const startRegionCount = Array.isArray(startRegions) ? startRegions.length : startRegions.count;
  const biomeCounts = new Array(startRegionCount);
  for (let i = 0; i < startRegionCount; i++) {
    biomeCounts[i] = [];
  }
  const navRiverCounts = [];
  const NWCounts = [];
  for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
    for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
      biomeCounts[iRegion][iBiome] = 0;
    }
    navRiverCounts[iRegion] = 0;
    NWCounts[iRegion] = 0;
  }
  for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
    let tileCount = 0;
    const processTile = (xCoord, yCoord) => {
      const biomeType = GameplayMap.getBiomeType(xCoord, yCoord);
      biomeCounts[iRegion][biomeType]++;
      if (GameplayMap.isNavigableRiver(xCoord, yCoord)) {
        navRiverCounts[iRegion]++;
      }
      if (GameplayMap.isNaturalWonder(xCoord, yCoord)) {
        NWCounts[iRegion]++;
      }
      ++tileCount;
    };
    if (Array.isArray(startRegions)) {
      const region = startRegions[iRegion];
      for (let iX = region.west; iX <= region.east; iX++) {
        for (let iY = region.south; iY <= region.north; iY++) {
          processTile(iX, iY);
        }
      }
    } else {
      for (const [iX, iY] of startRegions.getTileCoords(iRegion)) {
        processTile(iX, iY);
      }
    }
    console.log(`Processed ${tileCount} tiles in region ${iRegion}`);
  }
  console.log("biomeCounts " + biomeCounts);
  console.log("navRiverCounts " + navRiverCounts);
  console.log("NWCounts " + NWCounts);
  let regionScores = [];
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const regionScore = new PlayerRegionScores();
    regionScore.playerIndex = majorGroup[iMajorGroup];
    regionScore.playerId = aliveMajorIds[majorGroup[iMajorGroup]];
    for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
      regionScore.totalBias += biomeBiases[iMajorGroup][iBiome];
    }
    regionScore.totalBias += navRiverBias[iMajorGroup];
    regionScore.totalBias += NWBias[iMajorGroup];
    regionScores.push(regionScore);
  }
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const regionScore = regionScores[iMajorGroup];
    for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
      let regionScoreForMajor = 0;
      for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
        regionScoreForMajor += biomeBiases[iMajorGroup][iBiome] * biomeCounts[iRegion][iBiome];
      }
      regionScoreForMajor += navRiverBias[iMajorGroup] * navRiverCounts[iRegion];
      regionScoreForMajor += NWBias[iMajorGroup] * NWCounts[iRegion];
      console.log(`majorIndex ${iMajorGroup}, regionScore: ${regionScoreForMajor}`);
      regionScore.scores.push(regionScoreForMajor);
    }
  }
  return regionScores;
}
function updateRegionsForStartBias(majorGroup, startRegions) {
  const regionScores = getRegionScoresPerPlayer(majorGroup, startRegions);
  console.log(`totalMajorBiases: ${regionScores.map((v) => v.totalBias)}`);
  regionScores.sort((a, b) => b.totalBias - a.totalBias);
  console.log(`sortedMajorIndices: ${regionScores.map((v) => v.playerId)}`);
  majorGroup.fill(-1);
  for (const playerRegionScores of regionScores) {
    let iBestScore = -1;
    let iBestRegion = -1;
    for (let iRegion = 0; iRegion < playerRegionScores.scores.length; iRegion++) {
      if (majorGroup[iRegion] == -1) {
        const regionScoreForPlayer = playerRegionScores.scores[iRegion];
        if (regionScoreForPlayer > iBestScore) {
          iBestScore = regionScoreForPlayer;
          iBestRegion = iRegion;
        }
      }
    }
    if (iBestRegion >= 0) {
      majorGroup[iBestRegion] = playerRegionScores.playerIndex;
      console.log(
        `Region ${iBestRegion} is best for major: ${playerRegionScores.playerId} (index: ${playerRegionScores.playerIndex})`
      );
    }
  }
  console.log("Majors (final form):" + majorGroup);
}
function pickStartPlotByTile(tiles, continentId, numFoundEarlier, playerId, ignoreBias, startPositions, plotTagFilter) {
  let chosenPlotIndex = -1;
  let highestScore = 0;
  for (const tile of tiles) {
    if (!plotTagFilter || GameplayMap.getPlotTag(tile.x, tile.y) & plotTagFilter) {
      let score = scorePlot(tile.x, tile.y, continentId);
      if (score > 0) {
        if (!ignoreBias) {
          score += adjustScoreByStartBias(tile.x, tile.y, playerId);
        }
        if (numFoundEarlier > 0) {
          score = adjustScoreByClosestStart(score, tile.x, tile.y, startPositions);
        }
        if (score > highestScore) {
          highestScore = score;
          chosenPlotIndex = tile.y * GameplayMap.getGridWidth() + tile.x;
        }
      }
    }
  }
  return chosenPlotIndex;
}
function pickStartPlot(region, numFoundEarlier, playerId, ignoreBias, startPositions, plotTagFilter) {
  const tiles = [];
  for (let iY = region.south; iY <= region.north; iY++) {
    for (let iX = region.west; iX <= region.east; iX++) {
      tiles.push({ x: iX, y: iY });
    }
  }
  return pickStartPlotByTile(
    tiles,
    region.continent,
    numFoundEarlier,
    playerId,
    ignoreBias,
    startPositions,
    plotTagFilter
  );
}
function scorePlot(iX, iY, iContinent) {
  let score = -1;
  if (!GameplayMap.isWater(iX, iY) && !GameplayMap.isMountain(iX, iY)) {
    if (iContinent == -1 || GameplayMap.getContinentType(iX, iY) == iContinent) {
      score = StartPositioner.getStartPositionScore(iX, iY);
    }
  }
  return score;
}
function adjustScoreByClosestStart(originalScore, iX, iY, startPositions) {
  let score = originalScore;
  if (g_DesiredBufferBetweenMajorStarts <= g_RequiredBufferBetweenMajorStarts) return score;
  const distance = getDistanceToClosestStart(iX, iY, startPositions);
  if (distance < g_RequiredBufferBetweenMajorStarts) {
    score = 0;
  } else if (distance < g_DesiredBufferBetweenMajorStarts) {
    score = score * (distance - g_RequiredBufferBetweenMajorStarts + 1) / (g_DesiredBufferBetweenMajorStarts - g_RequiredBufferBetweenMajorStarts + 1);
  }
  return score;
}
function getDistanceToClosestStart(iX, iY, startPositions) {
  let minDistance = 32768;
  for (let iStart = 0; iStart < startPositions.length; iStart++) {
    const startPlotIndex = startPositions[iStart];
    if (startPlotIndex) {
      const iStartX = startPlotIndex % GameplayMap.getGridWidth();
      const iStartY = startPlotIndex / GameplayMap.getGridWidth();
      const distance = GameplayMap.getPlotDistance(iX, iY, iStartX, iStartY);
      if (distance < minDistance) {
        minDistance = distance;
      }
    }
  }
  return minDistance;
}
function adjustScoreByStartBias(iX, iY, playerId) {
  let score = 0;
  const player = Players.get(playerId);
  if (player == null || player.isAlive == false) {
    return score;
  }
  const eCivType = player.civilizationType;
  const eLeaderType = player.leaderType;
  for (let biomeIdx = 0; biomeIdx < GameInfo.StartBiasBiomes.length; biomeIdx++) {
    const startBiasCivilization = GameInfo.StartBiasBiomes[biomeIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasBiomes[biomeIdx]?.LeaderType;
    const startBiasBiome = GameInfo.StartBiasBiomes[biomeIdx]?.BiomeType;
    if (startBiasBiome) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getBiomeStartBiasScore(startBiasBiome, GameInfo.StartBiasBiomes[biomeIdx].Score, iX, iY);
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getBiomeStartBiasScore(startBiasBiome, GameInfo.StartBiasBiomes[biomeIdx].Score, iX, iY);
        }
      }
    }
  }
  for (let terrainIdx = 0; terrainIdx < GameInfo.StartBiasTerrains.length; terrainIdx++) {
    const startBiasCivilization = GameInfo.StartBiasTerrains[terrainIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasTerrains[terrainIdx]?.LeaderType;
    const startBiasTerrain = GameInfo.StartBiasTerrains[terrainIdx]?.TerrainType;
    if (startBiasTerrain) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getTerrainStartBiasScore(
            startBiasTerrain,
            GameInfo.StartBiasTerrains[terrainIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getTerrainStartBiasScore(
            startBiasTerrain,
            GameInfo.StartBiasTerrains[terrainIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let riverIdx = 0; riverIdx < GameInfo.StartBiasRivers.length; riverIdx++) {
    const startBiasCivilization = GameInfo.StartBiasRivers[riverIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasRivers[riverIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getRiverStartBiasScore(GameInfo.StartBiasRivers[riverIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getRiverStartBiasScore(GameInfo.StartBiasRivers[riverIdx].Score, iX, iY);
      }
    }
  }
  for (let coastIdx = 0; coastIdx < GameInfo.StartBiasAdjacentToCoasts.length; coastIdx++) {
    const startBiasCivilization = GameInfo.StartBiasAdjacentToCoasts[coastIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasAdjacentToCoasts[coastIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getCoastStartBiasScore(GameInfo.StartBiasAdjacentToCoasts[coastIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getCoastStartBiasScore(GameInfo.StartBiasAdjacentToCoasts[coastIdx].Score, iX, iY);
      }
    }
  }
  for (let featureIdx = 0; featureIdx < GameInfo.StartBiasFeatureClasses.length; featureIdx++) {
    const startBiasCivilization = GameInfo.StartBiasFeatureClasses[featureIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasFeatureClasses[featureIdx]?.LeaderType;
    const startBiasFeature = GameInfo.StartBiasFeatureClasses[featureIdx]?.FeatureClassType;
    if (startBiasFeature) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getFeatureClassStartBiasScore(
            startBiasFeature,
            GameInfo.StartBiasFeatureClasses[featureIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getFeatureClassStartBiasScore(
            startBiasFeature,
            GameInfo.StartBiasFeatureClasses[featureIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let resourceIdx = 0; resourceIdx < GameInfo.StartBiasResources.length; resourceIdx++) {
    const startBiasCivilization = GameInfo.StartBiasResources[resourceIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasResources[resourceIdx]?.LeaderType;
    const startBiasResource = GameInfo.StartBiasResources[resourceIdx]?.ResourceType;
    if (startBiasResource) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getResourceStartBiasScore(
            startBiasResource,
            GameInfo.StartBiasResources[resourceIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getResourceStartBiasScore(
            startBiasResource,
            GameInfo.StartBiasResources[resourceIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let lakeIdx = 0; lakeIdx < GameInfo.StartBiasLakes.length; lakeIdx++) {
    const startBiasCivilization = GameInfo.StartBiasLakes[lakeIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasLakes[lakeIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getLakeStartBiasScore(GameInfo.StartBiasLakes[lakeIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getLakeStartBiasScore(GameInfo.StartBiasLakes[lakeIdx].Score, iX, iY);
      }
    }
  }
  for (let nwIdx = 0; nwIdx < GameInfo.StartBiasNaturalWonders.length; nwIdx++) {
    const startBiasCivilization = GameInfo.StartBiasNaturalWonders[nwIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasNaturalWonders[nwIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getNaturalWonderStartBiasScore(GameInfo.StartBiasNaturalWonders[nwIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getNaturalWonderStartBiasScore(GameInfo.StartBiasNaturalWonders[nwIdx].Score, iX, iY);
      }
    }
  }
  return score;
}
function getBiomeStartBiasScore(biome, score, iX, iY) {
  const startBiasBiomeTypeIndex = GameInfo.Biomes.lookup(biome)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const biomeInfoTypeIndex = GameInfo.Biomes.lookup(GameplayMap.getBiomeType(iLocation.x, iLocation.y))?.$index;
    if (startBiasBiomeTypeIndex == biomeInfoTypeIndex) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getTerrainStartBiasScore(terrain, score, iX, iY) {
  const startBiasTerrainTypeIndex = GameInfo.Terrains.lookup(terrain)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const terrainInfoTypeIndex = GameInfo.Terrains.lookup(
      GameplayMap.getTerrainType(iLocation.x, iLocation.y)
    )?.$index;
    if (startBiasTerrainTypeIndex == terrainInfoTypeIndex) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getRiverStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isRiver(iLocation.x, iLocation.y)) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getCoastStartBiasScore(score, iX, iY) {
  let outputScore = 0;
  if (isOceanAccess(iX, iY)) {
    outputScore += score;
  }
  return outputScore;
}
function getFeatureClassStartBiasScore(feature, score, iX, iY) {
  const startBiasFeatureTypeIndex = GameInfo.FeatureClasses.lookup(feature)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const featureInfoTypeIndex = GameInfo.Features.lookup(
      GameplayMap.getFeatureType(iLocation.x, iLocation.y)
    )?.FeatureClassType;
    if (featureInfoTypeIndex) {
      const featureClassInfoTypeIndex = GameInfo.FeatureClasses.lookup(featureInfoTypeIndex)?.$index;
      if (featureClassInfoTypeIndex == startBiasFeatureTypeIndex) {
        let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
        if (distance < 1) {
          distance = 1;
        }
        outputScore += score / distance;
      }
    }
  }
  return outputScore;
}
function getResourceStartBiasScore(resource, score, iX, iY) {
  const startBiasResourceTypeIndex = GameInfo.Resources.lookup(resource)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const resourceInfoTypeIndex = GameInfo.Resources.lookup(
      GameplayMap.getResourceType(iLocation.x, iLocation.y)
    )?.$index;
    if (startBiasResourceTypeIndex == resourceInfoTypeIndex) {
      outputScore += score;
    }
  }
  return outputScore;
}
function getLakeStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isLake(iLocation.x, iLocation.y)) {
      outputScore += score;
    }
  }
  if (outputScore > 0) {
    console.log("Start Bias Score: " + outputScore);
  }
  return outputScore;
}
function getNaturalWonderStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isNaturalWonder(iLocation.x, iLocation.y)) {
      outputScore += score;
    }
  }
  if (outputScore > 0) {
    console.log("Start Bias Score: " + outputScore);
  }
  return outputScore;
}

export { PlayerRegion, PlayerRegionScores, assignSingleContinentStartPositions, assignStartPositions, assignStartPositionsFromTiles, chooseStartSectors };
//# sourceMappingURL=assign-starting-plots.js.map
</file>

<file path="mod/maps/base-standard/maps/continents-plus.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpTerrain, dumpContinents, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_OceanWaterColumns, g_NavigableRiverTerrain, g_CoastTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, addPlotTags, createIslands, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, createOrganicLandmasses, adjustOceanPlotTags, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script continents-plus.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  let naturalWonderEvent = false;
  const requestedNaturalWonders = [];
  let liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_RACE_TO_WONDERS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    naturalWonderEvent = true;
    requestedNaturalWonders.push("FEATURE_BERMUDA_TRIANGLE");
  }
  liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_MARVELOUS_MOUNTAINS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    naturalWonderEvent = true;
    requestedNaturalWonders.push("FEATURE_MOUNT_EVEREST");
  }
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  console.log(
    westContinent.west,
    ", ",
    westContinent.east,
    ", ",
    eastContinent.west,
    ", ",
    eastContinent.east,
    ", ",
    westContinent2.west,
    ", ",
    westContinent2.east,
    ", ",
    eastContinent2.west,
    ", ",
    eastContinent2.east,
    ", "
  );
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash || naturalWonderEvent;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = !naturalWonderEvent ? TerrainBuilder.getRandomNumber(2, "East or West") : 0;
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    dumpTerrain(iWidth, iHeight);
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
    dumpTerrain(iWidth, iHeight);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 15;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    dumpTerrain(iWidth, iHeight);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
    dumpTerrain(iWidth, iHeight);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders, naturalWonderEvent, requestedNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iNumPlayers1 > iNumPlayers2) {
          if (iX < westContinent.west - 2 || iX > westContinent.east + 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          }
        } else {
          if (iX > eastContinent.east + 2 || iX < eastContinent.west - 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          }
        }
      }
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded continents-plus.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=continents-plus.js.map
</file>

<file path="mod/maps/base-standard/maps/continents-voronoi.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { PlayerRegion, assignStartPositionsFromTiles, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_FlatTerrain, g_MountainTerrain, g_HillTerrain, g_VolcanoFeature, g_OceanTerrain, g_CoastTerrain, g_NavigableRiverTerrain, g_AvoidSeamOffset } from './map-globals.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { kdTree } from '../scripts/kd-tree.js';
import { TerrainType } from '../scripts/voronoi-utils.js';
import { VoronoiContinents } from '../scripts/voronoi_maps/continents.js';
import { RuleAvoidEdge } from '../scripts/voronoi_rules/avoid-edge.js';
import './map-utilities.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../scripts/random-pcg-32.js';
import '../scripts/voronoi_generators/map-generator.js';
import '../scripts/voronoi_maps/map-common.js';
import '../scripts/voronoi-builder.js';
import '../scripts/voronoi-hex.js';
import '../../core/scripts/MathHelpers.js';
import '../scripts/heap.js';
import '../scripts/voronoi_generators/continent-generator.js';
import '../scripts/quadtree.js';
import '../scripts/voronoi-region.js';
import '../scripts/voronoi_rules/avoid-other-regions.js';
import '../scripts/voronoi_rules/rules-base.js';
import '../scripts/voronoi_rules/cell-area.js';
import '../scripts/voronoi_rules/near-map-center.js';
import '../scripts/voronoi_rules/near-neighbor.js';
import '../scripts/voronoi_rules/near-plate-boundary.js';
import '../scripts/voronoi_rules/near-region-seed.js';
import '../scripts/voronoi_rules/neighbors-in-region.js';
import '../scripts/voronoi_rules/prefer-latitude.js';

console.log("Generating using script Continents-Voronoi.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
async function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iTotalPlayers = Players.getAliveMajorIds().length;
  const startTime = Date.now();
  const voronoiMap = new VoronoiContinents();
  voronoiMap.init(mapInfo.$index);
  const rules = voronoiMap.getBuilder().getGenerator().getRules();
  for (const value of Object.values(rules)) {
    for (const rule of value) {
      if (rule.name == RuleAvoidEdge.getName()) {
        rule.configValues.poleDistance = g_PolarWaterRows;
      }
    }
  }
  const generatorSettings = voronoiMap.getBuilder().getGenerator().getSettings();
  const sizeRatio = generatorSettings.landmass[0].size / (generatorSettings.landmass[0].size + generatorSettings.landmass[1].size);
  const iNumPlayers1 = Math.round(iTotalPlayers * sizeRatio);
  const iNumPlayers2 = iTotalPlayers - iNumPlayers1;
  generatorSettings.landmass[0].playerAreas = iNumPlayers1;
  generatorSettings.landmass[1].playerAreas = iNumPlayers2;
  voronoiMap.getBuilder().simulate();
  const tiles = voronoiMap.getBuilder().getTiles();
  const landmassKdTree = new kdTree((tile) => tile.pos);
  landmassKdTree.build(tiles.flatMap((row) => row.filter((tile) => tile.landmassId > 0)));
  for (let y = 0; y < tiles.length; ++y) {
    for (let x = 0; x < tiles[y].length; ++x) {
      const tile = tiles[y][x];
      if (tile.isLand()) {
        const type = tile.terrainType === TerrainType.Flat ? g_FlatTerrain : tile.terrainType === TerrainType.Mountainous || tile.terrainType === TerrainType.Volcano ? g_MountainTerrain : tile.terrainType === TerrainType.Rough ? g_HillTerrain : g_FlatTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        if (tile.terrainType === TerrainType.Volcano) {
          TerrainBuilder.setFeatureType(x, y, {
            Feature: g_VolcanoFeature,
            Direction: -1,
            Elevation: 0
          });
        }
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_LANDMASS);
        if (tile.landmassId === 1) {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_LANDMASS);
        } else if (tile.landmassId === 2) {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_EAST_LANDMASS);
        } else {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND);
        }
      } else if (tile.isWater()) {
        const type = tile.terrainType === TerrainType.Ocean ? g_OceanTerrain : g_CoastTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
        if (tile.terrainType === TerrainType.Coast) {
          const landmassTile = landmassKdTree.search(tile.pos);
          if (landmassTile.landmassId === 1) {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_WATER);
          } else if (landmassTile.landmassId === 2) {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND_WATER);
          }
        }
      }
    }
  }
  const endTime = Date.now();
  console.log(`Initial Voronoi map generation took ${endTime - startTime} ms`);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  const lakeTiles = generateLakes(iWidth, iHeight, iTilesPerLake);
  console.log(`Updating plot tags for ${lakeTiles.length} lakes.`);
  for (const coord of lakeTiles) {
    const tile = tiles[coord.y][coord.x];
    TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WATER);
    if (tile.landmassId === 1) {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WEST_WATER);
    } else if (tile.landmassId === 2) {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_EAST_WATER);
    } else {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_ISLAND_WATER);
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  let startPositions = [];
  const USE_VORONOI_START_POSITIONS = true;
  if (USE_VORONOI_START_POSITIONS) {
    const fertilityGetter = (tile) => StartPositioner.getPlotFertilityForCoord(tile.coord.x, tile.coord.y);
    voronoiMap.getBuilder().createMajorPlayerAreas(fertilityGetter);
    const playerRegions = Array.from({ length: iTotalPlayers }, () => new PlayerRegion());
    playerRegions.forEach((region, index) => region.regionId = index);
    console.log(`Creating player regions.. initializing indices: ${playerRegions.map((pr) => pr.regionId)}`);
    let offset = 0;
    const offsets = [0].concat([...generatorSettings.landmass.map((n) => offset += n.playerAreas)]);
    for (const row of tiles) {
      for (const tile of row) {
        if (tile.majorPlayerRegionId >= 0 && tile.landmassId > 0) {
          const regionId = tile.majorPlayerRegionId + offsets[tile.landmassId - 1];
          const playerRegion = playerRegions[regionId];
          playerRegion.landmassId = tile.landmassId - 1;
          playerRegion.tiles.push({ x: tile.coord.x, y: tile.coord.y });
        }
      }
    }
    startPositions = assignStartPositionsFromTiles(playerRegions);
  } else {
    const continent = {
      west: g_AvoidSeamOffset,
      east: iWidth - g_AvoidSeamOffset,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    startPositions = assignStartPositions(iNumPlayers1, iNumPlayers2, continent, continent, 0, 0, []);
  }
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
//# sourceMappingURL=continents-voronoi.js.map
</file>

<file path="mod/maps/base-standard/maps/continents.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoasts, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight, g_CoastTerrain } from './map-globals.js';
import { needHumanNearEquator, applyCoastalErosionAdjustingForStartSectors, addPlotTags, createOrganicLandmasses, applyCoastalErosion, adjustOceanPlotTags, adjustLakePlotTags, getHeightAdjustingForStartSector, getSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script Continents.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = g_OceanWaterColumns;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 18;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoasts(iWidth, iHeight);
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  adjustLakePlotTags(westContinent, true);
  adjustLakePlotTags(eastContinent, false);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded Continents.ts");
console.log("hey, continents is firing");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          if (startSectors[iSector]) {
            terrain = g_CoastTerrain;
          } else {
            terrain = g_OceanTerrain;
          }
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
//# sourceMappingURL=continents.js.map
</file>

<file path="mod/maps/base-standard/maps/discovery-generator.js">
import { g_OceanWaterColumns, g_RequiredDistanceFromMajorForDiscoveries, g_CoastTerrain, g_OceanTerrain } from './map-globals.js';
import { getDistanceToClosestStart } from './map-utilities.js';

function generateDiscoveries(iWidth, iHeight, startingPositions) {
  if (GameInfo.Ages.lookup(Game.age).GenerateDiscoveries == false) {
    console.log("DISCOVERIES TURNED OFF FOR " + Game.age);
    return;
  }
  if (Configuration.getGameValue("DiscoverySiftingType") == 2316276985) {
    console.log("DISCOVERIES TURNED OFF");
    return;
  }
  console.log("Discovery generation", iWidth, iHeight);
  let discoveryCounter = 0;
  let oceanDiscoveryCounter = 0;
  let discoveryPlacedCounter = 0;
  let totalCoastalDiscoveryNotPlaced = 0;
  let totalOceanDiscoveryNotPlaced = 0;
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 5;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  let distanceToClosestStart = 0;
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) {
    console.log("Skipping discoveries.  No mapInfo for map of size ", uiMapSize);
    return;
  }
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: 0,
    north: 0,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: 0,
    north: 0,
    continent: 0
  };
  function DiscoveryDiceRoller() {
    const randomthing = TerrainBuilder.getRandomNumber(100, "Discovery Type Roll");
    if (randomthing <= 65) {
      return DiscoveryActivationTypes.BASIC;
    } else if (randomthing <= 100) {
      return DiscoveryActivationTypes.INVESTIGATION;
    } else {
      return DiscoveryActivationTypes.MYTHIC;
    }
  }
  function DiscoveryVisualString(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
        return "Cave";
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
        return "Ruins";
      case DiscoveryVisualTypes.IMPROVEMENT_CAMPFIRE:
        return "Campfire";
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
        return "Tents";
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
        return "Cairn";
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
        return "Rich";
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return "Wreckage";
      default:
        return "";
    }
  }
  function DiscoveryTypeString(numb) {
    switch (numb) {
      case DiscoveryActivationTypes.BASIC:
        return "Basic";
      case DiscoveryActivationTypes.INVESTIGATION:
        return "Investigation";
      default:
        return "Unknown";
    }
  }
  function AllowedDiscoveryVisual(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAMPFIRE:
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return true;
      default:
        return false;
    }
  }
  function AllowedDiscoveryVisualExploration(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return true;
      default:
        return false;
    }
  }
  console.log("counting");
  console.log(DiscoveryVisualTypes.IMPROVEMENT_CAVE);
  const basicsMap = [];
  const investigationMap = [];
  if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
    GameInfo.DiscoverySiftingImprovements.forEach((discoverySift) => {
      if (AllowedDiscoveryVisualExploration(Database.makeHash(discoverySift.ConstructibleType))) {
        const amount = GameInfo.NarrativeStories.filter((def) => def.Queue == discoverySift.QueueType).length;
        if (amount > 0) {
          if (discoverySift.Activation === "BASIC") {
            basicsMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          } else if (discoverySift.Activation === "INVESTIGATION") {
            investigationMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          }
        }
      }
    });
  } else {
    GameInfo.DiscoverySiftingImprovements.forEach((discoverySift) => {
      if (AllowedDiscoveryVisual(Database.makeHash(discoverySift.ConstructibleType))) {
        const amount = GameInfo.NarrativeStories.filter((def) => def.Queue == discoverySift.QueueType).length;
        if (amount > 0) {
          if (discoverySift.Activation === "BASIC") {
            basicsMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          } else if (discoverySift.Activation === "INVESTIGATION") {
            investigationMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          }
        }
      }
    });
  }
  console.log("poisson number?: " + poisson);
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const iLocation = GameplayMap.getLocationFromIndex(index);
        const terrainType = GameplayMap.getTerrainType(iX, iY);
        if (startingPositions.length > 0) {
          distanceToClosestStart = getDistanceToClosestStart(
            iX,
            iY,
            startingPositions.length,
            startingPositions
          );
          if (distanceToClosestStart < g_RequiredDistanceFromMajorForDiscoveries) {
            continue;
          }
        } else {
          const owner = GameplayMap.getOwner(iX, iY);
          if (owner != PlayerIds.NO_PLAYER) {
            console.log(
              "Can't Place Discovery, tile already owned: ",
              "X=" + iLocation.x + " Y=" + iLocation.y
            );
            continue;
          }
        }
        if (GameplayMap.isImpassable(iX, iY)) {
          continue;
        }
        if (GameplayMap.isNavigableRiver(iX, iY)) {
          continue;
        }
        const resourceAtThisLocal = GameplayMap.getResourceType(iX, iY);
        if (resourceAtThisLocal !== -1) {
          continue;
        }
        if (GameplayMap.isNaturalWonder(iX, iY)) {
          continue;
        }
        if (terrainType === g_CoastTerrain && TerrainBuilder.getRandomNumber(100, "Coast Check") >= 65) {
          const discoveryType2 = DiscoveryDiceRoller();
          discoveryCounter++;
          if (MapConstructibles.addDiscovery(iX, iY, DiscoveryVisualTypes.IMPROVEMENT_COAST, discoveryType2)) {
            discoveryPlacedCounter++;
            console.log("Discovery #", discoveryCounter);
            console.log(
              "VALID coastal DISCOVERY SPOT FOUND!-------------------------------------",
              "X=" + iLocation.x + " Y=" + iLocation.y
            );
            continue;
          } else {
            ++totalCoastalDiscoveryNotPlaced;
            console.log("did not place COASTAL Discovery#: " + discoveryCounter);
            continue;
          }
        }
        if (terrainType === g_OceanTerrain) {
          if (Game.age == Database.makeHash("AGE_EXPLORATION") && TerrainBuilder.getRandomNumber(100, "Coast Check") >= 65) {
            if (iX < westContinent.west || iX > westContinent.east && iX < eastContinent.west || iX > eastContinent.east) {
              const discoveryType2 = DiscoveryDiceRoller();
              discoveryCounter++;
              if (MapConstructibles.addDiscovery(
                iX,
                iY,
                DiscoveryVisualTypes.IMPROVEMENT_SHIPWRECK,
                discoveryType2
              )) {
                discoveryPlacedCounter++;
                oceanDiscoveryCounter++;
                console.log("Discovery #", discoveryCounter);
                console.log(
                  "VALID coastal DISCOVERY SPOT FOUND!-------------------------------------",
                  "X=" + iLocation.x + " Y=" + iLocation.y
                );
                continue;
              } else {
                ++totalOceanDiscoveryNotPlaced;
                console.log("did not place OCEAN discovery#: " + discoveryCounter);
                continue;
              }
            }
          }
        }
        if (GameplayMap.isWater(iX, iY)) {
          continue;
        }
        discoveryCounter++;
        const discoveryType = DiscoveryDiceRoller();
        const discoveryTypeString = DiscoveryTypeString(discoveryType);
        let discoveryHash = DiscoveryVisualTypes.INVALID;
        let visualIndex = -1;
        if (discoveryType == DiscoveryActivationTypes.BASIC) {
          if (basicsMap.length > 0) {
            visualIndex = TerrainBuilder.getRandomNumber(basicsMap.length, "Discovery roll");
            discoveryHash = basicsMap[visualIndex][0];
          }
        } else {
          if (investigationMap.length > 0) {
            visualIndex = TerrainBuilder.getRandomNumber(investigationMap.length, "Discovery roll");
            discoveryHash = investigationMap[visualIndex][0];
          }
        }
        const discoveryVisual = DiscoveryVisualString(discoveryHash);
        if (discoveryHash == DiscoveryVisualTypes.INVALID) {
          console.log(
            "Could not find available discovery: ",
            discoveryTypeString,
            "Discovery#: ",
            discoveryCounter
          );
          continue;
        }
        if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
          console.log("in exploration age");
          console.log("Discovery #", discoveryCounter);
          console.log(
            "VALID DISCOVERY SPOT FOUND-------------------------------------",
            "X=" + iLocation.x + " Y=" + iLocation.y + "  Type: " + discoveryVisual
          );
          if (MapConstructibles.addDiscovery(iX, iY, discoveryHash, discoveryType)) {
            if (discoveryType == DiscoveryActivationTypes.BASIC) {
              --basicsMap[visualIndex][1];
              if (basicsMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                basicsMap.splice(visualIndex, 1);
              }
            } else {
              --investigationMap[visualIndex][1];
              if (investigationMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                investigationMap.splice(visualIndex, 1);
              }
            }
            discoveryPlacedCounter++;
            const discoveryX = iX;
            const discoveryY = iY;
            console.log(discoveryX, discoveryY, discoveryVisual, discoveryTypeString);
          } else {
            console.log(
              "did not place discovery#: " + discoveryCounter + " discovery visual: " + discoveryVisual + " discovery type: " + discoveryTypeString
            );
          }
        } else {
          console.log("in antiquity age");
          console.log("Discovery #", discoveryCounter);
          console.log(
            "VALID DISCOVERY SPOT FOUND-------------------------------------",
            "X=" + iLocation.x + " Y=" + iLocation.y + "  Type: " + discoveryVisual
          );
          if (MapConstructibles.addDiscovery(iX, iY, discoveryHash, discoveryType)) {
            if (discoveryType == DiscoveryActivationTypes.BASIC) {
              --basicsMap[visualIndex][1];
              if (basicsMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                basicsMap.splice(visualIndex, 1);
              }
            } else {
              --investigationMap[visualIndex][1];
              if (investigationMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                investigationMap.splice(visualIndex, 1);
              }
            }
            discoveryPlacedCounter++;
            const discoveryX = iX;
            const discoveryY = iY;
            console.log(discoveryX, discoveryY, discoveryVisual, discoveryTypeString);
          } else {
            console.log(
              "did not place discovery#: " + discoveryCounter + " discovery visual: " + discoveryVisual + " discovery type: " + discoveryTypeString
            );
          }
        }
      }
    }
  }
  console.log("Basics: ");
  for (const [key, value] of basicsMap) {
    console.log(key, "->", value);
  }
  console.log("investigations: ");
  for (const [key, value] of investigationMap) {
    console.log(key, "->", value);
  }
  console.log("Total Discoveries Placed: " + discoveryPlacedCounter);
  console.log("Total ocean Discoveries Placed: " + oceanDiscoveryCounter);
  console.log("Total Coastal Discoveries Not Placed: " + totalCoastalDiscoveryNotPlaced);
  console.log("Total Ocean Discoveries Not Placed: " + totalOceanDiscoveryNotPlaced);
  console.log("could not place this many discoveries: " + (discoveryCounter - discoveryPlacedCounter));
}

export { generateDiscoveries };
//# sourceMappingURL=discovery-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/elevation-terrain-generator.js">
import { g_MountainFractal, g_HillFractal, g_MountainTerrain, g_FlatTerrain, g_HillTerrain, g_OceanTerrain, g_OceanWaterColumns, g_CoastTerrain, g_StandardRainfall, g_MountainTopIncrease, g_RainShadowDrop, g_RainShadowIncreasePerHex } from './map-globals.js';
import { isCliff } from './map-utilities.js';

function addMountains(iWidth, iHeight) {
  const adjustment = 3;
  let extra_mountains = 0;
  const iFlags = 0;
  const grainAmount = 5;
  const liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_MARVELOUS_MOUNTAINS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    extra_mountains = 40;
  }
  const mountains = 93 - adjustment - extra_mountains;
  FractalBuilder.create(g_MountainFractal, iWidth, iHeight, grainAmount, iFlags);
  FractalBuilder.create(g_HillFractal, iWidth, iHeight, grainAmount, iFlags);
  const iMountainThreshold = FractalBuilder.getHeightFromPercent(g_MountainFractal, mountains);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = GameplayMap.getTerrainType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false) {
        const iMountainHeight = FractalBuilder.getHeight(g_MountainFractal, iX, iY);
        if (iMountainHeight >= iMountainThreshold) {
          terrain = g_MountainTerrain;
        }
        if (terrain != g_FlatTerrain) {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      }
    }
  }
}
function addHills(iWidth, iHeight) {
  const adjustment = 3;
  const base_hills_threshold = 950;
  const extra_hills = 0;
  const hillsThreshold = base_hills_threshold - adjustment * 20 - extra_hills;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false && GameplayMap.isMountain(iX, iY) == false) {
        const iIndex = GameplayMap.getIndexFromXY(iX, iY);
        const iLocation = GameplayMap.getLocationFromIndex(iIndex);
        let iHillScore = 0;
        const iElevation = GameplayMap.getElevation(iX, iY);
        for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
          if (GameplayMap.isCliffCrossing(iX, iY, iDirection) == false) {
            const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
            const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
            const iAdjacentElevation = GameplayMap.getElevation(iAdjacentX, iAdjacentY);
            const iElevationDifference = iAdjacentElevation - iElevation;
            if (iElevationDifference > 0) {
              iHillScore = iHillScore + iElevationDifference;
            } else {
              iHillScore = iHillScore - iElevationDifference;
            }
          }
        }
        if (iHillScore > hillsThreshold) {
          TerrainBuilder.setTerrainType(iX, iY, g_HillTerrain);
        }
      }
    }
  }
}
function expandCoasts(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (iX > g_OceanWaterColumns / 2 && (iX < (iWidth - g_OceanWaterColumns) / 2 || iX > (iWidth + g_OceanWaterColumns) / 2) && iX < iWidth - g_OceanWaterColumns / 2) {
          if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(4, "Shallow Water Scater Scatter") == 0) {
            TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
          }
        }
      }
    }
  }
}
function generateLakes(iWidth, iHeight, iTilesPerLake) {
  let iLakesAdded = 0;
  if (iTilesPerLake == 0) iTilesPerLake = 25;
  const ilakePlotRand = Math.floor(iWidth * iHeight / iTilesPerLake);
  console.log("Num Directions" + DirectionTypes.NUM_DIRECTION_TYPES);
  const lakeTiles = [];
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        if (GameplayMap.isCoastalLand(iX, iY) == false) {
          if (GameplayMap.isImpassable(iX, iY) == false) {
            const r = TerrainBuilder.getRandomNumber(ilakePlotRand, "MapGenerator AddLakes");
            if (r == 0) {
              iLakesAdded = iLakesAdded + 1;
              lakeTiles.push(...addMoreLake(iX, iY));
              lakeTiles.push({ x: iX, y: iY });
              TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
            }
          }
        }
      }
    }
  }
  if (iLakesAdded > 0) {
    console.log("Lakes Added: " + iLakesAdded);
  }
  return lakeTiles;
}
function addMoreLake(iX, iY) {
  let iLargeLakes = 0;
  const lakeTiles = [];
  const adjacentPlots = [];
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.isWater(iAdjacentX, iAdjacentY) == false) {
      if (GameplayMap.isAdjacentToShallowWater(iAdjacentX, iAdjacentY) == false) {
        if (GameplayMap.isImpassable(iAdjacentX, iAdjacentY) == false) {
          const r = TerrainBuilder.getRandomNumber(4 + iLargeLakes, "MapGenerator Enlarge Lakes");
          if (r < 3) {
            adjacentPlots.push(iAdjacentPlot);
            iLargeLakes = iLargeLakes + 1;
          }
        }
      }
    }
  }
  for (let adjacentIdx = 0; adjacentIdx < adjacentPlots.length; adjacentIdx++) {
    const x = adjacentPlots[adjacentIdx].x;
    const y = adjacentPlots[adjacentIdx].y;
    TerrainBuilder.setTerrainType(x, y, g_CoastTerrain);
    lakeTiles.push({ x, y });
  }
  return lakeTiles;
}
function buildRainfallMap(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    let iMountainXTilesAgo = -1;
    for (let iX = 0; iX < iWidth; iX++) {
      let iRainfall = g_StandardRainfall;
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (GameplayMap.isLake(iX, iY) == true) {
        TerrainBuilder.setRainfall(iX, iY, iRainfall * 2);
      } else if (GameplayMap.isWater(iX, iY) == false) {
        if (terrain == g_MountainTerrain || isCliff(iX, iY)) {
          iMountainXTilesAgo = 0;
        } else if (iMountainXTilesAgo >= 0) {
          iMountainXTilesAgo++;
        }
        if (iMountainXTilesAgo == 0) {
          iRainfall += g_MountainTopIncrease;
        } else if (iMountainXTilesAgo > 0) {
          iRainfall += g_RainShadowDrop;
          iRainfall += iMountainXTilesAgo * g_RainShadowIncreasePerHex;
          if (iRainfall > g_StandardRainfall) {
            iRainfall = g_StandardRainfall;
          }
        }
        TerrainBuilder.setRainfall(iX, iY, iRainfall);
      } else {
        iMountainXTilesAgo = -1;
      }
    }
  }
}

export { addHills, addMountains, buildRainfallMap, expandCoasts, generateLakes };
//# sourceMappingURL=elevation-terrain-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/feature-biome-generator.js">
import { g_PlainsLatitude, g_MarineBiome, g_TropicalLatitude, g_PlainsBiome, g_TropicalBiome, g_DesertLatitude, g_DesertBiome, g_GrasslandLatitude, g_GrasslandBiome, g_TundraBiome } from './map-globals.js';
import { isAdjacentToNaturalWonder } from './map-utilities.js';

function designateBiomes(iWidth, iHeight) {
  console.log("Biomes");
  let iTotalLandPlots = 0;
  let iTotalLandPlotsAbove = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const latitude = GameplayMap.getPlotLatitude(iX, iY);
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots = iTotalLandPlots + 1;
      }
      if (!GameplayMap.isWater(iX, iY) && g_PlainsLatitude < latitude) {
        iTotalLandPlotsAbove = iTotalLandPlotsAbove + 1;
      }
    }
  }
  let iPlainsLowering = 0;
  let iDesertLowering = 0;
  let iGrassLowering = 0;
  let iTropicalLowering = 0;
  if (Math.round(iTotalLandPlots / 5 * 2 * 0.75) > iTotalLandPlotsAbove) {
    iPlainsLowering += 5;
    iDesertLowering += 4;
    iGrassLowering += 4;
    iTropicalLowering += 2;
    console.log(
      "Less  iTotalLandPlots: " + iTotalLandPlots + " iTotalLandPlotsAbove: " + iTotalLandPlotsAbove
    );
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY)) {
        TerrainBuilder.setBiomeType(iX, iY, g_MarineBiome);
      } else {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude;
        latitude += Math.round(GameplayMap.getElevation(iX, iY) / 120);
        if (GameplayMap.isRiver(iX, iY)) {
          latitude -= 10;
        } else if (GameplayMap.isAdjacentToRivers(iX, iY, 1)) {
          latitude -= 5;
        }
        const rainfall = GameplayMap.getRainfall(iX, iY);
        if (latitude < g_TropicalLatitude - iTropicalLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_PlainsBiome);
        } else if (latitude < g_TropicalLatitude - iTropicalLowering) {
          TerrainBuilder.setBiomeType(iX, iY, g_TropicalBiome);
        } else if (latitude < g_PlainsLatitude - iPlainsLowering || latitude < g_TropicalLatitude - iTropicalLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_PlainsBiome);
        } else if (latitude < g_DesertLatitude - iDesertLowering || latitude < g_PlainsLatitude - iPlainsLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_DesertBiome);
        } else if (latitude < g_GrasslandLatitude - iGrassLowering) {
          TerrainBuilder.setBiomeType(iX, iY, g_GrasslandBiome);
        } else {
          TerrainBuilder.setBiomeType(iX, iY, g_TundraBiome);
        }
      }
    }
  }
}
function addFeatures(iWidth, iHeight) {
  console.log("Features");
  addPositionalFeatures(iWidth, iHeight);
  scatterFeatures(iWidth, iHeight);
  addIce(iWidth, iHeight);
  addReefs(iWidth, iHeight);
}
function addPositionalFeatures(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false && feature == FeatureTypes.NO_FEATURE && GameplayMap.isNavigableRiver(iX, iY) == false) {
        if (GameplayMap.isCoastalLand(iX, iY)) {
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              true,
              false,
              false,
              false,
              false
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        } else if (GameplayMap.isAdjacentToRivers(iX, iY, 2)) {
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              true,
              false,
              false,
              false
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        } else {
          if (GameplayMap.isAdjacentToRivers(iX, iY, 1)) {
            continue;
          } else if (GameplayMap.isCoastalLand(iX, iY)) {
            continue;
          }
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (!GameplayMap.isAdjacentToFeature(iX, iY, featIdx) && canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              false,
              true,
              false,
              false
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        }
      }
    }
  }
}
function scatterFeatures(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false && feature == FeatureTypes.NO_FEATURE && GameplayMap.isNavigableRiver(iX, iY) == false) {
        for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
          if (canAddFeature(
            iX,
            iY,
            featIdx,
            true,
            false,
            false,
            false,
            false,
            false,
            false
          )) {
            const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
            const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
            if (iRoll < iScatterChance) {
              const featureParam = {
                Feature: featIdx,
                Direction: -1,
                Elevation: 0
              };
              TerrainBuilder.setFeatureType(iX, iY, featureParam);
              break;
            }
          }
        }
      }
    }
  }
}
function addReefs(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude;
        for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
          if (canAddFeature(
            iX,
            iY,
            featIdx,
            false,
            false,
            false,
            false,
            false,
            true,
            false
          )) {
            if (GameInfo.Features[featIdx].MinLatitude <= latitude && GameInfo.Features[featIdx].MaxLatitude > latitude) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iWeight = (latitude + 50) * 2;
              const iRoll = TerrainBuilder.getRandomNumber(iWeight, "Feature Reef");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        }
      }
    }
  }
}
function addIce(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude - 5;
        if (latitude > 78) {
          for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              false,
              false,
              false,
              true
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              let iScore = TerrainBuilder.getRandomNumber(100, "Feature Ice");
              iScore = iScore + latitude;
              if (GameplayMap.isAdjacentToLand(iX, iY)) {
                iScore = 0;
              }
              if (isAdjacentToNaturalWonder(iX, iY)) {
                iScore = 0;
              }
              if (iScore > iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        }
      }
    }
  }
}
function canAddFeature(iX, iY, feature, bScatterable, bRiverMouth, bCoastal, bNearRiver, bIsolated, bReef, bIce) {
  if (!bScatterable || GameInfo.Features[feature].PlacementClass == "SCATTER") {
    if (!bRiverMouth || GameInfo.Features[feature].PlacementClass == "RIVERMOUTH") {
      if (!bCoastal || GameInfo.Features[feature].PlacementClass == "COASTAL") {
        if (!bNearRiver || GameInfo.Features[feature].PlacementClass == "NEARRIVER") {
          if (!bIsolated || GameInfo.Features[feature].PlacementClass == "ISOLATED") {
            if (!bReef || GameInfo.Features[feature].PlacementClass == "REEF") {
              if (!bIce || GameInfo.Features[feature].PlacementClass == "ICE") {
                return TerrainBuilder.canHaveFeature(iX, iY, feature);
              }
            }
          }
        }
      }
    }
  }
  return false;
}

export { addFeatures, designateBiomes };
//# sourceMappingURL=feature-biome-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/fractal.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_OceanWaterColumns, g_NavigableRiverTerrain, g_CoastTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, addPlotTags, createIslands, createOrganicLandmasses, adjustOceanPlotTags, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script fractal.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 3;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 12;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iNumPlayers1 > iNumPlayers2) {
          if (iX < westContinent.west - 2 || iX > westContinent.east + 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          }
        } else {
          if (iX > eastContinent.east + 2 || iX < eastContinent.west - 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          }
        }
      }
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded fractal.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 3, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 13.5);
  const iBuffer2 = Math.floor(iWidth / 21);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          0,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * (g_FractalWeight + g_StartSectorWeight)) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=fractal.js.map
</file>

<file path="mod/maps/base-standard/maps/index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="mod/maps/base-standard/maps/map-debug-helpers.js">
import { g_FlatTerrain, g_HillTerrain, g_MountainTerrain, g_OceanTerrain, g_StandardRainfall, g_MountainTopIncrease, g_MarineBiome, g_PlainsBiome, g_DesertBiome, g_TropicalBiome, g_TundraBiome, g_GrasslandBiome } from './map-globals.js';

function dumpStartSectors(sectors) {
  for (let iX = 0; iX < sectors.length; iX++) {
    console.log(iX + ": " + sectors[iX]);
  }
}
function dumpContinents(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let terrainString = " ";
      if (GameplayMap.isWater(iX, iY) == false) {
        const continent = GameplayMap.getContinentType(iX, iY);
        if (typeof continent == "number") {
          terrainString = Math.floor(continent % 10).toString();
        }
      }
      str += terrainString + " ";
    }
    console.log(str);
  }
}
function dumpTerrain(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      let terrainString = " ";
      if (terrain == g_FlatTerrain) {
        terrainString = ".";
      } else if (terrain == g_HillTerrain) {
        terrainString = "^";
      } else if (terrain == g_MountainTerrain) {
        terrainString = "M";
      } else if (terrain == g_OceanTerrain) {
        terrainString = "~";
      }
      str += terrainString + " ";
    }
    console.log(str);
  }
}
function dumpElevation(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        const elevation = GameplayMap.getElevation(iX, iY);
        let elevationToDisplay = " ";
        const iNumToDisplay = Math.floor(elevation / 100);
        elevationToDisplay = iNumToDisplay.toString();
        str += elevationToDisplay + " ";
      } else {
        str += "  ";
      }
    }
    console.log(str);
  }
}
function dumpRainfall(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        const rainfall = GameplayMap.getRainfall(iX, iY);
        let rainfallToDisplay = " ";
        if (rainfall == g_StandardRainfall + g_MountainTopIncrease) {
          rainfallToDisplay = "D";
        } else if (rainfall == g_StandardRainfall) {
          rainfallToDisplay = "s";
        } else {
          const iNumToDisplay = Math.floor(rainfall / 10);
          rainfallToDisplay = iNumToDisplay.toString();
        }
        str += rainfallToDisplay + " ";
      } else {
        str += "  ";
      }
    }
    console.log(str);
  }
}
function dumpBiomes(iWidth, iHeight) {
  const biomes = new Array(GameInfo.Biomes.length);
  for (let biomeIdx = 0; biomeIdx < GameInfo.Biomes.length; biomeIdx++) {
    biomes[biomeIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const biome = GameplayMap.getBiomeType(iX, iY);
      let biomeString = " ";
      if (biome == g_MarineBiome) {
        biomeString = " ";
      } else if (biome == g_PlainsBiome) {
        biomeString = "_";
      } else if (biome == g_DesertBiome) {
        biomeString = ".";
      } else if (biome == g_TropicalBiome) {
        biomeString = "#";
      } else if (biome == g_TundraBiome) {
        biomeString = "*";
      } else if (biome == g_GrasslandBiome) {
        biomeString = "~";
      }
      str += biomeString + " ";
      if (typeof biome == "number") {
        biomes[biome]++;
      }
    }
    console.log(str);
  }
  for (let biomeIDx = 0; biomeIDx < GameInfo.Biomes.length; biomeIDx++) {
    let str = "";
    str += GameInfo.Biomes[biomeIDx].Name + " ( " + biomeIDx + " )  Count: " + biomes[biomeIDx];
    console.log(str);
  }
}
function getFeatureTypeIndex(name) {
  const def = GameInfo.Features.lookup(name);
  if (def) {
    return def.$index;
  }
  return -1;
}
function dumpFeatures(iWidth, iHeight) {
  console.log("Feature placement");
  const displayTypes = [
    { index: getFeatureTypeIndex("FEATURE_SAGEBRUSH_STEPPE"), ch: "P" },
    { index: getFeatureTypeIndex("FEATURE_OASIS"), ch: "O" },
    { index: getFeatureTypeIndex("FEATURE_DESERT_FLOODPLAIN_MINOR"), ch: "d" },
    { index: getFeatureTypeIndex("FEATURE_DESERT_FLOODPLAIN_NAVIGABLE"), ch: "d" },
    { index: getFeatureTypeIndex("FEATURE_FOREST"), ch: "F" },
    { index: getFeatureTypeIndex("FEATURE_MARSH"), ch: "M" },
    { index: getFeatureTypeIndex("FEATURE_GRASSLAND_FLOODPLAIN_MINOR"), ch: "g" },
    { index: getFeatureTypeIndex("FEATURE_GRASSLAND_FLOODPLAIN_NAVIGABLE"), ch: "g" },
    { index: getFeatureTypeIndex("FEATURE_REEF"), ch: "E" },
    { index: getFeatureTypeIndex("FEATURE_COLD_REEF"), ch: "E" },
    { index: getFeatureTypeIndex("FEATURE_ICE"), ch: "I" },
    { index: getFeatureTypeIndex("FEATURE_SAVANNA_WOODLAND"), ch: "T" },
    { index: getFeatureTypeIndex("FEATURE_WATERING_HOLE"), ch: "W" },
    { index: getFeatureTypeIndex("FEATURE_PLAINS_FLOODPLAIN_MINOR"), ch: "p" },
    { index: getFeatureTypeIndex("FEATURE_PLAINS_FLOODPLAIN_NAVIGABLE"), ch: "p" },
    { index: getFeatureTypeIndex("FEATURE_RAINFOREST"), ch: "R" },
    { index: getFeatureTypeIndex("FEATURE_MANGROVE"), ch: "G" },
    { index: getFeatureTypeIndex("FEATURE_TROPICAL_FLOODPLAIN_MINOR"), ch: "t" },
    { index: getFeatureTypeIndex("FEATURE_TROPICAL_FLOODPLAIN_NAVIGABLE"), ch: "t" },
    { index: getFeatureTypeIndex("FEATURE_TAIGA"), ch: "T" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_BOG"), ch: "B" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_FLOODPLAIN_MINOR"), ch: "u" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_FLOODPLAIN_NAVIGABLE"), ch: "u" },
    { index: getFeatureTypeIndex("FEATURE_VOLCANO"), ch: "%" },
    // Wonders
    { index: getFeatureTypeIndex("FEATURE_VALLEY_OF_FLOWERS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_BARRIER_REEF"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_BERMUDA_TRIANGLE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_REDWOOD_FOREST"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_GRAND_CANYON"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_GULLFOSS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_IGUAZU_FALLS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_KILIMANJARO"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_ZHANGJIAJIE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_THERA"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_TORRES_DEL_PAINE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_ULURU"), ch: "@" }
  ];
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let featureString = GameplayMap.isWater(iX, iY) == false ? "." : " ";
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (feature != FeatureTypes.NO_FEATURE) {
        for (const entry of displayTypes) {
          if (entry.index == feature) {
            featureString = entry.ch;
            break;
          }
        }
      }
      str += featureString + " ";
    }
    console.log(str);
  }
}
function dumpResources(iWidth, iHeight) {
  const resources = new Array(GameInfo.Resources.length);
  for (var resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resources[resourceIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const resource = GameplayMap.getResourceType(iX, iY);
      let resourcestring = " ";
      if (resource != ResourceTypes.NO_RESOURCE && typeof resource == "number") {
        resourcestring = resource.toString();
        resources[resource]++;
      } else {
        if (GameplayMap.isWater(iX, iY) == false) {
          resourcestring = "*";
        }
      }
      str += resourcestring + " ";
    }
    console.log(str);
  }
  let totalCount = 0;
  for (var resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    let str = "";
    str += GameInfo.Resources[resourceIdx].Name + " ( " + resourceIdx + " )  Count: " + resources[resourceIdx];
    totalCount += resources[resourceIdx];
    console.log(str);
  }
  console.log("Total resources on map after generation: " + totalCount);
}
function dumpNoisePredicate(iWidth, iHeight, noise, pred) {
  console.log("NOISE MAP (Predicate)");
  if (!pred) {
    console.log("dumpNoiseInterp error: no predicate provided");
    return;
  }
  if (noise.length != iWidth * iHeight) {
    console.log("dumpNoiseInterp error: noise map does not match map width*height");
    return;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      str += pred(noise[index]);
    }
    console.log(str);
  }
}

export { dumpBiomes, dumpContinents, dumpElevation, dumpFeatures, dumpNoisePredicate, dumpRainfall, dumpResources, dumpStartSectors, dumpTerrain };
//# sourceMappingURL=map-debug-helpers.js.map
</file>

<file path="mod/maps/base-standard/maps/map-globals.js">
const g_MountainTerrain = GameInfo.Terrains.find(
  (t) => t.TerrainType == "TERRAIN_MOUNTAIN"
).$index;
const g_HillTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_HILL").$index;
const g_FlatTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_FLAT").$index;
const g_CoastTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_COAST").$index;
const g_OceanTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_OCEAN").$index;
const g_NavigableRiverTerrain = GameInfo.Terrains.find(
  (t) => t.TerrainType == "TERRAIN_NAVIGABLE_RIVER"
).$index;
const g_TundraBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TUNDRA").$index;
const g_GrasslandBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_GRASSLAND").$index;
const g_PlainsBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_PLAINS").$index;
const g_TropicalBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TROPICAL").$index;
const g_DesertBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_DESERT").$index;
const g_MarineBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_MARINE").$index;
const g_VolcanoFeature = GameInfo.Features.find((t) => t.FeatureType == "FEATURE_VOLCANO").$index;
let temp;
let g_GrasslandLatitude = 0;
let g_PlainsLatitude = 0;
let g_DesertLatitude = 0;
let g_TropicalLatitude = 0;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_GRASSLAND").MaxLatitude;
if (temp) g_GrasslandLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_PLAINS").MaxLatitude;
if (temp) g_PlainsLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_DESERT").MaxLatitude;
if (temp) g_DesertLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TROPICAL").MaxLatitude;
if (temp) g_TropicalLatitude = temp;
const g_LandmassFractal = 0;
const g_MountainFractal = 1;
const g_HillFractal = 2;
const g_PolarWaterRows = 2;
const g_OceanWaterColumns = 4;
const g_FractalWeight = 0.8;
const g_WaterPercent = 20;
const g_IgnoreStartSectorPctFromCtr = 93;
const g_StartSectorWeight = 0.5;
const g_CenterWeight = 0.7;
const g_CenterExponent = 1.5;
const g_Cutoff = 2;
const g_AvoidSeamOffset = 2;
const g_IslandWidth = 5;
const g_StandardRainfall = 100;
const g_MountainTopIncrease = 100;
const g_RainShadowDrop = -80;
const g_RainShadowIncreasePerHex = 10;
const g_RequiredBufferBetweenMajorStarts = 6;
const g_DesiredBufferBetweenMajorStarts = 12;
const g_RequiredDistanceFromMajorForDiscoveries = 3;

export { g_AvoidSeamOffset, g_CenterExponent, g_CenterWeight, g_CoastTerrain, g_Cutoff, g_DesertBiome, g_DesertLatitude, g_DesiredBufferBetweenMajorStarts, g_FlatTerrain, g_FractalWeight, g_GrasslandBiome, g_GrasslandLatitude, g_HillFractal, g_HillTerrain, g_IgnoreStartSectorPctFromCtr, g_IslandWidth, g_LandmassFractal, g_MarineBiome, g_MountainFractal, g_MountainTerrain, g_MountainTopIncrease, g_NavigableRiverTerrain, g_OceanTerrain, g_OceanWaterColumns, g_PlainsBiome, g_PlainsLatitude, g_PolarWaterRows, g_RainShadowDrop, g_RainShadowIncreasePerHex, g_RequiredBufferBetweenMajorStarts, g_RequiredDistanceFromMajorForDiscoveries, g_StandardRainfall, g_StartSectorWeight, g_TropicalBiome, g_TropicalLatitude, g_TundraBiome, g_VolcanoFeature, g_WaterPercent };
//# sourceMappingURL=map-globals.js.map
</file>

<file path="mod/maps/base-standard/maps/map-utilities.js">
import { g_LandmassFractal, g_CenterExponent, g_IgnoreStartSectorPctFromCtr, g_FlatTerrain, g_OceanTerrain, g_CoastTerrain } from './map-globals.js';

const EAST_LAND_MASS_ID = 0;
const WEST_LAND_MASS_ID = 1;
const AVAILABLE_ON_ALL_LANDMASSES_ID = 2;
function needHumanNearEquator() {
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  let iPlayerCount = 0;
  if (mapInfo) iPlayerCount = mapInfo.PlayersLandmass1 + mapInfo.PlayersLandmass2;
  for (let iPlay = 0; iPlay < iPlayerCount; iPlay++) {
    if (Players.getEverAlive()[iPlay] && Players.getEverAlive()[iPlay].isHuman) {
      const uiCivType = Players.getEverAlive()[iPlay].civilizationType;
      const uiLeaderType = Players.getEverAlive()[iPlay].leaderType;
      for (let startBiomeIdx = 0; startBiomeIdx < GameInfo.StartBiasBiomes.length; startBiomeIdx++) {
        const civString = GameInfo.StartBiasBiomes[startBiomeIdx]?.CivilizationType;
        const ldrString = GameInfo.StartBiasBiomes[startBiomeIdx]?.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null && GameInfo.Civilizations.lookup(civString) != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null && GameInfo.Leaders.lookup(ldrString) != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          const szBiome = GameInfo.StartBiasBiomes[startBiomeIdx].BiomeType;
          console.log(szBiome);
          if (szBiome == "BIOME_TROPICAL") {
            console.log("Human player needing a Tropical start.");
            return true;
          }
        }
      }
    }
  }
  return false;
}
function getMinimumResourcePlacementModifier() {
  const mapSizeInfo = GameInfo.Maps.lookup(GameplayMap.getMapSize());
  if (mapSizeInfo == null) return;
  let iMapMinimumModifer = 0;
  const mapType = Configuration.getMapValue("Name");
  for (const option of GameInfo.MapResourceMinimumAmountModifier) {
    if (option.MapType === mapType && option.MapSizeType == mapSizeInfo.MapSizeType) {
      iMapMinimumModifer = option.Amount;
      break;
    }
  }
  if (iMapMinimumModifer == 0) {
    for (const option of GameInfo.MapResourceMinimumAmountModifier) {
      if (option.MapType === "DEFAULT" && option.MapSizeType == mapSizeInfo.MapSizeType) {
        iMapMinimumModifer = option.Amount;
        console.log(
          "Using default map size for resuource placemtn, please update the table for this map type. Modifer is " + iMapMinimumModifer + " by default."
        );
        break;
      }
    }
  }
  return iMapMinimumModifer;
}
function getDistanceFromContinentCenter(iX, iY, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol, iEastContinentRightCol) {
  let iContinentLeftEdge = iWestContinentLeftCol;
  let iContinentRightEdge = iWestContinentRightCol;
  if (iX >= iEastContinentLeftCol) {
    iContinentLeftEdge = iEastContinentLeftCol;
    iContinentRightEdge = iEastContinentRightCol;
  }
  const iContinentHeight = iContinentTopRow - iContinentBottomRow;
  const iContinentWidth = iContinentRightEdge - iContinentLeftEdge;
  const iContinentCenterX = iContinentLeftEdge + iContinentWidth / 2;
  const iContinentCenterY = iContinentBottomRow + iContinentHeight / 2;
  const iDistance = GameplayMap.getPlotDistance(iX, iY, iContinentCenterX, iContinentCenterY);
  return iDistance;
}
function getMaxDistanceFromContinentCenter(iX, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol, iEastContinentRightCol) {
  let iContinentLeftEdge = iWestContinentLeftCol;
  let iContinentRightEdge = iWestContinentRightCol;
  if (iX >= iEastContinentLeftCol) {
    iContinentLeftEdge = iEastContinentLeftCol;
    iContinentRightEdge = iEastContinentRightCol;
  }
  const iContinentHeight = iContinentTopRow - iContinentBottomRow;
  const iContinentWidth = iContinentRightEdge - iContinentLeftEdge;
  const iContinentCenterX = iContinentLeftEdge + iContinentWidth / 2;
  const iContinentCenterY = iContinentBottomRow + iContinentHeight / 2;
  const iDistance = GameplayMap.getPlotDistance(
    iContinentLeftEdge,
    iContinentBottomRow,
    iContinentCenterX,
    iContinentCenterY
  );
  return iDistance;
}
function getSector(iX, iY, iRows, iCols, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol) {
  let iContinentBase = 0;
  if (iX >= iEastContinentLeftCol) {
    iContinentBase += iRows * iCols;
    iX = iX - iEastContinentLeftCol + iWestContinentLeftCol;
  }
  const iXSector = Math.floor(
    (iX - iWestContinentLeftCol) / ((iWestContinentRightCol - iWestContinentLeftCol) / iCols)
  );
  const iYSector = Math.floor(
    (iY - iContinentBottomRow) / ((iContinentTopRow - iContinentBottomRow) / iRows)
  );
  const iSector = iYSector * iCols + iXSector;
  const iReturnValue = iContinentBase + iSector;
  return iReturnValue;
}
function getSectorRegion(iSector, iRows, iCols, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol) {
  const region = { west: 0, east: 0, south: 0, north: 0, continent: 0 };
  if (iCols == 0) return region;
  const bIsEastContinent = iSector >= iRows * iCols;
  let iSectorAdjust = 0;
  if (bIsEastContinent) {
    iSectorAdjust = iRows * iCols;
  }
  const row = Math.floor((iSector - iSectorAdjust) / iCols);
  const col = Math.floor(iSector - iSectorAdjust - row * iCols);
  const iSectorWidth = (iWestContinentRightCol - iWestContinentLeftCol) / iCols;
  const iSectorHeight = (iContinentTopRow - iContinentBottomRow) / iRows;
  let iXAdjust = iWestContinentLeftCol;
  if (bIsEastContinent) {
    iXAdjust = iEastContinentLeftCol;
  }
  region.west = Math.floor(iXAdjust + iSectorWidth * col);
  region.east = Math.floor(iXAdjust + iSectorWidth * (col + 1));
  region.south = Math.floor(iContinentBottomRow + iSectorHeight * row);
  region.north = Math.floor(iContinentBottomRow + iSectorHeight * (row + 1));
  region.continent = -1;
  return region;
}
function getHeightAdjustingForStartSector(iX, iY, iWaterHeight, iFractalWeight, iCenterWeight, iStartSectorWeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  let iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
  iPlotHeight *= iFractalWeight;
  const iDistanceFromCenter = getDistanceFromContinentCenter(
    iX,
    iY,
    continent1.south,
    continent1.north,
    continent1.west,
    continent1.east,
    continent2.west,
    continent2.east
  );
  const iMaxDistanceFromCenter = getMaxDistanceFromContinentCenter(
    iX,
    continent1.south,
    continent1.north,
    continent1.west,
    continent1.east,
    continent2.west,
    continent2.east
  );
  const iPercentFromCenter = Math.min(100 * iDistanceFromCenter / iMaxDistanceFromCenter, 100);
  iPlotHeight += iCenterWeight * Math.pow(iWaterHeight * (100 - iPercentFromCenter) / 100, g_CenterExponent);
  if (iPercentFromCenter < g_IgnoreStartSectorPctFromCtr) {
    const iSector = getSector(
      iX,
      iY,
      iStartSectorRows,
      iStartSectorCols,
      continent1.south,
      continent1.north,
      continent1.west,
      continent1.east,
      continent2.west
    );
    if (startSectors[iSector]) {
      const sectorCenterX = (continent1.west + continent1.east) / 2;
      const sectorCenterY = (continent1.south + continent1.north) / 2;
      const distanceToSectorCenter = Math.sqrt((iX - sectorCenterX) ** 2 + (iY - sectorCenterY) ** 2);
      const maxSectorRadius = Math.min(continent1.east - continent1.west, continent1.north - continent1.south) / 3;
      const sectorBoostFactor = 1 - Math.pow(Math.min(distanceToSectorCenter / maxSectorRadius, 1), 1.5);
      iPlotHeight += iStartSectorWeight * iWaterHeight * sectorBoostFactor;
      if (iPercentFromCenter < g_IgnoreStartSectorPctFromCtr * 2 / 3) {
        iPlotHeight += iStartSectorWeight * iWaterHeight;
      }
    }
    if (iStartSectorCols > 2 && iStartSectorRows > 2) {
      let iTestSector = iSector;
      if (iTestSector >= iStartSectorRows * iStartSectorCols) {
        iTestSector = iSector - iStartSectorRows * iStartSectorCols;
      }
      if (iTestSector % iStartSectorCols > 0 && iTestSector % iStartSectorCols < iStartSectorCols - 1) {
        if (iTestSector >= iStartSectorCols && iTestSector < iStartSectorRows * iStartSectorCols - iStartSectorCols) {
          iPlotHeight += iCenterWeight * iWaterHeight;
        }
      }
    }
  }
  return iPlotHeight;
}
function createIslands(iWidth, iHeight, continent1, continent2, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iBuffer = Math.floor(iWidth / 24);
  const terrain = g_FlatTerrain;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      if (iY >= continent1.south + iRandom && iY <= continent1.north - iRandom && (iX >= continent1.west && iX <= continent1.east || iX >= continent2.west && iX <= continent2.east)) {
        const iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
        if (iPlotHeight > iWaterHeight) {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
          TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
        }
      }
    }
  }
}
function applyCoastalErosion(continent, strength, falloff, minRadiusFactor, verticalOnly) {
  console.log(
    `Applying Coastal Erosion with strength ${strength} to continent at (${continent.west}, ${continent.east})`
  );
  const centerX = (continent.west + continent.east) / 2;
  const centerY = (continent.south + continent.north) / 2;
  const maxRadiusY = (continent.north - continent.south) / 2;
  const maxRadius = verticalOnly ? maxRadiusY : Math.min(continent.east - continent.west, continent.north - continent.south) / 2;
  const minRadius = maxRadius * minRadiusFactor;
  const erosionTiles = [];
  for (let iY = continent.south; iY <= continent.north; iY++) {
    for (let iX = continent.west; iX <= continent.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) continue;
      let distance = 0;
      if (verticalOnly) {
        distance = Math.abs(iY - (continent.south + continent.north) / 2);
      } else {
        distance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);
      }
      if (distance <= minRadius) continue;
      const erosionFactor = distance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;
      const erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;
      const randomChance = TerrainBuilder.getRandomNumber(100, "Coastal Erosion") / 100;
      if (randomChance < erosionThreshold) {
        erosionTiles.push({ x: iX, y: iY });
      }
    }
  }
  const expandedErosion = /* @__PURE__ */ new Set();
  function addErosionTile(x, y) {
    const key = `${x},${y}`;
    if (!expandedErosion.has(key)) {
      expandedErosion.add(key);
      TerrainBuilder.setTerrainType(x, y, g_OceanTerrain);
      TerrainBuilder.setPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
    }
  }
  for (const tile of erosionTiles) {
    addErosionTile(tile.x, tile.y);
    const expansionChance = TerrainBuilder.getRandomNumber(100, "Erosion Expansion") / 100;
    if (expansionChance < 0.7) {
      const neighbors = [
        { x: tile.x + 1, y: tile.y },
        { x: tile.x - 1, y: tile.y },
        { x: tile.x, y: tile.y + 1 },
        { x: tile.x, y: tile.y - 1 }
      ];
      for (const neighbor of neighbors) {
        if (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== g_OceanTerrain) {
          addErosionTile(neighbor.x, neighbor.y);
        }
      }
    }
  }
  console.log("Coastal Erosion Applied.");
}
function applyCoastalErosionAdjustingForStartSectors(continent1, continent2, strength, falloff, minRadiusFactor, iStartSectorRows, iStartSectorCols, startSectors) {
  console.log(
    `Applying Coastal Erosion Ajdusting for Start Sectors with strength ${strength} to continent at (${continent1.west}, ${continent1.east})`
  );
  const centerX = (continent1.west + continent1.east) / 2;
  const centerY = (continent1.south + continent1.north) / 2;
  const maxRadius = Math.min(continent1.east - continent1.west, continent1.north - continent1.south) / 2;
  const minRadius = maxRadius * minRadiusFactor;
  const erosionTiles = [];
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) continue;
      let distance = 0;
      distance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);
      if (distance <= minRadius) continue;
      const erosionFactor = distance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;
      let erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;
      const randomChance = TerrainBuilder.getRandomNumber(100, "Coastal Erosion") / 100;
      const iSector = getSector(
        iX,
        iY,
        iStartSectorRows,
        iStartSectorCols,
        continent1.south,
        continent1.north,
        continent1.west,
        continent1.east,
        continent2.west
      );
      if (startSectors[iSector]) {
        if (!isNearContinentCorner(iX, iY, continent1, 0.1)) {
          erosionThreshold = erosionThreshold / 10;
        }
      }
      if (randomChance < erosionThreshold) {
        erosionTiles.push({ x: iX, y: iY });
      }
    }
  }
  function isNearContinentCorner(iX, iY, continent, bufferScale) {
    const continentWidth = continent.east - continent.west;
    const continentHeight = continent.north - continent.south;
    const bufferX = Math.max(2, Math.min(Math.floor(continentWidth * bufferScale), 10));
    const bufferY = Math.max(2, Math.min(Math.floor(continentHeight * bufferScale), 10));
    const topLeft = { x: continent.west, y: continent.north };
    const topRight = { x: continent.east, y: continent.north };
    const bottomLeft = { x: continent.west, y: continent.south };
    const bottomRight = { x: continent.east, y: continent.south };
    function isNearCorner(cornerX, cornerY) {
      return Math.abs(iX - cornerX) <= bufferX && Math.abs(iY - cornerY) <= bufferY;
    }
    return isNearCorner(topLeft.x, topLeft.y) || isNearCorner(topRight.x, topRight.y) || isNearCorner(bottomLeft.x, bottomLeft.y) || isNearCorner(bottomRight.x, bottomRight.y);
  }
  const expandedErosion = /* @__PURE__ */ new Set();
  function addErosionTile(x, y) {
    const key = `${x},${y}`;
    if (!expandedErosion.has(key)) {
      expandedErosion.add(key);
      TerrainBuilder.setTerrainType(x, y, g_OceanTerrain);
      TerrainBuilder.setPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
    }
  }
  for (const tile of erosionTiles) {
    addErosionTile(tile.x, tile.y);
    const expansionChance = TerrainBuilder.getRandomNumber(100, "Erosion Expansion") / 100;
    if (expansionChance < 0.7) {
      const neighbors = [
        { x: tile.x + 1, y: tile.y },
        { x: tile.x - 1, y: tile.y },
        { x: tile.x, y: tile.y + 1 },
        { x: tile.x, y: tile.y - 1 }
      ];
      for (const neighbor of neighbors) {
        if (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== g_OceanTerrain) {
          addErosionTile(neighbor.x, neighbor.y);
        }
      }
    }
  }
  console.log("Coastal Erosion Applied.");
}
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = TerrainBuilder.getRandomNumber(currentIndex, "Array Shuffle");
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}
function getContinentEdgeHeightBump(iX, iY) {
  if (GameplayMap.findSecondContinent(iX, iY, 1)) {
    return 100;
  } else if (GameplayMap.findSecondContinent(iX, iY, 2)) {
    return 40;
  } else if (GameplayMap.findSecondContinent(iX, iY, 3)) {
    return 20;
  }
  return 0;
}
function getDistanceToClosestStart(iX, iY, numFoundEarlier, startPositions) {
  let minDistance = 32768;
  for (let iStart = 0; iStart < numFoundEarlier; iStart++) {
    const startPlotIndex = startPositions[iStart];
    const iStartX = startPlotIndex % GameplayMap.getGridWidth();
    const iStartY = Math.floor(startPlotIndex / GameplayMap.getGridWidth());
    const distance = GameplayMap.getPlotDistance(iX, iY, iStartX, iStartY);
    if (distance < minDistance) {
      minDistance = distance;
    }
  }
  return minDistance;
}
function addLandmassPlotTags(iX, iY, iEastContinentLeftCol) {
  TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_LANDMASS);
  if (iX >= iEastContinentLeftCol) {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_LANDMASS);
  } else {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_LANDMASS);
  }
}
function addWaterPlotTags(iX, iY, iEastContinentLeftCol) {
  TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
  if (iX >= iEastContinentLeftCol - 1) {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
  } else {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
  }
}
function adjustOceanPlotTags(bWestSide) {
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (bWestSide) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
        }
      }
    }
  }
}
function adjustLakePlotTags(region, bWestSide) {
  for (let iY = region.south; iY <= region.north; iY++) {
    for (let iX = region.west; iX <= region.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        TerrainBuilder.addPlotTag(
          iX,
          iY,
          bWestSide ? PlotTags.PLOT_TAG_WEST_WATER : PlotTags.PLOT_TAG_EAST_WATER
        );
      }
    }
  }
}
function isAdjacentToNaturalWonder(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    if (GameplayMap.isNaturalWonder(iAdjacentX, iAdjacentY)) {
      return true;
    }
  }
  return false;
}
function isCliff(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    if (GameplayMap.isCliffCrossing(iX, iY, iDirection) == false) {
      return true;
    }
  }
  return false;
}
function isOceanAccess(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentIndex = GameplayMap.getIndexFromXY(iAdjacentX, iAdjacentY);
    if (GameplayMap.getRiverType(iAdjacentX, iAdjacentY) == RiverTypes.RIVER_NAVIGABLE && MapRivers.isRiverConnectedToOcean(iAdjacentIndex)) {
      return true;
    }
    if (GameplayMap.getAreaId(iAdjacentX, iAdjacentY) > -1 && GameplayMap.getAreaIsWater(iAdjacentX, iAdjacentY) && AreaBuilder.isAreaConnectedToOcean(GameplayMap.getAreaId(iAdjacentX, iAdjacentY))) {
      return true;
    }
  }
  return false;
}
function removeRuralDistrict(iX, iY) {
  const districtID = MapCities.getDistrict(iX, iY);
  if (districtID != null) {
    const cityID = MapCities.getCity(iX, iY);
    if (cityID != null) {
      const city = Cities.get(cityID);
      if (city != null) {
        if (city.location.x != iX || city.location.y != iY) {
          console.log("Removed district at (" + iX + ", " + iY + ")");
          city.Districts?.removeDistrict(districtID);
        }
      }
    }
  }
}
function placeRuralDistrict(iX, iY) {
  const cityID = MapCities.getCity(iX, iY);
  if (cityID != null) {
    const city = Cities.get(cityID);
    if (city != null) {
      if (city.location.x != iX || city.location.y != iY) {
        console.log("Placed district at (" + iX + ", " + iY + ")");
        city.Growth?.claimPlot({ x: iX, y: iY });
      }
    }
  }
}
function replaceIslandResources(iWidth, iHeight, zResourceClassType) {
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resources = [];
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    const resourceInfo = GameInfo.Resources.lookup(resourceIdx);
    if (resourceInfo && resourceInfo.Tradeable) {
      if (GameInfo.Resources.lookup(resourceIdx)?.ResourceClassType == zResourceClassType) {
        resources.push(resourceIdx);
      }
      resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
    }
    resourceRunningWeight[resourceIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {
        const resourceAtLocation = GameplayMap.getResourceType(iX, iY);
        if (resourceAtLocation != ResourceTypes.NO_RESOURCE) {
          if (resources.length > 0) {
            let resourceChosen = ResourceTypes.NO_RESOURCE;
            let resourceChosenIndex = 0;
            for (let iI = 0; iI < resources.length; iI++) {
              if (resources[iI] != resourceAtLocation) {
                if (ResourceBuilder.canHaveResource(iX, iY, resources[iI], true)) {
                  if (resourceChosen == ResourceTypes.NO_RESOURCE) {
                    resourceChosen = resources[iI];
                    resourceChosenIndex = resources[iI];
                  } else {
                    if (resourceRunningWeight[resources[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                      resourceChosen = resources[iI];
                      resourceChosenIndex = resources[iI];
                    } else if (resourceRunningWeight[resources[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                      const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                      if (iRoll >= 1) {
                        resourceChosen = resources[iI];
                        resourceChosenIndex = resources[iI];
                      }
                    }
                  }
                }
              }
            }
            if (resourceChosen != ResourceTypes.NO_RESOURCE) {
              const iResourcePlotIndex = GameplayMap.getIndexFromXY(iX, iY);
              if (iResourcePlotIndex != -1) {
                removeRuralDistrict(iX, iY);
                ResourceBuilder.setResourceType(iX, iY, ResourceTypes.NO_RESOURCE);
                ResourceBuilder.setResourceType(iX, iY, resourceChosen);
                placeRuralDistrict(iX, iY);
                resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
                const oldName = GameInfo.Resources.lookup(resourceAtLocation)?.Name;
                const name = GameInfo.Resources.lookup(resourceChosenIndex)?.Name;
                console.log("Replaced " + Locale.compose(oldName) + " at (" + iX + ", " + iY + ")");
                console.log("Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")");
              } else {
                console.log("Resource Index Failure");
              }
            } else {
              console.log("No valid resource replacement");
            }
          }
        }
      }
    }
  }
}
function isAdjacentToLand(iX, iY) {
  if (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {
    return true;
  } else {
    for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
      const iIndex = GameplayMap.getIndexFromXY(iX, iY);
      const iLocation = GameplayMap.getLocationFromIndex(iIndex);
      const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
      const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
      if (GameplayMap.hasPlotTag(iAdjacentX, iAdjacentY, PlotTags.PLOT_TAG_ISLAND)) {
        return true;
      }
    }
  }
  return false;
}
function shiftTerrain(iWidth, iHeight) {
  let shift_x = 0;
  let shift_y = 0;
  shift_x = determineXShift(iWidth, iHeight);
  shift_y = determineYShift(iWidth, iHeight);
  console.log("shift_x: " + shift_x);
  console.log("shift_y: ", shift_y);
  shiftPlotTypesBy(iWidth, iHeight, shift_x, shift_y);
}
function shiftPlotTypesBy(iWidth, iHeight, xshift, yshift) {
  if (xshift > 0 || yshift > 0) {
    const iTempTerrainArray = Array(iWidth).fill(g_OceanTerrain).map((_) => Array(iHeight));
    for (let iX = 0; iX < iWidth; iX++) {
      for (let iY = 0; iY < iHeight; iY++) {
        iTempTerrainArray[iX][iY] = GameplayMap.getTerrainType(iX, iY);
      }
    }
    for (let iDestX = 0; iDestX < iWidth; iDestX++) {
      for (let iDestY = 0; iDestY < iHeight; iDestY++) {
        const iSourceX = (iDestX + xshift) % iWidth;
        const iSourceY = (iDestY + yshift) % iHeight;
        const iTerrain = iTempTerrainArray[iSourceX][iSourceY];
        TerrainBuilder.setTerrainType(iDestX, iDestY, iTerrain);
      }
    }
  }
}
function determineXShift(iWidth, iHeight) {
  const waterTotals = [];
  for (let iX = 0; iX < iWidth; iX++) {
    let colWaterCount = 0;
    for (let iY = 0; iY < iHeight; iY++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain) {
        colWaterCount = colWaterCount + 1;
      }
    }
    waterTotals.push(colWaterCount);
  }
  const columnGroups = [];
  const groupRadius = Math.floor(iWidth / 10);
  for (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {
    let currentGroupTotal = 0;
    for (let currentCol = columnIndex - groupRadius; currentCol <= columnIndex + groupRadius; currentCol++) {
      const currentIdx = (currentCol + iWidth) % iWidth;
      currentGroupTotal = currentGroupTotal + waterTotals[currentIdx];
    }
    columnGroups.push(currentGroupTotal);
  }
  let bestValue = 0;
  let bestGroup = 0;
  for (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {
    if (columnGroups[columnIndex] > bestValue) {
      bestValue = columnGroups[columnIndex];
      bestGroup = columnIndex;
    }
  }
  const x_shift = bestGroup;
  return x_shift;
}
function determineYShift(iWidth, iHeight) {
  const waterTotals = [];
  for (let iY = 0; iY < iHeight; iY++) {
    let rowWaterCount = 0;
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain) {
        rowWaterCount = rowWaterCount + 1;
      }
    }
    waterTotals.push(rowWaterCount);
  }
  const rowGroups = [];
  const groupRadius = Math.floor(iHeight / 15);
  for (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {
    let currentGroupTotal = 0;
    for (let currentRow = rowIndex - groupRadius; currentRow <= rowIndex + groupRadius; currentRow++) {
      const currentIdx = (currentRow + iHeight) % iHeight;
      currentGroupTotal = currentGroupTotal + waterTotals[currentIdx];
    }
    rowGroups.push(currentGroupTotal);
  }
  let bestValue = 0;
  let bestGroup = 0;
  for (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {
    if (rowGroups[rowIndex] > bestValue) {
      bestValue = rowGroups[rowIndex];
      bestGroup = rowIndex;
    }
  }
  const y_shift = bestGroup;
  return y_shift;
}
function createOrganicLandmasses(iWidth, iHeight, continent1, continent2, iFractalGrain, iWaterPercent, iLargestContinentPercent) {
  let bLargeEnoughFound = false;
  while (!bLargeEnoughFound) {
    let iFlags = 0;
    iFlags = 1;
    iFlags += 2;
    FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iFractalGrain, iFlags);
    const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iWaterPercent);
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        let terrain = g_OceanTerrain;
        const iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
        if (iPlotHeight >= iWaterHeight) {
          terrain = g_FlatTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
    shiftTerrain(iWidth, iHeight);
    let iTilesChoppedInGutter = 0;
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        if (GameplayMap.getTerrainType(iX, iY) != g_OceanTerrain) {
          if (iY < continent1.south || iY >= continent1.north) {
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iY == continent1.south || iY == continent1.north - 1) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
          if (iX < continent1.west || iX > continent2.east - 1) {
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iX == continent1.west || iX == continent2.east - 1) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
          if (iX > continent1.east - 1 && iX < continent2.west) {
            iTilesChoppedInGutter = iTilesChoppedInGutter + 1;
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iX == continent1.east - 1 || iX == continent2.west) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
        }
      }
    }
    console.log("Tiles in Center Gutter:" + iTilesChoppedInGutter);
    const iMaxTilesToChop = iHeight * (continent2.west - continent1.east) / 2;
    console.log("Max Tiles to Chop: " + iMaxTilesToChop);
    if (iTilesChoppedInGutter >= iMaxTilesToChop) {
      console.log("Fail. Too many tiles lost in center gutter");
    } else {
      AreaBuilder.recalculateAreas();
      const iAreaID = AreaBuilder.findBiggestArea(false);
      const iPlotCount = AreaBuilder.getPlotCount(iAreaID);
      console.log("Plots in Largest Landmass:" + iPlotCount);
      const iPlotsNeeded = iWidth * iHeight * iLargestContinentPercent / 100;
      console.log("Plots Needed:" + iPlotsNeeded);
      if (iPlotCount >= iPlotsNeeded) {
        console.log("Useable continent found");
        bLargeEnoughFound = true;
      }
    }
  }
}
function addPlotTags(iHeight, iWidth, iEastContinentLeftCol) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        addLandmassPlotTags(iX, iY, iEastContinentLeftCol);
      } else {
        addWaterPlotTags(iX, iY, iEastContinentLeftCol);
      }
    }
  }
}
function clearContinent(continent1) {
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = g_OceanTerrain;
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}

export { AVAILABLE_ON_ALL_LANDMASSES_ID, EAST_LAND_MASS_ID, WEST_LAND_MASS_ID, addLandmassPlotTags, addPlotTags, addWaterPlotTags, adjustLakePlotTags, adjustOceanPlotTags, applyCoastalErosion, applyCoastalErosionAdjustingForStartSectors, clearContinent, createIslands, createOrganicLandmasses, determineXShift, determineYShift, getContinentEdgeHeightBump, getDistanceFromContinentCenter, getDistanceToClosestStart, getHeightAdjustingForStartSector, getMaxDistanceFromContinentCenter, getMinimumResourcePlacementModifier, getSector, getSectorRegion, isAdjacentToLand, isAdjacentToNaturalWonder, isCliff, isOceanAccess, needHumanNearEquator, placeRuralDistrict, removeRuralDistrict, replaceIslandResources, shiftPlotTypesBy, shiftTerrain, shuffle };
//# sourceMappingURL=map-utilities.js.map
</file>

<file path="mod/maps/base-standard/maps/natural-wonder-generator.js">
import { shuffle } from './map-utilities.js';
import './map-globals.js';

function addNaturalWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive = false, requestedWonders = []) {
  if (GameInfo.Feature_NaturalWonders.length < iNumNaturalWonders) {
    iNumNaturalWonders = GameInfo.Feature_NaturalWonders.length;
  }
  console.log("Generating " + iNumNaturalWonders + " Natural Wonders");
  if (wonderEventActive) {
    console.log("Race to wonders event registered");
  }
  placeWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive, requestedWonders);
}
function placeWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive, requestedWonders) {
  let aPossibleWonders = [];
  let iPlacedWonders = 0;
  const requests = [];
  const configRequests = Configuration.getMapValue("RequestedNaturalWonders");
  if (configRequests) {
    for (const requested of configRequests) {
      if (typeof requested == "string") {
        requests.push(Database.makeHash(requested));
      } else if (typeof requested == "number") {
        requests.push(requested);
      }
    }
  }
  for (const nwDef of GameInfo.Feature_NaturalWonders) {
    if (requestedWonders.includes(nwDef.FeatureType)) {
      requests.push(nwDef.$hash);
    }
    aPossibleWonders.push(nwDef.$hash);
  }
  if (aPossibleWonders.length > 0) {
    aPossibleWonders = shuffle(aPossibleWonders);
    for (const requested of requests) {
      const index = aPossibleWonders.indexOf(requested);
      if (index >= 1) {
        aPossibleWonders.splice(index, 1);
        aPossibleWonders.unshift(requested);
      }
    }
    for (let iI = 0; iI < aPossibleWonders.length; iI++) {
      if (iPlacedWonders < iNumNaturalWonders) {
        const eFeature = aPossibleWonders[iI];
        const nwDef = GameInfo.Feature_NaturalWonders.lookup(eFeature);
        if (nwDef != null) {
          if (nwDef.PlaceFirst == true) {
            const aPossibleLocations = [];
            for (let iY = iHeight - 1; iY >= 0; iY--) {
              for (let iX = 0; iX < iWidth; iX++) {
                const iElevation = GameplayMap.getElevation(iX, iY);
                const featureParam = {
                  Feature: eFeature,
                  Direction: nwDef.Direction,
                  Elevation: iElevation
                };
                if (TerrainBuilder.canHaveFeatureParam(iX, iY, featureParam)) {
                  if (wonderEventActive) {
                    if (GameplayMap.getHemisphere(iX) != GameplayMap.getPrimaryHemisphere()) {
                      aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                    }
                  } else {
                    aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                  }
                }
              }
            }
            if (aPossibleLocations.length > 0) {
              const randomIndex = TerrainBuilder.getRandomNumber(
                aPossibleLocations.length,
                "Natural Wonder placement location"
              );
              const placementLocation = GameplayMap.getLocationFromIndex(
                aPossibleLocations[randomIndex]
              );
              const iElevation = GameplayMap.getElevation(placementLocation.x, placementLocation.y);
              const featureParam = {
                Feature: eFeature,
                Direction: nwDef.Direction,
                Elevation: iElevation
              };
              console.log("FeatureParam Elevation: " + featureParam.Elevation);
              TerrainBuilder.setFeatureType(placementLocation.x, placementLocation.y, featureParam);
              iPlacedWonders++;
              console.log(
                "Placed A Top Priority Natural Wonder " + nwDef.FeatureType + " At X:" + placementLocation.x + " Y:" + placementLocation.y + " out of " + aPossibleLocations.length + " possible locations."
              );
            } else {
              console.log("No valid location for " + nwDef.FeatureType);
            }
          }
        }
      }
    }
    for (let iI = 0; iI < aPossibleWonders.length; iI++) {
      if (iPlacedWonders < iNumNaturalWonders) {
        const eFeature = aPossibleWonders[iI];
        const nwDef = GameInfo.Feature_NaturalWonders.lookup(eFeature);
        if (nwDef != null && nwDef.PlaceFirst == false) {
          let iPlacementPercent = nwDef.PlacementPercentage;
          if (requests.indexOf(eFeature) != -1) {
            iPlacementPercent = 100;
            console.log(nwDef.FeatureType + " is requested to be placed.");
          }
          const iRoll = TerrainBuilder.getRandomNumber(100, "Random Natural Wonder Chance");
          if (iPlacementPercent > iRoll) {
            const aPossibleLocations = [];
            for (let iY = iHeight - 1; iY >= 0; iY--) {
              for (let iX = 0; iX < iWidth; iX++) {
                const iElevation = GameplayMap.getElevation(iX, iY);
                const featureParam = {
                  Feature: eFeature,
                  Direction: nwDef.Direction,
                  Elevation: iElevation
                };
                if (TerrainBuilder.canHaveFeatureParam(iX, iY, featureParam)) {
                  if (wonderEventActive) {
                    if (GameplayMap.getHemisphere(iX) != GameplayMap.getPrimaryHemisphere()) {
                      aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                    }
                  } else {
                    aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                  }
                }
              }
            }
            if (aPossibleLocations.length > 0) {
              const randomIndex = TerrainBuilder.getRandomNumber(
                aPossibleLocations.length,
                "Natural Wonder placement location"
              );
              const placementLocation = GameplayMap.getLocationFromIndex(
                aPossibleLocations[randomIndex]
              );
              const iElevation = GameplayMap.getElevation(placementLocation.x, placementLocation.y);
              const featureParam = {
                Feature: eFeature,
                Direction: nwDef.Direction,
                Elevation: iElevation
              };
              console.log("FeatureParam Elevation: " + featureParam.Elevation);
              TerrainBuilder.setFeatureType(placementLocation.x, placementLocation.y, featureParam);
              iPlacedWonders++;
              console.log(
                "Placed A Natural Wonder " + nwDef.FeatureType + " At X:" + placementLocation.x + " Y:" + placementLocation.y + " out of " + aPossibleLocations.length + " possible locations."
              );
            } else {
              console.log("No valid location for " + nwDef.FeatureType);
            }
          }
        }
      }
    }
  }
}

export { addNaturalWonders };
//# sourceMappingURL=natural-wonder-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/pangaea-plus.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignSingleContinentStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight, g_CoastTerrain } from './map-globals.js';
import { needHumanNearEquator, createIslands, applyCoastalErosionAdjustingForStartSectors, createOrganicLandmasses, addPlotTags, applyCoastalErosion, adjustOceanPlotTags, adjustLakePlotTags, replaceIslandResources, getHeightAdjustingForStartSector, addLandmassPlotTags, addWaterPlotTags, clearContinent } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script pangaea-plus.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iNumPlayers1 = mapInfo.PlayersLandmass1;
  const iNumPlayers2 = mapInfo.PlayersLandmass2;
  const bWestDominant = TerrainBuilder.getRandomNumber(2, "Choose Dominant Hemisphere") === 0;
  console.log(`Dominant Landmass: ${bWestDominant ? "West (80%)" : "East (80%)"}`);
  let westContinent;
  let westContinent2;
  let eastContinent;
  let eastContinent2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  if (bWestDominant) {
    westContinent2 = {
      west: g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.1),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    westContinent = {
      west: westContinent2.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.8) - g_AvoidSeamOffset,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent = {
      west: westContinent.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.9),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent2 = {
      west: eastContinent.east,
      east: iWidth - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
  } else {
    westContinent2 = {
      west: g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.1),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    westContinent = {
      west: westContinent2.east,
      east: Math.floor(iWidth * 0.2) - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent = {
      west: westContinent.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.8),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent2 = {
      west: eastContinent.east + g_AvoidSeamOffset * 2,
      east: iWidth - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
  }
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const ISLAND_COVERAGE_TARGET = 0.04;
  const totalTiles = iWidth * iHeight;
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced && totalTiles != 0) {
    console.log("Balanced Map");
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createPrimaryLandmass(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      bWestDominant,
      iOceanWaterColumns
    );
    if (bWestDominant) {
      createSecondaryLandmass(iWidth, iHeight, eastContinent, eastContinent2);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 4);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 5);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      applyCoastalErosionAdjustingForStartSectors(
        westContinent,
        eastContinent,
        0.1,
        1.5,
        0.8,
        iStartSectorRows,
        iStartSectorCols,
        startSectors
      );
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    } else {
      createSecondaryLandmass(iWidth, iHeight, westContinent, westContinent2);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 4);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 5);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      applyCoastalErosionAdjustingForStartSectors(
        eastContinent,
        westContinent,
        0.1,
        1.5,
        0.8,
        iStartSectorRows,
        iStartSectorCols,
        startSectors
      );
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    }
  } else if (totalTiles != 0) {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 30;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    if (bWestDominant) {
      createSecondaryLandmass(iWidth, iHeight, eastContinent, eastContinent2);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 4);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      applyCoastalErosion(westContinent, 0.15, 1.5, 0.8, false);
      applyCoastalErosion(eastContinent, 0.01, 1.5, 0.8, true);
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    } else {
      createSecondaryLandmass(iWidth, iHeight, westContinent, westContinent2);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 4);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      applyCoastalErosion(westContinent, 0.01, 1.5, 0.8, true);
      applyCoastalErosion(eastContinent, 0.15, 1.5, 0.8, false);
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    }
    applyCoastalErosion(westContinent2, 0.01, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.01, 1.5, 0.8, true);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  adjustOceanPlotTags(bWestDominant);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  adjustLakePlotTags(westContinent, true);
  adjustLakePlotTags(westContinent2, true);
  adjustLakePlotTags(eastContinent, false);
  adjustLakePlotTags(eastContinent2, false);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpStartSectors(startSectors);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  if (bWestDominant) {
    generateResources(iWidth, iHeight);
    startPositions = assignSingleContinentStartPositions(
      iNumPlayers1 + iNumPlayers2,
      westContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  } else {
    generateResources(iWidth, iHeight);
    startPositions = assignSingleContinentStartPositions(
      iNumPlayers1 + iNumPlayers2,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  }
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded pangaea-plus.ts");
function createPrimaryLandmass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        addLandmassPlotTags(iX, iY, continent2.west);
      } else {
        addWaterPlotTags(iX, iY, continent2.west);
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createSecondaryLandmass(iWidth, iHeight, continent1, continent2) {
  console.log("Generating secondary landmass as small islands...");
  clearContinent(continent1);
  clearContinent(continent2);
  createIslands(iWidth, iHeight, continent1, continent2, 4);
  createIslands(iWidth, iHeight, continent1, continent2, 6);
  createIslands(iWidth, iHeight, continent1, continent2, 6);
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}
function countIslandTiles(iWidth, iHeight) {
  let islandCount = 0;
  for (let y = 0; y < iHeight; y++) {
    for (let x = 0; x < iWidth; x++) {
      if (GameplayMap.hasPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND)) {
        islandCount++;
      }
    }
  }
  return islandCount;
}

export { expandCoastsPlus };
//# sourceMappingURL=pangaea-plus.js.map
</file>

<file path="mod/maps/base-standard/maps/pangaea-voronoi.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { PlayerRegion, assignStartPositionsFromTiles, assignSingleContinentStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_FlatTerrain, g_MountainTerrain, g_HillTerrain, g_VolcanoFeature, g_OceanTerrain, g_CoastTerrain, g_NavigableRiverTerrain, g_AvoidSeamOffset } from './map-globals.js';
import { replaceIslandResources } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { kdTree } from '../scripts/kd-tree.js';
import { TerrainType } from '../scripts/voronoi-utils.js';
import { VoronoiPangaea } from '../scripts/voronoi_maps/pangaea.js';
import { RuleAvoidEdge } from '../scripts/voronoi_rules/avoid-edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../scripts/random-pcg-32.js';
import '../scripts/voronoi_generators/map-generator.js';
import '../scripts/voronoi_maps/map-common.js';
import '../scripts/voronoi-builder.js';
import '../scripts/voronoi-hex.js';
import '../../core/scripts/MathHelpers.js';
import '../scripts/heap.js';
import '../scripts/voronoi_generators/continent-generator.js';
import '../scripts/quadtree.js';
import '../scripts/voronoi-region.js';
import '../scripts/voronoi_rules/avoid-other-regions.js';
import '../scripts/voronoi_rules/rules-base.js';
import '../scripts/voronoi_rules/cell-area.js';
import '../scripts/voronoi_rules/near-map-center.js';
import '../scripts/voronoi_rules/near-neighbor.js';
import '../scripts/voronoi_rules/near-plate-boundary.js';
import '../scripts/voronoi_rules/near-region-seed.js';
import '../scripts/voronoi_rules/neighbors-in-region.js';
import '../scripts/voronoi_rules/prefer-latitude.js';

console.log("Generating using script pangaea-voronoi.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iTotalPlayers = Players.getAliveMajorIds().length;
  const startTime = Date.now();
  const voronoiMap = new VoronoiPangaea();
  voronoiMap.init(mapInfo.$index);
  const rules = voronoiMap.getBuilder().getGenerator().getRules();
  for (const value of Object.values(rules)) {
    for (const rule of value) {
      if (rule.name == RuleAvoidEdge.getName()) {
        rule.configValues.poleDistance = g_PolarWaterRows;
      }
    }
  }
  const generatorSettings = voronoiMap.getBuilder().getGenerator().getSettings();
  generatorSettings.landmass[0].playerAreas = iTotalPlayers;
  voronoiMap.getBuilder().simulate();
  const tiles = voronoiMap.getBuilder().getTiles();
  const landmassKdTree = new kdTree((tile) => tile.pos);
  landmassKdTree.build(tiles.flatMap((row) => row.filter((tile) => tile.landmassId > 0)));
  for (let y = 0; y < tiles.length; ++y) {
    for (let x = 0; x < tiles[y].length; ++x) {
      const tile = tiles[y][x];
      if (tile.isLand()) {
        const type = tile.terrainType === TerrainType.Flat ? g_FlatTerrain : tile.terrainType === TerrainType.Mountainous || tile.terrainType === TerrainType.Volcano ? g_MountainTerrain : tile.terrainType === TerrainType.Rough ? g_HillTerrain : g_FlatTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        if (tile.terrainType === TerrainType.Volcano) {
          TerrainBuilder.setFeatureType(x, y, {
            Feature: g_VolcanoFeature,
            Direction: -1,
            Elevation: 0
          });
        }
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_LANDMASS);
        if (tile.landmassId === 1) {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_LANDMASS);
        } else {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND);
        }
      } else {
        const type = tile.terrainType === TerrainType.Ocean ? g_OceanTerrain : g_CoastTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
        if (tile.terrainType === TerrainType.Coast) {
          const landmassTile = landmassKdTree.search(tile.pos);
          if (landmassTile.landmassId == 1) {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND_WATER);
          }
        }
      }
    }
  }
  const endTime = Date.now();
  console.log(`Initial Voronoi map generation took ${endTime - startTime} ms`);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  const lakeTiles = generateLakes(iWidth, iHeight, iTilesPerLake);
  console.log(`Updating plot tags for ${lakeTiles.length} lakes.`);
  for (const coord of lakeTiles) {
    const tile = tiles[coord.y][coord.x];
    TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WATER);
    if (tile.landmassId === 1) {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WEST_WATER);
    } else {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_ISLAND_WATER);
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  let startPositions = [];
  const USE_VORONOI_START_POSITIONS = true;
  if (USE_VORONOI_START_POSITIONS) {
    voronoiMap.getBuilder().createMajorPlayerAreas(
      (tile) => StartPositioner.getPlotFertilityForCoord(tile.coord.x, tile.coord.y)
    );
    const playerRegions = Array.from({ length: iTotalPlayers }, () => new PlayerRegion());
    playerRegions.forEach((region, index) => {
      region.regionId = index;
      region.landmassId = 0;
    });
    for (const row of tiles) {
      for (const tile of row) {
        if (tile.landmassId == 1 && tile.majorPlayerRegionId >= 0) {
          playerRegions[tile.majorPlayerRegionId].tiles.push({ x: tile.coord.x, y: tile.coord.y });
        }
      }
    }
    startPositions = assignStartPositionsFromTiles(playerRegions);
  } else {
    const continent = {
      west: g_AvoidSeamOffset,
      east: iWidth - g_AvoidSeamOffset,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    startPositions = assignSingleContinentStartPositions(
      iTotalPlayers,
      continent,
      0,
      0,
      [],
      PlotTags.PLOT_TAG_WEST_LANDMASS
    );
  }
  replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded pangaea-voronoi.ts");
//# sourceMappingURL=pangaea-voronoi.js.map
</file>

<file path="mod/maps/base-standard/maps/resource-generator.js">
import { getMinimumResourcePlacementModifier, AVAILABLE_ON_ALL_LANDMASSES_ID, EAST_LAND_MASS_ID, WEST_LAND_MASS_ID, replaceIslandResources, shuffle } from './map-utilities.js';
import './map-globals.js';

function generateResources(iWidth, iHeight) {
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountHome = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountDistant = new Array(GameInfo.Resources.length);
  const resourcesPlacedCount = new Array(GameInfo.Resources.length);
  let minimumResourcePlacementModifer = getMinimumResourcePlacementModifier();
  if (minimumResourcePlacementModifer == void 0) {
    minimumResourcePlacementModifer = 0;
  }
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resourceWeight[resourceIdx] = 0;
    resourceRunningWeight[resourceIdx] = 0;
    resourcesPlacedCount[resourceIdx] = 0;
  }
  const aResourceTypes = [];
  const resources = ResourceBuilder.getGeneratedMapResources();
  for (let ridx = 0; ridx < resources.length; ++ridx) {
    const resourceInfo = GameInfo.Resources.lookup(resources[ridx]);
    if (resourceInfo && resourceInfo.Tradeable) {
      resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
      aResourceTypes.push(resourceInfo.$index);
      importantResourceRegionalCountHome[resourceInfo.$index] = 0;
      importantResourceRegionalCountDistant[resourceInfo.$index] = 0;
    }
  }
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const resources2 = [];
        aResourceTypes.forEach((resourceIdx) => {
          const assignedLandmass = ResourceBuilder.getResourceLandmass(resourceIdx);
          if (assignedLandmass == AVAILABLE_ON_ALL_LANDMASSES_ID) {
            if (canHaveFlowerPlot(iX, iY, resourceIdx)) {
              resources2.push(resourceIdx);
            }
          } else if (assignedLandmass == EAST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS) {
            if (canHaveFlowerPlot(iX, iY, resourceIdx)) {
              resources2.push(resourceIdx);
            }
          } else if (assignedLandmass == WEST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
            if (canHaveFlowerPlot(iX, iY, resourceIdx)) {
              resources2.push(resourceIdx);
            }
          }
        });
        if (resources2.length > 0) {
          let resourceChosen = ResourceTypes.NO_RESOURCE;
          let resourceChosenIndex = 0;
          for (let iI = 0; iI < resources2.length; iI++) {
            if (resourceChosen == ResourceTypes.NO_RESOURCE) {
              resourceChosen = resources2[iI];
              resourceChosenIndex = resources2[iI];
            } else {
              if (resourceRunningWeight[resources2[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                resourceChosen = resources2[iI];
                resourceChosenIndex = resources2[iI];
              } else if (resourceRunningWeight[resources2[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                if (iRoll >= 1) {
                  resourceChosen = resources2[iI];
                  resourceChosenIndex = resources2[iI];
                }
              }
            }
          }
          if (resourceChosen != ResourceTypes.NO_RESOURCE) {
            const iResourcePlotIndex = getFlowerPlot(iX, iY, resourceChosen);
            if (iResourcePlotIndex != -1) {
              const iLocation = GameplayMap.getLocationFromIndex(iResourcePlotIndex);
              const iResourceX = iLocation.x;
              const iResourceY = iLocation.y;
              ResourceBuilder.setResourceType(iResourceX, iResourceY, resourceChosen);
              resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
              resourcesPlacedCount[resourceChosenIndex]++;
              plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS ? importantResourceRegionalCountHome[resourceChosenIndex]++ : importantResourceRegionalCountDistant[resourceChosenIndex]++;
            } else {
              console.log("Resource Index Failure");
            }
          } else {
            console.log("Resource Type Failure");
          }
        }
      }
    }
  }
  let checkHomeHemisphereLP = true;
  let checkDistantHemisphereLP = true;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      const resourceAtLocation = GameplayMap.getResourceType(iX, iY);
      if (resourceAtLocation == ResourceTypes.NO_RESOURCE) {
        const resourcesEligible = [];
        for (let i = 0; i < resourcesPlacedCount.length; ++i) {
          const resourceToPlace = GameInfo.Resources.lookup(i);
          if (resourceToPlace) {
            const assignedLandmass = ResourceBuilder.getResourceLandmass(i);
            if (assignedLandmass == AVAILABLE_ON_ALL_LANDMASSES_ID || assignedLandmass == EAST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS || assignedLandmass == WEST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
              const minimumPerLandMass = resourceToPlace.MinimumPerHemisphere > 0 ? resourceToPlace.MinimumPerHemisphere + minimumResourcePlacementModifer : 0;
              if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS && importantResourceRegionalCountHome[i] < minimumPerLandMass || plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS && importantResourceRegionalCountDistant[i] < minimumPerLandMass) {
                if (checkHomeHemisphereLP && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS) {
                  checkHomeHemisphereLP = ResourceBuilder.isResourceClassRequiredForLegacyPath(
                    i,
                    plotTag
                  );
                } else if (checkDistantHemisphereLP && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
                  checkDistantHemisphereLP = ResourceBuilder.isResourceClassRequiredForLegacyPath(
                    i,
                    plotTag
                  );
                }
                if (ResourceBuilder.isResourceRequiredForAge(i)) {
                  if (ResourceBuilder.canHaveResource(iX, iY, i, false)) {
                    let hasAdjResource = false;
                    for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
                      const iIndex = GameplayMap.getIndexFromXY(iX, iY);
                      const iLocation = GameplayMap.getLocationFromIndex(iIndex);
                      const iAdjacentX = GameplayMap.getAdjacentPlotLocation(
                        iLocation,
                        iDirection
                      ).x;
                      const iAdjacentY = GameplayMap.getAdjacentPlotLocation(
                        iLocation,
                        iDirection
                      ).y;
                      if (GameplayMap.getResourceType(iAdjacentX, iAdjacentY) != ResourceTypes.NO_RESOURCE) {
                        hasAdjResource = true;
                        break;
                      }
                    }
                    if (!hasAdjResource) {
                      resourcesEligible.push(i);
                    }
                  }
                }
              }
            }
          }
        }
        let resourceChosenIndex = -1;
        if (resourcesEligible.length > 0) {
          let resourceChosen = ResourceTypes.NO_RESOURCE;
          for (let iI = 0; iI < resourcesEligible.length; iI++) {
            if (resourceChosen == ResourceTypes.NO_RESOURCE) {
              resourceChosen = resourcesEligible[iI];
              resourceChosenIndex = resourcesEligible[iI];
            } else {
              if (resourceRunningWeight[resourcesEligible[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                resourceChosen = resourcesEligible[iI];
                resourceChosenIndex = resourcesEligible[iI];
              } else if (resourceRunningWeight[resourcesEligible[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                if (iRoll >= 1) {
                  resourceChosen = resourcesEligible[iI];
                  resourceChosenIndex = resourcesEligible[iI];
                }
              }
            }
          }
        }
        if (resourceChosenIndex > -1) {
          ResourceBuilder.setResourceType(iX, iY, resourceChosenIndex);
          resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
          const name = GameInfo.Resources.lookup(resourceChosenIndex)?.Name;
          console.log("Force Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")");
          plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS ? importantResourceRegionalCountHome[resourceChosenIndex]++ : importantResourceRegionalCountDistant[resourceChosenIndex]++;
          break;
        }
      }
    }
  }
  const definition = GameInfo.Ages.lookup(Game.age);
  if (definition) {
    const mapType = Configuration.getMapValue("Name");
    for (const option of GameInfo.MapIslandBehavior) {
      if (option.MapType === mapType) {
        replaceIslandResources(iWidth, iHeight, option.ResourceClassType);
      }
    }
  }
}
function canHaveFlowerPlot(iX, iY, resourceType) {
  if (ResourceBuilder.canHaveResource(iX, iY, resourceType, false)) {
    return true;
  }
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    if (ResourceBuilder.canHaveResource(iAdjacentX, iAdjacentY, resourceType, false)) {
      return true;
    }
  }
  return false;
}
function getFlowerPlot(iX, iY, resourceType) {
  if (ResourceBuilder.canHaveResource(iX, iY, resourceType, false)) {
    return GameplayMap.getIndexFromXY(iX, iY);
  }
  const resourcePlotIndexes = [];
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentIndex = GameplayMap.getIndexFromXY(iAdjacentX, iAdjacentY);
    if (ResourceBuilder.canHaveResource(iAdjacentX, iAdjacentY, resourceType, false)) {
      resourcePlotIndexes.push(iAdjacentIndex);
    }
  }
  if (resourcePlotIndexes.length > 0) {
    return shuffle(resourcePlotIndexes)[0];
  } else {
    return -1;
  }
}

export { canHaveFlowerPlot, generateResources, getFlowerPlot };
//# sourceMappingURL=resource-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/shuffle.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_NavigableRiverTerrain, g_CoastTerrain, g_OceanTerrain, g_LandmassFractal, g_FlatTerrain, g_WaterPercent, g_StartSectorWeight, g_FractalWeight, g_CenterWeight, g_Cutoff } from './map-globals.js';
import { needHumanNearEquator, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, addPlotTags, createIslands, adjustOceanPlotTags, isAdjacentToLand, getSector, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes } from './volcano-generator.js';

console.log("Generating using script shuffle.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
  if (iRandom == 1) {
    const iNum1 = iNumPlayers1;
    const iNum2 = iNumPlayers2;
    iNumPlayers1 = iNum2;
    iNumPlayers2 = iNum1;
  }
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iOceanWaterColumns
    );
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
  } else {
    console.log("Standard Map");
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iOceanWaterColumns
    );
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
  }
  addPlotTags(iHeight, iWidth, eastContinent.west);
  TerrainBuilder.validateAndFixTerrain();
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  const iRandomRiver = TerrainBuilder.getRandomNumber(10, "Intensity of Rivers");
  if (iRandomRiver == 0) {
    TerrainBuilder.modelRivers(10, 85, g_NavigableRiverTerrain);
  } else if (iRandomRiver < 3) {
    TerrainBuilder.modelRivers(5, 70, g_NavigableRiverTerrain);
  } else {
    TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  }
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iNumPlayers1 > iNumPlayers2) {
          if (iX < westContinent.west - 2 || iX > westContinent.east + 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          }
        } else {
          if (iX > eastContinent.east + 2 || iX < eastContinent.west - 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          }
        }
      }
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded shuffle.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iOceanWaterColumns) {
  const iRandomLandmassSetup = TerrainBuilder.getRandomNumber(4, "Shuffle Map Landmass Structure");
  if (iRandomLandmassSetup == 0) {
    createArchipelago(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Archipelago");
  } else if (iRandomLandmassSetup == 1) {
    createContinents(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Continents");
  } else if (iRandomLandmassSetup == 2) {
    createFractal(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Fractal");
  } else if (iRandomLandmassSetup == 3) {
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      }
    }
    createTerraMass(
      iWidth,
      iHeight,
      continent1,
      continent2,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      true,
      iOceanWaterColumns
    );
    createTerraMass(
      iWidth,
      iHeight,
      continent1,
      continent2,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      false,
      iOceanWaterColumns
    );
    console.log("Random Landmass Setup: Terra");
  }
}
function createArchipelago(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
    }
  }
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    3
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    4
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    5
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    6
  );
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.removePlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function generateFractalLayerWithoutHills(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iCenterWeight = 0;
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain || GameplayMap.getTerrainType(iX, iY) == g_CoastTerrain) {
        let terrain = g_FlatTerrain;
        const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
        const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
        if (isAdjacentToLand(iX, iY)) {
          continue;
        } else if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
          continue;
        } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
          terrain = g_OceanTerrain;
        } else {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          let iStartSectorWeight = 0;
          let iFractalWeight = 1;
          if (startSectors[iSector]) {
            iStartSectorWeight = 0.7;
            iFractalWeight = 0.35;
          }
          const iPlotHeight = getHeightAdjustingForStartSector(
            iX,
            iY,
            iWaterHeight,
            iFractalWeight,
            iCenterWeight,
            iStartSectorWeight,
            continent1,
            continent2,
            iStartSectorRows,
            iStartSectorCols,
            startSectors
          );
          if (iPlotHeight < iWaterHeight) {
            continue;
          }
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function createContinents(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}
function createFractal(iWidth, iHeight, westContinent, eastContinent, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 3, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 13.5);
  const iBuffer2 = Math.floor(iWidth / 21);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < westContinent.south + iRandom || iY >= westContinent.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX == 0) {
        terrain = g_OceanTerrain;
      } else if (iX < westContinent.west + iRandom2 || iX >= eastContinent.east - iRandom2) {
        terrain = g_OceanTerrain;
      } else if (iX >= westContinent.east - iRandom2 && iX < eastContinent.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          iFractalWeight,
          0,
          iStartSectorWeight,
          westContinent,
          eastContinent,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * (g_FractalWeight + g_StartSectorWeight)) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createTerraMass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bFirst, iOceanWaterColumns) {
  const iSize = TerrainBuilder.getRandomNumber(6, "Random Land Size") + 2;
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iRanHeight = 100 - (iSize * 10 - 20);
  const iMaxHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iRanHeight);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (bFirst == true) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      }
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        if (bFirst == true) {
          terrain = g_OceanTerrain;
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        if (bFirst == true) {
          terrain = g_OceanTerrain;
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      } else if (bFirst == true && iX > continent1.east + iOceanWaterColumns || bFirst == false && iX < continent2.west - iOceanWaterColumns) {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iMaxHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iMaxHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (bFirst == false && iX > continent1.east + iOceanWaterColumns || bFirst == true && iX < continent2.west - iOceanWaterColumns) {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iMaxHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iMaxHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=shuffle.js.map
</file>

<file path="mod/maps/base-standard/maps/snow-generator.js">
import { g_PolarWaterRows } from './map-globals.js';

function generateSnow(mapWidth, mapHeight) {
  console.log("Generating permanent snow");
  const mapHalfHeight = GameplayMap.getGridHeight() / 2;
  const snowLatitudeEnd = 60;
  const snowRowEnd = Math.ceil(mapHalfHeight * ((90 - snowLatitudeEnd) / 90));
  const snowRowStarts = [g_PolarWaterRows, g_PolarWaterRows];
  const snowRowLimits = [
    snowRowEnd > snowRowStarts[0] ? snowRowEnd - snowRowStarts[0] : 0,
    snowRowEnd > snowRowStarts[1] ? snowRowEnd - snowRowStarts[1] : 0
  ];
  const snowRowDeltas = [-1, 1];
  console.log(
    "Snow latitude:" + snowLatitudeEnd.toString() + ", rows:" + snowRowStarts[0].toString() + " to " + (snowRowStarts[0] + snowRowLimits[0]).toString()
  );
  const aLightSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "LIGHT", "PERMANENT"]);
  const aMediumSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "MEDIUM", "PERMANENT"]);
  const aHeavySnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "HEAVY", "PERMANENT"]);
  const weightRange = 3;
  const changeTotalAdjustment = 60;
  const aWeightEffect = [-1, -1, -1];
  aWeightEffect[0] = aLightSnowEffects ? aLightSnowEffects[0] : -1;
  aWeightEffect[1] = aMediumSnowEffects ? aMediumSnowEffects[0] : -1;
  aWeightEffect[2] = aHeavySnowEffects ? aHeavySnowEffects[0] : -1;
  const colEnd = mapWidth;
  const rowStart = [mapHeight - 1 - snowRowStarts[0], snowRowStarts[1]];
  for (let pole = 0; pole != 2; ++pole) {
    const rowCount = snowRowLimits[pole];
    if (rowCount > 0) {
      const nextRowDelta = snowRowDeltas[pole];
      const rowEnd = rowStart[pole] + rowCount * nextRowDelta;
      const chanceAdjustment = Math.ceil(changeTotalAdjustment / rowCount);
      const aWeightChance = [10, 30, 60];
      let chanceForAny = 90;
      for (let row = rowStart[pole]; row != rowEnd; row += nextRowDelta) {
        for (let col = 0; col < colEnd; ++col) {
          if (GameplayMap.isWater(col, row) == false) {
            let rndVal = TerrainBuilder.getRandomNumber(100, "Any Snow");
            if (rndVal <= chanceForAny) {
              rndVal = TerrainBuilder.getRandomNumber(100, "Snow Weight");
              for (let weight = weightRange - 1; weight >= 0; --weight) {
                if (rndVal < aWeightChance[weight]) {
                  MapPlotEffects.addPlotEffect(
                    GameplayMap.getIndexFromXY(col, row),
                    aWeightEffect[weight]
                  );
                  break;
                } else {
                  rndVal -= aWeightChance[weight];
                }
              }
            }
          }
        }
        chanceForAny -= chanceAdjustment;
        const adjustBy = chanceAdjustment;
        aWeightChance[2] -= adjustBy;
        for (let weight = weightRange - 2; weight >= 0; --weight) {
          aWeightChance[weight] += adjustBy;
        }
      }
    }
  }
}
function dumpPermanentSnow(iWidth, iHeight) {
  console.log("Permanent Snow");
  console.log("@ = heavy");
  console.log("# = medium");
  console.log("* = light");
  console.log(". = no-snow");
  const aLightSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "LIGHT", "PERMANENT"]);
  const aMediumSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "MEDIUM", "PERMANENT"]);
  const aHeavySnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "HEAVY", "PERMANENT"]);
  const eLightPlotEffect = aLightSnowEffects ? aLightSnowEffects[0] : -1;
  const eMediumPlotEffect = aMediumSnowEffects ? aMediumSnowEffects[0] : -1;
  const eHeavyPlotEffect = aHeavySnowEffects ? aHeavySnowEffects[0] : -1;
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let effectString = " ";
      if (GameplayMap.isWater(iX, iY) == false) {
        const iIndex = GameplayMap.getIndexFromXY(iX, iY);
        if (MapPlotEffects.hasPlotEffect(iIndex, eLightPlotEffect)) {
          effectString = "*";
        } else if (MapPlotEffects.hasPlotEffect(iIndex, eMediumPlotEffect)) {
          effectString = "#";
        } else if (MapPlotEffects.hasPlotEffect(iIndex, eHeavyPlotEffect)) {
          effectString = "@";
        } else {
          effectString = ".";
        }
      }
      str += effectString + " ";
    }
    console.log(str);
  }
}

export { dumpPermanentSnow, generateSnow };
//# sourceMappingURL=snow-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/terra-incognita.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight, g_CoastTerrain } from './map-globals.js';
import { needHumanNearEquator, createIslands, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, createOrganicLandmasses, clearContinent, addPlotTags, adjustOceanPlotTags, adjustLakePlotTags, getHeightAdjustingForStartSector, addLandmassPlotTags, addWaterPlotTags } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script terra-incognita.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createPrimaryLandmass(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iNumPlayers1 > iNumPlayers2,
      iOceanWaterColumns
    );
    createSecondaryLandmassBalanced(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iNumPlayers1 > iNumPlayers2,
      iOceanWaterColumns
    );
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 15;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
      clearContinent(westContinent);
      createSecondaryLandmassStandard(westContinent);
    } else {
      clearContinent(eastContinent);
      createSecondaryLandmassStandard(eastContinent);
    }
    addPlotTags(iHeight, iWidth, eastContinent.west);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  adjustLakePlotTags(westContinent, true);
  adjustLakePlotTags(westContinent2, true);
  adjustLakePlotTags(eastContinent, false);
  adjustLakePlotTags(eastContinent2, false);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpStartSectors(startSectors);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded terra-incognita.ts");
function createPrimaryLandmass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        addLandmassPlotTags(iX, iY, continent2.west);
      } else {
        addWaterPlotTags(iX, iY, continent2.west);
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createSecondaryLandmassBalanced(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  const iSize = TerrainBuilder.getRandomNumber(6, "Random Land Size");
  console.log("Random Land Size " + iSize);
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iRanHeight = 130 - iSize * 10;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(
    g_LandmassFractal,
    g_WaterPercent * iRanHeight / 100
  );
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
        if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
          addLandmassPlotTags(iX, iY, continent2.west);
        } else {
          addWaterPlotTags(iX, iY, continent2.west);
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
        if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
          addLandmassPlotTags(iX, iY, continent2.west);
        } else {
          addWaterPlotTags(iX, iY, continent2.west);
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
          addLandmassPlotTags(iX, iY, continent2.west);
        } else {
          addWaterPlotTags(iX, iY, continent2.west);
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
}
function createSecondaryLandmassStandard(continent1) {
  console.log("Creating new landmass in this box");
  console.log("  North: " + continent1.north);
  console.log("  South: " + continent1.south);
  console.log("  East:  " + continent1.east);
  console.log("  West:  " + continent1.west);
  const iGrain = TerrainBuilder.getRandomNumber(3, "Secondary Landmass Fractal Grain") + 2;
  console.log("Secondary Landmass Fractal Grain: " + iGrain);
  FractalBuilder.create(
    g_LandmassFractal,
    continent1.east - continent1.west + 1,
    continent1.north - continent1.south + 1,
    iGrain,
    0
  );
  const iWaterHeightRange = 30;
  const iRanHeight = TerrainBuilder.getRandomNumber(iWaterHeightRange, "Random Water Height");
  console.log("Random Water Height: " + iRanHeight);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(
    g_LandmassFractal,
    g_WaterPercent * g_Cutoff + iRanHeight - 5
  );
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = g_FlatTerrain;
      const iPlotHeight = FractalBuilder.getHeight(
        g_LandmassFractal,
        iX - continent1.west,
        iY - continent1.south
      );
      if (iPlotHeight >= iWaterHeight) {
        if (iY == continent1.south || iY == continent1.north || iX == continent1.west || iX == continent1.east) {
          if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
            TerrainBuilder.setTerrainType(iX, iY, terrain);
          }
        } else {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      }
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=terra-incognita.js.map
</file>

<file path="mod/maps/base-standard/maps/volcano-generator.js">
import { g_VolcanoFeature, g_MountainTerrain, g_TundraBiome } from './map-globals.js';

function getContinentBoundaryPlotCount(iWidth, iHeight) {
  let iContinentBoundaryPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.findSecondContinent(iX, iY, 3)) {
        iContinentBoundaryPlots = iContinentBoundaryPlots + 1;
      }
    }
  }
  return iContinentBoundaryPlots;
}
function getNumberAdjacentMountains(iX, iY) {
  let iCount = 0;
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const pAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.isMountain(pAdjacentPlot.x, pAdjacentPlot.y)) {
      iCount = iCount + 1;
    }
  }
  return iCount;
}
function getNumberAdjacentVolcanoes(iX, iY) {
  let iCount = 0;
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const pAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.getFeatureType(pAdjacentPlot.x, pAdjacentPlot.y) == g_VolcanoFeature) {
      iCount = iCount + 1;
    }
  }
  return iCount;
}
function addVolcanoes(iWidth, iHeight, spacing = 2) {
  console.log("Volcanoes");
  const iMountainPercentByDistance = [30, 18, 6];
  let iCountVolcanoesPlaced = 0;
  const placedVolcanoes = [];
  const minDistanceBetweenVolcanoes = spacing;
  let iTotalLandPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots = iTotalLandPlots + 1;
      }
    }
  }
  const iDesiredVolcanoes = iTotalLandPlots / 150;
  console.log("Desired Volcanoes: " + iDesiredVolcanoes);
  const iContinentBoundaryPlots = getContinentBoundaryPlotCount(iWidth, iHeight);
  console.log("Continent Boundary Plots: " + iContinentBoundaryPlots);
  const iDesiredNearBoundaries = iDesiredVolcanoes * 2 / 3;
  console.log("Desired Boundary Volcanoes: " + iDesiredNearBoundaries);
  if (iDesiredNearBoundaries > 0) {
    const iBoundaryPlotsPerVolcano = iContinentBoundaryPlots / iDesiredNearBoundaries;
    console.log("Boundary Plots Per Volcano: " + iBoundaryPlotsPerVolcano);
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        if (!GameplayMap.isWater(iX, iY)) {
          let iPlotsFromBoundary = -1;
          let bVolcanoHere = false;
          const iNumAdjacentMountains = getNumberAdjacentMountains(iX, iY);
          if (iNumAdjacentMountains != 6) {
            if (GameplayMap.findSecondContinent(iX, iY, 1)) {
              if (TerrainBuilder.getRandomNumber(iBoundaryPlotsPerVolcano * 0.7, "Volcano on boundary") == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 1;
            } else if (GameplayMap.findSecondContinent(iX, iY, 2)) {
              if (TerrainBuilder.getRandomNumber(iBoundaryPlotsPerVolcano, "Volcano 1 from boundary") == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 2;
            } else if (GameplayMap.findSecondContinent(iX, iY, 3)) {
              if (TerrainBuilder.getRandomNumber(
                iBoundaryPlotsPerVolcano * 1.5,
                "Volcano 2 from boundary"
              ) == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 3;
            }
          }
          if (bVolcanoHere && !isTooCloseToExistingVolcanoes(iX, iY, placedVolcanoes, minDistanceBetweenVolcanoes)) {
            TerrainBuilder.setTerrainType(iX, iY, g_MountainTerrain);
            TerrainBuilder.setFeatureType(iX, iY, {
              Feature: g_VolcanoFeature,
              Direction: -1,
              Elevation: 0
            });
            placedVolcanoes.push({ x: iX, y: iY });
            iCountVolcanoesPlaced++;
          } else if (iPlotsFromBoundary > 0) {
            let iMountainChance = iMountainPercentByDistance[iPlotsFromBoundary - 1];
            if (getNumberAdjacentVolcanoes(iX, iY) > 0) {
              iMountainChance = iMountainChance / 2;
            }
            if (TerrainBuilder.getRandomNumber(100, "Mountain near boundary") < iMountainChance) {
              TerrainBuilder.setTerrainType(iX, iY, g_MountainTerrain);
            }
          }
        }
      }
    }
  }
  console.log("Continent Edge Volcanoes Placed: " + iCountVolcanoesPlaced);
}
function isTooCloseToExistingVolcanoes(iX, iY, existingVolcanoes, minDistance) {
  for (const volcano of existingVolcanoes) {
    const dx = volcano.x - iX;
    const dy = volcano.y - iY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < minDistance) return true;
  }
  return false;
}
function addTundraVolcanoes(iWidth, iHeight, spacing = 3) {
  console.log(`Adding tundra volcanoes`);
  let iTotalLandPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots++;
      }
    }
  }
  let tundraVolcanoesPlaced = 0;
  const iDesiredVolcanoes = Math.floor(iTotalLandPlots / 300);
  console.log("Desired Tundra Volcanoes: " + iDesiredVolcanoes);
  const placedVolcanoes = [];
  const tundraCandidates = [];
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const biome = GameplayMap.getBiomeType(iX, iY);
      if (biome === g_TundraBiome && GameplayMap.isMountain(iX, iY)) {
        const isInland = !GameplayMap.isCoastalLand(iX, iY);
        tundraCandidates.push({ x: iX, y: iY, isInland });
      }
    }
  }
  shuffleCandidates(tundraCandidates);
  tundraCandidates.sort((a, b) => {
    if (a.isInland === b.isInland) return 0;
    return a.isInland ? -1 : 1;
  });
  const baseChance = 20;
  const falloffPerVolcano = 5;
  for (const { x, y } of tundraCandidates) {
    if (tundraVolcanoesPlaced >= iDesiredVolcanoes) break;
    if (!isTooCloseToExistingVolcanoes(x, y, placedVolcanoes, spacing)) {
      const currentChance = Math.max(1, baseChance - tundraVolcanoesPlaced * falloffPerVolcano);
      if (TerrainBuilder.getRandomNumber(100, "Tundra Volcano Roll") < currentChance) {
        TerrainBuilder.setTerrainType(x, y, g_MountainTerrain);
        TerrainBuilder.setFeatureType(x, y, {
          Feature: g_VolcanoFeature,
          Direction: -1,
          Elevation: 0
        });
        placedVolcanoes.push({ x, y });
        tundraVolcanoesPlaced++;
        console.log(`Tundra Volcano Placed at (${x}, ${y})  chance was ${currentChance}%`);
      }
    }
  }
  console.log(`Total Tundra Volcanoes Placed: ${tundraVolcanoesPlaced}`);
  function shuffleCandidates(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = TerrainBuilder.getRandomNumber(i + 1, "Shuffle");
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
}

export { addTundraVolcanoes, addVolcanoes, isTooCloseToExistingVolcanoes };
//# sourceMappingURL=volcano-generator.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_generators/continent-generator.js">
import { sub2, rotate2, add2, dot2, dot2_90, mul2s, mul2 } from '../../../core/scripts/MathHelpers.js';
import { Aabb2, QuadTree } from '../quadtree.js';
import { kdTree } from '../kd-tree.js';
import { RandomImpl } from '../random-pcg-32.js';
import { PlateRegion, LandmassRegion } from '../voronoi-region.js';
import { PlateBoundaryPosGetter, RegionType, MapSize, VoronoiUtils, MapDims, RegionCell, RegionCellPosGetter, TerrainType } from '../voronoi-utils.js';
import { MapGenerator, GeneratorType } from './map-generator.js';
import { RuleAvoidEdge } from '../voronoi_rules/avoid-edge.js';
import { RuleAvoidOtherRegions } from '../voronoi_rules/avoid-other-regions.js';
import { RuleCellArea } from '../voronoi_rules/cell-area.js';
import { RuleNearMapCenter } from '../voronoi_rules/near-map-center.js';
import { RuleNearNeighbor } from '../voronoi_rules/near-neighbor.js';
import { RuleNearPlateBoundary } from '../voronoi_rules/near-plate-boundary.js';
import { RuleNearRegionSeed } from '../voronoi_rules/near-region-seed.js';
import { RuleNeighborsInRegion } from '../voronoi_rules/neighbors-in-region.js';
import { RulePreferLatitude } from '../voronoi_rules/prefer-latitude.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../voronoi_rules/rules-base.js';

class ContinentGenerator extends MapGenerator {
  m_plateRegions = [];
  m_landmassRegions = [];
  m_plateBoundaries = new kdTree(PlateBoundaryPosGetter);
  m_platesDiagram;
  m_plateRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.15, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.8, record: { scaleFactor: 0.5 } }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.02, record: {} }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.6, record: { preferredNeighborCount: 6, deviation: 3 } }]
  ];
  m_landmassRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 6,
          poleFalloffCurve: 0.2,
          meridianDistance: 2,
          meridianDistanceFalloff: 6,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleCellArea, { isActive: true, weight: 0.1, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.5, record: {} }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.05, record: { scaleFactor: 8 } }],
    [
      RuleNeighborsInRegion,
      { isActive: true, weight: 0.25, record: { preferredNeighborCount: 4, deviation: 1.5 } }
    ],
    [RuleNearMapCenter, { isActive: false, weight: 0.05, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 8, falloffCurve: 0.2, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 3, directionInfluence: 0.5 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ],
    [RulePreferLatitude, { isActive: true, weight: 0.5, record: {} }]
  ];
  m_coastalIslandRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 4,
          poleFalloffCurve: 0.2,
          meridianDistance: 2,
          meridianDistanceFalloff: 10,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleNearNeighbor, { isActive: true, weight: 0.5, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Other Landmass",
        key: "avoidOther",
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Own Landmass",
        key: "avoidSelf",
        isActive: true,
        weight: 1,
        record: { minDistance: 0.25, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Islands",
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Island }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 3, directionInfluence: 0.5 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ],
    [RuleNearRegionSeed, { isActive: true, weight: 0.3, record: { scaleFactor: 15, invert: 1 } }]
  ];
  m_islandRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 8,
          poleFalloffCurve: 0.5,
          meridianDistance: 2,
          meridianDistanceFalloff: 10,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleCellArea, { isActive: true, weight: 0.15, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.9, record: { scaleFactor: 0.5 } }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.03, record: {} }],
    [
      RuleNeighborsInRegion,
      { isActive: true, weight: 0.6, record: { preferredNeighborCount: 1.5, deviation: 0.5 } }
    ],
    [RuleNearMapCenter, { isActive: true, weight: 0.04, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 4, falloffCurve: 0.15, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 2, directionInfluence: 0.8 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ]
  ];
  m_mountainRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.3, record: { invert: true } }],
    [RuleNearNeighbor, { isActive: false, weight: 0.25, record: {} }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.6, record: { preferredNeighborCount: 6, deviation: 4 } }],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 1, directionInfluence: 0.4 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ]
  ];
  m_volcanoRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.3, record: { invert: true } }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.9, record: { preferredNeighborCount: 0, deviation: 1 } }]
  ];
  m_plateRules = [];
  m_landmassRules = [];
  m_coastalIslandRules = [];
  m_islandRules = [];
  m_mountainRules = [];
  m_volcanoRules = [];
  static plateDistributionDescription = "The distribution of sizes of plates is controlled by 'Plate Curve Power' and 'Plate Linear Strength'. This helps the world have a mix of plate sizes. The calculation is a lerp between y=x^(Plate Curve Power) and y=x (linear) based on 'Linear Strength'. A 'Linear Strength' of 1 will mean all the plates are about the same size, less than that and the distribution becomes more curved. 'Plate Curve Power' affects the steepness of the curve";
  m_generatorSettingsSchema = [
    {
      groupLabel: "Plates",
      key: "plate",
      children: {
        type: "configs",
        data: [
          {
            key: "factor",
            label: "Plate Factor",
            description: "Number of tectonic plates to spawn per 100 tiles.",
            min: 0,
            max: 2,
            default: 0.38,
            step: 0.01
          },
          {
            key: "curvePower",
            label: "Plate Curve Power",
            description: ContinentGenerator.plateDistributionDescription,
            min: 1,
            max: 50,
            default: 4,
            step: 1
          },
          {
            key: "linearStrength",
            label: "Plate Linear Strength",
            description: ContinentGenerator.plateDistributionDescription,
            min: 0,
            max: 1,
            default: 0.6,
            step: 0.01
          },
          {
            key: "useUniqueVoronoi",
            label: "Use Unique Voronoi",
            description: "Causes the plate generation to create it's own unique voronoi diagram instead of using the same one as the rest of the map. This allows using fewer cells for plates, leading to more blobby shapes and higher performance.",
            min: 0,
            max: 1,
            default: 1,
            step: 1
          },
          {
            key: "voronoiCellRatio",
            label: "Cell Count Multiple",
            description: "When 'Use Unique Voronoi' is on, this affects the ratio of plate voronoi cells relative to the rest of the map, squared.",
            min: 1e-3,
            max: 1,
            default: 0.25,
            step: 1e-3
          },
          {
            key: "plateRotationMultiple",
            label: "Plate Rotation Multiple",
            description: "A scalar for plate rotation. This is useful since larger plates on big maps will move more around the edges of the plate than smaller ones for the same rotation value.",
            min: 0,
            max: 10,
            default: 1,
            step: 0.1
          }
        ]
      }
    },
    {
      groupLabel: "Landmass",
      key: "landmass",
      childCount: 2,
      children: {
        type: "configs",
        data: [
          {
            key: "enabled",
            label: "Enabled",
            description: "Controls if this landmass is created. Useful for quickly turning on and off a landmass without removing its settings entirely.",
            min: 0,
            max: 1,
            default: 1,
            step: 1
          },
          {
            key: "size",
            label: "Size %",
            description: "The size of the landmass as a percentage of total map area.",
            min: 5,
            max: 40,
            default: 17,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance +/- %",
            description: "The random variance (plus or minus) percentage of the total size.",
            min: 0,
            max: 10,
            default: 1,
            step: 0.01
          },
          {
            key: "spawnCenterDistance",
            label: "Spawn Distance From Center",
            description: "The distance from center with 0 being center and 1 being the edge of a circle squished into the map dimensions",
            min: 0.25,
            max: 0.75,
            default: 0.5,
            step: 0.01
          },
          {
            key: "erosionPercent",
            label: "Erosion Percent",
            description: "The percent of cells in this region to erode.",
            min: 0,
            max: 25,
            step: 0.1,
            default: 8
          },
          {
            key: "playerAreas",
            label: "Player Areas",
            description: "The number of player areas to spawn on this landmass.",
            min: 0,
            max: 20,
            default: 4
          },
          {
            key: "coastalIslands",
            label: "Coastal Islands",
            description: "The number of spawn locations for coastal islands. These are cells just off the coast of landmasses, not too close to other landmasses or islands, which are used to add land to the landmass they spawn near. They follow their own grow rules.",
            min: 0,
            max: 20,
            default: 8
          },
          {
            key: "coastalIslandsMinDistance",
            label: "Coastal Islands Min Distance",
            description: "The minimum distance from the landmass for coastal islands to spawn",
            min: 1,
            max: 4,
            default: 2,
            step: 0.1
          },
          {
            key: "coastalIslandsMaxDistance",
            label: "Coastal Islands max Distance",
            description: "The maximum distance from the landmass for coastal islands to spawn",
            min: 1,
            max: 4,
            default: 3,
            step: 0.1
          },
          {
            key: "coastalIslandsSize",
            label: "Coastal Islands Size %",
            description: "The total amount of land area to create as coastal islands around this landmass as a percent of map size.",
            min: 0,
            max: 5,
            default: 1,
            step: 0.01
          },
          {
            key: "coastalIslandsSizeVariance",
            label: "Coastal Islands Size Variance %",
            description: "The random variance (plus or minus) percentage of the total coastal island size.",
            min: 0,
            max: 5,
            default: 0.5,
            step: 0.01
          }
        ]
      }
    },
    {
      groupLabel: "Islands",
      key: "island",
      children: {
        type: "configs",
        data: [
          {
            key: "factor",
            label: "Factor",
            description: "The number of distant land islands to spawn per 100 tiles.",
            min: 0,
            max: 2,
            default: 0.3,
            step: 0.01
          },
          {
            key: "minSize",
            label: "Minimum Size %",
            description: "The minimum size of -each- island as a percentage of total map size.",
            min: 0,
            max: 4,
            default: 0.33,
            step: 0.01
          },
          {
            key: "maxSize",
            label: "Maximum Size %",
            description: "The maximum size of -each- island as a percentage of total map size.",
            min: 0,
            max: 4,
            default: 2,
            step: 0.01
          },
          {
            key: "totalSize",
            label: "Size %",
            description: "The total size of all islands combined as a percentage of total map size.",
            min: 0,
            max: 10,
            default: 4,
            step: 0.01
          },
          {
            key: "variance",
            label: "Variance +/- %",
            description: "The random plus or minus variance in the total size of all islands as a percentage of total map size.",
            min: 0,
            max: 2,
            default: 0.2,
            step: 0.01
          },
          {
            key: "poleDistance",
            label: "Pole Distance Hexes",
            description: "The minimum distance from the poles that distant land islands can spawn.",
            min: 0,
            max: 10,
            default: 5
          },
          {
            key: "meridianDistance",
            label: "Meridian Distance Hexes",
            description: "The minimum distance from the meridian that distant land islands can spawn.",
            min: 0,
            max: 10,
            default: 5
          },
          {
            key: "landmassDistance",
            label: "Min Landmass Distance Hexes",
            description: "The minimum distance from the major landmasses that distant land islands can spawn.",
            min: 0,
            max: 15,
            default: 4
          },
          {
            key: "islandDistance",
            label: "Min Island Distance Hexes",
            description: "The minimum distance from other islands that distant land islands can spawn.",
            min: 0,
            max: 15,
            default: 3
          },
          {
            key: "erosionPercent",
            label: "Erosion Percent",
            description: "The percent of cells on any given distant land island to erode.",
            min: 0,
            max: 50,
            default: 20
          }
        ]
      }
    },
    {
      groupLabel: "Mountains",
      key: "mountain",
      children: {
        type: "configs",
        data: [
          {
            key: "percent",
            label: "Percent of Land",
            description: "The percentage of all land that should be mountainous",
            min: 0,
            max: 50,
            default: 8,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance Percent",
            description: "The random +/- percent to the total area covered by mountains",
            min: 0,
            max: 10,
            default: 2,
            step: 0.1
          },
          {
            key: "randomize",
            label: "Randomize",
            description: "The randomization applied to mountain scores",
            min: 0,
            max: 100,
            default: 2,
            step: 1
          }
        ]
      }
    },
    {
      groupLabel: "Volcanos",
      key: "volcano",
      children: {
        type: "configs",
        data: [
          {
            key: "percent",
            label: "Percent of Mountains",
            description: "The percentage of all mountains that should be volcanos",
            min: 0,
            max: 50,
            default: 15,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance Percent",
            description: "The random +/- percent to the total number of mountains that are volcanos",
            min: 0,
            max: 10,
            default: 5,
            step: 0.1
          },
          {
            key: "randomize",
            label: "Randomize",
            description: "The randomization applied to volcano scores",
            min: 0,
            max: 100,
            default: 10,
            step: 1
          }
        ]
      }
    }
  ];
  // Overrides for specific map sizes
  m_mapSizeSettings = {
    [MapSize.Tiny]: {},
    [MapSize.Small]: {},
    [MapSize.Standard]: {},
    [MapSize.Large]: {},
    [MapSize.Huge]: {}
  };
  constructor() {
    super();
    this.initializeRules();
    this.buildDefaultSettings(this.m_generatorSettingsSchema, this.m_mapSizeSettings);
  }
  initializeRules() {
    const initializeRuleGroup = (rules, config) => {
      rules.length = 0;
      for (const [ruleClass, ruleSetting] of config) {
        const rule = new ruleClass();
        rule.initialize(ruleSetting);
        rules.push(rule);
      }
    };
    initializeRuleGroup(this.m_plateRules, this.m_plateRuleConfigs);
    initializeRuleGroup(this.m_landmassRules, this.m_landmassRuleConfigs);
    initializeRuleGroup(this.m_coastalIslandRules, this.m_coastalIslandRuleConfigs);
    initializeRuleGroup(this.m_islandRules, this.m_islandRuleConfigs);
    initializeRuleGroup(this.m_mountainRules, this.m_mountainRuleConfigs);
    initializeRuleGroup(this.m_volcanoRules, this.m_volcanoRuleConfigs);
    const volcanoNeighborRule = this.m_volcanoRules.find(
      (rule) => rule.name === RuleNeighborsInRegion.getName()
    );
    volcanoNeighborRule.inRegionCheck = (_ctx, thisCell, neighborCell) => {
      return thisCell.terrainType === neighborCell.terrainType;
    };
  }
  resetToDefault() {
    super.resetToDefault();
    this.initializeRules();
  }
  getType() {
    return GeneratorType.Continent;
  }
  getGeneratorSettingsConfig() {
    return this.m_generatorSettingsSchema;
  }
  getTypedSettings() {
    return this.getSettings();
  }
  getRules() {
    return {
      Plates: this.m_plateRules,
      Landmasses: this.m_landmassRules,
      "Coastal Islands": this.m_coastalIslandRules,
      Islands: this.m_islandRules,
      Mountains: this.m_mountainRules,
      Volcanoes: this.m_volcanoRules
    };
  }
  simulate() {
    for (const regionCell of this.m_regionCells) {
      regionCell.reset();
    }
    VoronoiUtils.performanceMarker("Grow Plates");
    this.growPlates();
    VoronoiUtils.performanceMarker("Grow Landmasses");
    this.growLandmasses();
    VoronoiUtils.performanceMarker("Grow Islands");
    this.growIslands();
    VoronoiUtils.performanceMarker("Grow Coastal Islands");
    this.growCoastalIslands();
    VoronoiUtils.performanceMarker("Force Polar Margin");
    this.forcePoles();
    VoronoiUtils.performanceMarker("Mark Land and Ocean Tiles");
    this.markLandAndOcean();
    VoronoiUtils.performanceMarker("Remove Lakes");
    this.removeLakes();
    VoronoiUtils.performanceMarker("Add Coasts & Costal Erosion");
    this.addCoasts();
    VoronoiUtils.performanceMarker("Add Mountains & Volcanos");
    this.addMountains();
  }
  choosePlateToGrow(power, linearStrength, plateCount) {
    const x = RandomImpl.fRand("Plate Growth");
    const curve = plateCount * Math.pow(x, power);
    const linear = plateCount * x;
    return Math.floor(VoronoiUtils.lerp(curve, linear, linearStrength));
  }
  growPlates() {
    const area = this.m_worldDims.x * this.m_worldDims.y;
    const plateCount = Math.round(this.getTypedSettings().plate.factor * 0.01 * area) + 1;
    const power = this.getTypedSettings().plate.curvePower;
    const linearStrength = this.getTypedSettings().plate.linearStrength;
    const useUniqueDiagram = this.getTypedSettings().plate.useUniqueVoronoi;
    let voronoiCellRatio = this.getTypedSettings().plate.voronoiCellRatio;
    voronoiCellRatio *= voronoiCellRatio;
    const plateRotationMultiple = this.getTypedSettings().plate.plateRotationMultiple;
    const bbox = { xl: 0, xr: this.m_worldDims.x, yt: 0, yb: this.m_worldDims.y };
    const sites = VoronoiUtils.createRandomSites(plateCount, bbox.xr, bbox.yb);
    const diagram = VoronoiUtils.computeVoronoi(sites, bbox, 5);
    let plateDiagramCells = this.m_regionCells;
    let cellKdTree = this.m_kdTree;
    if (useUniqueDiagram) {
      const cellCount = Math.floor(
        MapDims[this.m_mapSize].x * MapDims[this.m_mapSize].y * voronoiCellRatio
      );
      const sites2 = VoronoiUtils.createRandomSites(cellCount, bbox.xr, bbox.yb);
      this.m_platesDiagram = VoronoiUtils.computeVoronoi(sites2, bbox, 2);
      plateDiagramCells = this.m_platesDiagram.cells.map((cell, index) => {
        const area2 = VoronoiUtils.calculateCellArea(cell);
        const regionCell = new RegionCell(cell, index, area2);
        return regionCell;
      });
      cellKdTree = new kdTree(RegionCellPosGetter);
      cellKdTree.build(plateDiagramCells);
    } else {
      this.m_platesDiagram = void 0;
    }
    this.m_plateRegions = diagram.cells.map((cell, index) => {
      const region = new PlateRegion("Plate" + index, index, 0, bbox.xr * bbox.yb, {
        x: RandomImpl.fRand("Plate Color R"),
        y: RandomImpl.fRand("Plate Color G"),
        z: RandomImpl.fRand("Plate Color B")
      });
      region.seedLocation = { x: cell.site.x, y: cell.site.y };
      const regionCell = cellKdTree.search(region.seedLocation);
      region.considerationList.push({ id: regionCell.id, score: 1 });
      return region;
    });
    for (const region of this.m_plateRegions) {
      region.prepareGrowth(
        plateDiagramCells,
        this.m_plateRegions,
        this.m_plateRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      region.growStep();
    }
    const regionFull = new Array(plateCount).fill(false);
    let growingCount = plateCount;
    while (growingCount > 0) {
      let plateToGrow = this.choosePlateToGrow(power, linearStrength, plateCount);
      if (regionFull[plateToGrow]) {
        plateToGrow = 0;
        while (regionFull[plateToGrow]) {
          ++plateToGrow;
        }
      }
      const canGrow = this.m_plateRegions[plateToGrow].growStep();
      if (!canGrow) {
        regionFull[plateToGrow] = true;
        --growingCount;
      }
    }
    if (useUniqueDiagram) {
      for (const regionCell of this.m_regionCells) {
        const plateCell = cellKdTree.search(regionCell.cell.site);
        regionCell.plateId = plateCell?.plateId;
      }
    }
    for (const plateRegion of this.m_plateRegions) {
      plateRegion.logStats();
    }
    const plateBoundaries = [];
    for (const plateCell of plateDiagramCells) {
      plateCell.ruleConsideration = true;
      for (const neighborId of plateCell.cell.getNeighborIds()) {
        const neighbor = plateDiagramCells[neighborId];
        if (neighbor.plateId !== plateCell.plateId && !neighbor.ruleConsideration) {
          const pos = {
            x: (plateCell.cell.site.x + neighbor.cell.site.x) * 0.5,
            y: (plateCell.cell.site.y + neighbor.cell.site.y) * 0.5
          };
          const normal = VoronoiUtils.normalize({
            x: neighbor.cell.site.x - plateCell.cell.site.x,
            y: neighbor.cell.site.y - plateCell.cell.site.y
          });
          const calculateMovement = (plate, pos2) => {
            const relPos = sub2(pos2, plate.seedLocation);
            const angularMovement = plate.m_rotation * Math.PI / 180 * plateRotationMultiple;
            const rotatedPos = rotate2(relPos, angularMovement);
            const rotationMovement = sub2(relPos, rotatedPos);
            const movement = add2(rotationMovement, plate.m_movement);
            return movement;
          };
          const plate1Movement = calculateMovement(this.m_plateRegions[plateCell.plateId], pos);
          const plate2Movement = calculateMovement(this.m_plateRegions[neighbor.plateId], pos);
          const subduction = dot2(normal, plate1Movement) - dot2(normal, plate2Movement);
          const sliding = Math.abs(dot2_90(normal, plate1Movement) - dot2_90(normal, plate2Movement));
          plateBoundaries.push({
            pos,
            normal,
            plateSubduction: subduction,
            plateSliding: sliding,
            id1: plateCell.plateId,
            id2: neighbor.plateId
          });
        }
      }
    }
    this.m_plateBoundaries.build(plateBoundaries);
  }
  growLandmasses() {
    this.m_landmassRegions = this.getLandmassRegions();
    for (const region of this.m_landmassRegions) {
      region.considerationList = [];
    }
    for (let i = 1; i < this.m_landmassRegions.length; i++) {
      const cell = this.m_kdTree.search(this.m_landmassRegions[i].seedLocation);
      this.m_landmassRegions[i].considerationList.push({ id: cell.id, score: 1 });
    }
    const growingRegions = this.m_landmassRegions.slice(1);
    const quadRegion = new Aabb2({ x: 0, y: 0 }, this.m_worldDims);
    const quadTree = new QuadTree(
      quadRegion,
      (item) => item.cell.site
    );
    for (const region of growingRegions) {
      region.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_landmassRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      region.SetQuadTree(quadTree);
    }
    for (const rule of this.m_landmassRules) {
      if (rule.name == RuleAvoidOtherRegions.getName()) {
        rule.setQuadTree(quadTree);
      }
    }
    let regionIndex = 0;
    while (growingRegions.length > 0) {
      if (!growingRegions[regionIndex].growStep()) {
        growingRegions.splice(regionIndex, 1);
      } else {
        regionIndex++;
      }
      regionIndex %= growingRegions.length;
    }
    for (const region of this.m_landmassRegions.slice(1)) {
      region.logStats();
    }
  }
  growIslands() {
    const area = this.getUsableArea();
    const islandSettings = this.getTypedSettings().island;
    let islandMinSize = islandSettings.minSize;
    let islandMaxSize = islandSettings.maxSize;
    const islandCount = Math.round(islandSettings.factor * area * 0.01);
    const randsForIndices = Array.from({ length: islandCount }, () => RandomImpl.fRand("Island Index"));
    if (islandMinSize > islandMaxSize) {
      console.log("Error: Island min size is larger than max size. Capping min size to the max size");
      islandMinSize = islandMaxSize;
    }
    if (islandMinSize * islandCount > islandSettings.totalSize - islandSettings.variance) {
      console.log("Error: Island min size is too large. Capping value to total size / the number of islands.");
      islandMinSize = (islandSettings.totalSize - islandSettings.variance) / islandCount;
    }
    if (islandMaxSize * islandCount < islandSettings.totalSize + islandSettings.variance) {
      console.log("Error: Island max size is too small. Capping value to total size / the number of islands.");
      islandMaxSize = (islandSettings.totalSize + islandSettings.variance) / islandCount;
    }
    const finalTotalSize = islandSettings.totalSize + RandomImpl.fRand("Island Size Variance") * islandSettings.variance * 2 - islandSettings.variance;
    const maxMinDifference = islandMaxSize - islandMinSize;
    let randomSizeRemaining = finalTotalSize - islandMinSize * islandCount;
    const islandSizes = Array.from({ length: islandCount }, () => islandMinSize);
    for (let i = 0; i < islandSizes.length - 1; ++i) {
      const maxAdded = Math.min(maxMinDifference, randomSizeRemaining);
      const averageRandomSize = randomSizeRemaining / islandCount;
      const randomPower = Math.log(averageRandomSize / maxAdded) / Math.log(0.5);
      const randomSize = Math.pow(RandomImpl.fRand("Island Random Size"), randomPower) * maxAdded;
      randomSizeRemaining -= randomSize;
      islandSizes[i] += randomSize;
    }
    islandSizes[islandSizes.length - 1] += randomSizeRemaining;
    console.log(`Creating ${islandSizes.length} islands. Sizes: ${islandSizes}`);
    const commonIslandsRegion = new LandmassRegion(
      "Islands",
      this.m_landmassRegions.length,
      RegionType.Island,
      0,
      0,
      { x: 0.7, y: 0.7, z: 0.2 }
    );
    this.m_landmassRegions.push(commonIslandsRegion);
    const landmassesKdTree = new kdTree((data) => {
      return { x: data.cell.site.x, y: data.cell.site.y };
    });
    landmassesKdTree.build(
      this.m_regionCells.filter(
        (value) => this.m_landmassRegions[value.landmassId].type === RegionType.Landmass
      )
    );
    for (let i = 0; i < islandCount; ++i) {
      const islandKdTree = new kdTree((data) => {
        return { x: data.cell.site.x, y: data.cell.site.y };
      });
      islandKdTree.build(
        this.m_regionCells.filter(
          (value) => this.m_landmassRegions[value.landmassId].type === RegionType.Island
        )
      );
      const scoreCtx = {
        cells: this.m_regionCells,
        region: commonIslandsRegion,
        regions: this.m_landmassRegions,
        plateRegions: this.m_plateRegions,
        m_worldDims: this.m_worldDims,
        totalArea: 0,
        cellCount: 0,
        rules: this.m_islandRules
      };
      const islandSeedCandidates = [];
      for (const regionCell of this.m_regionCells) {
        const x = regionCell.cell.site.x;
        const y = regionCell.cell.site.y;
        if (x < islandSettings.meridianDistance || x > this.m_worldDims.x - islandSettings.meridianDistance || y < islandSettings.poleDistance || y > this.m_worldDims.y - islandSettings.poleDistance || regionCell.landmassId > 0)
          continue;
        const nearestLandmassCell = landmassesKdTree.search({ x, y });
        const nearestIslandCell = islandKdTree.search({ x, y });
        const distanceToLandmass = VoronoiUtils.distanceBetweenSites(
          regionCell.cell.site,
          nearestLandmassCell.cell.site
        );
        const distanceToIsland = nearestIslandCell ? VoronoiUtils.distanceBetweenSites(regionCell.cell.site, nearestIslandCell.cell.site) : 1e3;
        const nearestPlate = this.m_plateBoundaries.search(regionCell.cell.site).pos;
        const distanceToNearestPlate = Math.sqrt(
          VoronoiUtils.sqDistance(nearestPlate, regionCell.cell.site)
        );
        if (distanceToLandmass > islandSettings.landmassDistance && distanceToIsland > islandSettings.islandDistance) {
          let score = 0;
          for (const rule of this.m_islandRules) {
            if (rule.isActive) {
              score += rule.score(regionCell, scoreCtx);
            }
          }
          score *= distanceToIsland;
          islandSeedCandidates.push([score, regionCell]);
        }
      }
      if (islandSeedCandidates.length == 0) {
        console.log("Failed to find any candidate locations for island.");
        break;
      }
      islandSeedCandidates.sort((a, b) => a[0] - b[0]);
      const randomIndex = Math.floor(
        VoronoiUtils.lerp(islandSeedCandidates.length * 0.9, islandSeedCandidates.length, randsForIndices[i])
      );
      const finalIslandSize = islandSizes[i] * 0.01 * area;
      const islandRegion = new LandmassRegion(
        "Island" + String(i),
        this.m_landmassRegions.length,
        RegionType.Island,
        finalIslandSize,
        0,
        { x: 0.7, y: 0.7, z: 0.2 }
      );
      islandRegion.seedLocation = islandSeedCandidates[randomIndex][1].cell.site;
      this.m_landmassRegions.push(islandRegion);
      islandRegion.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_islandRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      islandRegion.considerationList.push({ id: islandSeedCandidates[randomIndex][1].id, score: 1 });
      while (islandRegion.growStep()) {
        continue;
      }
      islandRegion.logStats();
      this.m_landmassRegions.pop();
      this.m_regionCells.forEach((value) => {
        if (value.landmassId === islandRegion.id) {
          value.landmassId = commonIslandsRegion.id;
        }
      });
    }
  }
  growCoastalIslands() {
    const oceanCells = this.m_regionCells.filter((cell) => cell.landmassId === 0);
    for (let i = 1; i < this.m_landmassRegions.length; ++i) {
      const landmassRegion = this.m_landmassRegions[i];
      if (landmassRegion.type !== RegionType.Landmass) {
        continue;
      }
      const landmassSettings = this.getTypedSettings().landmass[i - 1];
      const coastalIslandSpawnCount = landmassSettings.coastalIslands;
      if (coastalIslandSpawnCount === 0) {
        continue;
      }
      const minLandmassRange = landmassSettings.coastalIslandsMinDistance;
      const maxLandmassRange = landmassSettings.coastalIslandsMaxDistance;
      const nearCoastCells = oceanCells.filter((cell) => {
        let nearRegion = false;
        const filterCallback = (considerCell) => {
          if (considerCell.landmassId === landmassRegion.id) {
            if (VoronoiUtils.distanceBetweenSites(cell.cell.site, considerCell.cell.site) > minLandmassRange) {
              nearRegion = true;
            } else {
              return VoronoiUtils.RegionCellFilterResult.HaltFail;
            }
          } else if (considerCell.landmassId > 0) {
            return VoronoiUtils.RegionCellFilterResult.HaltFail;
          }
          return VoronoiUtils.RegionCellFilterResult.Continue;
        };
        const filterResult = VoronoiUtils.regionCellAreaFilter(
          cell,
          this.m_regionCells,
          maxLandmassRange,
          filterCallback
        );
        return filterResult === VoronoiUtils.RegionCellFilterResult.Continue ? nearRegion : false;
      });
      console.log(
        "Checking " + nearCoastCells.length + " cells near landmass " + landmassRegion.id + " for coastal island spots"
      );
      const minOtherLandmassRange = 4;
      const islandSpawnList = nearCoastCells.filter((cell) => {
        const filterCallback = (considerCell) => {
          if (considerCell.landmassId != 0 && considerCell.landmassId != landmassRegion.id) {
            return VoronoiUtils.RegionCellFilterResult.HaltFail;
          }
          return VoronoiUtils.RegionCellFilterResult.Continue;
        };
        const filterResult = VoronoiUtils.regionCellAreaFilter(
          cell,
          this.m_regionCells,
          minOtherLandmassRange,
          filterCallback
        );
        return filterResult === VoronoiUtils.RegionCellFilterResult.Continue;
      });
      for (const rule of this.m_coastalIslandRules) {
        if (rule instanceof RuleAvoidOtherRegions) {
          const avoidOtherRegionsRule = rule;
          if (avoidOtherRegionsRule.key === "avoidSelf") {
            avoidOtherRegionsRule.configValues.regionId = landmassRegion.id;
            console.log("setting islands for landmass " + landmassRegion.id + " to slightly avoid self");
          } else if (avoidOtherRegionsRule.key === "avoidOther") {
            avoidOtherRegionsRule.configValues.regionId = landmassRegion.id === 1 ? 2 : 1;
            console.log(
              "setting islands for landmass " + landmassRegion.id + " to strongly avoid " + avoidOtherRegionsRule.configValues.regionId
            );
          }
        }
      }
      const area = this.getUsableArea();
      const coastalIslandSize = landmassSettings.coastalIslandsSize;
      let coastalIslandSizeVariance = landmassSettings.coastalIslandsSizeVariance;
      coastalIslandSizeVariance *= RandomImpl.fRand("Coastal Island Size Variance") * 2 - 1;
      const finalIslandSize = (coastalIslandSize + coastalIslandSizeVariance) * 0.01 * area;
      const coastalIslandRegion = new LandmassRegion(
        "CoastalIsland",
        this.m_landmassRegions.length,
        RegionType.CoastalIsland,
        finalIslandSize,
        0,
        { x: 0.4, y: 0.7, z: 0.2 }
      );
      coastalIslandRegion.seedLocation = landmassRegion.seedLocation;
      coastalIslandRegion.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_coastalIslandRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      console.log("Found " + islandSpawnList.length + " cells for coastal island spots");
      let scoredIslandSpawnList = [];
      for (const cell of islandSpawnList) {
        scoredIslandSpawnList.push({ cell, score: coastalIslandRegion.scoreSingleCell(cell) });
      }
      scoredIslandSpawnList.sort((a, b) => b.score - a.score);
      scoredIslandSpawnList = scoredIslandSpawnList.slice(
        0,
        Math.max(coastalIslandSpawnCount, scoredIslandSpawnList.length * 0.25)
      );
      VoronoiUtils.shuffle(scoredIslandSpawnList, coastalIslandSpawnCount);
      scoredIslandSpawnList = scoredIslandSpawnList.slice(0, coastalIslandSpawnCount);
      scoredIslandSpawnList.forEach((tuple) => {
        coastalIslandRegion.considerationList.push({ id: tuple.cell.id, score: 100 });
      });
      while (coastalIslandRegion.growStep()) {
        continue;
      }
      this.m_regionCells.forEach((cell) => {
        if (cell.landmassId == coastalIslandRegion.id) {
          cell.landmassId = landmassRegion.id;
        }
      });
    }
  }
  forcePoles() {
    for (const cell of this.m_regionCells) {
      const minDist = 2;
      if (cell.cell.site.y < minDist || cell.cell.site.y > this.m_worldDims.y - minDist) {
        cell.landmassId = 0;
      }
    }
  }
  markLandAndOcean() {
    for (const cell of this.m_regionCells) {
      cell.terrainType = cell.landmassId > 0 ? TerrainType.Flat : TerrainType.Ocean;
    }
  }
  removeLakes() {
    for (let cell of this.m_regionCells) {
      if (cell.terrainType == TerrainType.Unknown) {
        let isInlandSea = false;
        let neighboringLandmassId = 0;
        const considerationList = [cell];
        const lakeList = [];
        cell.ruleConsideration = true;
        while (considerationList.length > 0) {
          cell = considerationList.pop();
          lakeList.push(cell);
          let neighborsLand = false;
          for (const neighborId of cell.cell.getNeighborIds()) {
            const neighbor = this.m_regionCells[neighborId];
            if (!neighbor.ruleConsideration) {
              if (neighbor.terrainType == TerrainType.Unknown) {
                neighbor.ruleConsideration = true;
                considerationList.push(neighbor);
              } else {
                neighborsLand = true;
                neighboringLandmassId = neighbor.landmassId;
              }
            }
          }
          if (!neighborsLand) {
            isInlandSea = true;
          }
        }
        if (isInlandSea) {
          lakeList.forEach((cell2) => {
            cell2.ruleConsideration = false;
            cell2.terrainType = TerrainType.Ocean;
          });
        } else {
          lakeList.forEach((cell2) => {
            cell2.ruleConsideration = false;
            cell2.terrainType = TerrainType.Flat;
            cell2.landmassId = neighboringLandmassId;
          });
        }
      }
    }
  }
  addCoasts() {
    for (const region of this.m_landmassRegions) {
      if (region.id === 0) continue;
      const coastalCells = [];
      const regionCells = this.m_regionCells.filter((cell) => cell.landmassId === region.id);
      for (const regionCell of regionCells) {
        for (const neighborId of regionCell.cell.getNeighborIds()) {
          let onCoast = false;
          if (this.m_regionCells[neighborId].terrainType == TerrainType.Ocean) {
            onCoast = true;
            this.m_regionCells[neighborId].terrainType = TerrainType.Coast;
            this.m_regionCells[neighborId].landmassId = regionCell.landmassId;
          }
          if (onCoast) {
            coastalCells.push(regionCell);
          }
        }
      }
      const erosionPercent = 0.01 * (region.type === RegionType.Landmass ? this.getTypedSettings().landmass[region.id - 1].erosionPercent : this.getTypedSettings().island.erosionPercent);
      let erosionCount = 0;
      const cellsInRegion = regionCells.length;
      const cellsToErode = erosionPercent * cellsInRegion;
      VoronoiUtils.shuffle(coastalCells);
      for (let i = 0; i < coastalCells.length; ++i) {
        const cell = coastalCells[i];
        if (i < cellsToErode) {
          const neighbors = cell.cell.getNeighborIds();
          for (const neighborId of neighbors) {
            const neighbor = this.m_regionCells[neighborId];
            if (neighbor.landmassId == region.id) {
              neighbor.terrainType = TerrainType.Coast;
              neighbor.landmassId = cell.landmassId;
              ++erosionCount;
              break;
            }
          }
        }
      }
      console.log(
        "Eroded " + erosionCount + " cells on landmass " + region.id + " from a total of " + region.considerationList.length + " coasts on a landmass with " + cellsInRegion + " cells."
      );
    }
  }
  addMountains() {
    const scoreCtx = {
      cells: this.m_regionCells,
      region: this.m_landmassRegions[1],
      regions: this.m_landmassRegions,
      plateRegions: this.m_plateRegions,
      m_worldDims: this.m_worldDims,
      totalArea: 0,
      cellCount: 0,
      rules: this.m_mountainRules
    };
    for (const rule of this.m_mountainRules) {
      if (rule.isActive) {
        rule.scoreAllCells(
          (cell) => cell.terrainType == TerrainType.Flat,
          scoreCtx,
          (cell) => this.m_landmassRegions[cell.landmassId],
          rule.weight
        );
      }
    }
    const mountainSettings = this.getTypedSettings().mountain;
    const scoredCells = this.m_regionCells.filter((cell) => cell.currentScore > 0);
    scoredCells.sort((a, b) => b.currentScore - a.currentScore);
    const mountainVariance = (RandomImpl.fRand("Mountain Variance") * 2 - 1) * mountainSettings.variance;
    const percentMountains = (mountainSettings.percent + mountainVariance) * 0.01;
    const totalMountains = Math.round(scoredCells.length * percentMountains);
    const totalMountainsToConsider = totalMountains + mountainSettings.randomize * 0.01 * (scoredCells.length - totalMountains);
    let mountainCells = scoredCells.slice(0, totalMountainsToConsider);
    VoronoiUtils.shuffle(mountainCells, totalMountains);
    mountainCells = mountainCells.slice(0, totalMountains);
    mountainCells.forEach((cell) => {
      cell.terrainType = TerrainType.Mountainous;
      cell.currentScore = 0;
    });
    scoreCtx.rules = this.m_volcanoRules;
    for (const rule of this.m_volcanoRules) {
      if (rule.isActive) {
        rule.scoreCells(
          mountainCells,
          scoreCtx,
          (cell) => this.m_landmassRegions[cell.landmassId],
          rule.weight
        );
      }
    }
    const volcanoSettings = this.getTypedSettings().volcano;
    const scoredVolcanoCells = mountainCells.filter((cell) => cell.currentScore > 0);
    scoredVolcanoCells.sort((a, b) => b.currentScore - a.currentScore);
    const volcanoVariance = (RandomImpl.fRand("Volcano Variance") * 2 - 1) * volcanoSettings.variance;
    const percentVolcanos = (volcanoSettings.percent + volcanoVariance) * 0.01;
    const totalVolcanos = Math.round(mountainCells.length * percentVolcanos);
    const totalVolcanosToConsider = totalVolcanos + volcanoSettings.randomize * 0.01 * (scoredVolcanoCells.length - totalVolcanos);
    let volcanoCells = scoredVolcanoCells.slice(0, totalVolcanosToConsider);
    VoronoiUtils.shuffle(volcanoCells, totalVolcanos);
    volcanoCells = volcanoCells.slice(0, totalVolcanos);
    volcanoCells.forEach((cell) => {
      cell.terrainType = TerrainType.Volcano;
    });
    this.m_regionCells.forEach((cell) => cell.currentScore = 0);
  }
  getLandmassRegions() {
    const regions = [
      new LandmassRegion("ocean", 0, RegionType.Ocean, 0, 0, { x: 0.2, y: 0.2, z: 0.8 })
    ];
    const area = this.getUsableArea();
    const numLandmasses = this.getTypedSettings().landmass.length;
    const arcOffset = Math.PI * 2 / numLandmasses;
    const randSpawnOffset = arcOffset * RandomImpl.fRand("Landmass spawn offset");
    for (let i = 0; i < numLandmasses; ++i) {
      const landmassSettings = this.getTypedSettings().landmass[i];
      if (!landmassSettings.enabled) {
        continue;
      }
      const landmassSize = landmassSettings.size * 0.01 * area + landmassSettings.variance * 0.01 * area * RandomImpl.fRand("Landmass " + i + " size variance") - landmassSettings.variance * 0.5;
      const landmassPlayerAreas = landmassSettings.playerAreas;
      const spawnOffset = randSpawnOffset + arcOffset * i;
      let circleOffset = { x: Math.cos(spawnOffset), y: Math.sin(spawnOffset) };
      circleOffset = mul2s(circleOffset, landmassSettings.spawnCenterDistance);
      const landmass = new LandmassRegion(
        "landmass" + i,
        1 + i,
        RegionType.Landmass,
        landmassSize,
        landmassPlayerAreas,
        { x: 0, y: 0.8, z: 0 }
      );
      const halfMapDims = mul2s(this.m_worldDims, 0.5);
      landmass.seedLocation = add2(mul2(circleOffset, halfMapDims), halfMapDims);
      regions.push(landmass);
    }
    return regions;
  }
  getLandmasses() {
    return this.m_landmassRegions;
  }
  getPlates() {
    return this.m_plateRegions;
  }
  getPlatesDiagram() {
    return this.m_platesDiagram || this.m_diagram;
  }
  getUsableArea() {
    const meridianMargin = 2;
    const polarMargin = 2;
    const width = this.m_worldDims.x - meridianMargin * 2;
    const height = this.m_worldDims.y - polarMargin * 2;
    return width * height;
  }
}

export { ContinentGenerator };
//# sourceMappingURL=continent-generator.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_generators/map-generator.js">
import { kdTree } from '../kd-tree.js';
import { VoronoiUtils, MapSize, RegionCellPosGetter, RegionCell } from '../voronoi-utils.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

var GeneratorType = /* @__PURE__ */ ((GeneratorType2) => {
  GeneratorType2[GeneratorType2["Continent"] = 0] = "Continent";
  return GeneratorType2;
})(GeneratorType || {});
class GeneratorSettingConfigGroup {
  groupLabel = "";
  key = "";
  childCount;
  // define this to allow this group to contain arrays of settings.
  children = { type: "configs", data: [] };
}
class MapGenerator {
  m_defaultGeneratorSettings = {};
  m_mapSizeOverrides = VoronoiUtils.defaultEnumRecord(MapSize);
  m_generatorSettings = {};
  m_regionCells = [];
  m_diagram;
  // initialized in init()
  m_worldDims = { x: 0, y: 0 };
  m_mapSize = MapSize.Standard;
  m_kdTree = new kdTree(RegionCellPosGetter);
  init(worldDims, diagram, mapSize) {
    this.m_diagram = diagram;
    this.m_worldDims = worldDims;
    this.m_mapSize = mapSize;
    if (Object.entries(this.m_generatorSettings).length === 0) {
      this.m_generatorSettings = VoronoiUtils.clone(this.m_defaultGeneratorSettings);
    }
    VoronoiUtils.deepMerge(this.m_generatorSettings, this.m_mapSizeOverrides[this.m_mapSize]);
    this.m_regionCells = diagram.cells.map((cell, index) => {
      const area = VoronoiUtils.calculateCellArea(cell);
      const regionCell = new RegionCell(cell, index, area);
      return regionCell;
    });
    this.m_kdTree.build(this.m_regionCells);
  }
  logSettings() {
    console.log(
      "generator " + this.getType() + " for map size [" + this.m_mapSize + "] initialized with the following settings:"
    );
    const logObject = (obj, indent, lastKey = "") => {
      if (obj === null) {
        console.log(indent + "null");
      } else if (Array.isArray(obj)) {
        console.log(indent + lastKey + ": [");
        for (let i = 0; i < obj.length; ++i) {
          logObject(obj[i], indent + "  ", i.toString());
        }
        console.log(indent + "]");
      } else if (typeof obj === "object") {
        if (lastKey != "") {
          console.log(indent + lastKey + ": ");
        }
        for (const [key, value] of Object.entries(obj)) {
          if (key[0] === "_") continue;
          logObject(value, indent + "  ", key);
        }
      } else {
        console.log(indent + lastKey + ": " + obj);
      }
    };
    logObject(this.m_generatorSettings, "  ");
    console.log("Rules:");
    const rules = this.getRules();
    for (const ruleSection of Object.keys(rules)) {
      console.log("  " + ruleSection + ":");
      for (const rule of rules[ruleSection]) {
        console.log("    " + rule.name + ": weight: " + rule.weight);
        for (const [key, value] of Object.entries(rule.configValues)) {
          logObject(value, "      ", key);
        }
      }
    }
  }
  buildDefaultSettings(nodes, mapsSizeOverrides) {
    const processConfigNodes = (nodes2) => {
      const out = {};
      for (const node of nodes2) {
        if ("children" in node) {
          if (node.children.type === "configs") {
            if (node.childCount && node.childCount > 0) {
              out["_defaultChild"] = processConfigNodes(node.children.data);
              const arr = [];
              for (let i = 0; i < node.childCount; ++i) {
                arr[i] = processConfigNodes(node.children.data);
              }
              out[node.key] = arr;
            } else {
              out[node.key] = processConfigNodes(node.children.data);
            }
          }
        } else {
          out[node.key] = node.default;
        }
      }
      return out;
    };
    this.m_defaultGeneratorSettings = processConfigNodes(nodes);
    this.m_mapSizeOverrides = mapsSizeOverrides;
  }
  getRegionCells() {
    return this.m_regionCells;
  }
  getKdTree() {
    return this.m_kdTree;
  }
  getSettings() {
    return this.m_generatorSettings;
  }
  getDiagram() {
    return this.m_diagram;
  }
  getPlatesDiagram() {
    return this.m_diagram;
  }
  resetToDefault() {
    this.m_generatorSettings = VoronoiUtils.clone(this.m_defaultGeneratorSettings);
    VoronoiUtils.deepMerge(this.m_generatorSettings, this.m_mapSizeOverrides[this.m_mapSize]);
  }
}

export { GeneratorSettingConfigGroup, GeneratorType, MapGenerator };
//# sourceMappingURL=map-generator.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_maps/continents.js">
import { RandomImpl } from '../random-pcg-32.js';
import { MapDims } from '../voronoi-utils.js';
import { GeneratorType } from '../voronoi_generators/map-generator.js';
import { VoronoiMap } from './map-common.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../kd-tree.js';
import '../voronoi-builder.js';
import '../voronoi-hex.js';
import '../../../core/scripts/MathHelpers.js';
import '../heap.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../voronoi-region.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';

const continentSettings = {
  "generatorKey": 0,
  "mapConfig": {
    "totalLandmassSize": 42,
    "minLandmassSize": 16
  },
  "generatorConfig": {
    "plate": {
      "plateRotationMultiple": 5
    },
    "landmass": [
      {
        "variance": 5,
        "erosionPercent": 4,
        "coastalIslands": 12
      },
      {
        "variance": 5,
        "erosionPercent": 4,
        "coastalIslands": 12
      }
    ],
    "island": {
      "totalSize": 5.5,
      "variance": 1,
      "meridianDistance": 3,
      "landmassDistance": 5,
      "erosionPercent": 15
    },
    "mountain": {
      "percent": 12,
      "randomize": 35
    }
  },
  "rulesConfig": {
    "Plates": {
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.8,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.02,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 3
    },
    "Landmasses": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 12,
      "Cell Area.weight": 0.01,
      "Near Neighbor.weight": 0.75,
      "Near Region Seed.weight": 0.05,
      "Near Region Seed.scaleFactor": 8,
      "Neighbors In Region.weight": 0.25,
      "Neighbors In Region.preferredNeighborCount": 3.5,
      "Neighbors In Region.deviation": 1.5,
      "Near Map Center.weight": 0.05,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.minDistance": 5,
      "Avoid Other Regions.distanceFalloff": 8,
      "Avoid Other Regions.falloffCurve": 0.2,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1.5,
      "Prefer Latitude.weight": 0.76,
      "Prefer Latitude.overlap": 4,
      "Prefer Latitude.latitudes": [
        {
          "latitude": 25,
          "weight": 20
        },
        {
          "latitude": 45,
          "weight": 20
        },
        {
          "latitude": 70,
          "weight": 20
        }
      ]
    },
    "Coastal Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 5,
      "Avoid Edge.meridianFalloffCurve": 0.2,
      "Avoid Edge.avoidCorners": 12,
      "Near Neighbor.weight": 0.5,
      "Avoid Other Landmass.weight": 1,
      "Avoid Other Landmass.distanceFalloff": 2,
      "Avoid Other Landmass.regionType": 2,
      "Avoid Other Landmass.regionId": 1,
      "Avoid Own Landmass.weight": 1,
      "Avoid Own Landmass.minDistance": 1,
      "Avoid Own Landmass.distanceFalloff": 2,
      "Avoid Own Landmass.regionType": 2,
      "Avoid Own Landmass.regionId": 2,
      "Avoid Islands.weight": 1,
      "Avoid Islands.distanceFalloff": 2,
      "Avoid Islands.regionType": 3,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Region Seed.weight": 0.3,
      "Near Region Seed.scaleFactor": 15,
      "Near Region Seed.invert": 1
    },
    "Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 4,
      "Avoid Edge.poleFalloffCurve": 0.5,
      "Avoid Edge.meridianDistance": 1,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 6,
      "Cell Area.weight": 0.15,
      "Cell Area.scaleFactor": -0.2,
      "Near Neighbor.weight": 0.9,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.03,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 1.5,
      "Neighbors In Region.deviation": 0.5,
      "Near Map Center.weight": 0.04,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.falloffCurve": 0.15,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.8
    },
    "Mountains": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Near Neighbor.weight": 0.25,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 4,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1,
      "Near Plate Boundary.directionInfluence": 0.4
    },
    "Volcanoes": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Neighbors In Region.weight": 0.9,
      "Neighbors In Region.preferredNeighborCount": 0
    }
  }
};

class VoronoiContinents extends VoronoiMap {
  m_schema = {
    voronoiCellCountMultiple: {
      label: "Cell Count Multiple",
      description: "The number of voronoi cells to use relative to hexes.",
      default: 1,
      min: 0.5,
      max: 4,
      step: 0.1
    },
    voronoiRelaxationSteps: {
      label: "Cell Relaxation Steps",
      description: "The number times to relax the voronoi diagram from its original random positions.",
      default: 3,
      min: 0,
      max: 10,
      step: 1
    },
    totalLandmassSize: {
      label: "Total Landmass Size",
      description: "The total percentage of land to be taken up by the major landmasses.",
      default: 32,
      min: 20,
      max: 50,
      step: 0.25
    },
    minLandmassSize: {
      label: "Minimum Landmass Size",
      description: "The minimum size a specific landmass can be.",
      default: 12,
      min: 5,
      max: 30,
      step: 0.25
    }
  };
  m_settings;
  constructor() {
    super();
    this.m_settings = this.createDefaultSettings();
  }
  getName() {
    return "Continents";
  }
  init(mapSize) {
    this.initInternal(
      mapSize,
      GeneratorType.Continent,
      continentSettings,
      this.m_settings.voronoiCellCountMultiple,
      this.m_settings.voronoiRelaxationSteps
    );
    const generatorSettings = this.getBuilder().getGenerator().getSettings();
    const landmassCount = generatorSettings.landmass.length;
    const totalSize = this.m_settings.totalLandmassSize;
    const minSize = this.m_settings.minLandmassSize;
    const dims = MapDims[mapSize];
    const tileCount = dims.x * dims.y;
    const avgDim = dims.x + dims.y / 2;
    const landmassSeparationWidth = 4;
    const landmassSeparationTiles = avgDim * (landmassCount - 1) * landmassSeparationWidth;
    const usablePercentage = (tileCount - landmassSeparationTiles) / tileCount;
    const adjustedTotalSize = totalSize * usablePercentage;
    const adjustedMinSize = minSize * usablePercentage;
    let minTotalSize = adjustedMinSize * landmassCount;
    if (adjustedMinSize > adjustedTotalSize) {
      console.error(
        `Minimum landmass size of ${minSize} is too large to fit ${landmassCount} landmasses with less than ${totalSize} total size.`
      );
      minTotalSize = adjustedTotalSize / landmassCount;
    }
    const remaining = adjustedTotalSize - minTotalSize;
    const cuts = Array.from(
      { length: landmassCount - 1 },
      (_value, index) => RandomImpl.fRand(`Landmass ${index + 1} Size Variance`) * remaining
    );
    cuts.sort((a, b) => a - b);
    const landmassSizes = [];
    let prev = 0;
    for (const cut of cuts) {
      landmassSizes.push(cut - prev + adjustedMinSize);
      prev = cut;
    }
    landmassSizes.push(remaining - prev + adjustedMinSize);
    generatorSettings.landmass.forEach((value, index) => {
      value.size = landmassSizes[index];
    });
    const settingsConfig = this.getBuilder().getGenerator().getGeneratorSettingsConfig();
    const landmassConfig = settingsConfig.find(
      (value) => value.key == "landmass"
    );
    const sizeConfig = landmassConfig.children.data.find(
      (value) => value.key == "size"
    );
    sizeConfig.locked = true;
    this.m_builder.getGenerator().logSettings();
  }
  getSettings() {
    return this.getTypedSettings();
  }
  getTypedSettings() {
    return this.m_settings;
  }
  getSettingsConfig() {
    return this.m_schema;
  }
  getFilename() {
    return "continents.mapconfig.js";
  }
}

export { VoronoiContinents };
//# sourceMappingURL=continents.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_maps/map-common.js">
import { VoronoiBuilder } from '../voronoi-builder.js';
import { VoronoiUtils } from '../voronoi-utils.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../voronoi-hex.js';
import '../../../core/scripts/MathHelpers.js';
import '../heap.js';
import '../kd-tree.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../random-pcg-32.js';
import '../voronoi-region.js';
import '../voronoi_generators/map-generator.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

var MapType = /* @__PURE__ */ ((MapType2) => {
  MapType2[MapType2["Continents"] = 0] = "Continents";
  MapType2[MapType2["Pangaea"] = 1] = "Pangaea";
  return MapType2;
})(MapType || {});
class VoronoiMap {
  m_builder = new VoronoiBuilder();
  m_initialized = false;
  getBuilder() {
    return this.m_builder;
  }
  initInternal(mapSize, generatorType, defaultGeneratorSettings, cellCountMultiple, relaxationSteps) {
    this.m_builder.init(mapSize, generatorType, cellCountMultiple, relaxationSteps);
    if (defaultGeneratorSettings && !this.m_initialized) {
      VoronoiUtils.loadSettingsFromJson(defaultGeneratorSettings, this);
    }
    this.m_initialized = true;
  }
  createDefaultSettings() {
    const settings = {};
    for (const [key, value] of Object.entries(this.getSettingsConfig())) {
      settings[key] = value.default;
    }
    return settings;
  }
}

export { MapType, VoronoiMap };
//# sourceMappingURL=map-common.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_maps/pangaea.js">
import { GeneratorType } from '../voronoi_generators/map-generator.js';
import { VoronoiMap } from './map-common.js';
import '../kd-tree.js';
import '../voronoi-utils.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';
import '../voronoi-builder.js';
import '../voronoi-hex.js';
import '../../../core/scripts/MathHelpers.js';
import '../heap.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../voronoi-region.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';

const pangaeaSettings = {
  "generatorKey": 0,
  "mapConfig": {},
  "generatorConfig": {
    "plate": {
      "plateRotationMultiple": 5
    },
    "landmass": [
      {
        "size": 44,
        "spawnCenterDistance": 0.25,
        "coastalIslands": 20,
        "coastalIslandsSize": 3
      }
    ],
    "island": {
      "minSize": 0.15,
      "maxSize": 2.25,
      "totalSize": 6,
      "poleDistance": 3,
      "meridianDistance": 2
    },
    "mountain": {
      "percent": 12,
      "randomize": 50
    }
  },
  "rulesConfig": {
    "Plates": {
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.8,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.02,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 3
    },
    "Landmasses": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 5,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 4,
      "Avoid Edge.polePerturbationWavelength": 5,
      "Avoid Edge.meridianDistanceFalloff": 12,
      "Avoid Edge.meridianFalloffCurve": 0.3,
      "Avoid Edge.avoidCorners": 18,
      "Cell Area.weight": 0.02,
      "Cell Area.scaleFactor": -0.5,
      "Near Neighbor.weight": 0.8,
      "Near Region Seed.weight": 0.04,
      "Near Region Seed.scaleFactor": 8,
      "Neighbors In Region.weight": 0.25,
      "Neighbors In Region.preferredNeighborCount": 4,
      "Neighbors In Region.deviation": 1.5,
      "Near Map Center.weight": 0.39,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.distanceFalloff": 8,
      "Avoid Other Regions.falloffCurve": 0.2,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.7,
      "Prefer Latitude.weight": 0.76,
      "Prefer Latitude.overlap": 4,
      "Prefer Latitude.latitudes": [
        {
          "latitude": 25,
          "weight": 20
        },
        {
          "latitude": 45,
          "weight": 20
        },
        {
          "latitude": 70,
          "weight": 20
        }
      ]
    },
    "Coastal Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 12,
      "Near Neighbor.weight": 0.5,
      "Avoid Other Landmass.weight": 1,
      "Avoid Other Landmass.distanceFalloff": 2,
      "Avoid Other Landmass.regionType": 2,
      "Avoid Other Landmass.regionId": 2,
      "Avoid Own Landmass.weight": 0.63,
      "Avoid Own Landmass.minDistance": 0.9,
      "Avoid Own Landmass.distanceFalloff": 3,
      "Avoid Own Landmass.falloffCurve": 0.7,
      "Avoid Own Landmass.regionType": 2,
      "Avoid Own Landmass.regionId": 1,
      "Avoid Islands.weight": 1,
      "Avoid Islands.distanceFalloff": 2,
      "Avoid Islands.regionType": 3,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 3,
      "Near Region Seed.weight": 0.3,
      "Near Region Seed.scaleFactor": 15,
      "Near Region Seed.invert": 1
    },
    "Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 4,
      "Avoid Edge.poleFalloffCurve": 0.5,
      "Avoid Edge.meridianDistanceFalloff": 10,
      "Avoid Edge.meridianFalloffCurve": 0.3,
      "Avoid Edge.avoidCorners": 12,
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.9,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.03,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 1.5,
      "Neighbors In Region.deviation": 0.5,
      "Near Map Center.weight": 0.04,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.falloffCurve": 0.15,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.8
    },
    "Mountains": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Near Neighbor.weight": 0.25,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 4,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1,
      "Near Plate Boundary.directionInfluence": 0.4
    },
    "Volcanoes": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Neighbors In Region.weight": 0.9,
      "Neighbors In Region.preferredNeighborCount": 0
    }
  }
};

class VoronoiPangaea extends VoronoiMap {
  m_schema = {
    voronoiCellCountMultiple: {
      label: "Cell Count Multiple",
      description: "The number of voronoi cells to use relative to hexes.",
      default: 1,
      min: 0.5,
      max: 4,
      step: 0.1
    },
    voronoiRelaxationSteps: {
      label: "Cell Relaxation Steps",
      description: "The number times to relax the voronoi diagram from its original random positions.",
      default: 3,
      min: 0,
      max: 10,
      step: 1
    }
  };
  m_settings;
  constructor() {
    super();
    this.m_settings = this.createDefaultSettings();
  }
  getName() {
    return "Continents";
  }
  init(mapSize) {
    this.initInternal(
      mapSize,
      GeneratorType.Continent,
      pangaeaSettings,
      this.m_settings.voronoiCellCountMultiple,
      this.m_settings.voronoiRelaxationSteps
    );
    this.m_builder.getGenerator().logSettings();
  }
  getSettings() {
    return this.getTypedSettings();
  }
  getTypedSettings() {
    return this.m_settings;
  }
  getSettingsConfig() {
    return this.m_schema;
  }
  getFilename() {
    return "pangaea.mapconfig.js";
  }
}

export { VoronoiPangaea };
//# sourceMappingURL=pangaea.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/avoid-edge.js">
import { RandomImpl } from '../random-pcg-32.js';
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

class RuleAvoidEdge extends Rule {
  static getName() {
    return "Avoid Edge";
  }
  name = RuleAvoidEdge.getName();
  description = "This rule is used to avoid edges of the map (poles and meridian) and also contains some useful parameters to help break up the edges. It will forcibly disqualify cells that get too close, and allows for a tapering of the score as cells get closer to the edge.";
  configDefs = {
    poleDistance: {
      label: "Polar Margin",
      description: "Cells within this many hexes of either pole are excluded.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    poleDistanceFalloff: {
      label: "Poles Distance Falloff",
      description: "The distance from the poles beyond the margin at which scores will start to be reduced, gently pushing new cells away from the poles.",
      defaultValue: 6,
      min: 0,
      max: 10,
      step: 0.1
    },
    poleFalloffCurve: {
      label: "Pole Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    polePerturbationScale: {
      label: "Pole Perturbation Scale",
      description: "The maximum distance to perturb the polar margins with a sine wave.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    polePerturbationWavelength: {
      label: "Pole Perturbation Wavelength",
      description: "The wavelength of the perturbation sine wave.",
      defaultValue: 4,
      min: 1,
      max: 10,
      step: 0.1
    },
    meridianDistance: {
      label: "Meridian Margin",
      description: "Cells within this many hexes of either meridian are excluded.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    meridianDistanceFalloff: {
      label: "Meridian Distance Falloff",
      description: "The distance from the meridian beyond the margin at which scores will start to be reduced, gently pushing new cells away from the meridian.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    meridianFalloffCurve: {
      label: "Meridian Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    avoidCorners: {
      label: "Avoid Corners",
      description: "Increases the meridian falloff by this much as it approaches the poles to discourage cells from clumping up in the corners of the map.",
      defaultValue: 8,
      min: 0,
      max: 20,
      step: 0.1
    }
  };
  configValues = {
    poleDistance: this.configDefs.poleDistance.defaultValue,
    poleDistanceFalloff: this.configDefs.poleDistanceFalloff.defaultValue,
    poleFalloffCurve: this.configDefs.poleFalloffCurve.defaultValue,
    polePerturbationScale: this.configDefs.polePerturbationScale.defaultValue,
    polePerturbationWavelength: this.configDefs.polePerturbationWavelength.defaultValue,
    meridianDistance: this.configDefs.meridianDistance.defaultValue,
    meridianDistanceFalloff: this.configDefs.meridianDistanceFalloff.defaultValue,
    meridianFalloffCurve: this.configDefs.meridianFalloffCurve.defaultValue,
    avoidCorners: this.configDefs.avoidCorners.defaultValue
  };
  randomOffsetTop = 0;
  randomOffsetBottom = 0;
  prepare() {
    this.randomOffsetTop = RandomImpl.fRand("RuleAvoidEdge random offset top");
    this.randomOffsetBottom = RandomImpl.fRand("RuleAvoidEdge random offset bottom");
  }
  score(regionCell, ctx) {
    let cornerAvoidance = Math.abs(ctx.m_worldDims.y - 2 * regionCell.cell.site.y) / ctx.m_worldDims.y;
    cornerAvoidance *= cornerAvoidance * this.configValues.avoidCorners;
    const meridianDistance = Math.min(regionCell.cell.site.x, ctx.m_worldDims.x - regionCell.cell.site.x);
    const meridianDistanceHex = meridianDistance;
    const minMeridianDistance = this.configValues.meridianDistance;
    const maxMeridianDistance = this.configValues.meridianDistance + this.configValues.meridianDistanceFalloff + cornerAvoidance;
    let meridianScore = VoronoiUtils.clamp(
      VoronoiUtils.iLerp(minMeridianDistance, maxMeridianDistance, meridianDistanceHex),
      0,
      1
    );
    meridianScore = Math.pow(meridianScore, this.configValues.meridianFalloffCurve);
    if (meridianDistanceHex < minMeridianDistance) {
      meridianScore = -100;
    }
    let poleDistance = Math.min(regionCell.cell.site.y, ctx.m_worldDims.y - regionCell.cell.site.y);
    const scale = this.configValues.polePerturbationScale * 0.5;
    const wavelength = this.configValues.polePerturbationWavelength;
    const randomOffset = regionCell.cell.site.y < ctx.m_worldDims.y - regionCell.cell.site.y ? this.randomOffsetTop : this.randomOffsetBottom;
    const randomPerturbation = scale + Math.sin((regionCell.cell.site.x + randomOffset * ctx.m_worldDims.x) / wavelength) * scale;
    poleDistance -= randomPerturbation;
    const minPoleDistance = this.configValues.poleDistance;
    const maxPoleDistance = minPoleDistance + this.configValues.poleDistanceFalloff;
    let poleScore = VoronoiUtils.clamp(VoronoiUtils.iLerp(minPoleDistance, maxPoleDistance, poleDistance), 0, 1);
    poleScore = Math.pow(poleScore, this.configValues.poleFalloffCurve);
    if (poleDistance < minPoleDistance) {
      poleScore = -100;
    }
    return Math.min(meridianScore, poleScore);
  }
}

export { RuleAvoidEdge };
//# sourceMappingURL=avoid-edge.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/avoid-other-regions.js">
import { RegionType, VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleAvoidOtherRegions extends Rule {
  static getName() {
    return "Avoid Other Regions";
  }
  name = RuleAvoidOtherRegions.getName();
  description = "This rule is used to avoid other regions within some radius. Cells that are too close will be forcibly disqualified, and scores will be tapered as they get close to this minimum distance. By default any region not in the source region is filtered, but at the code level filters can be added to avoid only specific region types or region ids.";
  configDefs = {
    minDistance: {
      label: "Minimum Separation",
      description: "Cells within this many hexes of another region are excluded.",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    distanceFalloff: {
      label: "Distance Falloff",
      description: "The distance from other regions beyond the minimum at which scores will start to be reduced, gently pushing new cells away from other regions.",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    falloffCurve: {
      label: "Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    regionType: {
      label: "Region Type",
      description: "Used to only avoid a specific region type instead of all regions.",
      defaultValue: RegionType.None,
      visible: false
    },
    regionId: {
      label: "Region Id",
      description: "Used to avoid only a specific region ID.",
      defaultValue: -1,
      visible: false
    }
  };
  configValues = {
    minDistance: this.configDefs.minDistance.defaultValue,
    distanceFalloff: this.configDefs.distanceFalloff.defaultValue,
    falloffCurve: this.configDefs.falloffCurve.defaultValue,
    regionType: this.configDefs.regionType.defaultValue,
    regionId: this.configDefs.regionId.defaultValue
  };
  quadtree;
  score(regionCell, ctx) {
    const minDistance = this.configValues.minDistance;
    const minDistanceSq = minDistance * minDistance;
    const maxDistance = minDistance + this.configValues.distanceFalloff;
    const maxDistanceSq = maxDistance * maxDistance;
    let closestDistSq = maxDistanceSq;
    if (this.quadtree) {
      const filter = (item) => ctx.region.getRegionIdForCell(item) != ctx.region.id;
      const nearest = this.quadtree.nearest(regionCell.cell.site, filter, maxDistanceSq);
      if (nearest.cell) {
        closestDistSq = nearest.distSq;
      }
    } else {
      regionCell.ruleConsideration = true;
      const considerList = [regionCell.id];
      const clearList = [regionCell];
      while (considerList.length > 0) {
        const cellId = considerList.pop();
        const cell = ctx.cells[cellId];
        const distanceSq = VoronoiUtils.sqDistanceBetweenSites(regionCell.cell.site, cell.cell.site);
        if (distanceSq < closestDistSq) {
          const regionId = ctx.region.getRegionIdForCell(cell);
          let bAvoidRegion = regionId != ctx.region.id && (regionId === this.configValues.regionId || this.configValues.regionId === -1);
          bAvoidRegion = bAvoidRegion && (this.configValues.regionType === RegionType.None || ctx.regions[regionId].type == this.configValues.regionType);
          if (bAvoidRegion) {
            closestDistSq = Math.min(distanceSq, closestDistSq);
            if (closestDistSq < minDistanceSq) {
              break;
            }
          } else {
            for (const neighborId of cell.cell.getNeighborIds()) {
              const neighbor = ctx.cells[neighborId];
              if (!neighbor.ruleConsideration) {
                neighbor.ruleConsideration = true;
                clearList.push(neighbor);
                considerList.push(neighborId);
              }
            }
          }
        }
      }
      for (const cell of clearList) {
        cell.ruleConsideration = false;
      }
    }
    if (closestDistSq < minDistanceSq) {
      return -100;
    }
    const closestDist = Math.sqrt(closestDistSq);
    let score = VoronoiUtils.clamp(VoronoiUtils.iLerp(minDistance, maxDistance, closestDist), 0, 1);
    score = Math.pow(score, this.configValues.falloffCurve);
    return score;
  }
  setQuadTree(quadtree) {
    this.quadtree = quadtree;
  }
}

export { RuleAvoidOtherRegions };
//# sourceMappingURL=avoid-other-regions.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/cell-area.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleCellArea extends Rule {
  static getName() {
    return "Cell Area";
  }
  name = RuleCellArea.getName();
  description = "This is a simple rule that scores larger cells higher than smaller cells. This is primary used to add some random variation to the score.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The cell area that represents a score of 0.5. Any cell smaller will score between 0 and 0.5, and any cell larger will score between 0.5 and 1.0",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    },
    invert: {
      label: "Invert",
      description: "Invert the calculation to score smaller cells higher.",
      defaultValue: 0,
      min: 0,
      max: 1,
      step: 1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    invert: this.configDefs.invert.defaultValue
  };
  score(cell, _ctx) {
    const cellArea = VoronoiUtils.calculateCellArea(cell.cell);
    let score = cellArea / (cellArea + this.configValues.scaleFactor);
    if (this.configValues.invert > 0) {
      score = 1 - score;
    }
    return score;
  }
}

export { RuleCellArea };
//# sourceMappingURL=cell-area.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-map-center.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearMapCenter extends Rule {
  static getName() {
    return "Near Map Center";
  }
  name = RuleNearMapCenter.getName();
  description = "This is a simple rule that scores cells closer to the map center higher than cells further away.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor %",
      description: "The distance from the center as a percentage of map width that represents a score of 0.5. Any distance smaller will score between 0.5 and 1.0, and any distance larger will score between 0.0 and 0.5",
      defaultValue: 50,
      min: 0,
      max: 100,
      step: 0.1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue
  };
  score(regionCell, ctx) {
    let distanceToCenter = VoronoiUtils.sqDistance(
      { x: ctx.m_worldDims.x * 0.5, y: ctx.m_worldDims.y * 0.5 },
      { x: regionCell.cell.site.x, y: regionCell.cell.site.y }
    );
    distanceToCenter = Math.sqrt(distanceToCenter);
    let scaleFactor = this.configValues.scaleFactor * 0.01 * ctx.m_worldDims.x;
    scaleFactor *= 0.5;
    return 1 - distanceToCenter / (distanceToCenter + scaleFactor);
  }
}

export { RuleNearMapCenter };
//# sourceMappingURL=near-map-center.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-neighbor.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearNeighbor extends Rule {
  static getName() {
    return "Near Neighbor";
  }
  name = RuleNearNeighbor.getName();
  description = "This is a simple rule that scores nearby cells higher than cells farther away. This is primary used to add some random variation to the score.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The distance from a neighboring cell that represents a score of 0.5. Any distance smaller will score between 0.5 and 1.0, and any distance larger will score between 0.0 and 0.5",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue
  };
  score(regionCell, ctx) {
    let neighborDistanceScore = 1;
    for (const neighborId of regionCell.cell.getNeighborIds()) {
      const neighbor = ctx.cells[neighborId];
      if (ctx.region.getRegionIdForCell(neighbor) == ctx.region.id) {
        const neighborDistance = VoronoiUtils.distanceBetweenSites(
          regionCell.cell.site,
          neighbor.cell.site
        );
        neighborDistanceScore = Math.min(
          neighborDistanceScore,
          neighborDistance / (neighborDistance + this.configValues.scaleFactor)
        );
      }
    }
    return 1 - neighborDistanceScore;
  }
}

export { RuleNearNeighbor };
//# sourceMappingURL=near-neighbor.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-plate-boundary.js">
import { kdTree } from '../kd-tree.js';
import { PlateBoundaryPosGetter, VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearPlateBoundary extends Rule {
  static getName() {
    return "Near Plate Boundary";
  }
  name = RuleNearPlateBoundary.getName();
  description = "Scores cells based on the distance from their site to the nearest plate boundary.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The distance from a plate boundary that represents a score of 0.5. Any cell nearer to a plate boundary will score between 0.5 and 1.0, and any cell farther away will score between 0.0 and 0.5",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    directionInfluence: {
      label: "Plate Direction Influence",
      description: "How much the direction of plate movement relative to the neighboring plate influences the score.",
      defaultValue: 0.5,
      min: 0,
      max: 1,
      step: 0.05
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    directionInfluence: this.configDefs.directionInfluence.defaultValue
  };
  // This must be provided before the rule can run.
  m_plateBoundaries = new kdTree(PlateBoundaryPosGetter);
  score(regionCell, _ctx) {
    const cellPos = { x: regionCell.cell.site.x, y: regionCell.cell.site.y };
    const boundary = this.m_plateBoundaries.search(cellPos);
    const distance = Math.sqrt(VoronoiUtils.sqDistance(cellPos, boundary.pos));
    const distanceScore = 1 - distance / (distance + this.configValues.scaleFactor);
    const plateMovementScore = distanceScore * boundary.plateSubduction * 0.5;
    return VoronoiUtils.lerp(distanceScore, plateMovementScore, this.configValues.directionInfluence);
  }
}

export { RuleNearPlateBoundary };
//# sourceMappingURL=near-plate-boundary.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-region-seed.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearRegionSeed extends Rule {
  static getName() {
    return "Near Region Seed";
  }
  name = RuleNearRegionSeed.getName();
  description = "This rule scores cells nearer to the region seed higher than cells farther away.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor %",
      description: "The distance from the region seed as a percentage of map width that represents a score of 0.5. Any cell nearer to the region seed will score between 0.5 and 1.0, and any cell farther away will score between 0.0 and 0.5",
      defaultValue: 20,
      min: 0,
      max: 100,
      step: 0.1
    },
    invert: {
      label: "Invert",
      description: "Invert the calculation to prefer tile further away from the region seed.",
      defaultValue: 0,
      min: 0,
      max: 1,
      step: 1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    invert: this.configDefs.invert.defaultValue
  };
  score(regionCell, ctx) {
    let distanceToSeed = VoronoiUtils.sqDistance(
      { x: ctx.region.seedLocation.x, y: ctx.region.seedLocation.y },
      { x: regionCell.cell.site.x, y: regionCell.cell.site.y }
    );
    distanceToSeed = Math.sqrt(distanceToSeed);
    let scaleFactor = this.configValues.scaleFactor * 0.01 * ctx.m_worldDims.x;
    scaleFactor *= 0.5;
    let score = distanceToSeed / (distanceToSeed + scaleFactor);
    if (!this.configValues.invert) {
      score = 1 - score;
    }
    return score;
  }
}

export { RuleNearRegionSeed };
//# sourceMappingURL=near-region-seed.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/neighbors-in-region.js">
import { Rule } from './rules-base.js';

class RuleNeighborsInRegion extends Rule {
  static getName() {
    return "Neighbors In Region";
  }
  name = RuleNeighborsInRegion.getName();
  description = "Scores cells based on how many of their neighbors are already in the region";
  configDefs = {
    preferredNeighborCount: {
      label: "Preferred Neighbor Count",
      description: "The normal distribution used for scoring is centered on this value. Any cells with exactly this number of neighbors will score 1, everything else will be less than that.",
      defaultValue: 3,
      min: 0,
      max: 10,
      step: 0.1
    },
    deviation: {
      label: "Preferred Neighbors Deviation",
      description: "The standard deviation for the normal distribution. Higher values will score number near the preferred count higher.",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    }
  };
  configValues = {
    preferredNeighborCount: this.configDefs.preferredNeighborCount.defaultValue,
    deviation: this.configDefs.deviation.defaultValue
  };
  // Can be replaced with custom logic.
  inRegionCheck = (ctx, _thisCell, neighborCell) => {
    return ctx.region.getRegionIdForCell(neighborCell) === ctx.region.id;
  };
  score(regionCell, ctx) {
    let neighborCount = 0;
    for (const neighborId of regionCell.cell.getNeighborIds()) {
      const neighbor = ctx.cells[neighborId];
      if (this.inRegionCheck(ctx, regionCell, neighbor)) {
        neighborCount++;
      }
    }
    const x = neighborCount;
    const d = this.configValues.deviation;
    const m = this.configValues.preferredNeighborCount;
    const zScore = (x - m) / d;
    const score = Math.exp(-0.5 * zScore * zScore);
    return score;
  }
}

export { RuleNeighborsInRegion };
//# sourceMappingURL=neighbors-in-region.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/prefer-latitude.js">
import { Rule } from './rules-base.js';

class LatitudeCells {
  totalCells = 0;
  cellsPerLatitude;
  constructor(numLatitudes) {
    this.cellsPerLatitude = new Array(numLatitudes).fill(0);
  }
}
class RulePreferLatitude extends Rule {
  static getName() {
    return "Prefer Latitude";
  }
  name = RulePreferLatitude.getName();
  description = "This rule scores cells based on how much area a given region occupies at different latitudes. When it is lacking certain latitudes, then it scores cells in that are higher. When it already has plenty of cells in a latitude, those cells will be scored lower. ";
  configDefs = {
    overlap: {
      label: "Overlap %",
      description: "The amount of overlap allowed between latitudes",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    mirror: {
      label: "Mirror",
      description: "Should the preferred latitudes be mirrored across the equator",
      defaultValue: true,
      min: 0,
      max: 1,
      step: 1
    },
    latitudes: {
      label: "Latitudes",
      description: "latitude bands from -90 to +90 degrees",
      defaultValue: [],
      arrayField: {
        latitude: {
          label: "Latitude",
          description: "A latitude bands between -90 and +90 degrees",
          defaultValue: 0
        },
        weight: {
          label: "Weight %",
          description: "What percentage of this continent should be in this latitude band",
          defaultValue: 0,
          min: 0,
          max: 100,
          step: 1
        }
      }
    }
  };
  configValues = {
    overlap: this.configDefs.overlap.defaultValue,
    mirror: this.configDefs.mirror.defaultValue,
    latitudes: new Array(0)
  };
  m_latitudeBounds = [];
  m_regionLatitudeCells = /* @__PURE__ */ new Map();
  prepare() {
    super.prepare();
    this.m_latitudeBounds = [];
    this.m_regionLatitudeCells.clear();
    let previousBoundary = 0;
    const overlap = this.configValues.overlap * 0.01;
    const halfOverlap = overlap * 0.5;
    let latitudes = this.configValues.latitudes.map((value, index) => [index, value]);
    if (this.configValues.mirror) {
      latitudes = latitudes.concat(
        latitudes.map((value) => {
          return [value[0], { latitude: -value[1].latitude, weight: value[1].weight }];
        })
      );
    }
    latitudes.sort((a, b) => b[1].latitude - a[1].latitude);
    for (let i = 0; i < latitudes.length; ++i) {
      const latitudeDegrees = latitudes[i][1].latitude;
      const latitude = -latitudeDegrees / 180 + 0.5;
      const last = i === latitudes.length - 1;
      const nextBoundary = (() => {
        if (last) {
          return 1;
        } else {
          const nextLatitudeDegrees = latitudes[i + 1][1].latitude;
          const nextLatitude = -nextLatitudeDegrees / 180 + 0.5;
          const difference = nextLatitude - latitude;
          return latitude + 0.5 * difference;
        }
      })();
      const latitudeSetting = {
        min: Math.max(0, previousBoundary - halfOverlap),
        max: Math.min(1, nextBoundary + halfOverlap),
        center: latitude,
        weight: latitudes[i][1].weight * 0.01,
        index: latitudes[i][0]
      };
      this.m_latitudeBounds.push(latitudeSetting);
      previousBoundary = nextBoundary;
    }
  }
  score(regionCell, ctx) {
    let latitudeCells = this.m_regionLatitudeCells.get(ctx.region.id);
    if (!latitudeCells) {
      latitudeCells = new LatitudeCells(this.configValues.latitudes.length);
      this.m_regionLatitudeCells.set(regionCell.landmassId, latitudeCells);
    }
    const overlap = this.configValues.overlap * 0.01;
    const yPos = regionCell.cell.site.y / ctx.m_worldDims.y;
    let score = 0;
    for (let i = 0; i < this.m_latitudeBounds.length; ++i) {
      const bounds = this.m_latitudeBounds[i];
      if (yPos < bounds.min || yPos > bounds.max) continue;
      const weight = yPos < bounds.min + overlap ? (yPos - bounds.min) / overlap : yPos > bounds.max - overlap ? (bounds.max - yPos) / overlap : 1;
      const currentPercentage = (latitudeCells.cellsPerLatitude[bounds.index] ?? 0) / Math.max(latitudeCells.totalCells, 1);
      const desiredPercentage = bounds.weight;
      score += weight * Math.min(1, Math.max(0, (desiredPercentage - currentPercentage) / desiredPercentage));
    }
    return score;
  }
  notifySelectedCell(cell, ctx) {
    super.notifySelectedCell(cell, ctx);
    let latitudeCells = this.m_regionLatitudeCells.get(cell.landmassId);
    if (!latitudeCells) {
      latitudeCells = new LatitudeCells(this.configValues.latitudes.length);
      this.m_regionLatitudeCells.set(cell.landmassId, latitudeCells);
    }
    latitudeCells.totalCells++;
    const overlap = this.configValues.overlap * 0.01;
    const yPos = cell.cell.site.y / ctx.m_worldDims.y;
    for (let i = 0; i < this.m_latitudeBounds.length; ++i) {
      const bounds = this.m_latitudeBounds[i];
      if (yPos < bounds.min) break;
      if (yPos < bounds.min + overlap) {
        latitudeCells.cellsPerLatitude[bounds.index] += (yPos - bounds.min) / overlap;
      } else if (yPos < bounds.max - overlap) {
        latitudeCells.cellsPerLatitude[bounds.index] += 1;
      } else if (yPos < bounds.max) {
        latitudeCells.cellsPerLatitude[bounds.index] += (bounds.max - yPos) / overlap;
      }
    }
  }
}

export { RulePreferLatitude };
//# sourceMappingURL=prefer-latitude.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/rules-base.js">
class RuleSetting {
  isActive = false;
  weight = 0;
  record = {};
  nameOverride;
  internalConfig = {};
  key;
}
class Rule {
  key;
  description;
  isActive = false;
  weight = 1;
  notifySelectedCell(_cell, _ctx) {
  }
  initialize(config) {
    this.isActive = config.isActive;
    this.weight = config.weight;
    this.name = config.nameOverride ?? this.name;
    this.key = config.key ?? this.name;
    for (const [recordName, recordValue] of Object.entries(config.record)) {
      if (recordName in this.configValues) {
        this.configValues[recordName] = recordValue;
      }
    }
    if (config.internalConfig) {
      for (const [recordName, recordValue] of Object.entries(config.internalConfig)) {
        if (recordName in this) {
          this[recordName] = recordValue;
        } else {
          console.log("Unable to find " + recordName + " in " + this.name);
        }
      }
    }
  }
  prepare() {
  }
  // Optionally overridden
  scoreAllCells(filter, ctx, regionIdGetter, weight = 1) {
    for (const cell of ctx.cells) {
      if (filter(cell)) {
        ctx.region = regionIdGetter(cell);
        cell.currentScore += this.score(cell, ctx) * weight;
      }
    }
  }
  scoreCells(cells, ctx, regionIdGetter, weight = 1) {
    for (const cell of cells) {
      ctx.region = regionIdGetter(cell);
      cell.currentScore += this.score(cell, ctx) * weight;
    }
  }
}

export { Rule, RuleSetting };
//# sourceMappingURL=rules-base.js.map
</file>

<file path="mod/maps/base-standard/scripts/age-transition-post-load.js">
import { generateDiscoveries } from '../maps/discovery-generator.js';
import { dumpResources } from '../maps/map-debug-helpers.js';
import { removeRuralDistrict, placeRuralDistrict, getMinimumResourcePlacementModifier, shuffle, AVAILABLE_ON_ALL_LANDMASSES_ID, EAST_LAND_MASS_ID, WEST_LAND_MASS_ID, replaceIslandResources } from '../maps/map-utilities.js';
import '../maps/map-globals.js';

console.log("Loading age-transition-post-load.ts");
let g_numMajorPlayers = 0;
let g_incomingAge = 0;
function requestInitializationParameters(initParams) {
  console.log("Getting Age Transition Parameters");
  console.log("Players: ", initParams.numMajorPlayers);
  console.log("Old Age: ", initParams.outgoingAge);
  console.log("New Age: ", initParams.incomingAge);
  g_numMajorPlayers = initParams.numMajorPlayers;
  g_incomingAge = initParams.incomingAge;
  engine.call("SetAgeInitializationParameters", initParams);
}
function doMapUpdates() {
  TerrainBuilder.storeWaterData();
}
function generateTransition() {
  console.log("Generating age transition!");
  const setting = Configuration.getGameValue("AgeTransitionSettingName");
  console.log("Age Transition Setting: " + setting);
  let continuityMode = false;
  if (setting == "AGE_TRANSITION_SETTING_KEEP_MORE") {
    console.log("Using continuity setting");
    continuityMode = true;
  }
  doMapUpdates();
  const iRemovedResourcePlots = [];
  const aGeneratedResources = ResourceBuilder.getGeneratedMapResources();
  removeObsoleteResources(iRemovedResourcePlots, aGeneratedResources);
  addNewResources(iRemovedResourcePlots, aGeneratedResources);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  generateDiscoveries(iWidth, iHeight, []);
  for (let iPlayer = 0; iPlayer < g_numMajorPlayers; iPlayer++) {
    if (!Players.get(iPlayer)?.isAlive) {
      continue;
    }
    const regressedCities = regressCitiesToTowns(iPlayer);
    if (continuityMode) {
      positionUnits(iPlayer);
    } else {
      positionArmyCommanders(iPlayer);
      positionFleetCommanders(iPlayer);
    }
    capGold(iPlayer, continuityMode);
    capInfluence(iPlayer, continuityMode);
    changeCapitalCards(iPlayer);
    generateDarkAgeCards(iPlayer);
    generateDynamicVictoryCards(iPlayer);
    generateRetainCityCards(iPlayer, regressedCities);
    Players.AdvancedStart.get(iPlayer)?.dynamicCardsAddedComplete();
  }
}
function removeObsoleteResources(iRemovedResourcePlots, aGeneratedResources) {
  console.log("Removing old resources");
  const aTypesRemoved = [];
  const aCutResources = [];
  const resourcesAvailable = ResourceBuilder.getResourceCounts(-1);
  let countOnMap = 0;
  let countRemoved = 0;
  for (let i = 0; i < resourcesAvailable.length; ++i) {
    if (resourcesAvailable[i] > 0) {
      countOnMap++;
    }
  }
  const countToAdd = aGeneratedResources.length;
  console.log("Adding new resources: " + countToAdd);
  console.log("Resources already on map: " + countOnMap);
  let totalResourceToCut = countOnMap + countToAdd - countOnMap;
  if (totalResourceToCut < 0) {
    totalResourceToCut = 0;
  }
  console.log("Number of resources to cut: " + totalResourceToCut);
  const resourceToCut = ResourceBuilder.getBestMapResourceCuts(aGeneratedResources, totalResourceToCut);
  for (let iI = 0; iI < resourceToCut.length; ++iI) {
    const resourceInfo = GameInfo.Resources.lookup(resourceToCut[iI]);
    if (resourceInfo) {
      aCutResources.push(resourceInfo.$index);
    }
  }
  console.log("Cutting " + aCutResources.length + " resources");
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const iIndex = iY * iWidth + iX;
      const resource = GameplayMap.getResourceType(iX, iY);
      if (resource != ResourceTypes.NO_RESOURCE) {
        let removeResource = false;
        if (aCutResources.find((x) => x == resource)) {
          removeResource = true;
        }
        if (!removeResource && !ResourceBuilder.isResourceValidForAge(resource, g_incomingAge)) {
          removeResource = true;
        }
        if (removeResource) {
          const resourceInfo = GameInfo.Resources.lookup(resource);
          if (resourceInfo) {
            countRemoved++;
            removeRuralDistrict(iX, iY);
            ResourceBuilder.setResourceType(iX, iY, ResourceTypes.NO_RESOURCE);
            console.log(
              "Removed resource: " + Locale.compose(resourceInfo.Name) + " at (" + iX + ", " + iY + ")"
            );
            iRemovedResourcePlots.push(iIndex);
            placeRuralDistrict(iX, iY);
            const resourceType = resourceInfo.$index;
            if (!aTypesRemoved.find((x) => x == resourceType)) {
              aTypesRemoved.push(resourceType);
            }
          }
        }
      }
    }
  }
  console.log("Removed total resource locations: " + countRemoved);
  return aTypesRemoved.length;
}
function addNewResources(iRemovedResourcePlots, aGeneratedResources) {
  console.log("Adding new resources");
  const iResourceCounts = ResourceBuilder.getResourceCounts(-1);
  const aResourceTypes = [];
  for (let ridx = 0; ridx < aGeneratedResources.length; ++ridx) {
    const resourceInfo = GameInfo.Resources.lookup(aGeneratedResources[ridx]);
    if (resourceInfo && resourceInfo.Tradeable) {
      if (iResourceCounts[resourceInfo.$index] == 0) {
        aResourceTypes.push(resourceInfo.$index);
      }
    }
  }
  let iMapMinimumModifer = getMinimumResourcePlacementModifier();
  if (iMapMinimumModifer == void 0) {
    iMapMinimumModifer = 0;
  }
  const aPlacementPlots = [];
  const seed = GameplayMap.getRandomSeed() * (1 + g_incomingAge);
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const districtID = MapCities.getDistrict(iX, iY);
        if (districtID == null) {
          aPlacementPlots.push(index);
        }
      }
    }
  }
  iRemovedResourcePlots.forEach((index) => {
    if (index) {
      if (!aPlacementPlots.find((x) => x == index)) {
        aPlacementPlots.push(index);
      }
    }
  });
  shuffle(aPlacementPlots);
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const resourcesPlacedCount = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountHome = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountDistant = new Array(GameInfo.Resources.length);
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resourceWeight[resourceIdx] = 0;
    resourceRunningWeight[resourceIdx] = 0;
    resourcesPlacedCount[resourceIdx] = 0;
    importantResourceRegionalCountHome[resourceIdx] = 0;
    importantResourceRegionalCountDistant[resourceIdx] = 0;
  }
  let maxPerHemisphere = 0;
  const resourceDistribution = GameInfo.Resource_Distribution.lookup(g_incomingAge);
  if (resourceDistribution) {
    maxPerHemisphere = resourceDistribution.ResourceTypeMaxPerHemisphere;
  }
  aResourceTypes.forEach((resourceType) => {
    if (resourceType) {
      const resourceInfo = GameInfo.Resources[resourceType];
      if (resourceInfo) {
        resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
      }
    }
  });
  let iNumPlaced = 0;
  aPlacementPlots.forEach((index) => {
    if (index) {
      const kLocation = GameplayMap.getLocationFromIndex(index);
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(kLocation.x, kLocation.y) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(kLocation.x, kLocation.y) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      const resources = [];
      aResourceTypes.forEach((resourceIdx) => {
        const assignedLandmass = ResourceBuilder.getResourceLandmass(resourceIdx);
        if (assignedLandmass == AVAILABLE_ON_ALL_LANDMASSES_ID || assignedLandmass == EAST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS || assignedLandmass == WEST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
          const existingResource = GameplayMap.getResourceType(kLocation.x, kLocation.y);
          if (existingResource != ResourceTypes.NO_RESOURCE && !ResourceBuilder.isResourceClassRequiredForLegacyPath(existingResource, assignedLandmass)) {
            if (ResourceBuilder.canHaveResource(kLocation.x, kLocation.y, resourceIdx, true)) {
              resources.push(resourceIdx);
            }
          } else {
            if (ResourceBuilder.canHaveResource(kLocation.x, kLocation.y, resourceIdx, true)) {
              resources.push(resourceIdx);
            }
          }
        }
      });
      if (resources.length > 0) {
        let resourceChosen = ResourceTypes.NO_RESOURCE;
        let resourceChosenIndex = 0;
        for (let iI = 0; iI < resources.length; iI++) {
          if (resourceChosen == ResourceTypes.NO_RESOURCE) {
            resourceChosen = resources[iI];
            resourceChosenIndex = resources[iI];
          } else {
            if (resourceRunningWeight[resources[iI]] > resourceRunningWeight[resourceChosenIndex]) {
              resourceChosen = resources[iI];
              resourceChosenIndex = resources[iI];
            } else if (resourceRunningWeight[resources[iI]] == resourceRunningWeight[resourceChosenIndex]) {
              const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
              if (iRoll >= 1) {
                resourceChosen = resources[iI];
                resourceChosenIndex = resources[iI];
              }
            }
          }
        }
        if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS && importantResourceRegionalCountHome[resourceChosenIndex] < maxPerHemisphere || plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS && importantResourceRegionalCountDistant[resourceChosenIndex] < maxPerHemisphere) {
          if (resourceChosen != ResourceTypes.NO_RESOURCE) {
            ResourceBuilder.setResourceType(kLocation.x, kLocation.y, resourceChosen);
            resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
            const name = GameInfo.Resources[resourceChosenIndex].Name;
            console.log(
              "Placed " + Locale.compose(name) + " at (" + kLocation.x + ", " + kLocation.y + ")"
            );
            iNumPlaced++;
            if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS) {
              importantResourceRegionalCountHome[resourceChosenIndex]++;
            } else {
              importantResourceRegionalCountDistant[resourceChosenIndex]++;
            }
            resourcesPlacedCount[resourceChosenIndex]++;
            removeRuralDistrict(kLocation.x, kLocation.y);
            placeRuralDistrict(kLocation.x, kLocation.y);
          } else {
            console.log("Resource Type Failure");
          }
        }
      }
    }
  });
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const districtID = MapCities.getDistrict(iX, iY);
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      if (districtID == null) {
        for (let i = 0; i < resourcesPlacedCount.length; ++i) {
          const resourceToPlace = GameInfo.Resources.lookup(i);
          if (resourceToPlace) {
            const assignedLandmass = ResourceBuilder.getResourceLandmass(i);
            if (assignedLandmass != AVAILABLE_ON_ALL_LANDMASSES_ID && (assignedLandmass == EAST_LAND_MASS_ID && plotTag != PlotTags.PLOT_TAG_EAST_LANDMASS || assignedLandmass == WEST_LAND_MASS_ID && plotTag != PlotTags.PLOT_TAG_WEST_LANDMASS)) {
              continue;
            }
            const minimumPerLandMass = resourceToPlace.MinimumPerHemisphere > 0 ? resourceToPlace.MinimumPerHemisphere + iMapMinimumModifer : 0;
            if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS && importantResourceRegionalCountHome[i] < minimumPerLandMass || plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS && importantResourceRegionalCountDistant[i] < minimumPerLandMass) {
              if (resourcesPlacedCount[i] > 0 && ResourceBuilder.isResourceRequiredForAge(i)) {
                if (ResourceBuilder.canHaveResource(iX, iY, i, false)) {
                  ResourceBuilder.setResourceType(iX, iY, i);
                  const name = GameInfo.Resources.lookup(i)?.Name;
                  console.log(
                    "Force Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")"
                  );
                  plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS ? importantResourceRegionalCountHome[i]++ : importantResourceRegionalCountDistant[i]++;
                  removeRuralDistrict(iX, iY);
                  placeRuralDistrict(iX, iY);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  const ageDefinition = GameInfo.Ages.lookup(g_incomingAge);
  if (ageDefinition) {
    const mapType = Configuration.getMapValue("Name");
    for (const option of GameInfo.MapIslandBehavior) {
      if (option.MapType === mapType && option.AgeType == ageDefinition.AgeType) {
        replaceIslandResources(iWidth, iHeight, option.ResourceClassType);
      }
    }
  }
  dumpResources(iWidth, iHeight);
}
var DynamicCardTypes = /* @__PURE__ */ ((DynamicCardTypes2) => {
  DynamicCardTypes2[DynamicCardTypes2["None"] = 0] = "None";
  DynamicCardTypes2[DynamicCardTypes2["Capital"] = 1] = "Capital";
  DynamicCardTypes2[DynamicCardTypes2["City"] = 2] = "City";
  DynamicCardTypes2[DynamicCardTypes2["Commander"] = 3] = "Commander";
  DynamicCardTypes2[DynamicCardTypes2["Wonder"] = 4] = "Wonder";
  DynamicCardTypes2[DynamicCardTypes2["Gold"] = 5] = "Gold";
  DynamicCardTypes2[DynamicCardTypes2["DarkAge"] = 6] = "DarkAge";
  DynamicCardTypes2[DynamicCardTypes2["Victory"] = 7] = "Victory";
  DynamicCardTypes2[DynamicCardTypes2["Unit"] = 8] = "Unit";
  return DynamicCardTypes2;
})(DynamicCardTypes || {});
function regressCitiesToTowns(iPlayer) {
  const player = Players.get(iPlayer);
  const playerSettlements = player?.Cities?.getCityIds();
  const regressedCities = [];
  if (playerSettlements != null) {
    for (let i = 0; i < playerSettlements.length; i++) {
      const settlement = Cities.get(playerSettlements[i]);
      if (settlement != null) {
        if (!settlement.isCapital && !settlement.isTown) {
          regressedCities.push(playerSettlements[i]);
          settlement.changeHasBuildQueue(-1);
        }
      }
    }
  }
  return regressedCities;
}
function changeCapitalCards(iPlayer) {
  const capitalOptions = 2;
  const player = Players.get(iPlayer);
  let playerSettlements = player?.Cities?.getCityIds();
  let currentPlayerCapitalName = "LOC_ERROR_NO_CAPITAL_NAME";
  const currentPlayerCapital = player?.Cities?.getCapital();
  if (currentPlayerCapital != null) {
    currentPlayerCapitalName = currentPlayerCapital.name;
  }
  if (player != null && playerSettlements != null) {
    playerSettlements = playerSettlements.sort((a, b) => {
      const popA = Cities.get(a)?.population;
      const popB = Cities.get(b)?.population;
      if (popA == null) return 1;
      if (popB == null) return -1;
      return popB - popA;
    });
    let capitalName = "LOC_ERROR_NO_CAPITAL_NAME";
    const civ = GameInfo.Civilizations.lookup(player.civilizationType);
    if (civ != null) {
      capitalName = civ.CapitalName;
    }
    let cardsGenerated = 0;
    for (let i = 0; i < playerSettlements.length && cardsGenerated < capitalOptions; i++) {
      const settlement = Cities.get(playerSettlements[i]);
      if (settlement != null) {
        if (!settlement.isCapital && settlement.Trade != null && settlement.Trade.isConnectedToOwnersCapitalByLand()) {
          const card = {
            id: "CARD_AT_CHANGE_CAPITAL_" + cardsGenerated,
            name: "LOC_CARD_AT_CHANGE_CAPITAL",
            description: "LOC_CARD_AT_CHANGE_CAPITAL_DESCRIPTION\\" + settlement.name + "\\" + capitalName + "\\" + currentPlayerCapitalName,
            tooltip: "",
            iconOverride: "",
            limitID: "CARD_AT_CHANGE_CAPITAL_0",
            individualLimit: 1,
            groupLimit: 1,
            categorySortOrder: 100,
            cost: [{ category: CardCategories.CARD_CATEGORY_WILDCARD, value: 0 }],
            effects: [
              {
                id: "CARD_AT_CHANGE_CAPITAL_" + cardsGenerated,
                type: "CARD_AT_CHANGE_CAPITAL",
                name: "",
                description: "",
                amount: 1,
                special: 0,
                metadata: {
                  Type: 1 /* Capital */,
                  SettlementId: settlement.id.id
                }
              }
            ],
            aiModifierLists: []
          };
          Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
          cardsGenerated += 1;
        }
      }
    }
  }
}
function positionUnits(iPlayer) {
  const player = Players.get(iPlayer);
  if (player != null) {
    const playerUnits = player?.Units;
    if (playerUnits != null) {
      let commanderIds = playerUnits.getUnitIds();
      if (commanderIds != null) {
        commanderIds = commanderIds.filter((unitId) => {
          return Units.get(unitId)?.isCommanderUnit;
        });
        const shadows = playerUnits.getUnitShadows();
        for (const shadow of shadows) {
          const unit = createUnitFromShadowAtLocation(player, shadow, shadow.location);
          if (unit != null && shadow.isInCommander) {
            console.log("In commander");
            for (const commanderId of commanderIds) {
              const army = Armies.get(commanderId);
              console.log(
                "Locations: " + army?.location.x + "," + army?.location.y + " " + shadow.location.x + "," + shadow.location.y + " " + (army != null) + " " + (army?.location == shadow.location)
              );
              if (army != null && army.location.x == shadow.location.x && army.location.y == shadow.location.y) {
                console.log("Packing");
                army.packUnit(unit);
              }
            }
          }
        }
      }
    }
  }
}
function positionArmyCommanders(iPlayer) {
  const LAND_DOMAIN_HASH = Database.makeHash("DOMAIN_LAND");
  const CORE_CLASS_MILITARY_HASH = Database.makeHash("CORE_CLASS_MILITARY");
  const numDefensiveUnits = getNumDefenders();
  const player = Players.get(iPlayer);
  if (player != null) {
    let playerSettlements = player?.Cities?.getCityIds();
    if (playerSettlements != null && playerSettlements.length > 0) {
      playerSettlements = playerSettlements.sort((a, b) => {
        const popA = Cities.get(a)?.population;
        const popB = Cities.get(b)?.population;
        if (popA == null) return 1;
        if (popB == null) return -1;
        return popB - popA;
      });
      const cityCount = playerSettlements.length;
      console.log("Cities available ", cityCount);
      const playerUnits = player?.Units;
      if (playerUnits != null) {
        let totalUnitsCreated = 0;
        let shadows = playerUnits.getUnitShadows();
        let unitIds = player?.Units?.getUnitIds();
        if (unitIds != null) {
          unitIds.forEach((unitID) => {
            const unit = Units.get(unitID);
            if (unit != null && unit.isArmyCommander) {
              console.log("Packing commander with previous units");
              const army = Armies.get(unit.armyId);
              let packedUnits = [];
              for (let i = 0; i < shadows.length; i++) {
                if (shadows[i].location.x == unit.location.x && shadows[i].location.y == unit.location.y && shadows[i].isInCommander) {
                  console.log("Found previous packed unit");
                  packedUnits.push(i);
                }
              }
              for (let i = 0; i < packedUnits.length; i++) {
                const newUnitID = createUnitFromShadowAtLocation(
                  player,
                  shadows[packedUnits[i]],
                  unit.location
                );
                totalUnitsCreated++;
                if (newUnitID != null) {
                  console.log("Packing unit");
                  army?.packUnit(newUnitID);
                }
              }
              while (packedUnits.length > 0) {
                const index = packedUnits.pop();
                if (index != null) {
                  playerUnits.removeUnitShadowAtIndex(index);
                }
              }
              shadows = playerUnits.getUnitShadows();
            }
          });
        }
        shadows = playerUnits.getUnitShadows();
        for (let i = 0; i < shadows.length; i++) {
          console.log(JSON.stringify(shadows[i]));
        }
        let cityIndex = 0;
        for (let i = 0; i < numDefensiveUnits; i++) {
          const city = Cities.get(playerSettlements[cityIndex]);
          if (city != null) {
            const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
              city.location,
              LAND_DOMAIN_HASH,
              CORE_CLASS_MILITARY_HASH
            );
            if (shadowIndex >= 0 && shadowIndex < shadows.length) {
              createUnitFromShadowAtLocation(player, shadows[shadowIndex], city.location);
              playerUnits.removeUnitShadowAtIndex(shadowIndex);
              shadows = playerUnits.getUnitShadows();
              totalUnitsCreated++;
            } else if (totalUnitsCreated < numDefensiveUnits) {
              console.log("Spawning free unit as defender");
              player.AdvancedStart?.createDefender(
                city.location,
                Database.makeHash("UNIT_CLASS_INFANTRY")
              );
              totalUnitsCreated++;
            }
          }
          cityIndex++;
          if (cityIndex >= cityCount) {
            cityIndex = 0;
          }
        }
        unitIds = player?.Units?.getUnitIds();
        if (unitIds != null) {
          unitIds = unitIds.filter((unitId) => {
            return Units.get(unitId)?.Experience?.canEarnExperience == true && Units.get(unitId)?.isArmyCommander;
          });
          unitIds = unitIds.sort((a, b) => {
            let expA = 0;
            let expB = 0;
            const expCompA = Units.get(a)?.Experience;
            if (expCompA != null) {
              expA = expCompA.experiencePoints;
            }
            const expCompB = Units.get(b)?.Experience;
            if (expCompB != null) {
              expB = expCompB.experiencePoints;
            }
            return expB - expA;
          });
          if (unitIds.length == 0) {
            const city = Cities.get(playerSettlements[0]);
            if (city != null) {
              const commanderType = player.Units?.getBuildUnit("UNIT_ARMY_COMMANDER");
              const result = Units.create(player.id, { Type: commanderType, Location: city.location });
              if (result.Success && result.ID) {
                unitIds.push(result.ID);
              }
            }
          }
          unitIds.forEach((unitID) => {
            const unit = Units.get(unitID);
            if (unit != null && playerSettlements != null) {
              console.log(Locale.compose(unit.name));
              if (unit.isArmyCommander) {
                const army = Armies.get(unit.armyId);
                const prevArmyLocation = unit.location;
                const city = player.Cities?.findClosest(unit.location);
                if (city != null && army != null) {
                  Units.setLocation(unitID, city.location);
                  unit.setProperty("PROPERTY_CHECK_COMMANDER", true);
                  unit.setProperty("PROPERTY_KEEP_COMMANDER", true);
                  const capacityRemaining = army.combatUnitCapacity - army.unitCount;
                  for (let i = 0; i < capacityRemaining && shadows.length > 0; i++) {
                    const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
                      prevArmyLocation,
                      LAND_DOMAIN_HASH,
                      CORE_CLASS_MILITARY_HASH
                    );
                    if (shadowIndex >= 0 && shadowIndex < shadows.length) {
                      const newUnitID = createUnitFromShadowAtLocation(
                        player,
                        shadows[shadowIndex],
                        city.location
                      );
                      playerUnits.removeUnitShadowAtIndex(shadowIndex);
                      shadows = playerUnits.getUnitShadows();
                      totalUnitsCreated++;
                      if (newUnitID != null) {
                        army.packUnit(newUnitID);
                      }
                    }
                  }
                }
              }
            }
          });
        }
      }
    }
  }
}
function positionFleetCommanders(iPlayer) {
  const SEA_DOMAIN_HASH = Database.makeHash("DOMAIN_SEA");
  const CORE_CLASS_MILITARY_HASH = Database.makeHash("CORE_CLASS_MILITARY");
  const player = Players.get(iPlayer);
  if (player != null) {
    let unitIds = player?.Units?.getUnitIds();
    if (unitIds != null) {
      unitIds = unitIds.filter((unitId) => {
        return Units.get(unitId)?.Experience?.canEarnExperience == true && Units.get(unitId)?.isFleetCommander;
      });
      unitIds = unitIds.sort((a, b) => {
        let expA = 0;
        let expB = 0;
        const expCompA = Units.get(a)?.Experience;
        if (expCompA != null) {
          expA = expCompA.experiencePoints;
        }
        const expCompB = Units.get(b)?.Experience;
        if (expCompB != null) {
          expB = expCompB.experiencePoints;
        }
        return expB - expA;
      });
      const playerUnits = player?.Units;
      if (playerUnits != null) {
        let shadows = playerUnits.getUnitShadows();
        unitIds.forEach((unitID) => {
          const unit = Units.get(unitID);
          if (unit != null) {
            console.log(Locale.compose(unit.name));
            if (unit.isFleetCommander) {
              const army = Armies.get(unit.armyId);
              const locationIndex = Game.PlacementRules.getValidOceanNavalLocation(iPlayer);
              console.log("Location Index: " + locationIndex);
              if (army != null && locationIndex != -1) {
                const location = GameplayMap.getLocationFromIndex(locationIndex);
                const prevArmyLocation = unit.location;
                Units.setLocation(unitID, location);
                console.log("Location: " + JSON.stringify(location));
                unit.setProperty("PROPERTY_CHECK_COMMANDER", true);
                unit.setProperty("PROPERTY_KEEP_COMMANDER", true);
                for (let i = 0; i < army.combatUnitCapacity && shadows.length > 0; i++) {
                  const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
                    prevArmyLocation,
                    SEA_DOMAIN_HASH,
                    CORE_CLASS_MILITARY_HASH
                  );
                  if (shadowIndex >= 0 && shadowIndex < shadows.length) {
                    const newUnitID = createUnitFromShadowAtLocation(
                      player,
                      shadows[shadowIndex],
                      prevArmyLocation
                    );
                    playerUnits.removeUnitShadowAtIndex(shadowIndex);
                    shadows = playerUnits.getUnitShadows();
                    if (newUnitID != null) {
                      army.packUnit(newUnitID);
                    }
                  } else {
                    console.log("Shadow index outside of valid range");
                  }
                }
              }
            }
          }
        });
      }
    }
  }
}
function createUnitFromShadowAtLocation(player, shadow, location) {
  for (const shadowOption of GameInfo.Unit_ShadowReplacements) {
    if (Database.makeHash(shadowOption.Domain) == shadow.domainHash && Database.makeHash(shadowOption.CoreClass) == shadow.coreClassHash && Database.makeHash(shadowOption.Tag) == shadow.tagHash) {
      const buildUnit = player.Units?.getBuildUnit(shadowOption.UnitType);
      if (buildUnit != null) {
        const result = Units.create(player.id, { Type: buildUnit, Location: location, Validate: true });
        if (result.Success && result.ID) {
          return result.ID;
        }
      }
    }
  }
  return null;
}
function getNumDefenders() {
  const definition = GameInfo.Ages.lookup(Game.age);
  if (definition != null) {
    return definition.NumDefenders;
  }
  return 0;
}
function capGold(iPlayer, bContinuityMode) {
  const player = Players.get(iPlayer);
  let defaultGold = Game.EconomicRules.adjustForGameSpeed(3e3);
  if (bContinuityMode) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      defaultGold = Game.EconomicRules.adjustForGameSpeed(6e3);
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      defaultGold = Game.EconomicRules.adjustForGameSpeed(9e3);
    }
  }
  console.log("Default gold: " + defaultGold);
  const currentGold = player?.Treasury?.goldBalance;
  if (currentGold != null) {
    if (currentGold > defaultGold) {
      player?.Treasury?.changeGoldBalance(defaultGold - currentGold);
    }
  }
}
function capInfluence(iPlayer, bContinuityMode) {
  const player = Players.get(iPlayer);
  let defaultInfluence = Game.EconomicRules.adjustForGameSpeed(500);
  if (bContinuityMode) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      defaultInfluence = Game.EconomicRules.adjustForGameSpeed(800);
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      defaultInfluence = Game.EconomicRules.adjustForGameSpeed(1200);
    }
  }
  console.log("Default influence: " + defaultInfluence);
  const currentInfluence = player?.DiplomacyTreasury?.diplomacyBalance;
  if (currentInfluence != null) {
    if (currentInfluence > defaultInfluence) {
      player?.DiplomacyTreasury?.changeDiplomacyBalance(defaultInfluence - currentInfluence);
    }
  }
}
function generateDarkAgeCards(iPlayer) {
  if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
    const card = {
      id: "CARD_AT_EXP_DARK_AGE_MILITARY",
      name: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_DARK_AGE_NAME",
      description: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_DARK_AGE_DESCRIPTION",
      tooltip: "",
      iconOverride: "agecard_dark.png",
      limitID: "",
      individualLimit: 1,
      unlock: "UNLOCK_DARK_AGE_MILITARISTIC_1",
      categorySortOrder: 100,
      cost: [{ category: CardCategories.CARD_CATEGORY_DARK_AGE, value: 1 }],
      effects: [
        {
          id: "CARD_AT_EXP_DARK_AGE_ARMY",
          type: "CARD_ADD_ARMY_CAVALRY_PLUS_SIEGE",
          name: "",
          description: "",
          amount: 3,
          special: 0,
          metadata: {
            Type: 6 /* DarkAge */
          }
        },
        {
          id: "CARD_AT_EXP_DARK_AGE_LOSE_ALL_BUT_CAPITAL",
          type: "",
          name: "",
          description: "",
          amount: 1,
          special: 0,
          metadata: {
            Type: 6 /* DarkAge */
          }
        }
      ],
      aiModifierLists: ["Dark Age Armies Pseudoyields"]
    };
    Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
  }
}
function generateRetainCityCards(iPlayer, aSettlements) {
  const player = Players.get(iPlayer);
  if (player != null) {
    if (aSettlements.length > 0) {
      if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
        const card = {
          id: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC",
          name: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_GOLDEN_AGE_NAME",
          description: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_GOLDEN_AGE_DESCRIPTION",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_EXP_VICTORY_CULTURE_GOLDEN_AGE",
          individualLimit: 1,
          goldenAgeReward: true,
          categorySortOrder: 10,
          unlock: "UNLOCK_WON_ECONOMIC_VICTORY_1",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [],
          aiModifierLists: []
        };
        for (let i = 0; i < aSettlements.length; i++) {
          card.effects.push({
            id: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC_" + i,
            type: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC",
            name: "",
            description: "",
            amount: 1,
            special: 0,
            metadata: {
              Type: 2 /* City */,
              SettlementId: aSettlements[i].id
            }
          });
        }
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      } else if (Game.age == Database.makeHash("AGE_MODERN")) {
        const card = {
          id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC",
          name: "LOC_LEGACY_PATH_EXPLORATION_ECONOMIC_GOLDEN_AGE_NAME",
          description: "LOC_LEGACY_PATH_EXPLORATION_ECONOMIC_GOLDEN_AGE_DESCRIPTION",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_MOD_VICTORY_MILITARISTIC_FIRST",
          individualLimit: 1,
          goldenAgeReward: true,
          categorySortOrder: 10,
          unlock: "UNLOCK_WON_ECONOMIC_VICTORY_2",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_POPULATION",
              type: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_POPULATION",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {}
            }
          ],
          aiModifierLists: []
        };
        for (let i = 0; i < aSettlements.length; i++) {
          card.effects.push({
            id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_" + i,
            type: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC",
            name: "",
            description: "",
            amount: 1,
            special: 0,
            metadata: {
              Type: 2 /* City */,
              SettlementId: aSettlements[i].id
            }
          });
        }
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    }
  }
}
function generateDynamicVictoryCards(iPlayer) {
  const player = Players.get(iPlayer);
  if (player != null) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      let yield_multiplier = 5;
      const numberOfroutes = player.getProperty("PROPERTY_ANTIQUITY_TRADE_ROUTE_TOTAL");
      let totalYield = numberOfroutes * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
          name: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_MILESTONE_2_DESCRIPTION_DYNAMIC\\5\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          categorySortOrder: 20,
          unlock: "UNLOCK_AT_LEAST_SECOND_ECONOMIC_VICTORY_1",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
              type: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
      yield_multiplier = 1;
      const numberOfGreatWorks = player.getProperty("PROPERTY_PREVIOUS_AGE_GREAT_WORK_TOTAL");
      totalYield = numberOfGreatWorks * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
          name: "LOC_LEGACY_PATH_ANTIQUITY_SCIENCE_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_ANTIQUITY_SCIENCE_MILESTONE_2_DESCRIPTION_DYNAMIC\\1\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          unlock: "UNLOCK_AT_LEAST_SECOND_SCIENTIFIC_VICTORY_1",
          categorySortOrder: 20,
          cost: [{ category: CardCategories.CARD_CATEGORY_SCIENTIFIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
              type: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
      {
        const card = {
          id: "CARD_AT_EXP_VICTORY_MILITARISTIC_UNITS",
          name: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_GOLDEN_AGE_NAME",
          description: "",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_EXP_VICTORY_CULTURE_GOLDEN_AGE",
          individualLimit: 1,
          goldenAgeReward: true,
          unlock: "UNLOCK_WON_MILITARISTIC_VICTORY_1",
          categorySortOrder: 10,
          cost: [{ category: CardCategories.CARD_CATEGORY_MILITARISTIC, value: 2 }],
          effects: [],
          aiModifierLists: []
        };
        let totalUnits = 0;
        if (player.Cities?.getCities() != null) {
          for (const city of player.Cities?.getCities()) {
            if (city.getProperty(Database.makeHash("PROPERTY_WAS_CONQUERED"))) {
              console.log("Was conquered: " + city.name);
              card.effects.push({
                id: "CARD_EFFECT_AT_EXP_VICTORY_MILITARISTIC_UNITS" + totalUnits,
                type: "CARD_AT_EXP_VICTORY_MILITARISTIC_UNITS",
                name: "",
                description: "",
                amount: 1,
                special: 0,
                metadata: {
                  Type: 8 /* Unit */,
                  SettlementId: city.id.id
                }
              });
              totalUnits++;
            }
          }
        }
        card.description = "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_GOLDEN_AGE_DESCRIPTION_DYNAMIC\\" + totalUnits;
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      const yield_multiplier = 2;
      const numberOfGreatWorks = player.getProperty("PROPERTY_PREVIOUS_AGE_GREAT_WORK_TOTAL");
      const totalYield = numberOfGreatWorks * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
          name: "LOC_LEGACY_PATH_EXPLORATION_CULTURE_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_EXPLORATION_CULTURE_MILESTONE_2_DESCRIPTION_DYNAMIC\\2\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          unlock: "UNLOCK_AT_LEAST_SECOND_CULTURAL_VICTORY_2",
          categorySortOrder: 20,
          cost: [{ category: CardCategories.CARD_CATEGORY_CULTURAL, value: 2 }],
          effects: [
            {
              id: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
              type: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    }
  }
}
engine.on("RequestAgeInitializationParameters", requestInitializationParameters);
engine.on("GenerateAgeTransition", generateTransition);
console.log("Loaded age-transition-post-load.ts");
//# sourceMappingURL=age-transition-post-load.js.map
</file>

<file path="mod/maps/base-standard/scripts/heap.js">
class Heap {
  constructor(compare) {
    this.compare = compare;
  }
  items = [];
  get size() {
    return this.items.length;
  }
  peak() {
    return this.items[0];
  }
  push(value) {
    this.items.push(value);
    this.bubbleUp(this.items.length - 1);
  }
  pop() {
    const top = this.items[0];
    const last = this.items.pop();
    if (this.items.length > 0) {
      this.items[0] = last;
      this.bubbleDown(0);
    }
    return top;
  }
  clear() {
    this.items = [];
  }
  bubbleUp(index) {
    while (index > 0) {
      const parent = Math.floor((index - 1) / 2);
      if (this.compare(this.items[index], this.items[parent]) >= 0) break;
      [this.items[parent], this.items[index]] = [this.items[index], this.items[parent]];
      index = parent;
    }
  }
  bubbleDown(index) {
    const length = this.items.length;
    while (true) {
      const left = 2 * index + 1;
      const right = left + 1;
      let smallest = index;
      if (left < length && this.compare(this.items[left], this.items[smallest]) < 0) {
        smallest = left;
      }
      if (right < length && this.compare(this.items[right], this.items[smallest]) < 0) {
        smallest = right;
      }
      if (smallest === index) break;
      [this.items[index], this.items[smallest]] = [this.items[smallest], this.items[index]];
      index = smallest;
    }
  }
}

export { Heap };
//# sourceMappingURL=heap.js.map
</file>

<file path="mod/maps/base-standard/scripts/index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="mod/maps/base-standard/scripts/kd-tree.js">
class kdNode {
  data;
  left;
  right;
  constructor(data) {
    this.data = data;
  }
}
class kdTree {
  rootNode;
  getPos;
  constructor(getPos) {
    this.getPos = getPos;
  }
  build(data) {
    this.rootNode = this.buildInternal([...data]);
  }
  search(pos) {
    return this.searchInternal(this.rootNode, pos, 0, [], 1)[0]?.data;
  }
  searchMultiple(pos, count) {
    return this.searchInternal(this.rootNode, pos, 0, [], count).sort((a, b) => a.distSq - b.distSq);
  }
  buildInternal(data, axis = 0) {
    if (data.length === 0) return void 0;
    data.sort((a, b) => axis === 0 ? this.getPos(a).x - this.getPos(b).x : this.getPos(a).y - this.getPos(b).y);
    const midIndex = Math.floor(data.length / 2);
    const midItem = data[midIndex];
    axis = (axis + 1) % 2;
    const node = new kdNode(midItem);
    node.left = this.buildInternal(data.slice(0, midIndex), axis);
    node.right = this.buildInternal(data.slice(midIndex + 1), axis);
    return node;
  }
  searchInternal(node, pos, axis, bestList, maxCount) {
    if (!node) return bestList;
    const distSq = this.distSq(pos, this.getPos(node.data));
    if (bestList.length < maxCount) {
      bestList.push({ data: node.data, distSq });
    } else {
      let bestI = 0;
      for (let i = 1; i < bestList.length; ++i) {
        if (bestList[i].distSq > bestList[bestI].distSq) {
          bestI = i;
        }
      }
      if (bestList[bestI].distSq > distSq) {
        bestList[bestI] = { data: node.data, distSq };
      }
    }
    const diff = axis === 0 ? pos.x - this.getPos(node.data).x : pos.y - this.getPos(node.data).y;
    const nearChild = diff < 0 ? node.left : node.right;
    const farChild = diff < 0 ? node.right : node.left;
    bestList = this.searchInternal(nearChild, pos, (axis + 1) % 2, bestList, maxCount);
    const axisDistSq = diff * diff;
    const furthestDistanceSq = bestList.reduce((max, data) => Math.max(max, data.distSq), 0);
    if (axisDistSq < furthestDistanceSq) {
      bestList = this.searchInternal(farChild, pos, (axis + 1) % 2, bestList, maxCount);
    }
    return bestList;
  }
  distSq(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }
}

export { kdTree };
//# sourceMappingURL=kd-tree.js.map
</file>

<file path="mod/maps/base-standard/scripts/quadtree.js">
import { sub2, dot2, div2s, add2 } from '../../core/scripts/MathHelpers.js';
import { VoronoiUtils } from './voronoi-utils.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';

class Aabb2 {
  min = { x: 0, y: 0 };
  max = { x: 0, y: 0 };
  constructor(min, max) {
    this.min = min;
    this.max = max;
  }
  contains(pos) {
    return pos.x >= this.min.x && pos.x <= this.max.x && pos.y >= this.min.y && pos.y <= this.max.y;
  }
  size() {
    return sub2(this.max, this.min);
  }
  distSqToPoint(p) {
    const d = { x: 0, y: 0 };
    if (p.x < this.min.x) d.x = this.min.x - p.x;
    else if (p.x >= this.max.x) d.x = p.x - this.max.x;
    if (p.y < this.min.y) d.y = this.min.y - p.y;
    else if (p.y >= this.max.y) d.y = p.y - this.max.y;
    return dot2(d, d);
  }
  intersects(other) {
    return !(other.min.x >= this.max.x || other.max.x <= other.min.x || other.min.y >= this.max.y || other.max.y <= other.min.y);
  }
}
var QuadIdx = /* @__PURE__ */ ((QuadIdx2) => {
  QuadIdx2[QuadIdx2["NW"] = 0] = "NW";
  QuadIdx2[QuadIdx2["NE"] = 1] = "NE";
  QuadIdx2[QuadIdx2["SE"] = 2] = "SE";
  QuadIdx2[QuadIdx2["SW"] = 3] = "SW";
  return QuadIdx2;
})(QuadIdx || {});
class QuadTree {
  bounds;
  capacity;
  maxDepth;
  depth;
  getPos;
  items = [];
  children = null;
  constructor(bounds, getPos, capacity = 4, maxDepth = 16, depth = 0) {
    this.bounds = bounds;
    this.getPos = getPos;
    this.capacity = capacity;
    this.maxDepth = maxDepth;
    this.depth = depth;
  }
  size() {
    return this.items.length + (this.children ? this.children.reduce((a, c) => a + c.size(), 0) : 0);
  }
  insert(item) {
    if (!this.bounds.contains(this.getPos(item))) return false;
    if (!this.children) {
      if (this.items.length < this.capacity || this.depth >= this.maxDepth) {
        this.items.push(item);
        return true;
      }
      this.subdivide();
      this.items.forEach((item2) => this.insertIntoChild(item2));
      this.items.length = 0;
    }
    return this.insertIntoChild(item);
  }
  nearest(target, filter = void 0, bestDistSq = Infinity, best = null) {
    for (const item of this.items) {
      if (filter && filter(item)) {
        const d = VoronoiUtils.sqDistance(this.getPos(item), target);
        if (d < bestDistSq) {
          bestDistSq = d;
          best = item;
        }
      }
    }
    if (!this.children) {
      return { cell: best, distSq: bestDistSq };
    }
    const ordered = this.children.map((child) => ({ child, d: child.bounds.distSqToPoint(target) })).sort((a, b) => a.d - b.d);
    for (const { child, d } of ordered) {
      if (d > bestDistSq) break;
      const candidate = child.nearest(target, filter, bestDistSq, best);
      if (candidate.cell) {
        [best, bestDistSq] = [candidate.cell, candidate.distSq];
      }
    }
    return { cell: best, distSq: bestDistSq };
  }
  queryRange(range = this.bounds, out = []) {
    if (!this.bounds.intersects(range)) return out;
    for (const item of this.items) {
      if (range.contains(this.getPos(item))) out.push(item);
    }
    if (this.children) {
      for (const child of this.children) child.queryRange(range, out);
    }
    return out;
  }
  insertIntoChild(item) {
    this.children[this.childIndex(item)].insert(item);
  }
  subdivide() {
    const childDepth = this.depth + 1;
    const min = this.bounds.min;
    const hDims = div2s(this.bounds.size(), 2);
    const mins = [min, { x: min.x + hDims.x, y: min.y }, add2(min, hDims), { x: min.x, y: min.y + hDims.y }];
    const maxes = mins.map((v) => add2(v, hDims));
    const c = Array.from(
      { length: 4 },
      (_v, k) => new QuadTree(new Aabb2(mins[k], maxes[k]), this.getPos, this.capacity, this.maxDepth, childDepth)
    );
    this.children = [c[0], c[1], c[2], c[3]];
  }
  childIndex(item) {
    const center = add2(this.bounds.min, div2s(this.bounds.size(), 2));
    const pos = this.getPos(item);
    const east = pos.x >= center.x;
    const south = pos.y >= center.y;
    return south ? east ? 2 /* SE */ : 3 /* SW */ : east ? 1 /* NE */ : 0 /* NW */;
  }
}

export { Aabb2, QuadTree };
//# sourceMappingURL=quadtree.js.map
</file>

<file path="mod/maps/base-standard/scripts/random-pcg-32.js">
var RandomPCG32;
((RandomPCG322) => {
  class RandomState {
    state = 0x08f5dc87e5c07d8an;
    inc = 0x3n;
  }
  RandomPCG322.RandomState = RandomState;
  function seed(value) {
    RandomPCG322.randomPCG32State.state = 0n;
    RandomPCG322.randomPCG32State.inc = 0x3n;
    rand();
    RandomPCG322.randomPCG32State.state += BigInt(value);
    rand();
  }
  RandomPCG322.seed = seed;
  function rand() {
    const oldState = RandomPCG322.randomPCG32State.state;
    RandomPCG322.randomPCG32State.state = (oldState * 6364136223846793005n & 0xffffffffffffffffn) + RandomPCG322.randomPCG32State.inc & 0xffffffffffffffffn;
    const xorshifted = (oldState >> 18n ^ oldState) >> 27n & 0xffffffffn;
    const rot0 = oldState >> 59n & 0xffffffffn;
    const rot1 = ~rot0 + 1n & 31n;
    const output = (xorshifted >> rot0 | xorshifted << rot1) & 0xffffffffn;
    return Number(output);
  }
  RandomPCG322.rand = rand;
  function fRand(strLog) {
    return getRandomNumber(65535, strLog) / 65535;
  }
  RandomPCG322.fRand = fRand;
  function getRandomNumber(iRange, strLog) {
    if (typeof TerrainBuilder == "object" && typeof TerrainBuilder.getRandomNumber == "function") {
      return TerrainBuilder.getRandomNumber(iRange, strLog);
    } else {
      return Math.floor((rand() & 65535) * (iRange / 65536));
    }
  }
  RandomPCG322.getRandomNumber = getRandomNumber;
  function getState() {
    return { state: RandomPCG322.randomPCG32State.state, inc: RandomPCG322.randomPCG32State.inc };
  }
  RandomPCG322.getState = getState;
  function setState(state) {
    RandomPCG322.randomPCG32State.state = state.state;
    RandomPCG322.randomPCG32State.inc = state.inc;
  }
  RandomPCG322.setState = setState;
  RandomPCG322.randomPCG32State = new RandomState();
})(RandomPCG32 || (RandomPCG32 = {}));
var GameCoreRandom;
((GameCoreRandom2) => {
  const RANDOM_A = 1103515245n;
  const RANDOM_C = 12345n;
  const RANDOM_SHIFT = 16n;
  const LOG_OUTPUT = false;
  class RandomState {
    state = 0x08f5dc87e5c07d8an;
  }
  GameCoreRandom2.RandomState = RandomState;
  function seed(value) {
    GameCoreRandom2.randomState.state = BigInt(value);
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: setting seed to " + value);
    }
  }
  GameCoreRandom2.seed = seed;
  function rand() {
    GameCoreRandom2.randomState.state = RANDOM_A * GameCoreRandom2.randomState.state + RANDOM_C & 0xffffffffn;
    return GameCoreRandom2.randomState.state >> RANDOM_SHIFT & 0xffffn;
  }
  GameCoreRandom2.rand = rand;
  function fRand(strLog) {
    return getRandomNumber(65535, strLog) / 65535;
  }
  GameCoreRandom2.fRand = fRand;
  function getRandomNumber(iRange, strLog) {
    let num = 0;
    if (typeof TerrainBuilder == "object" && typeof TerrainBuilder.getRandomNumber == "function") {
      num = TerrainBuilder.getRandomNumber(iRange, strLog);
    } else {
      num = Math.floor(Number(rand()) * (iRange / 65536));
    }
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: getRandomNumber(" + iRange + ', "' + strLog + '") = ' + num);
    }
    return num;
  }
  GameCoreRandom2.getRandomNumber = getRandomNumber;
  function getState() {
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: getState() called with current state " + GameCoreRandom2.randomState.state);
    }
    return { state: GameCoreRandom2.randomState.state };
  }
  GameCoreRandom2.getState = getState;
  function setState(state) {
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: setState(" + state.state + ")");
    }
    GameCoreRandom2.randomState.state = state.state;
  }
  GameCoreRandom2.setState = setState;
  GameCoreRandom2.randomState = new RandomState();
})(GameCoreRandom || (GameCoreRandom = {}));
const RandomImpl = GameCoreRandom;

export { GameCoreRandom, RandomImpl, RandomPCG32 };
//# sourceMappingURL=random-pcg-32.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-builder.js">
import { Diagram } from '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import { VoronoiHex } from './voronoi-hex.js';
import { MapDims, VoronoiUtils } from './voronoi-utils.js';
import { ContinentGenerator } from './voronoi_generators/continent-generator.js';
import { GeneratorType } from './voronoi_generators/map-generator.js';
import '../../core/scripts/MathHelpers.js';
import './heap.js';
import './kd-tree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';
import './quadtree.js';
import './voronoi-region.js';
import './voronoi_rules/avoid-edge.js';
import './voronoi_rules/rules-base.js';
import './voronoi_rules/avoid-other-regions.js';
import './voronoi_rules/cell-area.js';
import './voronoi_rules/near-map-center.js';
import './voronoi_rules/near-neighbor.js';
import './voronoi_rules/near-plate-boundary.js';
import './voronoi_rules/near-region-seed.js';
import './voronoi_rules/neighbors-in-region.js';
import './voronoi_rules/prefer-latitude.js';

class VoronoiBuilder {
  m_generators = {
    [GeneratorType.Continent]: ContinentGenerator
  };
  m_diagram = new Diagram();
  m_diagramDims = { x: 0, y: 0 };
  m_hexDims = { x: 0, y: 0 };
  m_generator;
  m_hexTiles = new VoronoiHex();
  m_generatorType = void 0;
  constructor() {
  }
  init(mapSize, generatorType, cellCountMultiple, relaxationSteps) {
    this.m_generatorType = generatorType;
    this.m_diagramDims = { x: MapDims[mapSize].x * Math.sqrt(3) * 0.5, y: MapDims[mapSize].y * 0.75 };
    this.m_hexDims = MapDims[mapSize];
    const totalCells = MapDims[mapSize].x * MapDims[mapSize].y * cellCountMultiple;
    console.log("Initializing voronoi-builder");
    console.log("  Diagram dims: {x:" + this.m_diagramDims.x + ", y:" + this.m_diagramDims.y + "}");
    console.log("  Hex dims {x:" + this.m_hexDims.x + ", y:" + this.m_hexDims.y + "}");
    console.log("  Total cells: " + totalCells + ", relaxed " + relaxationSteps + " times.");
    this.buildVoronoi(this.m_diagramDims.x, this.m_diagramDims.y, totalCells, relaxationSteps);
    console.log("  voronoi built...");
    const newGenerator = new this.m_generators[generatorType]();
    console.log("  generator created...");
    if (!this.m_generator || this.m_generator.constructor.name != newGenerator.constructor.name) {
      this.m_generator = newGenerator;
    }
    this.m_generator.init(this.m_diagramDims, this.m_diagram, mapSize);
    console.log("  generator initialized...");
  }
  simulate() {
    this.m_generator.simulate();
    this.m_hexTiles.init(this.m_generator, this.m_hexDims.x, this.m_hexDims.y);
    this.m_hexTiles.validate();
  }
  createMajorPlayerAreas(valueFunction) {
    const playerLandmasses = [];
    for (const landmass of this.m_generator.getLandmasses()) {
      if (landmass.playerAreas > 0) {
        playerLandmasses.push(landmass);
      }
    }
    this.m_hexTiles.createMajorPlayerAreas(playerLandmasses, valueFunction);
  }
  getDiagram() {
    return this.m_diagram;
  }
  getGenerator() {
    return this.m_generator;
  }
  getGeneratorType() {
    return this.m_generatorType;
  }
  getTiles() {
    return this.m_hexTiles.getTiles();
  }
  buildVoronoi(width, height, cellCount, relaxationSteps) {
    const bbox = { xl: 0, xr: width, yt: 0, yb: height };
    const sites = VoronoiUtils.createRandomSites(cellCount, width, height);
    this.m_diagram = VoronoiUtils.computeVoronoi(sites, bbox, relaxationSteps);
  }
}

export { VoronoiBuilder };
//# sourceMappingURL=voronoi-builder.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-hex.js">
import { rotate2, add2 } from '../../core/scripts/MathHelpers.js';
import { Heap } from './heap.js';
import { kdTree } from './kd-tree.js';
import { TerrainType, BiomeType, DetailsType, VoronoiUtils } from './voronoi-utils.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';

class HexTile {
  pos = { x: 0, y: 0 };
  coord = { x: 0, y: 0 };
  plateId = -1;
  landmassId = -1;
  elevation = 0;
  majorPlayerRegionId = -1;
  terrainType = TerrainType.Unknown;
  biomeType = BiomeType.Unknown;
  detailsType = DetailsType.None;
  visited = 0;
  // used during map creation and processing.
  isLand() {
    return this.terrainType === TerrainType.Flat || this.terrainType === TerrainType.Mountainous || this.terrainType === TerrainType.Volcano || this.terrainType === TerrainType.Rough;
  }
  isWater() {
    return this.terrainType === TerrainType.Ocean || this.terrainType === TerrainType.Coast || this.terrainType === TerrainType.NavRiver;
  }
}
var FloodFillResult = /* @__PURE__ */ ((FloodFillResult2) => {
  FloodFillResult2[FloodFillResult2["Include"] = 0] = "Include";
  FloodFillResult2[FloodFillResult2["Exclude"] = 1] = "Exclude";
  FloodFillResult2[FloodFillResult2["Halt"] = 2] = "Halt";
  return FloodFillResult2;
})(FloodFillResult || {});
class VoronoiHex {
  static POLE_MARGIN = 2;
  // guaranteed rows of ocean near poles.
  m_tiles = [];
  m_wrappedXIndices = [];
  // Saves lots of % calls
  init(generator, width, height) {
    this.m_wrappedXIndices = Array.from({ length: width * 3 }, (_, index) => index % width);
    const tree = generator.getKdTree();
    const yOffset = 0.325;
    this.m_tiles = new Array(height);
    const offsetPoint = { x: 0.736 * 0.5, y: 0 };
    const offsetPoints = [{ x: 0, y: 0 }];
    for (let i = 0; i < 6; ++i) {
      offsetPoints.push(rotate2(offsetPoint, i * Math.PI / 3));
    }
    for (let y = 0; y < height; ++y) {
      this.m_tiles[y] = new Array(width);
      const xOffset = y % 2 == 0 ? 0 : Math.sqrt(3) * 0.25;
      for (let x = 0; x < width; ++x) {
        const center = { x: xOffset + x * Math.sqrt(3) * 0.5, y: yOffset + y * 0.75 };
        const getRegionCellKey = (cell) => {
          return `${cell.terrainType}`;
        };
        const regionCells = /* @__PURE__ */ new Map();
        for (const offsetPos of offsetPoints) {
          const samplePos = add2(offsetPos, center);
          const regionCell = tree.search(samplePos);
          if (regionCell) {
            const regionCellKey = getRegionCellKey(regionCell);
            const entry = regionCells.get(regionCellKey);
            if (entry) {
              entry[0]++;
            } else {
              regionCells.set(regionCellKey, [1, regionCell]);
            }
          }
        }
        let dominantCell = null;
        let maxCount = 0;
        for (const [_key, [count, cell]] of regionCells) {
          if (count > maxCount) {
            dominantCell = cell;
            maxCount = count;
          }
        }
        const hexTile = new HexTile();
        if (dominantCell) {
          hexTile.pos = center;
          hexTile.coord = { x, y };
          hexTile.plateId = dominantCell.plateId;
          hexTile.landmassId = dominantCell.landmassId;
          hexTile.terrainType = dominantCell.terrainType;
          hexTile.biomeType = dominantCell.biomeType;
          hexTile.detailsType = dominantCell.detailsType;
        }
        this.m_tiles[y][x] = hexTile;
      }
    }
  }
  // returns neighbors in clockwise order starting from upper-right. Tiles may be undefined if near poles. Wraps in x.
  getNeighbors(tile) {
    return this.getNeighborsOfArr(tile.coord, this.m_tiles);
  }
  EvenRowDeltas = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1]
  ];
  OddRowDeltas = [
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 0],
    [0, -1]
  ];
  getNeighborsOfArr(coord, arr) {
    const deltas = coord.y % 2 === 0 ? this.EvenRowDeltas : this.OddRowDeltas;
    return deltas.map(([dx, dy]) => {
      const ny = coord.y + dy;
      if (ny < 0 || ny >= arr.length) return void 0;
      const nx = coord.x + dx + arr[0].length;
      return arr[ny][this.m_wrappedXIndices[nx]];
    });
  }
  validate() {
    this.validatePoles();
    this.validateCoasts();
    this.removeLakes();
    this.removeAdjacentVolcanoes();
    this.removeBridgingCoasts();
  }
  validatePoles() {
    for (let y = 0; y < VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        tile.terrainType = TerrainType.Ocean;
      }
    }
    for (let y = this.m_tiles.length - VoronoiHex.POLE_MARGIN; y < this.m_tiles.length; ++y) {
      for (const tile of this.m_tiles[y]) {
        tile.terrainType = TerrainType.Ocean;
      }
    }
  }
  validateCoasts() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType !== TerrainType.Ocean && tile.terrainType !== TerrainType.Coast) {
          const neighbors = this.getNeighbors(tile);
          for (const neighbor of neighbors) {
            if (neighbor && neighbor.terrainType === TerrainType.Ocean) {
              neighbor.terrainType = TerrainType.Coast;
              neighbor.landmassId = tile.landmassId;
            }
          }
        }
      }
    }
  }
  removeLakes() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType === TerrainType.Coast && !tile.visited) {
          let foundOcean = false;
          let landmassId = 0;
          const floodTiles = this.floodFill(tile, (tile2) => {
            if (tile2.terrainType === TerrainType.Coast) {
              return 0 /* Include */;
            } else if (tile2.terrainType === TerrainType.Ocean) {
              foundOcean = true;
            } else if (tile2.terrainType === TerrainType.Flat) {
              landmassId = tile2.landmassId;
            }
            return 1 /* Exclude */;
          });
          if (!foundOcean) {
            for (const tile2 of floodTiles) {
              tile2.terrainType = TerrainType.Flat;
              tile2.landmassId = landmassId;
            }
          }
        }
      }
    }
    this.clearVisited();
  }
  removeAdjacentVolcanoes() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType === TerrainType.Volcano) {
          for (const neighbor of this.getNeighbors(tile)) {
            if (neighbor?.terrainType === TerrainType.Volcano) {
              tile.terrainType = TerrainType.Mountainous;
            }
          }
        }
      }
    }
  }
  removeBridgingCoasts() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType === TerrainType.Coast) {
          let allNeighborsAreWater = true;
          let hasForeignNeighbor = false;
          for (const neighbor of this.getNeighbors(tile)) {
            if (neighbor?.terrainType !== TerrainType.Coast && neighbor?.terrainType !== TerrainType.Ocean) {
              allNeighborsAreWater = false;
              break;
            }
            if (neighbor.landmassId != tile.landmassId && neighbor.landmassId != 0) {
              hasForeignNeighbor = true;
            }
          }
          if (allNeighborsAreWater && hasForeignNeighbor) {
            tile.landmassId = 0;
            tile.terrainType = TerrainType.Ocean;
          }
        }
      }
    }
  }
  createMajorPlayerAreas(landmasses, valueFunction) {
    console.log("Creating major player regions...");
    const detailedLogs = false;
    VoronoiUtils.performanceMarker("createMajorPlayerAreas - Begin");
    for (const landmass of landmasses) {
      console.log(`Requesting ${landmass.playerAreas} player areas on landmass ${landmass.id}`);
      if (landmass.playerAreas == 0) continue;
      let landmassTiles = this.m_tiles.flatMap(
        (row) => row.filter((tile) => tile.landmassId === landmass.id)
      );
      const tileIsPassable = (tile) => {
        return tile.terrainType != TerrainType.Mountainous && tile.terrainType != TerrainType.Volcano && tile.terrainType != TerrainType.Ocean;
      };
      const floodBucket = [];
      for (const tile of landmassTiles) {
        if (!tile.visited) {
          floodBucket.push(
            this.floodFill(
              tile,
              (tile2) => tileIsPassable(tile2) ? 0 /* Include */ : 1 /* Exclude */
            )
          );
        }
      }
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        tile.majorPlayerRegionId = -1;
      });
      landmassTiles = floodBucket.sort((a, b) => b.length - a.length)[0];
      if (landmass.playerAreas == 1) {
        landmassTiles.forEach((tile) => tile.majorPlayerRegionId = 0);
        continue;
      }
      const landmassKdTree = new kdTree((tile) => tile.pos);
      landmassKdTree.build(landmassTiles);
      class SeedTile {
        tile;
        count;
      }
      const seedTiles = new Array(landmass.playerAreas);
      for (let i = 0; i < landmass.playerAreas; ++i) {
        seedTiles[i] = {
          tile: landmassTiles[i * Math.floor(landmassTiles.length / landmass.playerAreas)],
          count: 0
        };
      }
      const getAverageRegionPositions = (seedTiles2) => {
        for (let j = 0; j < seedTiles2.length; ++j) {
          const totalPos = { x: 0, y: 0 };
          const tilesForSeed = landmassTiles.filter((tile) => tile.majorPlayerRegionId == j);
          tilesForSeed.forEach((tile) => {
            totalPos.x += tile.pos.x;
            totalPos.y += tile.pos.y;
          });
          const averagePos = {
            x: totalPos.x / tilesForSeed.length,
            y: totalPos.y / tilesForSeed.length
          };
          seedTiles2[j] = { tile: landmassKdTree.search(averagePos), count: 0 };
        }
      };
      const relaxationSteps = 10;
      let lastSizeDiff = Infinity;
      for (let i = 0; i < relaxationSteps; ++i) {
        for (const tile of landmassTiles) {
          let bestRegion = 0;
          let closestDistSq = VoronoiUtils.sqDistance(seedTiles[0].tile.pos, tile.pos);
          for (let j = 1; j < seedTiles.length; ++j) {
            const distSq = VoronoiUtils.sqDistance(seedTiles[j].tile.pos, tile.pos);
            if (distSq < closestDistSq) {
              bestRegion = j;
              closestDistSq = distSq;
            }
          }
          tile.majorPlayerRegionId = bestRegion;
          ++seedTiles[bestRegion].count;
        }
        const counts = seedTiles.map((seedTile) => seedTile.count);
        const sizeDiff = Math.max(...counts) - Math.min(...counts);
        if (detailedLogs) {
          console.log("Player region sizes: " + counts.join(", ") + ". Total size difference: " + sizeDiff);
        }
        if (Math.abs(lastSizeDiff - sizeDiff) < 5) {
          break;
        }
        lastSizeDiff = sizeDiff;
        getAverageRegionPositions(seedTiles);
      }
      landmassTiles.forEach((tile) => tile.majorPlayerRegionId = -1);
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - K-means clustering done");
      class ScoredTile {
        tile;
        scores = new Array(playerRegions.length).fill(-1);
        expScores = new Array(playerRegions.length).fill(-1);
        expSum = 0;
        constructor(tile) {
          this.tile = tile;
        }
      }
      class MajorPlayerRegion {
        id = 0;
        totalValue = 0;
        centerPos = { x: 0, y: 0 };
        considerationHeap;
        finalSet = /* @__PURE__ */ new Set();
        borderSet = Array.from({ length: landmass.playerAreas }, () => /* @__PURE__ */ new Set());
      }
      const playerRegions = Array.from({ length: seedTiles.length }, () => new MajorPlayerRegion());
      const scoredTiles = this.m_tiles.map((row) => row.map((item) => new ScoredTile(item)));
      const getScoredTile = (tile) => scoredTiles[tile.coord.y][tile.coord.x];
      const getTileCost = (tile) => {
        return [TerrainType.Coast, TerrainType.NavRiver, TerrainType.Rough].includes(tile.terrainType) ? 2 : 1;
      };
      for (let playerRegionId = 0; playerRegionId < playerRegions.length; ++playerRegionId) {
        const playerRegionBit = 1 << playerRegionId;
        const initialTile = getScoredTile(seedTiles[playerRegionId].tile);
        initialTile.scores[playerRegionId] = 0;
        const considerationHeap = new Heap(
          (a, b) => a.scores[playerRegionId] - b.scores[playerRegionId]
        );
        considerationHeap.push(initialTile);
        while (considerationHeap.size > 0) {
          const bestTile = considerationHeap.pop();
          for (const neighbor of this.getNeighbors(bestTile.tile)) {
            if (neighbor && (neighbor.visited & playerRegionBit) == 0) {
              neighbor.visited |= playerRegionBit;
              const scoredNeighbor = getScoredTile(neighbor);
              scoredNeighbor.scores[playerRegionId] = bestTile.scores[playerRegionId] + getTileCost(neighbor);
              considerationHeap.push(scoredNeighbor);
            }
          }
        }
      }
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        const scoredTile = getScoredTile(tile);
        const softMaxTemp = 5;
        scoredTile.expScores = scoredTile.scores.map((s) => Math.exp(-s / softMaxTemp));
        scoredTile.expSum = scoredTile.expScores.reduce((a, b) => a + b, 0);
      });
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Scoring Done");
      let majorPlayerRegionId = 0;
      for (const region of playerRegions) {
        const seedTile = seedTiles[majorPlayerRegionId].tile;
        const scoredSeedTile = getScoredTile(seedTile);
        scoredSeedTile.scores[majorPlayerRegionId] = 0;
        scoredSeedTile.tile.visited = 1 << majorPlayerRegionId;
        region.id = majorPlayerRegionId;
        region.considerationHeap = new Heap((a, b) => {
          const scoreA = a.expScores[region.id] / a.expSum;
          const scoreB = b.expScores[region.id] / b.expSum;
          return scoreB - scoreA;
        });
        region.considerationHeap.push(scoredSeedTile);
        region.centerPos = seedTile.pos;
        ++majorPlayerRegionId;
      }
      const scoringRegions = [...playerRegions];
      while (scoringRegions.length > 0) {
        for (const scoringRegion of scoringRegions) {
          let bestTile = void 0;
          while (bestTile === void 0 && scoringRegion.considerationHeap.size > 0) {
            bestTile = scoringRegion.considerationHeap.pop();
            if (bestTile.tile.majorPlayerRegionId != -1) {
              bestTile = void 0;
            }
          }
          if (bestTile === void 0) {
            scoringRegions.splice(scoringRegions.indexOf(scoringRegion), 1);
            continue;
          }
          bestTile.tile.majorPlayerRegionId = scoringRegion.id;
          scoringRegion.finalSet.add(bestTile.tile);
          const regionBit = 1 << scoringRegion.id;
          for (const neighbor of this.getNeighborsOfArr(bestTile.tile.coord, scoredTiles)) {
            if (neighbor?.tile.majorPlayerRegionId == -1 && (neighbor.tile.visited & regionBit) == 0) {
              neighbor.tile.visited |= regionBit;
              if (tileIsPassable(neighbor.tile)) {
                scoringRegion.considerationHeap.push(neighbor);
              }
            }
          }
        }
      }
      const getTileValue = valueFunction ? valueFunction : (tile) => {
        switch (tile.terrainType) {
          case TerrainType.Coast:
            return 0.5;
          default:
            return 1;
        }
      };
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        if (tile.majorPlayerRegionId >= 0) {
          playerRegions[tile.majorPlayerRegionId].totalValue += getTileValue(tile);
        }
      });
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Initial Growth Done");
      console.log(
        `After initial growth, region sizes are: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] and vales are: [${playerRegions.map((region) => region.totalValue).join(", ")}]`
      );
      class Border {
        regionId1 = -1;
        regionId2 = -1;
        count = 1;
        constructor(regionId1, regionId2) {
          [this.regionId1, this.regionId2] = [regionId1, regionId2];
          this.count = 1;
        }
        regionValueDiff() {
          return Math.abs(
            //playerRegions[this.regionId1].finalSet.size - playerRegions[this.regionId2].finalSet.size,
            playerRegions[this.regionId1].totalValue - playerRegions[this.regionId2].totalValue
          );
        }
        isSame(regionId1, regionId2) {
          return this.regionId1 == regionId1 && this.regionId2 == regionId2 || this.regionId2 == regionId1 && this.regionId1 == regionId2;
        }
        getOrderedRegions() {
          return playerRegions[this.regionId1].totalValue < playerRegions[this.regionId2].totalValue ? [this.regionId1, this.regionId2] : [this.regionId2, this.regionId1];
        }
      }
      const borders = [];
      const addBorder = (regionId1, regionId2) => {
        const existingBorder = borders.find(
          (border) => border.isSame(regionId1, regionId2)
        );
        if (existingBorder) {
          ++existingBorder.count;
        } else {
          borders.push(new Border(regionId1, regionId2));
        }
      };
      const getBorderNeighbors = (tile) => {
        const borderNeighbors = [];
        for (const neighbor of this.getNeighbors(tile)) {
          if (neighbor && neighbor.majorPlayerRegionId != -1 && neighbor.majorPlayerRegionId != tile.majorPlayerRegionId) {
            borderNeighbors.push(neighbor);
          }
        }
        return borderNeighbors;
      };
      const isBridgeForRegion = (tile) => {
        const regions = this.getNeighbors(tile).map(
          (n) => n == void 0 || n.majorPlayerRegionId != tile.majorPlayerRegionId ? 0 : 1
        );
        let lastRegionId = regions[0];
        let nonRegionBlobs = 1 - lastRegionId;
        let regionBlobs = lastRegionId;
        for (let i = 1; i < regions.length; ++i) {
          const regionId = regions[i];
          if (lastRegionId == 0 && regionId == 1) ++regionBlobs;
          else if (lastRegionId == 1 && regionId == 0) ++nonRegionBlobs;
          lastRegionId = regionId;
        }
        return nonRegionBlobs > 1 && regionBlobs > 1;
      };
      for (const tile of landmassTiles) {
        if (tile.majorPlayerRegionId == -1) {
          continue;
        }
        const region = playerRegions[tile.majorPlayerRegionId];
        const borderNeighbors = getBorderNeighbors(tile);
        for (const neighbor of borderNeighbors) {
          region.borderSet[neighbor.majorPlayerRegionId].add(tile);
          addBorder(tile.majorPlayerRegionId, neighbor.majorPlayerRegionId);
        }
      }
      const borderSorter = (a, b) => {
        return b.regionValueDiff() - a.regionValueDiff();
      };
      borders.sort(borderSorter);
      if (borders.length === 0) {
        console.warn(
          "No borders found between player regions, unable to balance the size of player starting areas."
        );
        return;
      }
      let count = 0;
      while (borders[0].regionValueDiff() > 1 && count < 100) {
        ++count;
        let bestScore = -Infinity;
        let bestSteal;
        let bestSource;
        let [smallRegionId, bigRegionId] = borders[0].getOrderedRegions();
        let [smallRegion, bigRegion] = [playerRegions[smallRegionId], playerRegions[bigRegionId]];
        let i = 0;
        let border = borders[i];
        while (bestSteal == void 0 && i < borders.length) {
          border = borders[i];
          ++i;
          bestScore = -Infinity;
          [smallRegionId, bigRegionId] = border.getOrderedRegions();
          [smallRegion, bigRegion] = [playerRegions[smallRegionId], playerRegions[bigRegionId]];
          for (const borderTile of smallRegion.borderSet[bigRegionId]) {
            for (const neighbor of getBorderNeighbors(borderTile)) {
              if (neighbor.majorPlayerRegionId == bigRegionId) {
                const neighborPairTile = getScoredTile(neighbor);
                const neighborValue = getTileValue(neighborPairTile.tile);
                const bigRegionScore = neighborPairTile.scores[bigRegionId] - neighborValue;
                const smallRegionScore = neighborPairTile.scores[smallRegionId] - neighborValue;
                const swapScore = bigRegionScore - smallRegionScore;
                if (swapScore > bestScore && !isBridgeForRegion(neighbor) && // doesn't cut region in two
                borders[0].regionValueDiff() - neighborValue > 0) {
                  bestScore = swapScore;
                  bestSteal = neighbor;
                  bestSource = borderTile;
                }
              }
            }
          }
        }
        if (bestSteal != void 0 && bestSource != void 0) {
          if (detailedLogs) {
            console.log(
              `Stealing (${bestSteal.coord.x}, ${bestSteal.coord.y}) from region ${bestSteal.majorPlayerRegionId} to region ${bestSource.majorPlayerRegionId} with score ${bestScore}`
            );
          }
          border.count -= getBorderNeighbors(bestSteal).length;
          {
            const bestStealValue = getTileValue(bestSteal);
            let count2 = 0;
            for (const borderSet of bigRegion.borderSet) {
              count2 += Number(borderSet.delete(bestSteal));
            }
            if (count2 == 0) throw new Error();
            if (!bigRegion.finalSet.delete(bestSteal)) throw new Error();
            bigRegion.totalValue -= bestStealValue;
            bestSteal.majorPlayerRegionId = smallRegionId;
            count2 = 0;
            for (const neighbor of getBorderNeighbors(bestSteal)) {
              if (neighbor.majorPlayerRegionId != smallRegion.id) {
                smallRegion.borderSet[neighbor.majorPlayerRegionId].add(bestSteal);
                ++count2;
              }
            }
            if (count2 == 0) throw new Error();
            smallRegion.finalSet.add(bestSteal);
            smallRegion.totalValue += bestStealValue;
            const borderNeighbors = getBorderNeighbors(bestSteal);
            for (const neighbor of borderNeighbors) {
              addBorder(smallRegionId, neighbor.majorPlayerRegionId);
              bigRegion.borderSet[smallRegionId].add(neighbor);
            }
          }
          if (getBorderNeighbors(bestSource).length == 0) {
            if (!smallRegion.borderSet[bigRegionId].delete(bestSource)) throw new Error();
          }
          if (border.count == 0) {
            VoronoiUtils.swapAndPop(borders, i - 1);
            borders.sort(borderSorter);
          }
          for (let i2 = 0; i2 < borders.length - 1; ++i2) {
            if (borders[i2].regionValueDiff() < borders[i2 + 1].regionValueDiff()) {
              [borders[i2], borders[i2 + 1]] = [borders[i2 + 1], borders[i2]];
            } else {
              break;
            }
          }
        } else {
          break;
        }
        if (detailedLogs) {
          console.log(`  Region sizes: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] `);
          console.log(`  Region values: [${playerRegions.map((region) => region.totalValue).join(", ")}] `);
          console.log(
            `  Borders: [${borders.map((border2) => "([" + border2.getOrderedRegions()[0] + ", " + border2.getOrderedRegions()[1] + "], diff: " + border2.regionValueDiff() + ", count: " + border2.count + ")").join(", ")}] `
          );
        }
      }
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Region Area Balancing Done");
      for (const region of playerRegions) {
        const inBorderTiles = /* @__PURE__ */ new Set();
        region.finalSet.forEach((tile) => {
          if (getBorderNeighbors(tile).length > 0) inBorderTiles.add(getScoredTile(tile));
        });
        const outBorderTiles = Array.from(
          { length: playerRegions.length },
          () => /* @__PURE__ */ new Set()
        );
        for (const tile of inBorderTiles) {
          for (const neighbor of getBorderNeighbors(tile.tile)) {
            outBorderTiles[neighbor.majorPlayerRegionId].add(getScoredTile(neighbor));
          }
        }
        while (true) {
          const regionPairs = /* @__PURE__ */ new Map();
          for (const inTile2 of inBorderTiles) {
            if (isBridgeForRegion(inTile2.tile)) {
              continue;
            }
            const borderRegions = [];
            for (const neighbor of getBorderNeighbors(inTile2.tile)) {
              if (borderRegions.indexOf(neighbor.majorPlayerRegionId) == -1) {
                borderRegions.push(neighbor.majorPlayerRegionId);
              }
            }
            for (const regionId of borderRegions) {
              let bestTradeScore = 0;
              let bestTradeTile;
              for (const outTile2 of outBorderTiles[regionId]) {
                const inTileValue = getTileValue(inTile2.tile);
                const outTileValue = getTileValue(outTile2.tile);
                const tileValueDiff = inTileValue - outTileValue;
                const scoreBefore = inTile2.scores[region.id] + outTile2.scores[outTile2.tile.majorPlayerRegionId] + tileValueDiff;
                const scoreAfter = inTile2.scores[outTile2.tile.majorPlayerRegionId] + outTile2.scores[region.id] - tileValueDiff;
                const tradeScore = scoreBefore - scoreAfter;
                if (tradeScore > bestTradeScore && !isBridgeForRegion(outTile2.tile)) {
                  bestTradeScore = tradeScore;
                  bestTradeTile = outTile2;
                }
              }
              if (bestTradeTile != void 0) {
                const tradeCandidate = regionPairs.get(regionId);
                if (tradeCandidate == void 0) {
                  regionPairs.set(regionId, {
                    inside: inTile2,
                    outside: bestTradeTile,
                    delta: bestTradeScore
                  });
                } else if (tradeCandidate.delta < bestTradeScore) {
                  tradeCandidate.inside = inTile2;
                  tradeCandidate.outside = bestTradeTile;
                  tradeCandidate.delta = bestTradeScore;
                }
              }
            }
          }
          if (regionPairs.size == 0) {
            break;
          }
          let bestTradeCandidate;
          for (const [_key, value] of regionPairs) {
            if (bestTradeCandidate == void 0 || bestTradeCandidate.delta < value.delta) {
              bestTradeCandidate = value;
            }
          }
          let [inTile, outTile] = [bestTradeCandidate.inside, bestTradeCandidate.outside];
          if (inTile.tile.majorPlayerRegionId == outTile.tile.majorPlayerRegionId) throw new Error("");
          {
            const scoreBefore = inTile.scores[region.id] + outTile.scores[outTile.tile.majorPlayerRegionId];
            const scoreAfter = inTile.scores[outTile.tile.majorPlayerRegionId] + outTile.scores[region.id];
            if (detailedLogs) {
              console.log(
                `Trading (${inTile.tile.coord.x}, ${inTile.tile.coord.y}), region: ${inTile.tile.majorPlayerRegionId} with (${outTile.tile.coord.x}, ${outTile.tile.coord.y}), region: ${outTile.tile.majorPlayerRegionId} to improve total score from ${scoreBefore} to ${scoreAfter} `
              );
            }
          }
          if (!inBorderTiles.delete(inTile)) throw new Error();
          if (!outBorderTiles[outTile.tile.majorPlayerRegionId].delete(outTile)) throw new Error();
          if (!playerRegions[inTile.tile.majorPlayerRegionId].finalSet.delete(inTile.tile)) throw new Error();
          if (!playerRegions[outTile.tile.majorPlayerRegionId].finalSet.delete(outTile.tile))
            throw new Error();
          playerRegions[inTile.tile.majorPlayerRegionId].totalValue -= getTileValue(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].totalValue -= getTileValue(outTile.tile);
          [inTile.tile.majorPlayerRegionId, outTile.tile.majorPlayerRegionId] = [
            outTile.tile.majorPlayerRegionId,
            inTile.tile.majorPlayerRegionId
          ];
          [inTile, outTile] = [outTile, inTile];
          if (inTile.tile.majorPlayerRegionId != region.id) throw new Error("");
          inBorderTiles.add(inTile);
          outBorderTiles[outTile.tile.majorPlayerRegionId].add(outTile);
          playerRegions[inTile.tile.majorPlayerRegionId].finalSet.add(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].finalSet.add(outTile.tile);
          playerRegions[inTile.tile.majorPlayerRegionId].totalValue += getTileValue(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].totalValue += getTileValue(outTile.tile);
          for (const neighbor of this.getNeighbors(inTile.tile)) {
            if (neighbor && getBorderNeighbors(neighbor).length == 0) {
              inBorderTiles.delete(getScoredTile(neighbor));
            }
          }
          for (const neighbor of this.getNeighbors(outTile.tile)) {
            if (neighbor && getBorderNeighbors(neighbor).length == 0) {
              outBorderTiles[neighbor.majorPlayerRegionId].delete(getScoredTile(neighbor));
            }
          }
        }
      }
      this.m_tiles.forEach((row) => row.forEach((tile) => tile.visited = 0));
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Region Optimizing Done");
      console.log(
        `"Finished creating major player regions for landmass ${landmass.id}, region sizes are: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] and vales are: [${playerRegions.map((region) => region.totalValue).join(", ")}]`
      );
    }
  }
  floodFill(initialTile, considerCallback) {
    initialTile.visited = 1;
    const considerationList = [initialTile];
    const returnList = [];
    while (considerationList.length > 0) {
      const tile = considerationList.pop();
      returnList.push(tile);
      const neighbors = this.getNeighbors(tile);
      for (const neighbor of neighbors) {
        if (neighbor && !neighbor.visited) {
          neighbor.visited = 1;
          const result = considerCallback(neighbor);
          switch (result) {
            case 0 /* Include */:
              considerationList.push(neighbor);
              break;
            case 2 /* Halt */:
              return returnList;
          }
        }
      }
    }
    return returnList;
  }
  clearVisited() {
    for (const row of this.m_tiles) {
      for (const tile of row) {
        tile.visited = 0;
      }
    }
  }
  getTiles() {
    return this.m_tiles;
  }
}

export { HexTile, VoronoiHex };
//# sourceMappingURL=voronoi-hex.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-plate.js">
class VoronoiPlate {
  m_center = { x: 0, y: 0 };
  m_direction = { x: 0, y: 0 };
  m_rotation = 0;
}

export { VoronoiPlate };
//# sourceMappingURL=voronoi-plate.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-region.js">
import { RandomImpl } from './random-pcg-32.js';
import { VoronoiUtils } from './voronoi-utils.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

class IdScorePair {
  id = 0;
  score = 0;
}
class VoronoiRegion {
  name = "";
  id = 0;
  type = 0;
  maxArea = 0;
  playerAreas = 0;
  color = { x: 0, y: 0, z: 0 };
  seedLocation = { x: 0, y: 0 };
  considerationList = [];
  scoringContext;
  colorString = "";
  quadTree;
  constructor(name, id, type, maxArea, playerAreas, color) {
    this.name = name;
    this.id = id;
    this.type = type;
    this.maxArea = maxArea;
    this.playerAreas = playerAreas;
    this.color = color;
    const r = Math.floor(color.x * 255);
    const g = Math.floor(color.y * 255);
    const b = Math.floor(color.z * 255);
    this.colorString = "rgb(" + r + " ," + g + ", " + b + ")";
  }
  prepareGrowth(regionCells, regions, rules, worldDims, plateRegions) {
    this.scoringContext = {
      cells: regionCells,
      region: this,
      regions,
      plateRegions,
      m_worldDims: { x: worldDims.x, y: worldDims.y },
      totalArea: 0,
      cellCount: 0,
      rules
    };
    for (const rule of Object.values(rules)) {
      rule.prepare();
    }
    regionCells.forEach((cell) => {
      cell.regionConsiderationBits = 0n;
    });
    this.quadTree = void 0;
  }
  growStep() {
    let newCellIndex = 0;
    const regionCells = this.scoringContext.cells;
    for (let i = 0; i < this.considerationList.length; ) {
      const cell = regionCells[this.considerationList[i].id];
      if (this.isCellClaimed(cell)) {
        VoronoiUtils.swapAndPop(this.considerationList, i);
        continue;
      }
      if (this.considerationList[i].score > this.considerationList[newCellIndex].score) {
        newCellIndex = i;
      }
      ++i;
    }
    if (this.considerationList.length == 0 || this.considerationList[newCellIndex].score < 0) {
      return false;
    }
    const newCellId = this.considerationList[newCellIndex].id;
    VoronoiUtils.swapAndPop(this.considerationList, newCellIndex);
    const newCell = regionCells[newCellId];
    this.setRegionIdForCell(newCell, this.id, this.scoringContext);
    this.scoringContext.totalArea += newCell.area;
    this.scoringContext.cellCount++;
    if (this.quadTree) {
      this.quadTree.insert(newCell);
    }
    this.scoringContext.rules.forEach((rule) => rule.notifySelectedCell(newCell, this.scoringContext));
    for (const neighborId of newCell.cell.getNeighborIds()) {
      const neighbor = regionCells[neighborId];
      if (this.isCellClaimed(neighbor)) {
        continue;
      }
      const score = this.scoreCell(neighbor, this.scoringContext);
      if (neighbor.regionConsiderationBits & BigInt(1 << this.id)) {
        const index = this.considerationList.findIndex((value) => value.id === neighborId);
        this.considerationList[index].score = score;
      } else {
        this.considerationList.push({ id: neighborId, score });
      }
    }
    return this.considerationList.length > 0 && this.scoringContext.totalArea < this.maxArea;
  }
  logStats() {
    console.log(
      "Region " + this.id + " total area: " + this.scoringContext?.totalArea + ", cell count: " + this.scoringContext?.cellCount
    );
  }
  getColorString() {
    return this.colorString;
  }
  scoreCell(regionCell, scoringContext) {
    let score = 0;
    for (const rule of Object.values(scoringContext.rules)) {
      if (rule.isActive) {
        score += rule.score(regionCell, scoringContext) * rule.weight;
      }
    }
    return score;
  }
  scoreSingleCell(regionCell) {
    return this.scoreCell(regionCell, this.scoringContext);
  }
  SetQuadTree(quadtree) {
    this.quadTree = quadtree;
  }
}
class LandmassRegion extends VoronoiRegion {
  setRegionIdForCell(cell, id, scoringContext) {
    cell.landmassId = id;
    cell.landmassOrder = scoringContext.cellCount;
  }
  getRegionIdForCell(cell) {
    return cell.landmassId;
  }
  isCellClaimed(cell) {
    return cell.landmassId != 0;
  }
}
class PlateRegion extends VoronoiRegion {
  m_movement = { x: 0, y: 0 };
  m_rotation = 0;
  constructor(name, id, type, maxArea, color) {
    super(name, id, type, maxArea, 0, color);
    const dir = RandomImpl.fRand("Plate Movement Direction") * Math.PI * 2;
    const movementSpeed = RandomImpl.fRand("Plate Movement Speed");
    this.m_movement.x = Math.cos(dir) * movementSpeed;
    this.m_movement.y = Math.sin(dir) * movementSpeed;
    this.m_rotation = RandomImpl.fRand("Plate Rotation") * 2 - 1;
  }
  setRegionIdForCell(cell, id, scoringContext) {
    cell.plateId = id;
    cell.plateOrder = scoringContext.cellCount;
  }
  getRegionIdForCell(cell) {
    return cell.plateId;
  }
  isCellClaimed(cell) {
    return cell.plateId != -1;
  }
}

export { LandmassRegion, PlateRegion, VoronoiRegion };
//# sourceMappingURL=voronoi-region.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-utils.js">
import { Voronoi } from '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import { RandomImpl } from './random-pcg-32.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

var MapSize = /* @__PURE__ */ ((MapSize2) => {
  MapSize2[MapSize2["Tiny"] = 0] = "Tiny";
  MapSize2[MapSize2["Small"] = 1] = "Small";
  MapSize2[MapSize2["Standard"] = 2] = "Standard";
  MapSize2[MapSize2["Large"] = 3] = "Large";
  MapSize2[MapSize2["Huge"] = 4] = "Huge";
  return MapSize2;
})(MapSize || {});
const MapDims = {
  [0 /* Tiny */]: { x: 60, y: 38 },
  [1 /* Small */]: { x: 74, y: 46 },
  [2 /* Standard */]: { x: 84, y: 54 },
  [3 /* Large */]: { x: 96, y: 60 },
  [4 /* Huge */]: { x: 106, y: 66 }
};
var RegionType = /* @__PURE__ */ ((RegionType2) => {
  RegionType2[RegionType2["None"] = 0] = "None";
  RegionType2[RegionType2["Ocean"] = 1] = "Ocean";
  RegionType2[RegionType2["Landmass"] = 2] = "Landmass";
  RegionType2[RegionType2["Island"] = 3] = "Island";
  RegionType2[RegionType2["CoastalIsland"] = 4] = "CoastalIsland";
  RegionType2[RegionType2["_Length"] = 5] = "_Length";
  return RegionType2;
})(RegionType || {});
var TerrainType = /* @__PURE__ */ ((TerrainType2) => {
  TerrainType2[TerrainType2["Unknown"] = 0] = "Unknown";
  TerrainType2[TerrainType2["Ocean"] = 1] = "Ocean";
  TerrainType2[TerrainType2["Coast"] = 2] = "Coast";
  TerrainType2[TerrainType2["Flat"] = 3] = "Flat";
  TerrainType2[TerrainType2["Rough"] = 4] = "Rough";
  TerrainType2[TerrainType2["Mountainous"] = 5] = "Mountainous";
  TerrainType2[TerrainType2["Volcano"] = 6] = "Volcano";
  TerrainType2[TerrainType2["NavRiver"] = 7] = "NavRiver";
  TerrainType2[TerrainType2["_Length"] = 8] = "_Length";
  return TerrainType2;
})(TerrainType || {});
var BiomeType = /* @__PURE__ */ ((BiomeType2) => {
  BiomeType2[BiomeType2["Unknown"] = 0] = "Unknown";
  BiomeType2[BiomeType2["Ocean"] = 1] = "Ocean";
  BiomeType2[BiomeType2["Desert"] = 2] = "Desert";
  BiomeType2[BiomeType2["Grassland"] = 3] = "Grassland";
  BiomeType2[BiomeType2["Plains"] = 4] = "Plains";
  BiomeType2[BiomeType2["Tropical"] = 5] = "Tropical";
  BiomeType2[BiomeType2["Tundra"] = 6] = "Tundra";
  BiomeType2[BiomeType2["_Length"] = 7] = "_Length";
  return BiomeType2;
})(BiomeType || {});
var DetailsType = /* @__PURE__ */ ((DetailsType2) => {
  DetailsType2[DetailsType2["None"] = 0] = "None";
  DetailsType2[DetailsType2["MinorRiver"] = 1] = "MinorRiver";
  DetailsType2[DetailsType2["Wet"] = 2] = "Wet";
  DetailsType2[DetailsType2["Vegetated"] = 3] = "Vegetated";
  DetailsType2[DetailsType2["Floodplain"] = 4] = "Floodplain";
  DetailsType2[DetailsType2["Snow"] = 5] = "Snow";
  DetailsType2[DetailsType2["_Length"] = 6] = "_Length";
  return DetailsType2;
})(DetailsType || {});
class RegionCell {
  id = 0;
  cell;
  area = 0;
  landmassId = 0;
  landmassOrder = 0;
  plateId = -1;
  plateOrder = 0;
  elevation = 0;
  terrainType = 0 /* Unknown */;
  biomeType = 0 /* Unknown */;
  detailsType = 0 /* None */;
  regionConsiderationBits = 0n;
  // helps avoid a set lookup when on a region's consideration heap during processing.
  ruleConsideration = false;
  // used by individual rules. Rule should clear back to false after each use.
  currentScore = 0;
  // can hold a current score temporarily, but should be zeroed out between operations.
  constructor(cell, id, area) {
    this.cell = cell;
    this.id = id;
    this.area = area;
  }
  reset() {
    this.landmassId = 0;
    this.landmassOrder = 0;
    this.plateId = -1;
    this.plateOrder = 0;
    this.elevation = 0;
    this.terrainType = 0 /* Unknown */;
    this.biomeType = 0 /* Unknown */;
    this.detailsType = 0 /* None */;
  }
}
const RegionCellPosGetter = (cell) => {
  return { x: cell.cell.site.x, y: cell.cell.site.y };
};
class PlateBoundary {
  pos = { x: 0, y: 0 };
  normal = { x: 0, y: 0 };
  plateSubduction = 0;
  plateSliding = 0;
  id1 = 0;
  id2 = 0;
}
const PlateBoundaryPosGetter = (data) => {
  return { x: data.pos.x, y: data.pos.y };
};
var VoronoiUtils;
((VoronoiUtils2) => {
  function voronoiCentroid(cell) {
    const site = { x: 0, y: 0, id: 0 };
    for (const halfedge of cell.halfedges) {
      site.x += halfedge.getStartpoint().x;
      site.y += halfedge.getStartpoint().y;
    }
    site.x /= cell.halfedges.length;
    site.y /= cell.halfedges.length;
    return site;
  }
  VoronoiUtils2.voronoiCentroid = voronoiCentroid;
  function lloydRelaxation(cells, strength) {
    return cells.map((cell) => {
      const centerSite = voronoiCentroid(cell);
      const newX = cell.site.x + strength * (centerSite.x - cell.site.x);
      const newY = cell.site.y + strength * (centerSite.y - cell.site.y);
      return {
        id: 0,
        x: newX,
        y: newY
      };
    });
  }
  VoronoiUtils2.lloydRelaxation = lloydRelaxation;
  function computeVoronoi(sites, bbox, relaxationSteps) {
    const voronoi = new Voronoi();
    let diagram = voronoi.compute(sites, bbox);
    for (let index = 0; index < relaxationSteps; index++) {
      sites = lloydRelaxation(diagram.cells, 1);
      voronoi.toRecycle = diagram;
      diagram = voronoi.compute(sites, bbox);
    }
    return diagram;
  }
  VoronoiUtils2.computeVoronoi = computeVoronoi;
  function createRandomSites(count, maxX, maxY) {
    return Array.from({ length: count }, () => ({
      id: 0,
      x: RandomImpl.fRand("Voronoi Site X") * maxX,
      y: RandomImpl.fRand("Voronoi Site Y") * maxY
    }));
  }
  VoronoiUtils2.createRandomSites = createRandomSites;
  function dot(dir1, dir2) {
    return dir1.x * dir2.x + dir1.y * dir2.y;
  }
  VoronoiUtils2.dot = dot;
  function crossZ(dir1, dir2) {
    return dir1.x * dir2.y - dir1.y * dir2.x;
  }
  VoronoiUtils2.crossZ = crossZ;
  function lerp(a, b, t) {
    return a + t * (b - a);
  }
  VoronoiUtils2.lerp = lerp;
  function normalize(v) {
    const len = Math.sqrt(v.x * v.x + v.y * v.y);
    return { x: v.x / len, y: v.y / len };
  }
  VoronoiUtils2.normalize = normalize;
  function iLerp(a, b, t) {
    return (t - a) / (b - a);
  }
  VoronoiUtils2.iLerp = iLerp;
  function clamp(a, min, max) {
    const lowerClamp = Math.max(a, min);
    return Math.min(lowerClamp, max);
  }
  VoronoiUtils2.clamp = clamp;
  function pointInsideCell(cell, point) {
    for (const halfEdge of cell.halfedges) {
      const ept1 = halfEdge.getStartpoint();
      const ept2 = halfEdge.getEndpoint();
      const edgeDir = { x: ept2.x - ept1.x, y: ept2.y - ept1.y };
      const ptDir = { x: point.x - ept1.x, y: point.y - ept1.y };
      if (crossZ(edgeDir, ptDir) > 0) {
        return false;
      }
    }
    return true;
  }
  VoronoiUtils2.pointInsideCell = pointInsideCell;
  function calculateCellArea(cell) {
    let area = 0;
    for (const halfedge of cell.halfedges) {
      const pt1 = halfedge.getStartpoint();
      const pt2 = halfedge.getEndpoint();
      area += pt1.x * pt2.y - pt2.x * pt1.y;
    }
    return area * -0.5;
  }
  VoronoiUtils2.calculateCellArea = calculateCellArea;
  function sqDistance(pt1, pt2) {
    const xDiff = pt1.x - pt2.x;
    const yDiff = pt1.y - pt2.y;
    return xDiff * xDiff + yDiff * yDiff;
  }
  VoronoiUtils2.sqDistance = sqDistance;
  function sqDistanceBetweenSites(site1, site2) {
    return sqDistance({ x: site1.x, y: site1.y }, { x: site2.x, y: site2.y });
  }
  VoronoiUtils2.sqDistanceBetweenSites = sqDistanceBetweenSites;
  function distanceBetweenSites(site1, site2) {
    return Math.sqrt(sqDistance({ x: site1.x, y: site1.y }, { x: site2.x, y: site2.y }));
  }
  VoronoiUtils2.distanceBetweenSites = distanceBetweenSites;
  function defaultEnumRecord(e) {
    const obj = {};
    for (const k of Object.values(e)) {
      if (typeof k === "number") obj[k] = {};
    }
    return obj;
  }
  VoronoiUtils2.defaultEnumRecord = defaultEnumRecord;
  function shuffle(arr, count = arr.length) {
    for (let i = 0; i < count; ++i) {
      const idx = RandomImpl.getRandomNumber(arr.length - i, "Shuffle Idx") + i;
      [arr[i], arr[idx]] = [arr[idx], arr[i]];
    }
  }
  VoronoiUtils2.shuffle = shuffle;
  let RegionCellFilterResult;
  ((RegionCellFilterResult2) => {
    RegionCellFilterResult2[RegionCellFilterResult2["Continue"] = 0] = "Continue";
    RegionCellFilterResult2[RegionCellFilterResult2["HaltSuccess"] = 1] = "HaltSuccess";
    RegionCellFilterResult2[RegionCellFilterResult2["HaltFail"] = 2] = "HaltFail";
  })(RegionCellFilterResult = VoronoiUtils2.RegionCellFilterResult || (VoronoiUtils2.RegionCellFilterResult = {}));
  function regionCellAreaFilter(cell, regionCells, maxDistance, filterCallback) {
    const consideringList = [cell.id];
    cell.ruleConsideration = true;
    let filterResult = 0 /* Continue */;
    for (let i = 0; i < consideringList.length; ++i) {
      const considerCell = regionCells[consideringList[i]];
      filterResult = filterCallback(considerCell);
      if (filterResult != 0 /* Continue */) {
        break;
      }
      const neighborIds = considerCell.cell.getNeighborIds();
      for (const neighborId of neighborIds) {
        const neighbor = regionCells[neighborId];
        if (!neighbor.ruleConsideration && VoronoiUtils2.distanceBetweenSites(cell.cell.site, neighbor.cell.site) < maxDistance) {
          neighbor.ruleConsideration = true;
          consideringList.push(neighborId);
        }
      }
    }
    consideringList.forEach((cellId) => regionCells[cellId].ruleConsideration = false);
    return filterResult;
  }
  VoronoiUtils2.regionCellAreaFilter = regionCellAreaFilter;
  function deepMerge(a, b) {
    for (const key in b) {
      if (b[key] && typeof b[key] === "object" && !Array.isArray(b[key]) && typeof a[key] === "object" && a[key] !== null) {
        deepMerge(a[key], b[key]);
      } else if (Array.isArray(a[key]) && Array.isArray(b[key])) {
        const aArr = a[key];
        const bArr = b[key];
        if (aArr.length < bArr.length && "_defaultChild" in a) {
          while (aArr.length < bArr.length) {
            aArr.push(clone(a["_defaultChild"]));
          }
        }
        aArr.length = bArr.length;
        for (let i = 0; i < bArr.length; ++i) {
          deepMerge(aArr[i], bArr[i]);
        }
      } else if (key in a) {
        a[key] = b[key];
      } else {
        console.log("Warning: key " + key + " not in merged object.");
      }
    }
  }
  VoronoiUtils2.deepMerge = deepMerge;
  async function loadTextFromPath(url) {
    if (typeof fetch == "function") {
      try {
        const response = await fetch(url, { cache: "no-cache" });
        if (!response.ok) {
          console.error(`Failed to load ${url}: ${response.statusText}`);
          return null;
        }
        return await response.text();
      } catch (err) {
        console.error(`Error loading ${url}`, err);
        return null;
      }
    } else {
      console.error("Environment does not support fetch().");
      return null;
    }
  }
  VoronoiUtils2.loadTextFromPath = loadTextFromPath;
  async function loadJsonFromPath(url) {
    const text = await loadTextFromPath(url);
    if (text) {
      return JSON.parse(text);
    }
    return null;
  }
  VoronoiUtils2.loadJsonFromPath = loadJsonFromPath;
  async function loadJsFromPath(url) {
    const text = await loadTextFromPath(url);
    if (text) {
      const match = text.match(/export\s+default\s+({[\s\S]*});?\s*$/);
      if (!match) throw new Error("Could not find export default object");
      return JSON.parse(match[1]);
    }
    return null;
  }
  VoronoiUtils2.loadJsFromPath = loadJsFromPath;
  function loadSettingsFromJson(json, map) {
    const configObject = typeof json === "string" ? JSON.parse(json) : json;
    VoronoiUtils2.deepMerge(map.getSettings(), configObject.mapConfig);
    const generator = map.getBuilder().getGenerator();
    generator.resetToDefault();
    VoronoiUtils2.deepMerge(generator.getSettings(), configObject.generatorConfig);
    const rules = generator.getRules();
    for (const [groupKey, groupValue] of Object.entries(configObject.rulesConfig)) {
      const rulesGroup = rules[groupKey];
      for (const [ruleKey, ruleValue] of Object.entries(groupValue)) {
        const ruleKeyParts = ruleKey.split(".");
        for (const rule of rulesGroup) {
          if (rule.name === ruleKeyParts[0]) {
            if (ruleKeyParts[1] === "weight") {
              rule.weight = ruleValue;
            } else {
              rule.configValues[ruleKeyParts[1]] = ruleValue;
            }
            break;
          }
        }
      }
    }
  }
  VoronoiUtils2.loadSettingsFromJson = loadSettingsFromJson;
  function loadSettingsFromJs(jsText, map) {
    const match = jsText.match(/export\s+default\s+({[\s\S]*});?\s*$/);
    if (!match) throw new Error("Could not find export default object");
    return loadSettingsFromJson(match[1], map);
  }
  VoronoiUtils2.loadSettingsFromJs = loadSettingsFromJs;
  function clone(obj) {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    } else {
      return JSON.parse(JSON.stringify(obj));
    }
  }
  VoronoiUtils2.clone = clone;
  function getRoundedString(value, precision) {
    return String(parseFloat(value.toFixed(precision)));
  }
  VoronoiUtils2.getRoundedString = getRoundedString;
  function swapAndPop(arr, indexToRemove) {
    arr[indexToRemove] = arr[arr.length - 1];
    arr.pop();
  }
  VoronoiUtils2.swapAndPop = swapAndPop;
  function performanceMarker(label) {
    if (typeof BuildInfo === "undefined") {
      performance.mark(label);
    } else {
      console.log(label);
    }
  }
  VoronoiUtils2.performanceMarker = performanceMarker;
})(VoronoiUtils || (VoronoiUtils = {}));

export { BiomeType, DetailsType, MapDims, MapSize, PlateBoundary, PlateBoundaryPosGetter, RegionCell, RegionCellPosGetter, RegionType, TerrainType, VoronoiUtils };
//# sourceMappingURL=voronoi-utils.js.map
</file>

<file path="mod/maps/base-standard/base-standard.modinfo">
<?xml version="1.0" encoding="utf-8"?>
<Mod id="base-standard" version="1"
    xmlns="ModInfo">
    <Properties>
        <Name>Base Game</Name>
        <Description>This module contains almost everything necessary for the base game.</Description>
        <Authors>LOC_AUTHORS_FIRAXIS</Authors>
        <ShowInBrowser>0</ShowInBrowser>
        <Package>BaseGame</Package>
        <PackageSortIndex>1</PackageSortIndex>
    </Properties>
    <Dependencies></Dependencies>
    <References>
        <Mod id="core" title="LOC_MODULE_CORE_NAME" />
    </References>
    <ActionCriteria>
        <Criteria id="always">
            <AlwaysMet />
        </Criteria>
        <Criteria id="standard-games">
            <RuleSetInUse>RULESET_STANDARD</RuleSetInUse>
        </Criteria>
    </ActionCriteria>
    <ActionGroups>
        <ActionGroup id="base-game-main" scope="game" criteria="always">
            <Actions>
                <ImportFiles>
                    <Item>ui/loading/root-loading.html</Item>
                    <Item>ui/root-game.html</Item>
                    <Item>ui/unit-flags/unit-info.js</Item>
                </ImportFiles>
                <UIScripts>
                    <Item>ui/action/panel-action.js</Item>
                    <Item>ui/advanced-start/model-advanced-start.js</Item>
                    <Item>ui/advanced-start/screen-advanced-start.js</Item>
                    <Item>
                        ui/age-progression-warning-mini-banner/panel-age-progression-warning-mini-banner.js</Item>
                    <Item>ui/age-progression-warning-popup/panel-age-progression-warning-popup.js</Item>
                    <Item>ui/age-scores/model-age-scores.js</Item>
                    <Item>ui/age-scores/panel-age-scores.js</Item>
                    <Item>ui/age-rankings/model-age-rankings.js</Item>
                    <Item>ui/age-rankings/panel-age-rankings.js</Item>
                    <Item>ui/age-summary/model-age-summary-hub.js</Item>
                    <Item>ui/age-transition-banner/age-transition-banner.js</Item>
                    <Item>ui/army-panel/army-panel.js</Item>
                    <Item>ui/unit-rename/unit-rename.js</Item>
                    <Item>ui/attribute-trees/screen-attribute-trees.js</Item>
                    <Item>ui/attribute-trees/attribute-card.js</Item>
                    <Item>ui/attribute-trees/attribute-small-card.js</Item>
                    <Item>ui/befriend-independent-details/screen-befriend-independent-details.js</Item>
                    <Item>ui/benchmark/screen-benchmark.js</Item>
                    <Item>ui/build-queue/model-build-queue.js</Item>
                    <Item>ui/build-queue/panel-build-queue.js</Item>
                    <Item>ui/building-placement/building-placement-manager.js</Item>
                    <Item>ui/cinematic/screen-cinematic-placard.js</Item>
                    <Item>ui/city-banners/city-banners.js</Item>
                    <Item>ui/city-details/panel-city-details.js</Item>
                    <Item>ui/city-hud-model/model-city-hud.js</Item>
                    <Item>ui/city-selection/city-selection.js</Item>
                    <Item>ui/city-state-bonus-chooser/screen-city-state-bonus-chooser.js</Item>
                    <Item>ui/city-trade/screen-city-trade.js</Item>
                    <Item>ui/civilopedia/screen-civilopedia.js</Item>
                    <Item>ui/civilopedia/civilopedia-sidebar-panels.js</Item>
                    <Item>ui/chooser-item/chooser-item.js</Item>
                    <Item>ui/constructible-details/constructible-details.js</Item>
                    <Item>ui/tree-chooser-item/tree-chooser-item.js</Item>
                    <Item>ui/culture-tree-chooser/screen-culture-tree-chooser.js</Item>
                    <Item>ui/crisis-meter/crisis-meter.js</Item>
                    <Item>ui/diplo-ribbon/panel-diplo-ribbon.js</Item>
                    <Item>ui/diplo-ribbon/panel-yield-banner.js</Item>
                    <Item>ui/diplomacy-action-details/screen-diplomacy-action-details.js</Item>
                    <Item>ui/diplomacy-actions/panel-diplomacy-actions.js</Item>
					<Item>ui/diplomacy-actions/panel-other-diplomacy.js</Item>
					<Item>ui/diplomacy-actions/panel-player-diplomacy.js</Item>
                    <Item>ui/diplomacy-call-to-arms/screen-diplomacy-call-to-arms.js</Item>
                    <Item>ui/diplomacy-hub/panel-diplomacy-hub.js</Item>
                    <Item>ui/diplomacy-peace-deal/panel-diplomacy-peace-deal.js</Item>
                    <Item>ui/diplomacy-project-reaction/panel-diplomacy-project-reaction.js</Item>
                    <Item>ui/diplomacy-actions/screen-diplomacy-target-select.js</Item>
                    <Item>ui/diplomacy/diplomacy-events.js</Item>
                    <Item>ui/diplomacy/diplomacy-manager.js</Item>
                    <Item>ui/district/district-health-manager.js</Item>
                    <Item>ui/district/district-health.js</Item>
                    <Item>ui/end-result-graphs/panel-end-result-graphs.js</Item>
                    <Item>ui/endgame/model-endgame.js</Item>
                    <Item>ui/endgame/screen-endgame.js</Item>
                    <Item>ui/espionage-details/screen-espionage-details.js</Item>
                    <Item>ui/victory-progress/screen-victory-progress.js</Item>
                    <Item>ui/victory-progress/screen-victory-achieved.js</Item>
                    <Item>ui/victory-progress/panel-advisor-victory.js</Item>
                    <Item>ui/city-capture-chooser/panel-city-capture-chooser.js</Item>
                    <Item>ui/general-chooser/screen-general-chooser.js</Item>
                    <Item>ui/celebration-chooser/panel-celebration-chooser.js</Item>
                    <Item>ui/great-works/model-great-works.js</Item>
                    <Item>ui/great-works/screen-great-works.js</Item>
                    <Item>ui/panel-belief-picker/panel-belief-picker.js</Item>
                    <Item>ui/belief-picker-chooser-item/belief-picker-chooser-item.js</Item>
                    <Item>ui/panel-religion-picker/panel-religion-picker.js</Item>
                    <Item>ui/culture-tree/screen-culture-tree.js</Item>
                    <Item>ui/end-results/end-results.js</Item>
                    <Item>ui/pantheon-chooser/panel-religion-chooser.js</Item>
                    <Item>ui/settler-legend/panel-settler-legend.js</Item>
                    <Item>ui/tech-tree-chooser/screen-tech-tree-chooser.js</Item>
                    <Item>ui/trade-route-chooser/trade-route-banner.js</Item>
                    <Item>ui/trade-route-chooser/trade-route-chooser.js</Item>
                    <Item>ui/trade-route-chooser/trade-routes-model.js</Item>
                    <Item>ui/trade-route-chooser/trade-route-tooltip.js</Item>
                    <Item>ui/interface-modes/interface-mode-advanced-start.js</Item>
                    <Item>ui/interface-modes/interface-mode-acquire-tile.js</Item>
                    <Item>ui/interface-modes/interface-mode-add-to-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-aerial-recon.js</Item>
                    <Item>ui/interface-modes/interface-mode-air-attack.js</Item>
                    <Item>ui/interface-modes/interface-mode-naval-attack.js</Item>
                    <Item>ui/interface-modes/interface-mode-army-overrun.js</Item>
                    <Item>ui/interface-modes/interface-mode-bonus-placement.js</Item>
                    <Item>ui/interface-modes/interface-mode-call-to-arms.js</Item>
                    <Item>ui/interface-modes/interface-mode-cargo-drop.js</Item>
                    <Item>ui/interface-modes/interface-mode-chat.js</Item>
                    <Item>ui/interface-modes/interface-mode-choose-plot.js</Item>
                    <Item>ui/interface-modes/interface-mode-cinematic.js</Item>
                    <Item>ui/interface-modes/interface-mode-city-production.js</Item>
                    <Item>ui/interface-modes/interface-mode-city-purchase.js</Item>
                    <Item>ui/interface-modes/interface-mode-connect-with-road.js</Item>
                    <Item>ui/interface-modes/interface-mode-construct-in-range.js</Item>
                    <Item>ui/interface-modes/interface-mode-commander-reinforcement.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-land-melee.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-land-ranged.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-sea-melee.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-sea-ranged.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-air-to-land.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-air-to-air.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-air-bomb.js</Item>
                    <Item>ui/interface-modes/interface-mode-found-city-adjacent-plot.js</Item>
                    <Item>ui/interface-modes/interface-mode-default.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplo-claim-plot.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplomacy-dialog.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplomacy-hub.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplomacy-project-reaction.js</Item>
                    <Item>ui/interface-modes/interface-mode-establish-base.js</Item>
                    <Item>ui/interface-modes/interface-mode-move-by-rail.js</Item>
                    <Item>ui/interface-modes/interface-mode-move-to.js</Item>
                    <Item>ui/interface-modes/interface-mode-pause-menu.js</Item>
                    <Item>ui/interface-modes/interface-mode-place-building.js</Item>
                    <Item>ui/interface-modes/interface-mode-peace-deal.js</Item>
                    <Item>ui/interface-modes/interface-mode-radial-selection.js</Item>
                    <Item>ui/interface-modes/interface-mode-ranged-attack.js</Item>
                    <Item>ui/interface-modes/interface-mode-rebase.js</Item>
                    <Item>ui/interface-modes/interface-mode-reinforce-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-remove-from-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-resource-allocation.js</Item>
                    <Item>ui/interface-modes/interface-mode-screenshot.js</Item>
                    <Item>ui/interface-modes/interface-mode-tutorial-start.js</Item>
                    <Item>ui/interface-modes/interface-mode-unit-air-drop.js</Item>
                    <Item>ui/interface-modes/interface-mode-unit-promotion.js</Item>
                    <Item>ui/interface-modes/interface-mode-unit-selected.js</Item>
                    <Item>ui/interface-modes/interface-mode-unpack-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-wmd-strike.js</Item>
                    <Item>ui/interface-modes/interface-mode-teleport-to-city.js</Item>
                    <Item>ui/interface-modes/interface-mode-coastal-raid.js</Item>
                    <Item>ui/interface-modes/interface-mode-pillage-land.js</Item>
                    <Item>ui/interface-modes/interface-mode-pillage-route.js</Item>
                    <Item>ui/interface-modes/interface-mode-grant-second-wind.js</Item>
                    <Item>ui/interface-modes/interface-mode-commander-attack.js</Item>
                    <Item>ui/legend-progress/legend-progress.js</Item>
                    <Item>ui/legends-report/screen-legends-report.js</Item>
                    <Item>ui/legends-manager/legends-manager.js</Item>
                    <Item>ui/lenses/panel-continents.js</Item>
                    <Item>ui/lenses/layer/appeal-layer.js</Item>
                    <Item>ui/lenses/layer/building-placement-layer.js</Item>
                    <Item>ui/lenses/layer/city-borders-layer.js</Item>
                    <Item>ui/lenses/layer/city-growth-improvements-layer.js</Item>
                    <Item>ui/lenses/layer/culture-borders-layer.js</Item>
                    <Item>ui/lenses/layer/hexgrid-layer.js</Item>
                    <Item>ui/lenses/layer/random-events-layer.js</Item>
                    <Item>ui/lenses/layer/operation-target-layer.js</Item>
                    <Item>ui/lenses/layer/resource-layer.js</Item>
                    <Item>ui/lenses/layer/settlement-recommendations-layer.js</Item>
                    <Item>ui/lenses/layer/trade-layer.js</Item>
                    <Item>ui/lenses/layer/worker-yields-layer.js</Item>
                    <Item>ui/lenses/layer/yields-layer.js</Item>
                    <Item>ui/lenses/layer/continent-layer.js</Item>
                    <Item>ui/lenses/lens/acquire-tile-lens.js</Item>
                    <Item>ui/lenses/lens/building-placement-lens.js</Item>
                    <Item>ui/lenses/lens/cinematic-lens.js</Item>
                    <Item>ui/lenses/lens/city-lens.js</Item>
                    <Item>ui/lenses/lens/default-lens.js</Item>
                    <Item>ui/lenses/lens/diplomacy-lens.js</Item>
                    <Item>ui/lenses/lens/founder-lens.js</Item>
                    <Item>ui/lenses/lens/settler-lens.js</Item>
                    <Item>ui/lenses/lens/trade-lens.js</Item>
                    <Item>ui/lenses/lens/continent-lens.js</Item>
                    <Item>ui/live-notice/live-notice.js</Item>
                    <Item>ui/mini-map/panel-mini-map.js</Item>
                    <Item>ui/mp-ingame-mgr/mp-ingame-mgr.js</Item>
                    <Item>ui/narrative-event/graphic-narrative-event.js</Item>
                    <Item>ui/narrative-event/screen-narrative-event.js</Item>
                    <Item>ui/notification-connection-status/notification-connection-status.js</Item>
                    <Item>ui/notification-train/model-notification-train.js</Item>
                    <Item>ui/notification-train/notification-handlers.js</Item>
                    <Item>ui/notification-train/panel-notification-train.js</Item>
                    <Item>ui/notification-train-mobile/panel-notification-mobile-opener.js</Item>
                    <Item>ui/notification-train-mobile/panel-notification-train-mobile.js</Item>
                    <Item>ui/pantheon-chooser/screen-pantheon-chooser.js</Item>
                    <Item>ui/pantheon-complete/panel-pantheon-complete.js</Item>
                    <Item>ui/pantheon-chooser-item/pantheon-chooser-item.js</Item>
                    <Item>ui/pause-event-rules/screen-pause-event-rules.js</Item>
                    <Item>ui-next/screens/pause-menu/pause-menu-bootstrap.js</Item>
                    <Item>ui/place-building/model-place-building.js</Item>
                    <Item>ui/place-building/panel-place-building.js</Item>
                    <Item>ui/place-building/model-place-building-v2.js</Item>
                    <Item>ui/place-building/panel-place-building-v2.js</Item>
                    <Item>ui/place-population/model-place-population.js</Item>
                    <Item>ui/place-population/panel-place-population.js</Item>
                    <Item>ui/placement-city-banner/placement-city-banner.js</Item>
					<Item>ui/player-yields-report/player-yields-report-screen.js</Item>
					<Item>ui/plot-icon/plot-icon-random-event.js</Item>
                    <Item>ui/plot-icon/plot-icon-resource.js</Item>
                    <Item>ui/plot-icon/plot-icon-suggested-settlement.js</Item>
                    <Item>ui/plot-icon/plot-icon-archeology.js</Item>
                    <Item>ui/plot-workers/plot-workers-manager.js</Item>
                    <Item>ui/popup-sequencer/popup-sequencer.js</Item>
                    <Item>ui/production-chooser/panel-production-chooser.js</Item>
                    <Item>ui/production-chooser/panel-production-tooltips.js</Item>
                    <Item>ui/quest-tracker/narrative-quest-manager.js</Item>
                    <Item>ui/quest-tracker/quest-item.js</Item>
                    <Item>ui/quest-tracker/quest-list.js</Item>
                    <Item>ui/quest-tracker/quest-tracker.js</Item>
                    <Item>ui/quick-save-indicator/quick-save-indicator.js</Item>
                    <Item>ui/save-indicator/save-indicator.js</Item>
                    <Item>ui/small-narrative-event/small-narrative-event.js</Item>
                    <Item>ui/resource-allocation/screen-resource-allocation.js</Item>
                    <Item>ui/sub-system-dock/panel-sub-system-dock.js</Item>
                    <Item>ui/system-bar/panel-system-bar.js</Item>
                    <Item>ui/system-bar/panel-system-button.js</Item>
                    <Item>ui/tech-civic-complete/screen-tech-civic-complete.js</Item>
                    <Item>ui/tech-tree-chooser/screen-tech-tree-chooser.js</Item>
                    <Item>ui/tech-tree/screen-tech-tree.js</Item>
                    <Item>ui/tree-grid/tree-card.js</Item>
                    <Item>ui/tree-grid/tree-line.js</Item>
                    <Item>ui/tree-grid/tree-detail.js</Item>
                    <Item>ui/tooltips/plot-tooltip.js</Item>
                    <Item>ui/tooltips/relationship-tooltip.js</Item>
                    <Item>ui/tooltips/tech-civic-tooltip.js</Item>
                    <Item>ui/tooltips/advanced-start-tooltip.js</Item>
                    <Item>ui/tooltips/settlement-recommendation-tooltip.js</Item>
                    <Item>ui/tooltips/random-event-tooltip.js</Item>
                    <Item>ui/tooltips/archeology-tooltip.js</Item>
                    <Item>ui/tooltips/peace-deal-tooltip.js</Item>
                    <Item>ui/policies/screen-policies.js</Item>
                    <Item>ui/policies/policy-chooser-item.js</Item>
                    <Item>ui/screen-government-picker/screen-government-picker.js</Item>
                    <Item module="false">ui/tuner-input/tuner-input.js</Item>
                    <Item>ui/turn-icon/turn-icon.js</Item>
                    <Item>ui/tutorial/tutorial-callout.js</Item>
                    <Item>ui/tutorial/tutorial-dialog-page.js</Item>
                    <Item>ui/tutorial/tutorial-dialog.js</Item>
                    <Item>ui/tutorial/tutorial-inspector.js</Item>
                    <Item>ui/tutorial/tutorial-manager.js</Item>
                    <Item>ui/tutorial/tutorial-item.js</Item>
                    <Item>ui/tutorial/tutorial-quest-panel.js</Item>
                    <Item>ui/unit-actions/unit-actions.js</Item>
                    <Item>ui/unit-combat-preview/panel-unit-combat-preview.js</Item>
                    <Item>ui/unit-flags/army-commander-flags.js</Item>
                    <Item>ui/unit-flags/unit-flag-manager.js</Item>
                    <Item>ui/unit-flags/unit-flags-independent-powers.js</Item>
                    <Item>ui/unit-flags/unit-flags.js</Item>
                    <Item>ui/unit-interact/unit-action-handlers.js</Item>
                    <Item>ui/unit-promotion/panel-unit-promotion.js</Item>
                    <Item>ui/unit-selection/unit-selection.js</Item>
                    <Item>ui/unlocks/screen-unlocks.js</Item>
                    <Item>ui/unlocks/screen-reward-unlocked.js</Item>
                    <Item>ui/unlocks/model-unlocks.js</Item>
                    <Item>ui/unlocks/unlocks-manager.js</Item>
                    <Item>ui/unlocks/panel-player-rewards.js</Item>
                    <Item>ui/victory-points/model-victory-points.js</Item>
                    <Item>ui/victory-points/panel-victory-points.js</Item>
                    <Item>ui/views/view-advanced-start.js</Item>
                    <Item>ui/views/view-bonus-placement.js</Item>
                    <Item>ui/views/view-cinematic.js</Item>
                    <Item>ui/views/view-city.js</Item>
                    <Item>ui/views/view-diplomacy.js</Item>
                    <Item>ui/views/view-pause-menu.js</Item>
                    <Item>ui/views/view-placement.js</Item>
                    <Item>ui/views/view-screenshot.js</Item>
                    <Item>ui/views/view-resource-allocation.js</Item>
                    <Item>ui/views/view-unit-promotion.js</Item>
                    <Item>ui/views/view-unit.js</Item>
                    <Item>ui/views/view-reinforcement.js</Item>
                    <Item>ui/views/view-world.js</Item>
                    <Item>ui/watch-out/watch-out-manager.js</Item>
                    <Item>ui/watch-out/screen-watch-out.js</Item>
                    <Item>ui/world-anchor-text/world-anchor-text-manager.js</Item>
                    <Item>ui/world-anchor-text/world-anchor-text.js</Item>
                    <Item>ui/world-input/world-input.js</Item>
                    <Item>ui/world-vfx/world-vfx.js</Item>
                    <Item>ui/yield-bar/model-yield-bar.js</Item>
                    <Item>ui/yield-bar/yield-bar.js</Item>
                    <Item>ui/yield-bar-base/yield-bar-base.js</Item>
                </UIScripts>
                <UpdateDatabase>
                    <Item>data/gameplay.xml</Item>
                    <Item>data/advanced-start-gameeffects.xml</Item>
                    <Item>data/advisory.xml</Item>
                    <Item>data/age-transition-gameeffects.xml</Item>
                    <Item>data/ages.xml</Item>
                    <Item>data/army-names.xml</Item>
                    <Item>data/attributes-gameeffects.xml</Item>
                    <Item>data/attributes.xml</Item>
                    <Item>data/AI_Base.xml</Item>
					<Item>data/AI_Base_Naval.xml</Item>
                    <Item>data/Barbarians.xml</Item>
                    <Item>data/behaviortrees.xml</Item>
                    <Item>data/calendar.xml</Item>
                    <Item>data/capabilities.xml</Item>
                    <Item>data/city-commands.xml</Item>
                    <Item>data/city-properties.xml</Item>
                    <Item>data/civilizations-gameeffects.xml</Item>
                    <Item>data/civilizations.xml</Item>
                    <Item>data/civilopedia.xml</Item>
                    <Item>data/civilopedia-ages.xml</Item>
                    <Item>data/civilopedia-concepts.xml</Item>
                    <Item>data/common-property-types.xml</Item>
                    <Item>data/core-types.xml</Item>
                    <Item>data/constructibles.xml</Item>
                    <Item>data/definition-property-types.xml</Item>
                    <Item>data/difficulties.xml</Item>
                    <Item>data/diplomacy-actions.xml</Item>
                    <Item>data/diplomacy-deal-items.xml</Item>
                    <Item>data/diplomacy-deal-item-agreements.xml</Item>
                    <Item>data/diplomacy-gameeffects.xml</Item>
                    <Item>data/diplomacy-statements.xml</Item>
                    <Item>data/discovery-stories-gameeffects.xml</Item>
                    <Item>data/discovery-stories.xml</Item>
                    <Item>data/districts.xml</Item>
                    <Item>data/game-speeds.xml</Item>
                    <Item>data/gameplay-systems.xml</Item>
                    <Item>data/gossip.xml</Item>
                    <Item>data/governments.xml</Item>
                    <Item>data/happiness-identity.xml</Item>
                    <Item>data/happiness-identity-gameeffects.xml</Item>
                    <Item>data/Independents.xml</Item>
                    <Item>data/interface-modes.xml</Item>
                    <Item>data/leaders.xml</Item>
                    <Item>data/leaders-gameeffects.xml</Item>
                    <Item>data/legacy-path-gameeffects.xml</Item>
                    <Item>data/loading-info.xml</Item>
                    <Item>data/maps.xml</Item>
                    <Item>data/movies.xml</Item>
                    <Item>data/plot-effects.xml</Item>
                    <Item>data/mementos.xml</Item>
                    <Item>data/mementos-gameeffects.xml</Item>
                    <Item>data/metaprogression.xml</Item>
                    <Item>data/metaprogression-gameeffects.xml</Item>
                    <Item>data/modifiers.xml</Item>
                    <Item>data/named-places.xml</Item>
                    <Item>data/narrative-sifting.xml</Item>
                    <Item>data/narrative-crises-stories-gameeffects.xml</Item>
                    <Item>data/narrative-crises-stories.xml</Item>
                    <Item>data/narrative-stories-gameeffects.xml</Item>
                    <Item>data/narrative-stories.xml</Item>
                    <Item>data/narrative-stories-common.xml</Item>
                    <Item>data/narrative-stories-common-gameeffects.xml</Item>
                    <Item>data/narrative-tags.xml</Item>
                    <Item>data/notification.xml</Item>
                    <Item>data/player-properties.xml</Item>
                    <Item>data/progression-trees-common-gameeffects.xml</Item>
                    <Item>data/progression-trees-common.xml</Item>
                    <Item>data/projects.xml</Item>
                    <Item>data/projects-gameeffects.xml</Item>
                    <Item>data/pseudoyields.xml</Item>
                    <Item>data/racetowonders-terrain.xml</Item>
                    <Item>data/racetowonders-terrain-gameeffects.xml</Item>
                    <Item>data/marvelous-mountains-terrain.xml</Item>
                    <Item>data/marvelous-mountains-terrain-gameeffects.xml</Item>
                    <Item>data/resources.xml</Item>
                    <Item>data/resources-v2.xml</Item>
                    <Item>data/random-events.xml</Item>
                    <Item>data/religion.xml</Item>
                    <Item>data/routes.xml</Item>
                    <Item>data/terrain.xml</Item>
                    <Item>data/terrain-gameeffects.xml</Item>
                    <Item>data/traditions.xml</Item>
                    <Item>data/traditions-gameeffects.xml</Item>
                    <Item>data/unit-commands.xml</Item>
                    <Item>data/unit-movement.xml</Item>
                    <Item>data/unit-operations.xml</Item>
                    <Item>data/unit-properties.xml</Item>
                    <Item>data/unit-promotions-gameeffects.xml</Item>
                    <Item>data/unit-promotions.xml</Item>
                    <Item>data/units-gameeffects.xml</Item>
                    <Item>data/units.xml</Item>
                    <Item>data/unlocks.xml</Item>
                    <Item>data/victories.xml</Item>
                    <Item>data/wars.xml</Item>
                </UpdateDatabase>
                <UpdateColors>
                    <Item>data/colors/playercolors.xml</Item>
                    <Item>data/colors/playerstandardcolors.xml</Item>
                </UpdateColors>
                <UpdateIcons>
                    <Item>data/icons/advisor-icons.xml</Item>
                    <Item>data/icons/attribute-icons.xml</Item>
                    <Item>data/icons/chat-icons.xml</Item>
                    <Item>data/icons/city-icons.xml</Item>
                    <Item>data/icons/building-icons.xml</Item>
                    <Item>data/icons/card-icons.xml</Item>
                    <Item>data/icons/diplomacy-icons.xml</Item>
                    <Item>data/icons/civilization-icons.xml</Item>
                    <Item>data/icons/emoji-icons.xml</Item>
                    <Item>data/icons/improvement-icons.xml</Item>
                    <Item>data/icons/leader-icons.xml</Item>
                    <Item>data/icons/legacy-path-icons.xml</Item>
                    <Item>data/icons/misc-icons.xml</Item>
                    <Item>data/icons/modifier-icons.xml</Item>
                    <Item>data/icons/narrative-icons.xml</Item>
                    <Item>data/icons/notification-icons.xml</Item>
                    <Item>data/icons/project-icons.xml</Item>
                    <Item>data/icons/promotion-icons.xml</Item>
                    <Item>data/icons/radial-icons.xml</Item>
                    <Item>data/icons/random-event-icons.xml</Item>
                    <Item>data/icons/relationship-icons.xml</Item>
                    <Item>data/icons/resource-icons.xml</Item>
                    <Item>data/icons/resource-icons-v2.xml</Item>
                    <Item>data/icons/trade-icons.xml</Item>
                    <Item>data/icons/tradition-icons.xml</Item>
                    <Item>data/icons/unit-icons.xml</Item>
                    <Item>data/icons/wonder-icons.xml</Item>
                    <Item>data/icons/victory-icons.xml</Item>
                    <Item>data/icons/yield-icons.xml</Item>
                    <Item>data/icons/tutorial-icons.xml</Item>
                    <Item>data/icons/rewards-icons.xml</Item>
                    <Item>data/icons/platform-icons.xml</Item>
                </UpdateIcons>
                <UpdateText>
                    <Item>text/en_us/ShellText.xml</Item>
                    <Item>text/en_us/ConfigText.xml</Item>
                    <Item>text/en_us/ActionPanelText.xml</Item>
                    <Item>text/en_us/AdvancedOptionText.xml</Item>
                    <Item>text/en_us/AdvancedStartText.xml</Item>
                    <Item>text/en_us/AdvisorText.xml</Item>
                    <Item>text/en_us/AgeTransitionText.xml</Item>
                    <Item>text/en_us/ArmyNamesText.xml</Item>
                    <Item>text/en_us/AttributesText.xml</Item>
                    <Item>text/en_us/BannerText.xml</Item>
                    <Item>text/en_us/CalendarText.xml</Item>
                    <Item>text/en_us/CityCommandsText.xml</Item>
                    <Item>text/en_us/CivilizationText.xml</Item>
                    <Item>text/en_us/CivilopediaText.xml</Item>
                    <Item>text/en_us/Civilopedia_Ages_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Concepts_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Constructibles_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Features_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Resources_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Terrain_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Leaders_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Units_Text.xml</Item>
                    <Item>text/en_us/CombatPreviewText.xml</Item>
                    <Item>text/en_us/CommonText.xml</Item>
                    <Item>text/en_us/ConstructibleText.xml</Item>
                    <Item>text/en_us/CultureText.xml</Item>
                    <Item>text/en_us/DiplomacyText.xml</Item>
                    <Item>text/en_us/DiplomacyStatementText.xml</Item>
                    <Item>text/en_us/EffectText.xml</Item>
                    <Item>text/en_us/EraVictoryText.xml</Item>
                    <Item>text/en_us/GameplaySystemsText.xml</Item>
                    <Item>text/en_us/InGameText.xml</Item>
                    <Item>text/en_us/InterfaceModeText.xml</Item>
                    <Item>text/en_us/LeaderDialog_Augustus.xml</Item>
                    <Item>text/en_us/LeaderDialog_BenjaminFranklin.xml</Item>
                    <Item>text/en_us/LeaderDialog_Catherine.xml</Item>
                    <Item>text/en_us/LeaderDialog_Isabella.xml</Item>
                    <Item>text/en_us/LeaderDialog_Lafayette.xml</Item>
                    <Item>text/en_us/LeaderDialog_Amina.xml</Item>
                    <Item>text/en_us/LeaderDialog_Ashoka.xml</Item>
                    <Item>text/en_us/LeaderDialog_Charlemagne.xml</Item>
                    <Item>text/en_us/LeaderDialog_Confucius.xml</Item>
                    <Item>text/en_us/LeaderDialog_FriedrichII.xml</Item>
                    <Item>text/en_us/LeaderDialog_HarrietTubman.xml</Item>
                    <Item>text/en_us/LeaderDialog_Hatshepsut.xml</Item>
                    <Item>text/en_us/LeaderDialog_Himiko.xml</Item>
                    <Item>text/en_us/LeaderDialog_IbnBattuta.xml</Item>
                    <Item>text/en_us/LeaderDialog_Machiavelli.xml</Item>
                    <Item>text/en_us/LeaderDialog_Pachacuti.xml</Item>
                    <Item>text/en_us/LeaderDialog_Rizal.xml</Item>
                    <Item>text/en_us/LeaderDialog_TrungTrac.xml</Item>
                    <Item>text/en_us/LeaderDialog_Xerxes.xml</Item>
                    <Item>text/en_us/LeaderText.xml</Item>
                    <Item>text/en_us/LoadingText.xml</Item>
                    <Item>text/en_us/MapText.xml</Item>
                    <Item>text/en_us/MementoText.xml</Item>
                    <Item>text/en_us/UnlockableRewardsText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.generated.xml</Item>
                    <Item>text/en_us/NamedPlacesText.xml</Item>
                    <Item>text/en_us/NarrativeCrisesStoriesText.xml</Item>
                    <Item>text/en_us/NarrativeStoriesText.xml</Item>
                    <Item>text/en_us/NarrativeStoriesTextCommon.xml</Item>
                    <Item>text/en_us/NaturalWonderQuoteText.xml</Item>
                    <Item>text/en_us/NotificationText.xml</Item>
                    <Item>text/en_us/PauseMenuText.xml</Item>
                    <Item>text/en_us/PlayerOperationsText.xml</Item>
                    <Item>text/en_us/PlotTooltipText.xml</Item>
                    <Item>text/en_us/ProductionChooserText.xml</Item>
                    <Item>text/en_us/ProjectsText.xml</Item>
                    <Item>text/en_us/QuestTrackerText.xml</Item>
                    <Item>text/en_us/RandomEventsText.xml</Item>
                    <Item>text/en_us/ResourcesText.xml</Item>
                    <Item>text/en_us/SettlementRecommendationText.xml</Item>
                    <Item>text/en_us/SubSystemDockText.xml</Item>
                    <Item>text/en_us/SystemMessageText.xml</Item>
                    <Item>text/en_us/TerrainText.xml</Item>
                    <Item>text/en_us/TraditionsText.xml</Item>
                    <Item>text/en_us/TreasuryText.xml</Item>
                    <Item>text/en_us/TutorialText.xml</Item>
                    <Item>text/en_us/UIText.xml</Item>
                    <Item>text/en_us/UnitCommandsText.xml</Item>
                    <Item>text/en_us/UnitOperationsText.xml</Item>
                    <Item>text/en_us/UnitPromotionsText.xml</Item>
                    <Item>text/en_us/UnitText.xml</Item>
                    <Item>text/en_us/UnlockText.xml</Item>
                    <Item>text/en_us/VictoryProgressText.xml</Item>
                    <Item>text/en_us/VictoriesText.xml</Item>
                    <Item>text/en_us/WarNamesText.xml</Item>
                    <Item>text/en_us/WorkersText.xml</Item>
                    <Item>text/en_us/YieldsText.xml</Item>

                    <!-- Items below were generated via our loc tool. -->
                    <Item locale="de_DE">l10n/de_DE_Text.xml</Item>
                    <Item locale="es_ES">l10n/es_ES_Text.xml</Item>
                    <Item locale="fr_FR">l10n/fr_FR_Text.xml</Item>
                    <Item locale="it_IT">l10n/it_IT_Text.xml</Item>
                    <Item locale="ja_JP">l10n/ja_JP_Text.xml</Item>
                    <Item locale="ko_KR">l10n/ko_KR_Text.xml</Item>
                    <Item locale="pl_PL">l10n/pl_PL_Text.xml</Item>
                    <Item locale="pt_BR">l10n/pt_BR_Text.xml</Item>
                    <Item locale="ru_RU">l10n/ru_RU_Text.xml</Item>
                    <Item locale="zh_Hans_CN">l10n/zh_Hans_CN_Text.xml</Item>
                    <Item locale="zh_Hant_HK">l10n/zh_Hant_HK_Text.xml</Item>

                    <!-- These text-override entries must happen *after* translations. -->
                    <Item platform="Switch">text/en_us/ShellText_Premium_Services_NX.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_Premium_Services_NX.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_AdditionalContent_Console.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_RestrictedContent.xml</Item>

                    <Item ecosystem="game-center">
                        text/en_us/AttributesText_LegendUnlocks_AppleArcade.xml</Item>
                    <Item ecosystem="game-center">text/en_us/AdvancedOptionText_LegendPathsWarning_AppleArcade.xml</Item>
                </UpdateText>
                <UpdateArt>
                    <!-- Asset Packages that the mod depends on -->
                    <Item>Civ7</Item>
                    <Item>boot-shell</Item>
                </UpdateArt>
                <UIShortcuts>
                    <Item>ui/root-game.html</Item>
                </UIShortcuts>
                <UpdateVisualRemaps>
                    <Item>data/visual-remaps.xml</Item>
                </UpdateVisualRemaps>

                <ImportFiles locale="de_DE">
                    <Item>l10n/de_DE/intro.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_amina.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/de_DE/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="es_ES">
                    <Item>l10n/es_ES/intro.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_amina.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/es_ES/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="fr_FR">
                    <Item>l10n/fr_FR/intro.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_amina.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/fr_FR/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="it_IT">
                    <Item>l10n/it_IT/intro.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_amina.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/it_IT/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="ja_JP">
                    <Item>l10n/ja_JP/intro.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_amina.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/ja_JP/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="ko_KR">
                    <Item>l10n/ko_KR/intro.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_amina.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/ko_KR/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="pl_PL">
                    <Item>l10n/pl_PL/intro.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_amina.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/pl_PL/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="pt_BR">
                    <Item>l10n/pt_BR/intro.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_amina.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/pt_BR/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="ru_RU">
                    <Item>l10n/ru_RU/intro.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_amina.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/ru_RU/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="zh_Hans_CN">
                    <Item>l10n/zh_Hans_CN/intro.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_amina.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="zh_Hant_HK">
                    <Item>l10n/zh_Hant_HK/intro.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_amina.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>
            </Actions>
        </ActionGroup>
        <ActionGroup id="base-game-shell" scope="shell" criteria="always">
            <Actions>
                <ImportFiles>
                    <Item>ui/loading/root-loading.html</Item>
                </ImportFiles>
                <UIScripts>
                    <Item>ui/live-notice/live-notice.js</Item>
                </UIScripts>
                <UpdateArt>
                    <Item>boot-shell</Item>
                </UpdateArt>
                <UpdateDatabase>
                    <Item>config/config.xml</Item>
                    <Item>config/hall-of-fame.xml</Item>
                    <Item>config/metaprogression.xml</Item>
                    <Item>config/unlockableRewards.xml</Item>
                </UpdateDatabase>
                <UpdateColors>
                    <Item>data/colors/playercolors.xml</Item>
                    <Item>data/colors/playerstandardcolors.xml</Item>
                </UpdateColors>
                <UpdateIcons>
                    <Item>data/icons/attribute-icons.xml</Item>
                    <Item>data/icons/chat-icons.xml</Item>
                    <Item>data/icons/building-icons.xml</Item>
                    <Item>data/icons/city-icons.xml</Item>
                    <Item>data/icons/civilization-icons.xml</Item>
                    <Item>data/icons/emoji-icons.xml</Item>
                    <Item>data/icons/improvement-icons.xml</Item>
                    <Item>data/icons/leader-icons.xml</Item>
                    <Item>data/icons/legacy-path-icons.xml</Item>
                    <Item>data/icons/misc-icons.xml</Item>
                    <Item>data/icons/modifier-icons.xml</Item>
                    <Item>data/icons/narrative-icons.xml</Item>
                    <Item>data/icons/notification-icons.xml</Item>
                    <Item>data/icons/project-icons.xml</Item>
                    <Item>data/icons/radial-icons.xml</Item>
                    <Item>data/icons/relationship-icons.xml</Item>
                    <Item>data/icons/resource-icons.xml</Item>
                    <Item>data/icons/resource-icons-v2.xml</Item>
                    <Item>data/icons/tutorial-icons.xml</Item>
                    <Item>data/icons/unit-icons.xml</Item>
                    <Item>data/icons/yield-icons.xml</Item>
                    <Item>data/icons/platform-icons.xml</Item>
                </UpdateIcons>
                <UpdateText>
                    <Item>text/en_us/CivilizationText.xml</Item>
                    <Item>text/en_us/LeaderText.xml</Item>
                    <Item>text/en_us/LoadingText.xml</Item>
                    <Item>text/en_us/ShellText.xml</Item>
                    <Item>text/en_us/SystemMessageText.xml</Item>
                    <Item>text/en_us/AdvancedOptionText.xml</Item>
                    <Item>text/en_us/ConfigText.xml</Item>
                    <Item>text/en_us/HallOfFameText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.generated.xml</Item>
                    <Item>text/en_us/MementoText.xml</Item>
                    <Item>text/en_us/UnlockableRewardsText.xml</Item>
                    <Item>text/en_us/UIText.xml</Item>
                    <Item>text/en_us/UnlockText.xml</Item>
                    <Item>text/en_us/NarrativeCrisesStoriesText.xml</Item>
                    <Item>text/en_us/LeaderDialog_BenjaminFranklin.xml</Item>
                    <Item>text/en_us/LeaderDialog_Augustus.xml</Item>
                    <Item>text/en_us/LeaderDialog_Catherine.xml</Item>
                    <Item>text/en_us/LeaderDialog_Isabella.xml</Item>
                    <Item>text/en_us/LeaderDialog_Lafayette.xml</Item>
                    <Item>text/en_us/LeaderDialog_Amina.xml</Item>
                    <Item>text/en_us/LeaderDialog_Ashoka.xml</Item>
                    <Item>text/en_us/LeaderDialog_Charlemagne.xml</Item>
                    <Item>text/en_us/LeaderDialog_Confucius.xml</Item>
                    <Item>text/en_us/LeaderDialog_FriedrichII.xml</Item>
                    <Item>text/en_us/LeaderDialog_HarrietTubman.xml</Item>
                    <Item>text/en_us/LeaderDialog_Hatshepsut.xml</Item>
                    <Item>text/en_us/LeaderDialog_Himiko.xml</Item>
                    <Item>text/en_us/LeaderDialog_IbnBattuta.xml</Item>
                    <Item>text/en_us/LeaderDialog_Machiavelli.xml</Item>
                    <Item>text/en_us/LeaderDialog_Pachacuti.xml</Item>
                    <Item>text/en_us/LeaderDialog_Rizal.xml</Item>
                    <Item>text/en_us/LeaderDialog_TrungTrac.xml</Item>
                    <Item>text/en_us/LeaderDialog_Xerxes.xml</Item>
					<Item>text/en_us/VictoriesText.xml</Item>
					<!-- Items below were generated via our loc tool. -->
                    <Item locale="de_DE">l10n/de_DE_Text.xml</Item>
                    <Item locale="es_ES">l10n/es_ES_Text.xml</Item>
                    <Item locale="fr_FR">l10n/fr_FR_Text.xml</Item>
                    <Item locale="it_IT">l10n/it_IT_Text.xml</Item>
                    <Item locale="ja_JP">l10n/ja_JP_Text.xml</Item>
                    <Item locale="ko_KR">l10n/ko_KR_Text.xml</Item>
                    <Item locale="pl_PL">l10n/pl_PL_Text.xml</Item>
                    <Item locale="pt_BR">l10n/pt_BR_Text.xml</Item>
                    <Item locale="ru_RU">l10n/ru_RU_Text.xml</Item>
                    <Item locale="zh_Hans_CN">l10n/zh_Hans_CN_Text.xml</Item>
                    <Item locale="zh_Hant_HK">l10n/zh_Hant_HK_Text.xml</Item>

					<!-- These text-override entries must happen *after* translations. -->
                    <Item platform="Switch">text/en_us/ShellText_Premium_Services_NX.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_Premium_Services_NX.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_AdditionalContent_Console.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_RestrictedContent.xml</Item>

                    <Item ecosystem="game-center">
                        text/en_us/AttributesText_LegendUnlocks_AppleArcade.xml</Item>
                    <Item ecosystem="game-center">text/en_us/AdvancedOptionText_LegendPathsWarning_AppleArcade.xml</Item>
                </UpdateText>

                <ImportFiles>
                    <Item locale="de_DE">l10n/de_DE/intro.vtt</Item>
                    <Item locale="es_ES">l10n/es_ES/intro.vtt</Item>
                    <Item locale="fr_FR">l10n/fr_FR/intro.vtt</Item>
                    <Item locale="it_IT">l10n/it_IT/intro.vtt</Item>
                    <Item locale="ja_JP">l10n/ja_JP/intro.vtt</Item>
                    <Item locale="ko_KR">l10n/ko_KR/intro.vtt</Item>
                    <Item locale="pl_PL">l10n/pl_PL/intro.vtt</Item>
                    <Item locale="pt_BR">l10n/pt_BR/intro.vtt</Item>
                    <Item locale="ru_RU">l10n/ru_RU/intro.vtt</Item>
                    <Item locale="zh_Hans_CN">l10n/zh_Hans_CN/intro.vtt</Item>
                    <Item locale="zh_Hant_HK">l10n/zh_Hant_HK/intro.vtt</Item>
                </ImportFiles>

                <UIShortcuts>
                    <Item>ui/loading/root-loading.html</Item>
                </UIShortcuts>
                <!-- Load Visual Remaps in the shell too, so they can be adjusted. -->
                <UpdateVisualRemaps>
                    <Item>data/visual-remaps.xml</Item>
                </UpdateVisualRemaps>
            </Actions>
        </ActionGroup>
    </ActionGroups>
    <LocalizedText></LocalizedText>
</Mod>
</file>

<file path="mod/maps/bootstrap/defaults/base.js">
// @ts-nocheck
/**
 * Base defaults for Epic Diverse Huge map configs.
 *
 * Purpose
 * - Single, explicit source for baseline defaults that all consumers compose from.
 * - These values form the canonical defaults (no other hidden defaults elsewhere).
 *
 * Notes
 * - Keep objects frozen to discourage mutation and encourage override/merge patterns.
 * - Arrays are provided as plain arrays; resolver will treat arrays as replace-by-default.
 */
// @ts-check
const CLIMATE_BASELINE_DEFAULT = Object.freeze({
    blend: Object.freeze({
        baseWeight: 0.6,
        bandWeight: 0.4,
    }),
    bands: Object.freeze({
        deg0to10: 120,
        deg10to20: 104,
        deg20to35: 75,
        deg35to55: 70,
        deg55to70: 60,
        deg70plus: 45,
    }),
    orographic: Object.freeze({
        hi1Threshold: 350,
        hi1Bonus: 8,
        hi2Threshold: 600,
        hi2Bonus: 7,
    }),
    coastal: Object.freeze({
        coastalLandBonus: 24,
        shallowAdjBonus: 16,
    }),
    noise: Object.freeze({
        baseSpanSmall: 3,
        spanLargeScaleFactor: 1.0,
    }),
});
const CLIMATE_REFINE_DEFAULT = Object.freeze({
    waterGradient: Object.freeze({
        radius: 5,
        perRingBonus: 5,
        lowlandBonus: 3,
    }),
    orographic: Object.freeze({
        steps: 4,
        reductionBase: 8,
        reductionPerStep: 6,
    }),
    riverCorridor: Object.freeze({
        lowlandAdjacencyBonus: 14,
        highlandAdjacencyBonus: 5,
    }),
    lowBasin: Object.freeze({
        radius: 3,
        delta: 6,
    }),
});
const CLIMATE_SWATCHES_DEFAULT = Object.freeze({
    maxPerMap: 7,
    forceAtLeastOne: true,
    sizeScaling: Object.freeze({
        widthMulSqrt: 0.3,
        lengthMulSqrt: 0.4,
    }),
    types: Object.freeze({
        macroDesertBelt: Object.freeze({
            weight: 8,
            latitudeCenterDeg: 20,
            halfWidthDeg: 12,
            drynessDelta: 28,
            bleedRadius: 3,
        }),
        equatorialRainbelt: Object.freeze({
            weight: 3,
            latitudeCenterDeg: 0,
            halfWidthDeg: 10,
            wetnessDelta: 24,
            bleedRadius: 3,
        }),
        rainforestArchipelago: Object.freeze({
            weight: 7,
            islandBias: 2,
            reefBias: 1,
            wetnessDelta: 18,
            bleedRadius: 3,
        }),
        mountainForests: Object.freeze({
            weight: 2,
            coupleToOrogeny: true,
            windwardBonus: 6,
            leePenalty: 2,
            bleedRadius: 3,
        }),
        greatPlains: Object.freeze({
            weight: 5,
            latitudeCenterDeg: 45,
            halfWidthDeg: 8,
            dryDelta: 12,
            lowlandMaxElevation: 300,
            bleedRadius: 4,
        }),
    }),
});

const LANDMASS_DEFAULT = Object.freeze({
    baseWaterPercent: 64,
    waterThumbOnScale: -4,
    jitterAmpFracBase: 0.03,
    jitterAmpFracScale: 0.015,
    curveAmpFrac: 0.05,
    // Core-first: interiors lead; boundaries get a light assist only.
    boundaryBias: 0.25,
    // Soft backstop: minimum share of land in the high-closeness band.
    boundaryShareTarget: 0.15,
    tectonics: Object.freeze({
        interiorNoiseWeight: 0.3, // 0..1 blend weight for plate-interior noise
        fractalGrain: 4, // coarser grain keeps tectonic blobs thick
        boundaryArcWeight: 0.8, // convergent arc multiplier; 1.0 = parity with closeness
        boundaryArcNoiseWeight: 0.5, // raggedness for arcs (0 = straight, 1 = noisy)
    }),
    geometry: Object.freeze({
        post: Object.freeze({
            expandTiles: 0,
            expandWestTiles: 0,
            expandEastTiles: 0,
        }),
    }),
});

const FOUNDATION_SEED_DEFAULT = Object.freeze({
    mode: "engine",
    fixed: null,
    offset: 0,
    offsets: Object.freeze({
        plates: 0,
        dynamics: 0,
        surface: 0,
        diagnostics: 0,
    }),
    manifestHash: null,
});

const FOUNDATION_PLATES_DEFAULT = Object.freeze({
    seedMode: "engine",
    count: 8,
    axisAngles: Object.freeze([15, -20, 35]),
    convergenceMix: 0.6,
    relaxationSteps: 5,
    seedJitter: 3,
    interiorSmooth: 3,
    plateRotationMultiple: 5,
    seedOffset: 0,
});

const FOUNDATION_WIND_DEFAULT = Object.freeze({
    jetStreaks: 5,
    jetStrength: 1.75,
    variance: 0.6,
    coriolisZonalScale: 1.0,
});

const FOUNDATION_CURRENTS_DEFAULT = Object.freeze({
    basinGyreCountMax: 2,
    westernBoundaryBias: 1.1,
    currentStrength: 4.0,
});

const FOUNDATION_MANTLE_DEFAULT = Object.freeze({
    bumps: 7,
    amplitude: 0.75,
    scale: 0.4,
});

const FOUNDATION_DIRECTIONALITY_DEFAULT = Object.freeze({
    cohesion: 0.45,
    primaryAxes: Object.freeze({
        plateAxisDeg: 0,
        windBiasDeg: 260,
        currentBiasDeg: -5,
    }),
    interplay: Object.freeze({
        windsFollowPlates: 0.55,
        currentsFollowWinds: 0.7,
        riftsFollowPlates: 0.75,
        orogenyOpposesRifts: 0.55,
    }),
    hemispheres: Object.freeze({
        southernFlip: true,
        equatorBandDeg: 18,
        monsoonBias: 0.6,
    }),
    variability: Object.freeze({
        angleJitterDeg: 15,
        magnitudeVariance: 0.45,
        seedOffset: 0,
    }),
});

const FOUNDATION_OCEAN_SEPARATION_DEFAULT = Object.freeze({
    enabled: false,
    bandPairs: Object.freeze([
        [0, 1],
        [1, 2],
    ]),
    baseSeparationTiles: 2,
    boundaryClosenessMultiplier: 1.0,
    maxPerRowDelta: 3,
    respectSeaLanes: true,
    minChannelWidth: 4,
    edgeWest: Object.freeze({
        enabled: false,
        baseTiles: 0,
        boundaryClosenessMultiplier: 1.0,
        maxPerRowDelta: 2,
    }),
    edgeEast: Object.freeze({
        enabled: false,
        baseTiles: 0,
        boundaryClosenessMultiplier: 1.0,
        maxPerRowDelta: 2,
    }),
});

const FOUNDATION_POLICY_DEFAULT = Object.freeze({
    windInfluence: 1.0,
    currentHumidityBias: 0.4,
    boundaryFjordBias: 0.3,
    shelfReefBias: 0.2,
    oceanSeparation: FOUNDATION_OCEAN_SEPARATION_DEFAULT,
});

const FOUNDATION_SURFACE_DEFAULT = Object.freeze({
    landmass: LANDMASS_DEFAULT,
    oceanSeparation: FOUNDATION_OCEAN_SEPARATION_DEFAULT,
    overrides: Object.freeze({}),
});

const FOUNDATION_DYNAMICS_DEFAULT = Object.freeze({
    wind: FOUNDATION_WIND_DEFAULT,
    currents: FOUNDATION_CURRENTS_DEFAULT,
    mantle: FOUNDATION_MANTLE_DEFAULT,
    directionality: FOUNDATION_DIRECTIONALITY_DEFAULT,
});

const FOUNDATION_DIAGNOSTICS_DEFAULT = Object.freeze({
    logSeed: false,
    logPlates: false,
    logDynamics: false,
    logSurface: false,
});

const FOUNDATION_DEFAULT = Object.freeze({
    seed: FOUNDATION_SEED_DEFAULT,
    plates: FOUNDATION_PLATES_DEFAULT,
    dynamics: FOUNDATION_DYNAMICS_DEFAULT,
    surface: FOUNDATION_SURFACE_DEFAULT,
    policy: FOUNDATION_POLICY_DEFAULT,
    diagnostics: FOUNDATION_DIAGNOSTICS_DEFAULT,
});

export const BASE_CONFIG = /** @type {import('../map_config.types.js').MapConfig} */ Object.freeze({
    // --- Master Feature Toggles ---
    // Enable or disable major Climate Story systems. Set to false to skip a layer entirely.
    toggles: Object.freeze({
        STORY_ENABLE_HOTSPOTS: false,
        STORY_ENABLE_RIFTS: false,
        STORY_ENABLE_OROGENY: false,
        STORY_ENABLE_SWATCHES: false,
        STORY_ENABLE_PALEO: false,
        STORY_ENABLE_CORRIDORS: false,
    }),
    // --- Climate aggregates (baseline + refinement + swatches) ---
    climate: Object.freeze({
        baseline: CLIMATE_BASELINE_DEFAULT,
        refine: CLIMATE_REFINE_DEFAULT,
        swatches: CLIMATE_SWATCHES_DEFAULT,
    }),
    // --- Stage Manifest ---
    // Canonical execution order and dependency graph for generator stages.
    stageManifest: Object.freeze({
        order: Object.freeze([
            "foundation",
            "landmassPlates",
            "coastlines",
            "storySeed",
            "storyHotspots",
            "storyRifts",
            "storyOrogeny",
            "storyPaleo",
            "storyCorridorsPre",
            "islands",
            "mountains",
            "volcanoes",
            "lakes",
            "climateBaseline",
            "storySwatches",
            "rivers",
            "storyCorridorsPost",
            "climateRefine",
            "biomes",
            "features",
            "placement",
        ]),
        stages: Object.freeze({
            foundation: Object.freeze({
                enabled: true,
                provides: Object.freeze([
                    "foundationContext",
                    "plates",
                    "wind",
                    "currents",
                    "mantle",
                    "directionality",
                ]),
            }),
            landmassPlates: Object.freeze({
                enabled: true,
                requires: Object.freeze(["foundation"]),
                provides: Object.freeze(["continents", "plateWindows", "heightfield"]),
            }),
            coastlines: Object.freeze({
                enabled: true,
                requires: Object.freeze(["landmassPlates"]),
                provides: Object.freeze(["expandedCoasts", "heightfield"]),
            }),
            storySeed: Object.freeze({
                enabled: true,
                requires: Object.freeze(["coastlines"]),
                provides: Object.freeze(["storyTags", "marginTags"]),
            }),
            storyHotspots: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed", "foundation"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_HOTSPOTS"]),
            }),
            storyRifts: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed", "foundation"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_RIFTS"]),
            }),
            storyOrogeny: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed", "foundation"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_OROGENY"]),
            }),
            storyPaleo: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_PALEO"]),
            }),
            storyCorridorsPre: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_CORRIDORS"]),
            }),
            islands: Object.freeze({
                enabled: true,
                requires: Object.freeze(["storySeed"]),
                provides: Object.freeze(["heightfield"]),
            }),
            mountains: Object.freeze({
                enabled: true,
                requires: Object.freeze(["landmassPlates"]),
                provides: Object.freeze(["mountainHeights", "hillHeights", "heightfield"]),
            }),
            volcanoes: Object.freeze({
                enabled: true,
                requires: Object.freeze(["mountains"]),
                provides: Object.freeze(["volcanoes", "heightfield"]),
            }),
            lakes: Object.freeze({
                enabled: true,
                requires: Object.freeze(["mountains"]),
                provides: Object.freeze(["heightfield"]),
            }),
            climateBaseline: Object.freeze({
                enabled: true,
                requires: Object.freeze(["mountains"]),
                provides: Object.freeze(["rainfallBaseline", "climateField"]),
            }),
            storySwatches: Object.freeze({
                enabled: false,
                requires: Object.freeze(["climateBaseline", "storySeed"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_SWATCHES"]),
            }),
            rivers: Object.freeze({
                enabled: true,
                requires: Object.freeze(["climateBaseline"]),
                provides: Object.freeze(["rivers"]),
            }),
            storyCorridorsPost: Object.freeze({
                enabled: false,
                requires: Object.freeze(["rivers", "storyCorridorsPre"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_CORRIDORS"]),
            }),
            climateRefine: Object.freeze({
                enabled: true,
                requires: Object.freeze(["climateBaseline", "rivers"]),
                provides: Object.freeze(["rainfallRefined", "climateField"]),
            }),
            biomes: Object.freeze({
                enabled: true,
                requires: Object.freeze(["climateRefine"]),
                provides: Object.freeze(["biomes"]),
            }),
            features: Object.freeze({
                enabled: true,
                requires: Object.freeze(["biomes"]),
                provides: Object.freeze(["features"]),
            }),
            placement: Object.freeze({
                enabled: true,
                requires: Object.freeze(["features"]),
                provides: Object.freeze(["starts", "resources", "discoveries"]),
            }),
        }),
    }),
    // --- World Foundation (seed + physics controls) ---
    foundation: FOUNDATION_DEFAULT,
    // --- Climate Story Tunables ---
    // Detailed parameters for each narrative motif.
    story: Object.freeze({
        // Deep-ocean hotspot trails (aligned island chains)
        hotspot: Object.freeze({
            maxTrails: 12, // total trails on a Huge map
            steps: 15, // polyline steps per trail
            stepLen: 2, // tiles advanced per step
            minDistFromLand: 5, // keep trails away from coasts
            minTrailSeparation: 12, // avoid parallel clutter between trails
            paradiseBias: 2, // 2:1 paradise:volcanic selection weight
            volcanicBias: 1,
            volcanicPeakChance: 0.7, // chance a volcanic center "peeks" as land
        }),
        // Continental rift lines (linear inland lakes/shoulders)
        rift: Object.freeze({
            maxRiftsPerMap: 3,
            lineSteps: 18,
            stepLen: 2,
            shoulderWidth: 1,
        }),
        // Orogeny belts (windward/lee amplification along mountain chains)
        orogeny: Object.freeze({
            beltMaxPerContinent: 2,
            beltMinLength: 30,
            radius: 2,
            windwardBoost: 5,
            leeDrynessAmplifier: 1.2,
        }),
        // "Black swan" climate swatches (guaranteed N1 macro zone)
        swatches: CLIMATE_SWATCHES_DEFAULT,
        // PaleoHydrology (deltas, oxbows, fossil channels)
        paleo: Object.freeze({
            maxDeltas: 4,
            deltaFanRadius: 1,
            deltaMarshChance: 0.35,
            maxOxbows: 6,
            oxbowElevationMax: 580,
            maxFossilChannels: 12,
            fossilChannelLengthTiles: 12,
            fossilChannelStep: 2,
            fossilChannelHumidity: 6,
            fossilChannelMinDistanceFromCurrentRivers: 4,
            minDistanceFromStarts: 7,
            sizeScaling: Object.freeze({
                lengthMulSqrt: 0.7,
            }),
            elevationCarving: Object.freeze({
                enableCanyonRim: true,
                rimWidth: 4,
                canyonDryBonus: 3,
                bluffWetReduction: 0,
            }),
        }),
    }),
    // --- Microclimate & Feature Adjustments ---
    // Small deltas applied by refinement passes.
    microclimate: Object.freeze({
        rainfall: Object.freeze({
            riftBoost: 8,
            riftRadius: 2,
            paradiseDelta: 6,
            volcanicDelta: 8,
        }),
        features: Object.freeze({
            paradiseReefChance: 23, // % chance
            volcanicForestChance: 27, // % chance
            volcanicTaigaChance: 25, // % chance
        }),
    }),
    // --- Strategic Corridors (sea lanes, island-hop, land, river chains) ---
    corridors: Object.freeze({
        sea: Object.freeze({
            maxLanes: 3,
            minLengthFrac: 0.7,
            scanStride: 6,
            avoidRadius: 2,
            // Scoring and spacing controls
            preferDiagonals: true,
            laneSpacing: 6,
            minChannelWidth: 3,
        }),
        islandHop: Object.freeze({
            useHotspots: true,
            maxArcs: 2,
        }),
        land: Object.freeze({
            useRiftShoulders: true,
            maxCorridors: 5,
            minRunLength: 24,
            spacing: 11,
        }),
        river: Object.freeze({
            maxChains: 2,
            maxSteps: 80,
            preferLowlandBelow: 300,
            coastSeedRadius: 2,
            minTiles: 24,
            mustEndNearCoast: true,
        }),
        // Per-consumer policy strengths and behaviors
        policy: Object.freeze({
            sea: Object.freeze({
                // 'hard' = never edit on lanes; 'soft' = reduce chance instead of skip
                protection: "hard",
                // When protection is 'soft', multiply coast edit probabilities by this factor (0..1)
                softChanceMultiplier: 0.5,
            }),
            land: Object.freeze({
                // 0..1; scales grassland bias strength on land-open corridors
                biomesBiasStrength: 0.6,
            }),
            river: Object.freeze({
                // 0..1; scales grassland bias strength on river-chain corridors
                biomesBiasStrength: 0.5,
            }),
        }),
        // Corridor kinds and styles (probabilities are gentle multipliers; consumers must validate)
        kinds: Object.freeze({
            sea: Object.freeze({
                styles: Object.freeze({
                    ocean: Object.freeze({
                        edge: Object.freeze({
                            cliffsChance: 0.15,
                            fjordChance: 0.1,
                        }),
                        features: Object.freeze({
                            reefBias: 0.1,
                        }),
                    }),
                    coastal: Object.freeze({
                        edge: Object.freeze({
                            cliffsChance: 0.25,
                            bayCarveMultiplier: 1.15,
                        }),
                        features: Object.freeze({
                            reefBias: 0.2,
                        }),
                    }),
                }),
            }),
            islandHop: Object.freeze({
                styles: Object.freeze({
                    archipelago: Object.freeze({
                        features: Object.freeze({
                            reefBias: 0.5,
                        }),
                        edge: Object.freeze({
                            shelfReefMultiplier: 1.25,
                        }),
                    }),
                }),
            }),
            land: Object.freeze({
                styles: Object.freeze({
                    desertBelt: Object.freeze({
                        biomes: Object.freeze({
                            desert: 0.7,
                            plains: 0.25,
                            grassland: 0.1,
                            tundra: 0.05,
                        }),
                        edge: Object.freeze({
                            mountainRimChance: 0.4,
                            forestRimChance: 0.1,
                        }),
                    }),
                    plainsBelt: Object.freeze({
                        biomes: Object.freeze({
                            plains: 0.55,
                            grassland: 0.3,
                            desert: 0.1,
                            tundra: 0.05,
                        }),
                        edge: Object.freeze({
                            forestRimChance: 0.1,
                            hillRimChance: 0.08,
                        }),
                    }),
                    grasslandBelt: Object.freeze({
                        biomes: Object.freeze({
                            grassland: 0.6,
                            plains: 0.25,
                            tropical: 0.1,
                            tundra: 0.05,
                        }),
                        edge: Object.freeze({
                            forestRimChance: 0.15,
                            hillRimChance: 0.05,
                        }),
                    }),
                    canyon: Object.freeze({
                        biomes: Object.freeze({
                            desert: 0.45,
                            plains: 0.3,
                            grassland: 0.15,
                            tundra: 0.1,
                        }),
                        edge: Object.freeze({
                            cliffChance: 0.6,
                            mountainRimChance: 0.12,
                        }),
                    }),
                    plateau: Object.freeze({
                        biomes: Object.freeze({
                            plains: 0.4,
                            grassland: 0.35,
                            desert: 0.15,
                            tundra: 0.1,
                        }),
                        edge: Object.freeze({
                            escarpmentChance: 0.71,
                            mountainRimChance: 0.08,
                        }),
                    }),
                    flatMtn: Object.freeze({
                        biomes: Object.freeze({
                            grassland: 0.35,
                            plains: 0.3,
                            tundra: 0.2,
                            desert: 0.15,
                        }),
                        edge: Object.freeze({
                            mountainRimChance: 0.6,
                            forestRimChance: 0.3,
                        }),
                    }),
                }),
            }),
            river: Object.freeze({
                styles: Object.freeze({
                    riverChain: Object.freeze({
                        biomes: Object.freeze({
                            grassland: 0.6,
                            plains: 0.25,
                            tropical: 0.15,
                        }),
                        features: Object.freeze({
                            floodplainBias: 0.1,
                            forestBias: 0.1,
                        }),
                        edge: Object.freeze({
                            forestRimChance: 0.15,
                        }),
                    }),
                }),
            }),
        }),
    }),
    // --- Landmass (base land/ocean and shaping) ---
    landmass: LANDMASS_DEFAULT,
    // --- Coastlines (rugged coasts; lane-safe) ---
    coastlines: Object.freeze({
        bay: Object.freeze({
            noiseGateAdd: 0,
            rollDenActive: 4,
            rollDenDefault: 5,
        }),
        fjord: Object.freeze({
            baseDenom: 12,
            activeBonus: 1,
            passiveBonus: 2,
        }),
        minSeaLaneWidth: 4,
        plateBias: Object.freeze({
            threshold: 0.45,
            power: 1.25,
            convergent: 1.0,
            transform: 0.4,
            divergent: -0.6,
            interior: 0,
            bayWeight: 0.35,
            bayNoiseBonus: 1.0,
            fjordWeight: 0.8,
        }),
    }),
    // --- Margins (active/passive tagging) ---
    margins: Object.freeze({
        activeFraction: 0.25,
        passiveFraction: 0.25,
        minSegmentLength: 12,
    }),
    // --- Islands (offshore clusters; hotspot bias) ---
    islands: Object.freeze({
        fractalThresholdPercent: 90,
        baseIslandDenNearActive: 5,
        baseIslandDenElse: 7,
        hotspotSeedDenom: 2,
        clusterMax: 3,
        minDistFromLandRadius: 2,
    }),
    // --- Climate Baseline (banded blend + local bonuses) ---
    // --- Mountains & Hills (WorldModel-driven, physics-threshold system) ---
    mountains: Object.freeze({
        // Physics-threshold controls (mountains only where physics justifies)
        tectonicIntensity: 1.0,      // Base intensity (1.0 = standard tectonics)
        mountainThreshold: 0.45,     // Score must exceed this for mountains
        hillThreshold: 0.25,         // Score must exceed this for hills
        // Physics weights
        upliftWeight: 0.6,
        fractalWeight: 0.4,
        riftDepth: 0.25,
        boundaryWeight: 0.85,
        boundaryExponent: 1.3,
        interiorPenaltyWeight: 0.18,
        convergenceBonus: 0.65,
        transformPenalty: 0.25,
        riftPenalty: 0.65,
        hillBoundaryWeight: 0.4,
        hillRiftBonus: 0.45,
        hillConvergentFoothill: 0.22,
        hillInteriorFalloff: 0.2,
        hillUpliftWeight: 0.3,
    }),
    volcanoes: Object.freeze({
        enabled: true,
        baseDensity: 1 / 170,
        minSpacing: 3,
        boundaryThreshold: 0.35,
        boundaryWeight: 1.2,
        convergentMultiplier: 2.4,
        transformMultiplier: 1.1,
        divergentMultiplier: 0.35,
        hotspotWeight: 0.12,
        shieldPenalty: 0.6,
        randomJitter: 0.08,
        minVolcanoes: 5,
        maxVolcanoes: 40,
    }),
    // --- Biomes (nudges) ---
    biomes: Object.freeze({
        tundra: Object.freeze({
            latMin: 70,
            elevMin: 850,
            rainMax: 90,
        }),
        tropicalCoast: Object.freeze({
            latMax: 18,
            rainMin: 105,
        }),
        riverValleyGrassland: Object.freeze({
            latMax: 50,
            rainMin: 75,
        }),
        riftShoulder: Object.freeze({
            grasslandLatMax: 50,
            grasslandRainMin: 75,
            tropicalLatMax: 18,
            tropicalRainMin: 100,
        }),
    }),
    // --- Features density tweaks (validated) ---
    featuresDensity: Object.freeze({
        rainforestExtraChance: 75,
        forestExtraChance: 20,
        taigaExtraChance: 35,
        shelfReefMultiplier: 0.6,
    }),
    // --- Placement ---
    placement: Object.freeze({
        wondersPlusOne: true,
        floodplains: Object.freeze({
            minLength: 4,
            maxLength: 10,
        }),
    }),
    // --- Dev logger defaults (ON for development) ---
    // These feed the resolved config; dev.js will be aligned to read from them.
    dev: Object.freeze({
        enabled: true,
        logTiming: true,
        logStoryTags: true,
        rainfallHistogram: true,
        LOG_FOUNDATION_SUMMARY: true,
        LOG_FOUNDATION_ASCII: true,
        LOG_FOUNDATION_SEED: true,
        LOG_FOUNDATION_PLATES: true,
        LOG_BOUNDARY_METRICS: true,
        LOG_LANDMASS_ASCII: true,
        LOG_LANDMASS_WINDOWS: true,
        LOG_RELIEF_ASCII: true,
        LOG_MOUNTAINS: true,
    }),
});
export default BASE_CONFIG;
</file>

<file path="mod/maps/bootstrap/presets/classic.js">
// @ts-nocheck
/**
 * Classic preset  baseline threeband layout with vanillalike oceans.
 *
 * Purpose
 * - Provide a named, conservative baseline preset suitable as a starting point
 *   for variants. This preset is intentionally minimal and close to defaults.
 *
 * Usage (example)
 *   import { CLASSIC_PRESET } from "./config/presets/classic.js";
 *   setConfig({
 *     ...CLASSIC_PRESET,
 *     // Optional overrides...
 *   });
 */
// @ts-check
export const CLASSIC_PRESET = Object.freeze({
    stageConfig: Object.freeze({
        foundation: true,
        landmassPlates: true,
    }),
    // Keep all major systems enabled by default
    toggles: Object.freeze({
        STORY_ENABLE_HOTSPOTS: true,
        STORY_ENABLE_RIFTS: true,
        STORY_ENABLE_OROGENY: true,
        STORY_ENABLE_SWATCHES: true,
        STORY_ENABLE_PALEO: true,
        STORY_ENABLE_CORRIDORS: true,
    }),
    // Dev logger defaults (quiet; entries/presets may override for debugging)
    dev: Object.freeze({
        enabled: false,
        logTiming: false,
        logStoryTags: false,
        rainfallHistogram: false,
    }),
});
export default CLASSIC_PRESET;
</file>

<file path="mod/maps/bootstrap/presets/temperate.js">
// @ts-nocheck
/**
 * Temperate preset  gentle, tradewind world with classic threeband layout.
 *
 * Purpose
 * - Provide a concise, conservative preset to compose with defaults and/or
 *   per-entry overrides. This is a partial config (no exhaustive fields).
 *
 * Usage (example)
 *   import { TEMPERATE_PRESET } from "./config/presets/temperate.js";
 *   setConfig({
 *     ...TEMPERATE_PRESET,
 *     // Optional overrides...
 *   });
 */
// @ts-check
export const TEMPERATE_PRESET = Object.freeze({
    stageConfig: Object.freeze({
        foundation: true,
        landmassPlates: true,
    }),
    // Keep all major systems enabled (gentle, cohesive world)
    toggles: Object.freeze({
        STORY_ENABLE_HOTSPOTS: true,
        STORY_ENABLE_RIFTS: true,
        STORY_ENABLE_OROGENY: true,
        STORY_ENABLE_SWATCHES: true,
        STORY_ENABLE_PALEO: true,
        STORY_ENABLE_CORRIDORS: true,
    }),
    // Lightweight Earth Forces with moderated global cohesion
    foundation: Object.freeze({
        dynamics: Object.freeze({
            directionality: Object.freeze({
                cohesion: 0.6,
                hemispheres: Object.freeze({
                    // Slight seasonal/hemispheric asymmetry
                    monsoonBias: 0.25,
                }),
            }),
        }),
    }),
    // Dev logger defaults (quiet; entries may override during debugging)
    dev: Object.freeze({
        enabled: false,
        logTiming: false,
        logStoryTags: false,
        rainfallHistogram: false,
    }),
});
export default TEMPERATE_PRESET;
</file>

<file path="mod/maps/bootstrap/climate-tunables.js">
/**
 * Climate-focused tunable surface. Thin wrapper over the unified tunables module
 * so climate layers can import a concise bundle without re-export noise.
 */
export {
    rebind,
    CLIMATE_TUNABLES,
    CLIMATE,
    CLIMATE_CFG,
    CLIMATE_DRIVERS,
    MOISTURE_ADJUSTMENTS,
    STORY_TUNABLES,
} from "./tunables.js";
</file>

<file path="mod/maps/bootstrap/dev.js">
// @ts-nocheck
/**
 * Developer logging configuration and helpers (disabled by default).
 *
 * Purpose
 * - Centralize all dev-only flags and utilities so verbose logs can be enabled
 *   temporarily without touching generation logic.
 * - Keep all helpers no-op when disabled to avoid perf impact or noisy output.
 *
 * Usage (example)
 *   import { DEV, devLog, devLogIf, timeSection, logStoryTagsSummary, logRainfallHistogram } from "./config/dev.js";
 *
 *   // Enable locally for a debugging session:
 *   // DEV.ENABLED = true; DEV.LOG_TIMING = true; DEV.LOG_STORY_TAGS = true;
 *
 *   devLog("Hello from dev logs");
 *   devLogIf("LOG_STORY_TAGS", "Story tags will be summarized later");
 *
 *   timeSection("Layer: addIslandChains", () => {
 *     addIslandChains(width, height);
 *   });
 *
 *   logStoryTagsSummary(StoryTags);
 *   logRainfallHistogram(width, height, 12);
 */
/**
 * Master toggles (all false by default).
 * Flip selectively during development sessions; keep off for release builds.
 */
import * as globals from "/base-standard/maps/map-globals.js";
import { dumpTerrain, dumpRainfall, dumpBiomes, dumpContinents } from "/base-standard/maps/map-debug-helpers.js";
import { DEV_LOG_CFG as __DEV_CFG__, FOUNDATION_DIAGNOSTICS as __FOUNDATION_DIAGNOSTICS__ } from "./resolved.js";
export const DEV = {
    ENABLED: false, // Master switch  must be true for any dev logging
    LOG_TIMING: false, // Log per-section timings (timeSection / timeStart/timeEnd)
    LOG_STORY_TAGS: false, // Log StoryTags summary counts
    RAINFALL_HISTOGRAM: false, // Log a coarse rainfall histogram (non-water tiles only)
    LOG_RAINFALL_SUMMARY: false, // Log rainfall min/max/avg statistics
    LOG_CORRIDOR_ASCII: false, // Print a coarse ASCII overlay of corridor tags (downsampled)
    LOG_FOUNDATION_SUMMARY: false, // Print compact Foundation summary when available
    LOG_FOUNDATION_ASCII: false, // ASCII visualization of plate boundaries & terrain mix
    LOG_LANDMASS_ASCII: false, // ASCII snapshot of land vs. ocean bands/continents
    LOG_LANDMASS_WINDOWS: false, // Log landmass window bounding boxes/areas
    LOG_RELIEF_ASCII: false, // ASCII visualization of major relief (mountains/hills/volcanoes)
    LOG_RAINFALL_ASCII: false, // ASCII heatmap buckets for rainfall bands
    LOG_BIOME_ASCII: false, // ASCII biome classification overlay
    LOG_BIOME_SUMMARY: false, // Log biome tile counts
    LOG_SWATCHES: false, // Log climate swatch usage/results
    LOG_MOUNTAINS: false, // Detailed mountain placement summaries
    LOG_VOLCANOES: false, // Detailed volcano placement summaries
    LOG_BOUNDARY_METRICS: false, // Quantitative summary of plate boundary coverage
    FOUNDATION_HISTOGRAMS: false, // Print histograms for rift/uplift (optionally near tags)
    LAYER_COUNTS: false, // Reserved for layer-specific counters (if used by callers)
    LOG_FOUNDATION_SEED: false,
    LOG_FOUNDATION_PLATES: false,
    LOG_FOUNDATION_DYNAMICS: false,
    LOG_FOUNDATION_SURFACE: false,
};
/**
 * Internal: guard that checks if a specific flag is enabled (and master is on).
 * @param {keyof typeof DEV} flag
 * @returns {boolean}
 */
/**
 * Initialize DEV flags from resolved.DEV_LOG_CFG() at module import time.
 * Entries/presets can override dev logging per run.
 */
try {
    const __cfg = typeof __DEV_CFG__ === "function" ? __DEV_CFG__() : null;
    if (__cfg && typeof __cfg === "object") {
        if ("enabled" in __cfg)
            DEV.ENABLED = !!__cfg.enabled;
        if ("logTiming" in __cfg)
            DEV.LOG_TIMING = !!__cfg.logTiming;
        if ("logStoryTags" in __cfg)
            DEV.LOG_STORY_TAGS = !!__cfg.logStoryTags;
        if ("rainfallHistogram" in __cfg)
            DEV.RAINFALL_HISTOGRAM = !!__cfg.rainfallHistogram;
        if ("LOG_RAINFALL_SUMMARY" in __cfg)
            DEV.LOG_RAINFALL_SUMMARY = !!__cfg.LOG_RAINFALL_SUMMARY;
        if ("LOG_CORRIDOR_ASCII" in __cfg)
            DEV.LOG_CORRIDOR_ASCII = !!__cfg.LOG_CORRIDOR_ASCII;
        if ("LOG_FOUNDATION_SUMMARY" in __cfg)
            DEV.LOG_FOUNDATION_SUMMARY = !!__cfg.LOG_FOUNDATION_SUMMARY;
        else if ("LOG_WORLDMODEL_SUMMARY" in __cfg)
            DEV.LOG_FOUNDATION_SUMMARY = !!__cfg.LOG_WORLDMODEL_SUMMARY;
        if ("LOG_FOUNDATION_ASCII" in __cfg)
            DEV.LOG_FOUNDATION_ASCII = !!__cfg.LOG_FOUNDATION_ASCII;
        else if ("LOG_WORLDMODEL_ASCII" in __cfg)
            DEV.LOG_FOUNDATION_ASCII = !!__cfg.LOG_WORLDMODEL_ASCII;
        if ("LOG_LANDMASS_ASCII" in __cfg)
            DEV.LOG_LANDMASS_ASCII = !!__cfg.LOG_LANDMASS_ASCII;
        if ("LOG_LANDMASS_WINDOWS" in __cfg)
            DEV.LOG_LANDMASS_WINDOWS = !!__cfg.LOG_LANDMASS_WINDOWS;
        if ("LOG_RELIEF_ASCII" in __cfg)
            DEV.LOG_RELIEF_ASCII = !!__cfg.LOG_RELIEF_ASCII;
        if ("LOG_RAINFALL_ASCII" in __cfg)
            DEV.LOG_RAINFALL_ASCII = !!__cfg.LOG_RAINFALL_ASCII;
        if ("LOG_BIOME_ASCII" in __cfg)
            DEV.LOG_BIOME_ASCII = !!__cfg.LOG_BIOME_ASCII;
        if ("LOG_BIOME_SUMMARY" in __cfg)
            DEV.LOG_BIOME_SUMMARY = !!__cfg.LOG_BIOME_SUMMARY;
        if ("LOG_SWATCHES" in __cfg)
            DEV.LOG_SWATCHES = !!__cfg.LOG_SWATCHES;
        if ("LOG_BOUNDARY_METRICS" in __cfg)
            DEV.LOG_BOUNDARY_METRICS = !!__cfg.LOG_BOUNDARY_METRICS;
        if ("LOG_MOUNTAINS" in __cfg)
            DEV.LOG_MOUNTAINS = !!__cfg.LOG_MOUNTAINS;
        if ("LOG_VOLCANOES" in __cfg)
            DEV.LOG_VOLCANOES = !!__cfg.LOG_VOLCANOES;
        if ("FOUNDATION_HISTOGRAMS" in __cfg)
            DEV.FOUNDATION_HISTOGRAMS = !!__cfg.FOUNDATION_HISTOGRAMS;
        else if ("WORLDMODEL_HISTOGRAMS" in __cfg)
            DEV.FOUNDATION_HISTOGRAMS = !!__cfg.WORLDMODEL_HISTOGRAMS;
        if ("LOG_FOUNDATION_SEED" in __cfg)
            DEV.LOG_FOUNDATION_SEED = !!__cfg.LOG_FOUNDATION_SEED;
        if ("LOG_FOUNDATION_PLATES" in __cfg)
            DEV.LOG_FOUNDATION_PLATES = !!__cfg.LOG_FOUNDATION_PLATES;
        if ("LOG_FOUNDATION_DYNAMICS" in __cfg)
            DEV.LOG_FOUNDATION_DYNAMICS = !!__cfg.LOG_FOUNDATION_DYNAMICS;
        if ("LOG_FOUNDATION_SURFACE" in __cfg)
            DEV.LOG_FOUNDATION_SURFACE = !!__cfg.LOG_FOUNDATION_SURFACE;
    }
}
catch (_) {
    /* no-op */
}

applyFoundationDiagnostics();

function isOn(flag) {
    return !!(DEV && DEV.ENABLED && DEV[flag]);
}

function applyFoundationDiagnostics() {
    let diag = null;
    try {
        diag = typeof __FOUNDATION_DIAGNOSTICS__ === "function" ? __FOUNDATION_DIAGNOSTICS__() : null;
    }
    catch (_) {
        diag = null;
    }
    if (!diag || typeof diag !== "object")
        return;
    const { logSeed, logPlates, logDynamics, logSurface } = diag;
    if (logSeed || logPlates || logDynamics || logSurface)
        DEV.ENABLED = true;
    if (logSeed) {
        DEV.LOG_FOUNDATION_SEED = true;
    }
    if (logPlates) {
        DEV.LOG_FOUNDATION_PLATES = true;
        DEV.LOG_FOUNDATION_SUMMARY = true;
        DEV.LOG_FOUNDATION_ASCII = true;
        DEV.LOG_BOUNDARY_METRICS = true;
    }
    if (logDynamics) {
        DEV.LOG_FOUNDATION_DYNAMICS = true;
        DEV.FOUNDATION_HISTOGRAMS = true;
    }
    if (logSurface) {
        DEV.LOG_FOUNDATION_SURFACE = true;
        DEV.LOG_LANDMASS_ASCII = true;
        DEV.LOG_LANDMASS_WINDOWS = true;
    }
}
/**
 * Safe console.log wrapper (no-op if disabled).
 * @param  {...any} args
 */
export function devLog(...args) {
    if (!DEV.ENABLED)
        return;
    try {
        console.log("[DEV]", ...args);
    }
    catch (_) {
        /* swallow */
    }
}
/**
 * Conditional console.log wrapper for a specific flag under the master switch.
 * @param {keyof typeof DEV} flag
 * @param  {...any} args
 */
export function devLogIf(flag, ...args) {
    if (!isOn(flag))
        return;
    try {
        console.log(`[DEV][${String(flag)}]`, ...args);
    }
    catch (_) {
        /* swallow */
    }
}
/**
 * Time a synchronous section and log duration (no-op if LOG_TIMING disabled).
 * @template T
 * @param {string} label
 * @param {() => T} fn
 * @returns {T}
 */
export function timeSection(label, fn) {
    if (!isOn("LOG_TIMING"))
        return fn();
    const t0 = nowMs();
    try {
        return fn();
    }
    finally {
        const dt = nowMs() - t0;
        safeLog(`[DEV][time] ${label}: ${fmtMs(dt)}`);
    }
}
/**
 * Start a timing span; returns a token to pass to timeEnd.
 * No-op (returns null) if LOG_TIMING disabled.
 * @param {string} label
 * @returns {{label:string,t0:number}|null}
 */
export function timeStart(label) {
    if (!isOn("LOG_TIMING"))
        return null;
    return { label, t0: nowMs() };
}
/**
 * End a timing span started by timeStart.
 * Safe to call with null (no-op).
 * @param {{label:string,t0:number}|null} token
 */
export function timeEnd(token) {
    if (!token)
        return;
    const dt = nowMs() - token.t0;
    safeLog(`[DEV][time] ${token.label}: ${fmtMs(dt)}`);
}
/**
 * Log a compact summary of StoryTags (sizes of known sets).
 * Safe if StoryTags is missing or partially defined.
 * No-op if LOG_STORY_TAGS disabled.
 * @param {{hotspot?:Set<string>,hotspotParadise?:Set<string>,hotspotVolcanic?:Set<string>,riftLine?:Set<string>,riftShoulder?:Set<string>,activeMargin?:Set<string>,passiveShelf?:Set<string>}} StoryTags
 * @param {{belts?:Set<string>,windward?:Set<string>,lee?:Set<string>}} [OrogenyCache]
 */
export function logStoryTagsSummary(StoryTags, OrogenyCache) {
    if (!isOn("LOG_STORY_TAGS"))
        return;
    if (!StoryTags || typeof StoryTags !== "object") {
        safeLog("[DEV][story] StoryTags not available");
        return;
    }
    const counts = {
        hotspot: sizeOf(StoryTags.hotspot),
        hotspotParadise: sizeOf(StoryTags.hotspotParadise),
        hotspotVolcanic: sizeOf(StoryTags.hotspotVolcanic),
        riftLine: sizeOf(StoryTags.riftLine),
        riftShoulder: sizeOf(StoryTags.riftShoulder),
        activeMargin: sizeOf(StoryTags.activeMargin),
        passiveShelf: sizeOf(StoryTags.passiveShelf),
        corridorSeaLane: sizeOf(StoryTags.corridorSeaLane),
        corridorIslandHop: sizeOf(StoryTags.corridorIslandHop),
        corridorLandOpen: sizeOf(StoryTags.corridorLandOpen),
        corridorRiverChain: sizeOf(StoryTags.corridorRiverChain),
    };
    safeLog("[DEV][story] tags:", counts);
    if (OrogenyCache && typeof OrogenyCache === "object") {
        const oroCounts = {
            belts: sizeOf(OrogenyCache.belts),
            windward: sizeOf(OrogenyCache.windward),
            lee: sizeOf(OrogenyCache.lee),
        };
        if (oroCounts.belts > 0) {
            safeLog("[DEV][story] orogeny:", oroCounts);
        }
    }
    // Optional ASCII corridor overlay (downsampled)
    if (isOn("LOG_CORRIDOR_ASCII")) {
        logCorridorAsciiOverlay();
    }
}
/**
 * Build and log a rainfall histogram over non-water tiles (coarse bins).
 * Depends on GameplayMap (provided by the game engine at runtime).
 * No-op if RAINFALL_HISTOGRAM disabled or GameplayMap is unavailable.
 * @param {number} width
 * @param {number} height
 * @param {number} [bins=10]
 */
export function logRainfallHistogram(width, height, bins = 10) {
    if (!isOn("RAINFALL_HISTOGRAM"))
        return;
    try {
        if (typeof GameplayMap?.getRainfall !== "function" ||
            typeof GameplayMap?.isWater !== "function") {
            safeLog("[DEV][rain] GameplayMap API unavailable; skipping histogram.");
            return;
        }
        const counts = new Array(Math.max(1, Math.min(100, bins))).fill(0);
        let samples = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (GameplayMap.isWater(x, y))
                    continue;
                const r = clampTo(GameplayMap.getRainfall(x, y), 0, 200);
                const idx = Math.min(counts.length - 1, Math.floor((r / 201) * counts.length));
                counts[idx]++;
                samples++;
            }
        }
        if (samples === 0) {
            safeLog("[DEV][rain] No land samples for histogram.");
            return;
        }
        const pct = counts.map((c) => ((c / samples) * 100).toFixed(1) + "%");
        safeLog("[DEV][rain] histogram (bins=", counts.length, "):", pct);
    }
    catch (err) {
        safeLog("[DEV][rain] histogram error:", err);
    }
}

export function logRainfallStats(label = "rainfall", width, height) {
    if (!isOn("LOG_RAINFALL_SUMMARY"))
        return;
    try {
        const w = Number.isFinite(width) ? width : GameplayMap?.getGridWidth?.();
        const h = Number.isFinite(height) ? height : GameplayMap?.getGridHeight?.();
        if (!w || !h) {
            safeLog(`[DEV][rain] stats ${label}: No map bounds.`);
            return;
        }
        if (typeof GameplayMap?.getRainfall !== "function" || typeof GameplayMap?.isWater !== "function") {
            safeLog(`[DEV][rain] stats ${label}: GameplayMap API unavailable.`);
            return;
        }
        let min = Infinity;
        let max = -Infinity;
        let sum = 0;
        let landTiles = 0;
        const buckets = { arid: 0, semiArid: 0, temperate: 0, wet: 0, lush: 0 };
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (GameplayMap.isWater(x, y))
                    continue;
                const value = GameplayMap.getRainfall(x, y) ?? 0;
                landTiles++;
                if (value < min)
                    min = value;
                if (value > max)
                    max = value;
                sum += value;
                if (value < 25)
                    buckets.arid++;
                else if (value < 60)
                    buckets.semiArid++;
                else if (value < 95)
                    buckets.temperate++;
                else if (value < 130)
                    buckets.wet++;
                else
                    buckets.lush++;
            }
        }
        if (landTiles === 0) {
            safeLog(`[DEV][rain] stats ${label}: No land tiles.`);
            return;
        }
        const avg = sum / landTiles;
        safeLog(`[DEV][rain] stats ${label}:`, {
            landTiles,
            min,
            max,
            avg: Number(avg.toFixed(2)),
            buckets,
        });
    }
    catch (err) {
        safeLog(`[DEV][rain] stats ${label} error:`, err);
    }
}

export function logBiomeSummary(label = "biomes", width, height) {
    if (!isOn("LOG_BIOME_SUMMARY"))
        return;
    try {
        const w = Number.isFinite(width) ? width : GameplayMap?.getGridWidth?.();
        const h = Number.isFinite(height) ? height : GameplayMap?.getGridHeight?.();
        if (!w || !h) {
            safeLog(`[DEV][biome] summary ${label}: No map bounds.`);
            return;
        }
        if (typeof GameplayMap?.getBiomeType !== "function") {
            safeLog(`[DEV][biome] summary ${label}: GameplayMap.getBiomeType unavailable.`);
            return;
        }
        const counts = new Map();
        let landTiles = 0;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (GameplayMap.isWater?.(x, y))
                    continue;
                landTiles++;
                const id = GameplayMap.getBiomeType(x, y) ?? -1;
                counts.set(id, (counts.get(id) ?? 0) + 1);
            }
        }
        const summary = Array.from(counts.entries())
            .map(([id, count]) => ({
            id,
            name: resolveBiomeName(id),
            count,
            share: landTiles > 0 ? Number(((count / landTiles) * 100).toFixed(2)) : 0,
        }))
            .sort((a, b) => b.count - a.count);
        safeLog(`[DEV][biome] summary ${label}:`, {
            landTiles,
            summary,
        });
    }
    catch (err) {
        safeLog(`[DEV][biome] summary ${label} error:`, err);
    }
}

function resolveBiomeName(id) {
    try {
        if (id == null || id < 0)
            return null;
        const entry = GameInfo?.Biomes?.[id];
        if (entry?.Name)
            return entry.Name;
    }
    catch {
        /* ignore */
    }
    return null;
}

/**
 * Log foundation seed configuration and (optional) captured plate seed snapshot.
 * @param {any} seedConfig
 * @param {any} plateSeed
 * @param {{skipConfig?:boolean}} [options]
 */
export function logFoundationSeed(seedConfig, plateSeed, options = {}) {
    if (!isOn("LOG_FOUNDATION_SEED"))
        return;
    const { skipConfig = false } = options || {};
    try {
        if (!skipConfig) {
            safeLog("[Foundation] seed config:", summarizeFoundationSeedConfig(seedConfig));
        }
        if (plateSeed && typeof plateSeed === "object") {
            safeLog("[Foundation] plate seed snapshot:", summarizePlateSeed(plateSeed));
        }
    }
    catch (err) {
        safeLog("[Foundation] seed log error:", err);
    }
}

/**
 * Log configured plate generation parameters.
 * @param {any} platesConfig
 */
export function logFoundationPlates(platesConfig) {
    if (!isOn("LOG_FOUNDATION_PLATES"))
        return;
    try {
        safeLog("[Foundation] plates config:", summarizeFoundationPlates(platesConfig));
    }
    catch (err) {
        safeLog("[Foundation] plates log error:", err);
    }
}

/**
 * Log wind/currents/mantle/directionality drivers.
 * @param {any} dynamicsConfig
 */
export function logFoundationDynamics(dynamicsConfig) {
    if (!isOn("LOG_FOUNDATION_DYNAMICS"))
        return;
    try {
        safeLog("[Foundation] dynamics config:", summarizeFoundationDynamics(dynamicsConfig));
    }
    catch (err) {
        safeLog("[Foundation] dynamics log error:", err);
    }
}

/**
 * Log surface targets (landmass + ocean separation).
 * @param {any} surfaceConfig
 */
export function logFoundationSurface(surfaceConfig) {
    if (!isOn("LOG_FOUNDATION_SURFACE"))
        return;
    try {
        safeLog("[Foundation] surface config:", summarizeFoundationSurface(surfaceConfig));
    }
    catch (err) {
        safeLog("[Foundation] surface log error:", err);
    }
}
/**
 * Foundation summary: plates and boundary type counts (compact).
 * Accepts a WorldModel-like object (so callers can pass the singleton).
 * No-op if LOG_FOUNDATION_SUMMARY disabled.
 * @param {{isEnabled?:()=>boolean,plateId?:Int16Array,boundaryType?:Uint8Array,boundaryCloseness?:Uint8Array,upliftPotential?:Uint8Array, riftPotential?:Uint8Array}} WorldModel
 */
export function logFoundationSummary(WorldModel) {
    if (!isOn("LOG_FOUNDATION_SUMMARY"))
        return;
    try {
        const enabled = !!WorldModel &&
            typeof WorldModel.isEnabled === "function" &&
            !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        const size = Math.max(0, width * height) | 0;
        const plateId = WorldModel.plateId;
        const bType = WorldModel.boundaryType;
        const bClose = WorldModel.boundaryCloseness;
        const uplift = WorldModel.upliftPotential;
        const rift = WorldModel.riftPotential;
        if (!plateId || !bType || !bClose) {
            safeLog("[DEV][foundation] Missing core fields; skipping summary.");
            return;
        }
        const plates = new Set();
        const btCounts = [0, 0, 0, 0]; // none, convergent, divergent, transform
        let boundaryTiles = 0;
        const n = Math.min(size, plateId.length, bType.length, bClose.length);
        for (let i = 0; i < n; i++) {
            plates.add(plateId[i]);
            const bt = bType[i] | 0;
            if (bt >= 0 && bt < btCounts.length)
                btCounts[bt]++;
            if ((bClose[i] | 0) > 32)
                boundaryTiles++;
        }
        function avgByte(arr) {
            if (!arr || !arr.length)
                return 0;
            const m = Math.min(arr.length, size || arr.length);
            let s = 0;
            for (let i = 0; i < m; i++)
                s += arr[i] | 0;
            return Math.round(s / Math.max(1, m));
        }
        // Row sampling to spot directional bias quickly.
        const rowSamples = [];
        const rowsToSample = [0, Math.floor(height * 0.25), Math.floor(height * 0.5), Math.floor(height * 0.75), height - 1].filter((y, idx, arr) => y >= 0 && y < height && arr.indexOf(y) === idx);
        for (const y of rowsToSample) {
            let clos = 0, ups = 0, landClos = 0, landUps = 0, landCount = 0;
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const c = bClose[i] | 0;
                const u = uplift ? uplift[i] | 0 : 0;
                const isLand = GameplayMap?.isWater ? !GameplayMap.isWater(x, y) : true;
                clos += c;
                ups += u;
                if (isLand) {
                    landCount++;
                    landClos += c;
                    landUps += u;
                }
            }
            rowSamples.push({
                row: y,
                closAvg: Math.round(clos / Math.max(1, width)),
                upliftAvg: uplift ? Math.round(ups / Math.max(1, width)) : null,
                landCount,
                landClosAvg: landCount ? Math.round(landClos / landCount) : null,
                landUpliftAvg: landCount && uplift ? Math.round(landUps / landCount) : null,
            });
        }
        const summary = {
            width,
            height,
            plates: plates.size,
            boundaryTiles,
            boundaryTypes: {
                none: btCounts[0] | 0,
                convergent: btCounts[1] | 0,
                divergent: btCounts[2] | 0,
                transform: btCounts[3] | 0,
            },
            upliftAvg: uplift ? avgByte(uplift) : null,
            riftAvg: rift ? avgByte(rift) : null,
            rowSamples,
        };
        safeLog(`[DEV][foundation] summary: ${JSON.stringify(summary)}`);
    }
    catch (err) {
        safeLog("[DEV][foundation] summary error:", err);
    }
}
/**
 * Foundation histograms for uplift/rift potentials. Optionally restrict samples
 * to tiles included in provided tag sets (Orogeny belts or Rift lines).
 * No-op if FOUNDATION_HISTOGRAMS disabled.
 * @param {{isEnabled?:()=>boolean,upliftPotential?:Uint8Array, riftPotential?:Uint8Array}} WorldModel
 * @param {{riftSet?:Set<string>, beltSet?:Set<string>, bins?:number}} [opts]
 */
export function logFoundationHistograms(WorldModel, opts = {}) {
    if (!isOn("FOUNDATION_HISTOGRAMS"))
        return;
    try {
        const enabled = !!WorldModel &&
            typeof WorldModel.isEnabled === "function" &&
            !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] hist: WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        const size = Math.max(0, width * height) | 0;
        const uplift = WorldModel.upliftPotential;
        const rift = WorldModel.riftPotential;
        if (!uplift || !rift) {
            safeLog("[DEV][foundation] hist: Missing fields (uplift/rift).");
            return;
        }
        const bins = Math.max(5, Math.min(50, opts.bins | 0 || 10));
        const histAll = (arr) => {
            const h = new Array(bins).fill(0);
            const n = Math.min(arr.length, size || arr.length);
            let samples = 0;
            for (let i = 0; i < n; i++) {
                const v = arr[i] | 0; // 0..255
                const bi = Math.min(bins - 1, Math.floor((v / 256) * bins));
                h[bi]++;
                samples++;
            }
            return { h, samples };
        };
        const histMasked = (arr, maskSet) => {
            if (!maskSet || !(maskSet instanceof Set) || maskSet.size === 0)
                return null;
            const h = new Array(bins).fill(0);
            let samples = 0;
            // Scan grid once; test membership by tile key
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const key = `${x},${y}`;
                    if (!maskSet.has(key))
                        continue;
                    const i = y * width + x;
                    const v = arr[i] | 0;
                    const bi = Math.min(bins - 1, Math.floor((v / 256) * bins));
                    h[bi]++;
                    samples++;
                }
            }
            return { h, samples };
        };
        const pct = (h, total) => h.map((c) => ((c / Math.max(1, total)) * 100).toFixed(1) + "%");
        const aU = histAll(uplift);
        const aR = histAll(rift);
        safeLog("[DEV][foundation] uplift (all) hist:", pct(aU.h, aU.samples));
        safeLog("[DEV][foundation] rift   (all) hist:", pct(aR.h, aR.samples));
        // Optional masked histograms near tags
        const mUrift = histMasked(uplift, opts.riftSet);
        const mRrift = histMasked(rift, opts.riftSet);
        if (mUrift && mRrift) {
            safeLog("[DEV][foundation] uplift (near riftLine) hist:", pct(mUrift.h, mUrift.samples));
            safeLog("[DEV][foundation] rift   (near riftLine) hist:", pct(mRrift.h, mRrift.samples));
        }
        const mUbelts = histMasked(uplift, opts.beltSet);
        const mRbelts = histMasked(rift, opts.beltSet);
        if (mUbelts && mRbelts) {
            safeLog("[DEV][foundation] uplift (near orogeny belts) hist:", pct(mUbelts.h, mUbelts.samples));
            safeLog("[DEV][foundation] rift   (near orogeny belts) hist:", pct(mRbelts.h, mRbelts.samples));
        }
    }
    catch (err) {
        safeLog("[DEV][foundation] hist error:", err);
    }
}
const ASCII_GRID_LAYOUT = {
    basePadding: {
        left: " ",
        right: " ",
    },
    overlayPadding: {
        left: " ",
        right: " ",
    },
};
const ASCII_FOUNDATION_CHARS = {
    base: {
        water: "~",
        land: ".",
    },
    overlay: {
        convergent: "^",
        divergent: "_",
        transform: "#",
        boundary: " ",
    },
};
const ASCII_CORRIDOR_CHARS = {
    base: {
        water: "~",
        land: ".",
    },
    overlays: {
        seaLane: "S",
        islandHop: "I",
        riverChain: "R",
        landOpen: "L",
    },
};
export const ASCII_DISPLAY = {
    grid: ASCII_GRID_LAYOUT,
    foundation: ASCII_FOUNDATION_CHARS,
    corridor: ASCII_CORRIDOR_CHARS,
};
/**
 * ASCII snapshot of terrain with optional plate-boundary overlay.
 * Prints a base map (water/mountains/hills/volcanoes) and a second map where
 * boundary tiles are annotated with their type (C=convergent, R=rift/divergent,
 * T=transform, +=boundary/no type).
 * @param {{isEnabled?:()=>boolean,boundaryCloseness?:Uint8Array,boundaryType?:Uint8Array}} WorldModel
 * @param {{step?:number,boundaryThreshold?:number}} [opts]
 */
export function logFoundationAscii(WorldModel, opts = {}) {
    if (!isOn("LOG_FOUNDATION_ASCII"))
        return;
    try {
        const enabled = !!WorldModel &&
            typeof WorldModel.isEnabled === "function" &&
            !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] ascii: WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog("[DEV][foundation] ascii: No map bounds; skipping overlay.");
            return;
        }
        const boundaryCloseness = WorldModel.boundaryCloseness;
        const boundaryType = WorldModel.boundaryType;
        if (!boundaryCloseness || !boundaryType) {
            safeLog("[DEV][foundation] ascii: Missing boundary data.");
            return;
        }
        const size = width * height;
        const boundaryLen = Math.min(size, boundaryCloseness.length, boundaryType.length);
        if (!boundaryLen) {
            safeLog("[DEV][foundation] ascii: Boundary arrays empty.");
            return;
        }
        const sampleStep = computeAsciiSampleStep(width, height, opts.step);
        const thresholdRatio = typeof opts.boundaryThreshold === "number"
            ? Math.max(0, Math.min(1, opts.boundaryThreshold))
            : 0.65;
        const closenessCutoff = Math.round(thresholdRatio * 255);
        const asciiChars = ASCII_DISPLAY.foundation;
        const baseWater = asciiChars.base.water;
        const baseLand = asciiChars.base.land;
        const overlays = asciiChars.overlay;
        const rows = renderAsciiGrid(width, height, sampleStep, (x, y) => {
            const idx = y * width + x;
            const close = idx < boundaryLen ? boundaryCloseness[idx] | 0 : 0;
            const isBoundary = close >= closenessCutoff;
            const base = GameplayMap?.isWater?.(x, y) ? baseWater : baseLand;
            if (!isBoundary)
                return { base };
            const bType = boundaryType[idx] | 0;
            const overlay = bType === 1
                ? overlays.convergent
                : bType === 2
                    ? overlays.divergent
                    : bType === 3
                        ? overlays.transform
                        : overlays.boundary;
            return { base, overlay };
        });
        safeLog(`[DEV][foundation] ascii plates (step=${sampleStep}): base ${legendBasePair(baseWater)} ocean, ${legendBasePair(baseLand)} land; overlays ${overlays.convergent} convergent, ${overlays.divergent} divergent, ${overlays.transform} transform, ${overlays.boundary} boundary/unknown`);
        rows.forEach((row) => safeLog(row));
    }
    catch (err) {
        safeLog("[DEV][foundation] ascii error:", err);
    }
}

export function logLandmassAscii(label = "landmass", opts = {}) {
    if (!isOn("LOG_LANDMASS_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][landmass] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][landmass] dump ${label}: delegating to base-standard dumpContinents()`);
        dumpContinents(width, height);
    }
    catch (err) {
        safeLog(`[DEV][landmass] dump ${label} error:`, err);
    }
}

export function logTerrainReliefAscii(label = "relief") {
    if (!isOn("LOG_RELIEF_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][relief] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][relief] dump ${label}: delegating to base-standard dumpTerrain()`);
        dumpTerrain(width, height);
    }
    catch (err) {
        safeLog(`[DEV][relief] dump ${label} error:`, err);
    }
}

export function logRainfallAscii(label = "rainfall") {
    if (!isOn("LOG_RAINFALL_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][rain] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][rain] dump ${label}: delegating to base-standard dumpRainfall()`);
        dumpRainfall(width, height);
    }
    catch (err) {
        safeLog(`[DEV][rain] dump ${label} error:`, err);
    }
}

export function logBiomeAscii(label = "biomes") {
    if (!isOn("LOG_BIOME_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][biome] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][biome] dump ${label}: delegating to base-standard dumpBiomes()`);
        dumpBiomes(width, height);
    }
    catch (err) {
        safeLog(`[DEV][biome] dump ${label} error:`, err);
    }
}
/**
 * Quantitative boundary diagnostics (coverage, closeness bands, terrain overlays).
 * @param {{isEnabled?:()=>boolean,boundaryType?:Uint8Array,boundaryCloseness?:Uint8Array}} WorldModel
 * @param {{bins?:number,thresholds?:number[],stage?:string}} [opts]
 */
export function logBoundaryMetrics(WorldModel, opts = {}) {
    if (!isOn("LOG_BOUNDARY_METRICS"))
        return;
    try {
        const enabled = !!WorldModel && typeof WorldModel.isEnabled === "function" && !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] metrics: WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog("[DEV][foundation] metrics: No map bounds.");
            return;
        }
        const boundaryType = WorldModel.boundaryType;
        const boundaryCloseness = WorldModel.boundaryCloseness;
        if (!boundaryType || !boundaryCloseness) {
            safeLog("[DEV][foundation] metrics: Missing boundary arrays.");
            return;
        }
        const bins = Math.max(3, Math.min(40, Number.isFinite(opts.bins) ? Math.trunc(opts.bins) : 10));
        const thresholds = Array.isArray(opts.thresholds) && opts.thresholds.length
            ? opts.thresholds.map((t) => Math.max(0, Math.min(1, Number(t)))).sort((a, b) => a - b)
            : [0.35, 0.6];
        const stage = opts.stage ? ` (${String(opts.stage)})` : "";

        const hist = new Array(bins).fill(0);
        const counts = [0, 0, 0, 0];
        const thresholdHits = thresholds.map(() => 0);
        const mountainByType = [0, 0, 0, 0];
        const hillByType = [0, 0, 0, 0];
        const volcanoByType = [0, 0, 0, 0];
        const mountainByBand = thresholds.map(() => 0);
        const hillByBand = thresholds.map(() => 0);
        const volcanoByBand = thresholds.map(() => 0);

        let mountains = 0;
        let hills = 0;
        let volcanoes = 0;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const closeness = (boundaryCloseness[i] | 0) / 255;
                const bType = boundaryType[i] | 0;
                if (bType >= 0 && bType < counts.length)
                    counts[bType]++;
                const bin = Math.min(bins - 1, Math.floor(closeness * bins));
                hist[bin]++;
                thresholds.forEach((t, idx) => {
                    if (closeness >= t)
                        thresholdHits[idx]++;
                });

                const isMountain = !!GameplayMap.isMountain?.(x, y);
                const terrainType = GameplayMap.getTerrainType?.(x, y) ?? -1;
                const featureType = GameplayMap.getFeatureType?.(x, y) ?? -1;

                if (isMountain) {
                    mountains++;
                    if (bType >= 0 && bType < mountainByType.length)
                        mountainByType[bType]++;
                    thresholds.forEach((t, idx) => {
                        if (closeness >= t)
                            mountainByBand[idx]++;
                    });
                } else if (terrainType === globals.g_HillTerrain) {
                    hills++;
                    if (bType >= 0 && bType < hillByType.length)
                        hillByType[bType]++;
                    thresholds.forEach((t, idx) => {
                        if (closeness >= t)
                            hillByBand[idx]++;
                    });
                }
                if (featureType === globals.g_VolcanoFeature) {
                    volcanoes++;
                    if (bType >= 0 && bType < volcanoByType.length)
                        volcanoByType[bType]++;
                    thresholds.forEach((t, idx) => {
                        if (closeness >= t)
                            volcanoByBand[idx]++;
                    });
                }
            }
        }

        const totalTiles = Math.min(boundaryType.length, boundaryCloseness.length, width * height);
        const pct = (value, total) => total > 0 ? ((value / total) * 100).toFixed(1) + "%" : "0%";

        safeLog(`[DEV][foundation] metrics${stage}: counts ${JSON.stringify({
            totalTiles,
            none: counts[0],
            convergent: counts[1],
            divergent: counts[2],
            transform: counts[3],
        })}`);
        safeLog(`[DEV][foundation] metrics: share ${JSON.stringify({
            convergent: pct(counts[1], totalTiles),
            divergent: pct(counts[2], totalTiles),
            transform: pct(counts[3], totalTiles),
        })}`);
        safeLog(`[DEV][foundation] metrics: closeness histogram ${JSON.stringify(hist.map((count, idx) => ({ bin: idx, count })))}`);
        thresholds.forEach((t, idx) => {
            safeLog(`[DEV][foundation] metrics: closeness >= ${t.toFixed(2)} ${JSON.stringify({
                tiles: thresholdHits[idx],
                share: pct(thresholdHits[idx], totalTiles),
            })}`);
        });
        safeLog(`[DEV][foundation] metrics: mountains ${JSON.stringify({
            total: mountains,
            none: mountainByType[0],
            convergent: mountainByType[1],
            divergent: mountainByType[2],
            transform: mountainByType[3],
        })}`);
        safeLog(`[DEV][foundation] metrics: hills ${JSON.stringify({
            total: hills,
            none: hillByType[0],
            convergent: hillByType[1],
            divergent: hillByType[2],
            transform: hillByType[3],
        })}`);
        safeLog(`[DEV][foundation] metrics: volcanoes ${JSON.stringify({
            total: volcanoes,
            none: volcanoByType[0],
            convergent: volcanoByType[1],
            divergent: volcanoByType[2],
            transform: volcanoByType[3],
        })}`);
        thresholds.forEach((t, idx) => {
            safeLog(`[DEV][foundation] metrics: >=${t.toFixed(2)} overlays ${JSON.stringify({
                mountains: mountainByBand[idx],
                hills: hillByBand[idx],
                volcanoes: volcanoByBand[idx],
            })}`);
        });
    }
    catch (err) {
        safeLog("[DEV][foundation] metrics error:", err);
    }
}
/**
 * Log a coarse ASCII overlay of corridor tags (downsampled).
 * Legend:
 * Legend:
 *  - S: corridorSeaLane (protected open water)
 *  - I: corridorIslandHop (hotspot arcs over water)
 *  - R: corridorRiverChain (river-adjacent land)
 *  - L: corridorLandOpen (open land lanes)
 *  - ~: water (no corridor)
 *  - .: land (no corridor)
 * The overlay samples every `step` tiles to keep output compact on Huge maps.
 * @param {number} [step=8] sampling stride in tiles
 */
export function logCorridorAsciiOverlay(step = 8) {
    if (!isOn("LOG_CORRIDOR_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog("[DEV][corridor] No map bounds; skipping ASCII overlay.");
            return;
        }
        const s = computeAsciiSampleStep(width, height, step);
        const asciiChars = ASCII_DISPLAY.corridor;
        const baseWater = asciiChars.base.water;
        const baseLand = asciiChars.base.land;
        const overlayChars = asciiChars.overlays;
        safeLog(`[DEV][corridor] ASCII overlay (step=${s}): base ${legendBasePair(baseWater)} ocean, ${legendBasePair(baseLand)} land; overlays ${overlayChars.seaLane} sea-lane, ${overlayChars.islandHop} island-hop, ${overlayChars.landOpen} land-open, ${overlayChars.riverChain} river-chain`);
        const rows = renderAsciiGrid(width, height, s, (x, y) => {
            const base = GameplayMap?.isWater?.(x, y) ? baseWater : baseLand;
            const key = `${x},${y}`;
            const overlays = [
                StoryTags?.corridorSeaLane?.has?.(key) ? overlayChars.seaLane : null,
                StoryTags?.corridorIslandHop?.has?.(key) ? overlayChars.islandHop : null,
                StoryTags?.corridorRiverChain?.has?.(key) ? overlayChars.riverChain : null,
                StoryTags?.corridorLandOpen?.has?.(key) ? overlayChars.landOpen : null,
            ].filter(Boolean);
            const overlay = overlays.length ? overlays[0] : null;
            return overlay ? { base, overlay } : { base };
        });
        rows.forEach((row) => safeLog(row));
    }
    catch (err) {
        safeLog("[DEV][corridor] ASCII overlay error:", err);
    }
}

function computeAsciiSampleStep(width, height, requested) {
    if (Number.isFinite(requested))
        return Math.max(1, Math.trunc(requested));
    const targetCols = 72;
    const targetRows = 48;
    const stepX = width > targetCols ? Math.floor(width / targetCols) : 1;
    const stepY = height > targetRows ? Math.floor(height / targetRows) : 1;
    const step = Math.max(1, Math.min(stepX || 1, stepY || 1));
    return step;
}

function renderAsciiGrid(width, height, sampleStep, cellFn) {
    const step = Math.max(1, sampleStep | 0);
    const rows = [];
    for (let y = 0; y < height; y += step) {
        let row = "";
        for (let x = 0; x < width; x += step) {
            const cell = cellFn(x, y) || {};
            row += asciiCell(cell.base, cell.overlay);
        }
        rows.push(row);
    }
    return rows;
}

function asciiCell(base, overlay) {
    const baseChar = typeof base === "string" && base.length ? base[0] : ".";
    const center = typeof overlay === "string" && overlay.length ? overlay[0] : baseChar;
    const grid = ASCII_DISPLAY.grid ?? {};
    const padding = (overlay ? grid.overlayPadding : grid.basePadding) || grid.basePadding || { left: "", right: "" };
    const left = padding.left ?? "";
    const right = padding.right ?? left;
    return `${left}${center}${right}`;
}

function legendBasePair(baseChar) {
    const c = typeof baseChar === "string" && baseChar.length ? baseChar[0] : ".";
    const grid = ASCII_DISPLAY.grid ?? {};
    const padding = grid.basePadding || { left: "", right: "" };
    const left = padding.left ?? "";
    const right = padding.right ?? left;
    return `${left}${c}${right}`;
}

function summarizeFoundationSeedConfig(cfg) {
    const seedCfg = typeof cfg === "object" && cfg ? cfg : {};
    const summary = {
        mode: seedCfg.mode ?? "engine",
        fixed: seedCfg.fixed ?? null,
        offset: seedCfg.offset ?? 0,
        manifestHash: seedCfg.manifestHash ?? null,
    };
    if (seedCfg.offsets && typeof seedCfg.offsets === "object") {
        const offsets = {};
        for (const key of Object.keys(seedCfg.offsets)) {
            const value = seedCfg.offsets[key];
            if (value != null)
                offsets[key] = value;
        }
        if (Object.keys(offsets).length > 0)
            summary.offsets = offsets;
    }
    return summary;
}

function summarizePlateSeed(plateSeed) {
    if (!plateSeed || typeof plateSeed !== "object")
        return { available: false };
    const summary = { available: true };
    const width = plateSeed.width ?? plateSeed.mapWidth;
    const height = plateSeed.height ?? plateSeed.mapHeight;
    if (width != null)
        summary.width = width;
    if (height != null)
        summary.height = height;
    const sites = Array.isArray(plateSeed.sites)
        ? plateSeed.sites
        : Array.isArray(plateSeed.siteCoords)
            ? plateSeed.siteCoords
            : null;
    if (sites)
        summary.siteCount = sites.length;
    if (plateSeed.seed != null)
        summary.seed = plateSeed.seed;
    if (plateSeed.seedOffset != null)
        summary.seedOffset = plateSeed.seedOffset;
    if (plateSeed.timestamp != null)
        summary.timestamp = plateSeed.timestamp;
    const rngState = plateSeed.rngState ?? plateSeed.randomState ?? null;
    if (rngState)
        summary.rngState = summarizeRngState(rngState);
    return summary;
}

function summarizeFoundationPlates(cfg) {
    if (!cfg || typeof cfg !== "object")
        return {};
    const summary = pickFields(cfg, [
        "seedMode",
        "count",
        "convergenceMix",
        "relaxationSteps",
        "seedJitter",
        "interiorSmooth",
        "plateRotationMultiple",
        "seedOffset",
    ]) || {};
    if (Array.isArray(cfg.axisAngles) && cfg.axisAngles.length)
        summary.axisAngles = cfg.axisAngles.slice(0, 3);
    return summary;
}

function summarizeFoundationDynamics(cfg) {
    if (!cfg || typeof cfg !== "object")
        return {};
    const wind = pickFields(cfg.wind, ["jetStreaks", "jetStrength", "variance", "coriolisZonalScale"]);
    const currents = pickFields(cfg.currents, ["basinGyreCountMax", "westernBoundaryBias", "currentStrength"]);
    const mantle = pickFields(cfg.mantle, ["bumps", "amplitude", "scale"]);
    const directionality = summarizeDirectionality(cfg.directionality);
    const out = {};
    if (wind)
        out.wind = wind;
    if (currents)
        out.currents = currents;
    if (mantle)
        out.mantle = mantle;
    if (directionality)
        out.directionality = directionality;
    return out;
}

function summarizeDirectionality(cfg) {
    if (!cfg || typeof cfg !== "object")
        return null;
    const out = {};
    if (cfg.cohesion != null)
        out.cohesion = cfg.cohesion;
    const primaryAxes = pickFields(cfg.primaryAxes, ["plateAxisDeg", "windBiasDeg", "currentBiasDeg"]);
    if (primaryAxes)
        out.primaryAxes = primaryAxes;
    const interplay = pickFields(cfg.interplay, [
        "windsFollowPlates",
        "currentsFollowWinds",
        "riftsFollowPlates",
        "orogenyOpposesRifts",
    ]);
    if (interplay)
        out.interplay = interplay;
    const hemispheres = pickFields(cfg.hemispheres, ["southernFlip", "equatorBandDeg", "monsoonBias"]);
    if (hemispheres)
        out.hemispheres = hemispheres;
    const variability = pickFields(cfg.variability, ["angleJitterDeg", "magnitudeVariance", "seedOffset"]);
    if (variability)
        out.variability = variability;
    return Object.keys(out).length ? out : null;
}

function summarizeFoundationSurface(cfg) {
    if (!cfg || typeof cfg !== "object")
        return {};
    const out = {};
    const landmass = pickFields(cfg.landmass, [
        "baseWaterPercent",
        "waterThumbOnScale",
        "jitterAmpFracBase",
        "jitterAmpFracScale",
        "curveAmpFrac",
    ]);
    if (landmass) {
        const post = pickFields(cfg.landmass?.geometry?.post, [
            "expandTiles",
            "expandWestTiles",
            "expandEastTiles",
            "clampWestMin",
            "clampEastMax",
            "minWidthTiles",
            "overrideSouth",
            "overrideNorth",
        ]);
        if (post)
            landmass.geometryPost = post;
        out.landmass = landmass;
    }
    const oceanSeparation = summarizeOceanSeparation(cfg.oceanSeparation);
    if (oceanSeparation)
        out.oceanSeparation = oceanSeparation;
    if (cfg.overrides && typeof cfg.overrides === "object") {
        const overrideKeys = Object.keys(cfg.overrides);
        if (overrideKeys.length)
            out.overrides = { count: overrideKeys.length };
    }
    return out;
}

function summarizeOceanSeparation(cfg) {
    if (!cfg || typeof cfg !== "object")
        return null;
    const out = pickFields(cfg, [
        "enabled",
        "baseSeparationTiles",
        "boundaryClosenessMultiplier",
        "maxPerRowDelta",
        "respectSeaLanes",
        "minChannelWidth",
    ]) || {};
    if (Array.isArray(cfg.bandPairs))
        out.bandPairs = cfg.bandPairs.length;
    if (cfg.edgeWest && cfg.edgeWest.enabled)
        out.edgeWest = pickFields(cfg.edgeWest, ["baseTiles", "boundaryClosenessMultiplier", "maxPerRowDelta"]);
    if (cfg.edgeEast && cfg.edgeEast.enabled)
        out.edgeEast = pickFields(cfg.edgeEast, ["baseTiles", "boundaryClosenessMultiplier", "maxPerRowDelta"]);
    return Object.keys(out).length ? out : null;
}

function summarizeRngState(state) {
    if (!state || typeof state !== "object")
        return state ?? null;
    const keys = Object.keys(state);
    if (!keys.length)
        return {};
    const summary = {};
    const limit = 4;
    for (let i = 0; i < Math.min(limit, keys.length); i++) {
        const key = keys[i];
        summary[key] = state[key];
    }
    if (keys.length > limit)
        summary.truncatedKeys = keys.length - limit;
    return summary;
}

function pickFields(src, fields) {
    if (!src || typeof src !== "object")
        return null;
    const out = {};
    for (const key of fields) {
        if (Object.prototype.hasOwnProperty.call(src, key) && src[key] != null) {
            out[key] = src[key];
        }
    }
    return Object.keys(out).length ? out : null;
}

/* ----------------------- internal helpers ----------------------- */
function safeLog(...args) {
    try {
        console.log(...args);
    }
    catch (_) {
        /* no-op */
    }
}
function nowMs() {
    try {
        // Prefer high-resolution timer when available
        // @ts-ignore
        if (typeof performance !== "undefined" &&
            typeof performance.now === "function")
            return performance.now();
    }
    catch (_) {
        /* ignore */
    }
    return Date.now();
}
function fmtMs(ms) {
    // Format as e.g. "12.34 ms"
    const n = typeof ms === "number" ? ms : Number(ms) || 0;
    return `${n.toFixed(2)} ms`;
}
function sizeOf(setLike) {
    if (!setLike)
        return 0;
    if (typeof setLike.size === "number")
        return setLike.size;
    try {
        return Array.isArray(setLike) ? setLike.length : 0;
    }
    catch {
        return 0;
    }
}
function clampTo(v, lo, hi) {
    if (v < lo)
        return lo;
    if (v > hi)
        return hi;
    return v;
}
export default {
    DEV,
    devLog,
    devLogIf,
    timeSection,
    timeStart,
    timeEnd,
    logStoryTagsSummary,
    logRainfallHistogram,
    logRainfallStats,
    logFoundationSummary,
    logFoundationHistograms,
    logFoundationAscii,
    logBoundaryMetrics,
    logBiomeSummary,
    ASCII_DISPLAY,
};
</file>

<file path="mod/maps/bootstrap/entry.js">
// @ts-check
/**
 * Entry Bootstrap Helper
 *
 * Purpose
 * - Minimize boilerplate in map entry files.
 * - Compose configuration from named presets and inline overrides, then
 *   set the active runtime config. Entries must import the orchestrator separately.
 *
 * Usage (in a map entry file):
 *   import { bootstrap } from "./config/entry.js";
 *   bootstrap({
 *     presets: ["classic", "temperate"], // optional, ordered
 *     overrides: {
 *       // any partial config to override the resolved result
 *       foundation: { world: { enabled: true } },
 *       // ...
 *     }
 *   });
 *
 * Notes
 * - This helper is intentionally simple and synchronous for game VM compatibility.
 * - Presets are applied by name via resolved.js; arrays replace, objects deep-merge.
 * - This helper does not import the orchestrator; keep the explicit import in the entry.
 */

/** @typedef {import('./map_config.types.js').MapConfig} MapConfig */

import { setConfig } from "./runtime.js";
/**
 * Deep merge utility (objects by key, arrays replaced, primitives overwritten).
 * Returns a new object; never mutates inputs.
 * @param {any} base
 * @param {any} src
 * @returns {any}
 */
function deepMerge(base, src) {
    const isObj = (v) => v != null &&
        typeof v === "object" &&
        (Object.getPrototypeOf(v) === Object.prototype ||
            Object.getPrototypeOf(v) === null);
    if (!isObj(base) || Array.isArray(src)) {
        return clone(src);
    }
    if (!isObj(src)) {
        return clone(src);
    }
    /** @type {Record<string, any>} */
    const out = {};
    for (const k of Object.keys(base))
        out[k] = clone(base[k]);
    for (const k of Object.keys(src)) {
        const b = out[k];
        const s = src[k];
        out[k] = isObj(b) && isObj(s) ? deepMerge(b, s) : clone(s);
    }
    return out;
}
/**
 * Shallow clone helper (new containers for arrays/objects).
 * @param {any} v
 * @returns {any}
 */
function clone(v) {
    if (Array.isArray(v))
        return v.slice();
    const isObj = v != null &&
        typeof v === "object" &&
        (Object.getPrototypeOf(v) === Object.prototype ||
            Object.getPrototypeOf(v) === null);
    if (isObj) {
        const o = {};
        for (const k of Object.keys(v))
            o[k] = v[k];
        return o;
    }
    return v;
}
/**
 * Compose a per-entry configuration object from presets and overrides,
 * and set it as the active runtime config.
 *
 * @param {object} [options]
 * @param {ReadonlyArray<string>} [options.presets] - Ordered list of preset names understood by resolved.js
 * @param {Partial<MapConfig>} [options.overrides] - Inline overrides applied last (highest precedence)
 * @param {Record<string, boolean>} [options.stageConfig] - Stage metadata indicating which stages provide config overrides
 */
export function bootstrap(options = {}) {
    const presets = Array.isArray(options.presets) &&
        options.presets.length > 0
        ? options.presets.filter((n) => typeof n === "string")
        : undefined;
    const overrides = options && typeof options === "object" && options.overrides
        ? clone(options.overrides)
        : undefined;
    const stageConfig = options && typeof options === "object" && options.stageConfig
        ? clone(options.stageConfig)
        : undefined;
    const cfg = {};
    if (presets)
        cfg.presets = presets;
    if (stageConfig)
        cfg.stageConfig = stageConfig;
    if (overrides) {
        // If both presets and overrides exist, ensure overrides apply last (highest precedence)
        Object.assign(cfg, deepMerge(cfg, overrides));
    }
    // Store runtime config for this map entry (entries must import orchestrator separately)
    setConfig(cfg);
}
export default { bootstrap };
</file>

<file path="mod/maps/bootstrap/foundation-tunables.js">
/**
 * Foundation/world settings tunable surface. Keeps imports focused on the
 * world-building primitives that layers commonly consume.
 */
export {
    rebind,
    FOUNDATION_TUNABLES,
    FOUNDATION,
    FOUNDATION_CFG,
    FOUNDATION_SEED,
    FOUNDATION_PLATES,
    FOUNDATION_DYNAMICS,
    FOUNDATION_SURFACE,
    FOUNDATION_POLICY,
    FOUNDATION_DIAGNOSTICS,
    FOUNDATION_DIRECTIONALITY,
    FOUNDATION_OCEAN_SEPARATION,
} from "./tunables.js";
</file>

<file path="mod/maps/bootstrap/map_config.types.js">
// @ts-nocheck
/**
 * JSDoc type definitions for Epic Diverse Huge Map Generator config.
 *
 * This file provides runtime-available type hints for IDE autocomplete.
 * For full TypeScript definitions, see map_config.d.ts (development only).
 * For validation schema, see map_config.schema.json
 *
 * Usage in map_config.js (JS with editor typings):
 *
 * @example
 * // @ts-check
 * // @type {import('./map_config.types.js').MapConfig}
 * export const MAP_CONFIG = Object.freeze({
 *   toggles: { STORY_ENABLE_HOTSPOTS: true },
 *   story: {},
 *   microclimate: {}
 * });
 */

/**
 * Master configuration object controlling all map generation layers.
 *
 * Generation pipeline: Foundation (plates/winds)  Landmass  Climate  Biomes  Features
 *
 * @typedef {Object} MapConfig
 * @property {Toggles} toggles - Enable/disable major systems (hotspots, rifts, orogeny, swatches, corridors)
 * @property {Story} story - Narrative elements creating distinctive terrain features (volcanic trails, rift valleys, mountain rain shadows)
 * @property {Microclimate} microclimate - Fine-tuned rainfall and feature bonuses near story elements (rift lines, hotspot centers)
 * @property {Climate} [climate] - Aggregated climate configuration (baseline/refine/swatches)
 * @property {Corridors} [corridors] - Protected travel routes (sea lanes, island chains, land corridors, river valleys) that remain unobstructed
 * @property {Landmass} [landmass] - Continental layout: water percentage, band geometry, curvature/jitter, plate-driven vs preset modes
 * @property {Coastlines} [coastlines] - Coast ruggedization: bay/fjord probabilities, active vs passive margin effects
 * @property {Margins} [margins] - Tectonic margin types: convergent (mountains, subduction) vs divergent (rifts, spreading)
 * @property {Islands} [islands] - Offshore island generation: fractal thresholds, hotspot biasing, cluster distribution
 * @property {Mountains} [mountains] - Mountain and hill placement weights: WorldModel uplift, boundary biasing, foothill distribution
 * @property {Volcanoes} [volcanoes] - Volcano placement controls: convergent arc bias, hotspot allowance, spacing
 * @property {Biomes} [biomes] - Biome assignment rules: tundra limits, tropical coast preferences, river grasslands, rift shoulders
 * @property {FeaturesDensity} [featuresDensity] - Feature density: rainforest, forest, taiga prevalence, coral reef placement
 * @property {Placement} [placement] - Final placement: natural wonder counts, floodplain river lengths
 * @property {DevLogging} [dev] - Debug logging: timing stats, story tag counts, rainfall distribution histograms
 * @property {FoundationConfig} [foundation] - Unified world foundation configuration (seed, plates, dynamics, surface, policy)
 * @property {StageManifest} [stageManifest] - Pipeline manifest describing stage order, enablement, and inter-stage dependencies
 * @property {StageConfigProviders} [stageConfig] - Metadata indicating which stages a preset or entry supplies configuration for
 */

/**
 * Known stage identifiers for the bootstrap manifest.
 *
 * Stage names mirror the major passes in map_orchestrator.js; use them to
 * express dependencies. Adding a new stage requires updating this union.
 *
* @typedef {"foundation" | "landmassPlates" | "coastlines" | "storySeed" | "storyHotspots" | "storyRifts" | "storyOrogeny" | "storyPaleo" | "storyCorridorsPre" | "islands" | "mountains" | "volcanoes" | "lakes" | "climateBaseline" | "storySwatches" | "rivers" | "storyCorridorsPost" | "climateRefine" | "biomes" | "features" | "placement"} StageName
 */

/**
 * Stage descriptor containing enablement and dependency metadata.
 *
 * @typedef {Object} StageDescriptor
 * @property {boolean} [enabled] - Explicit enable/disable flag (defaults to true when omitted)
 * @property {ReadonlyArray<StageName>} [requires] - Hard prerequisites that must execute (and remain enabled) first
 * @property {ReadonlyArray<StageName>} [provides] - Data surfaces emitted by the stage (documentation only)
 * @property {ReadonlyArray<string>} [legacyToggles] - Legacy toggle keys mirrored from the new manifest state
 * @property {string} [blockedBy] - Resolved reason for automatic disablement (populated by resolver diagnostics)
 */

/**
 * Stage manifest describing execution order and dependency graph for the generator.
 *
 * @typedef {Object} StageManifest
 * @property {ReadonlyArray<StageName>} order - Ordered list of stages to execute (duplicates removed during normalization)
 * @property {Record<StageName, StageDescriptor>} stages - Descriptor metadata keyed by stage identifier
 */

/**
 * Stage configuration providers metadata (used for diagnostics).
 * Keys are stage identifiers and values indicate whether overrides target that stage.
 *
 * @typedef {Object.<StageName, boolean>} StageConfigProviders
 */

/**
 * Plate tensors emitted by the foundation stage.
 *
 * @typedef {Object} FoundationPlateFields
 * @property {Int16Array} id - Plate identifier per tile
 * @property {Uint8Array} boundaryCloseness - Distance-to-boundary metric (0 = on boundary)
 * @property {Uint8Array} boundaryType - Encoded boundary type (convergent/divergent/transform)
 * @property {Uint8Array} tectonicStress - Aggregate stress magnitude per tile
 * @property {Uint8Array} upliftPotential - Mountain uplift weighting per tile
 * @property {Uint8Array} riftPotential - Rift weighting per tile
 * @property {Uint8Array} shieldStability - Continental interior stability per tile
 * @property {Int8Array} movementU - Horizontal plate motion component
 * @property {Int8Array} movementV - Vertical plate motion component
 * @property {Int8Array} rotation - Plate rotation scalar
 */

/**
 * Atmospheric and oceanic tensors emitted by the foundation stage.
 *
 * @typedef {Object} FoundationDynamicsFields
 * @property {Int8Array} windU - Zonal wind component per tile
 * @property {Int8Array} windV - Meridional wind component per tile
 * @property {Int8Array} currentU - Zonal ocean current component per tile
 * @property {Int8Array} currentV - Meridional ocean current component per tile
 * @property {Uint8Array} pressure - Mantle pressure field per tile
 */

/**
 * Diagnostics payload bundled with the foundation context.
 *
 * @typedef {Object} FoundationDiagnosticsFields
 * @property {any|null} boundaryTree - Spatial index for boundary queries
 */

/**
 * Immutable runtime snapshot emitted by the `foundation` stage.
 *
 * @typedef {Object} FoundationContext
 * @property {{ width: number, height: number, size: number }} dimensions - Map dimensions baked into the tensors
 * @property {Readonly<any>|null} plateSeed - Captured Voronoi seed bundle used for deterministic replay
 * @property {FoundationPlateFields} plates - Plate/boundary tensors shared across stages
 * @property {FoundationDynamicsFields} dynamics - Wind, current, and mantle pressure tensors
 * @property {FoundationDiagnosticsFields} diagnostics - Supplemental diagnostics (kd-tree, metadata)
 * @property {{
 *   seed: FoundationSeedConfig,
 *   plates: FoundationPlatesConfig,
 *   dynamics: FoundationDynamicsConfig,
 *   surface: FoundationSurfaceConfig,
 *   policy: FoundationPolicyConfig,
 *   diagnostics: FoundationDiagnosticsConfig,
 * }} config - Normalized configuration snapshot associated with the tensors
 */

/**
 * Feature toggles for major narrative and simulation systems.
 *
 * @typedef {Object} Toggles
 * @property {boolean} STORY_ENABLE_HOTSPOTS - Volcanic island chains (like Hawaii) formed as plates move over mantle plumes
 * @property {boolean} STORY_ENABLE_RIFTS - Continental rift valleys (like East African Rift) with humid shoulders and grassland bias
 * @property {boolean} STORY_ENABLE_OROGENY - Mountain rain shadows: wet windward slopes, dry leeward deserts (orographic effect)
 * @property {boolean} STORY_ENABLE_SWATCHES - Guaranteed macro-climate zones (e.g., Sahara-like desert belt, Congo/Amazon rainbelt)
 * @property {boolean} STORY_ENABLE_PALEO - Ancient river features: fossil channels in deserts, oxbow lakes, delta wetlands
 * @property {boolean} STORY_ENABLE_CORRIDORS - Protected routes for strategic gameplay (sea lanes, island chains, river valleys)
 */

/**
 * Story (motif) tunables
 * @typedef {Object} Story
 * @property {Hotspot} [hotspot] - Deep-ocean hotspot trails (aligned chains far from coasts)
 * @property {Rift} [rift] - Continental rift lines (linear basins with narrow shoulder bands)
 * @property {Orogeny} [orogeny] - Orogeny belts (derive windward/lee flanks; apply small wet/dry deltas)
 * @property {Swatches} [swatches] - "Black swan" macro climate swatches (paint one guaranteed macro zone)
 * @property {PaleoHydrology} [paleo] - Paleo-hydrology overlays (humidity hints; optional canyon rim contrast)
 */

/**
 * Deep-ocean hotspot trails (volcanic island chains).
 *
 * Simulates stationary mantle plumes creating linear archipelagos as tectonic plates drift overhead.
 * Think Hawaiian Islands: older islands to the northwest, active volcano in the southeast.
 *
 * @typedef {Object} Hotspot
 * @property {number} [maxTrails] - Maximum trails per map; fewer = more isolated chains (typically 2-5)
 * @property {number} [steps] - Chain length in steps; higher = longer trails like Hawaii (typically 8-15)
 * @property {number} [stepLen] - Spacing between islands in tiles (typically 3-6)
 * @property {number} [minDistFromLand] - Keep trails in deep ocean, away from continents in tiles (typically 15+)
 * @property {number} [minTrailSeparation] - Minimum distance between different chains in tiles (typically 25+)
 * @property {number} [paradiseBias] - Weight for tropical paradise centers (lush, high humidity, reefs)
 * @property {number} [volcanicBias] - Weight for volcanic centers (active, dramatic terrain, geothermal)
 * @property {number} [volcanicPeakChance] - Probability volcanic centers become land vs staying underwater (0..1, typically 0.3-0.7)
 */

/**
 * Continental rift lines (tectonic valleys where plates pull apart).
 *
 * Creates linear depressions like the East African Rift Valley or the Rio Grande Rift.
 * Rift shoulders receive extra humidity and grassland bias, while the valley floor may be drier.
 *
 * @typedef {Object} Rift
 * @property {number} [maxRiftsPerMap] - Maximum rifts on the map; 1-2 typical, 3+ creates heavily fractured continents
 * @property {number} [lineSteps] - Length of rift in steps; higher = longer valleys (typically 15-30)
 * @property {number} [stepLen] - Distance per step in tiles; controls rift straightness (typically 2-4)
 * @property {number} [shoulderWidth] - Width of elevated shoulders on each side receiving humidity bonus (typically 2-5 tiles)
 */

/**
 * Orogeny belts (mountain-building zones with rain shadow effects).
 *
 * Orographic effect: mountains force air upward, causing rainfall on the windward (upwind) side.
 * Air descends on the leeward (downwind) side, creating rain shadows (deserts).
 * Example: Sierra Nevada (wet west, dry east), Himalayas (wet south, dry Gobi Desert north).
 *
 * @typedef {Object} Orogeny
 * @property {number} [beltMaxPerContinent] - Maximum mountain belts per continent (typically 1-3)
 * @property {number} [beltMinLength] - Minimum tiles for a mountain range to qualify (typically 10-20)
 * @property {number} [radius] - Distance from mountains to apply rain shadow effect (typically 3-8 tiles)
 * @property {number} [windwardBoost] - Extra rainfall on upwind side in rainfall units (typically 10-30, max 200)
 * @property {number} [leeDrynessAmplifier] - Drying multiplier for downwind side; 1.5 = 50% drier (typically 1.2-2.0)
 */

/**
 * Macro climate swatches (guaranteed major climate features).
 *
 * Each map gets ONE guaranteed macro-climate zone to create distinctive character.
 * These override normal patterns to ensure interesting gameplay variety.
 *
 * @typedef {Object} Swatches
 * @property {number} [maxPerMap] - Maximum swatches per map; typically 1 to avoid competing features
 * @property {boolean} [forceAtLeastOne] - Guarantee at least one swatch is applied (recommended: true)
 * @property {Object} [sizeScaling] - Scale swatch dimensions with map size
 * @property {number} [sizeScaling.widthMulSqrt] - Width scaling for larger maps (typically 1.0-1.5)
 * @property {number} [sizeScaling.lengthMulSqrt] - Length scaling for larger maps (typically 1.0-1.5)
 * @property {Object} [types] - Available swatch types and their weights
 * @property {SwatchType} [types.macroDesertBelt] - Sahara/Kalahari-like subtropical desert band at ~20-30 latitude
 * @property {SwatchType} [types.equatorialRainbelt] - Congo/Amazon-like equatorial rainforest belt with high humidity
 * @property {SwatchType} [types.rainforestArchipelago] - Southeast Asia-style tropical island rainforests with coral reefs
 * @property {SwatchType} [types.mountainForests] - Alpine/Himalayan-style wet forests on windward mountain slopes
 * @property {SwatchType} [types.greatPlains] - Central Asia/American Great Plains-style continental grasslands/steppes
 */

/**
 * Individual swatch type configuration (fields vary by swatch kind).
 *
 * Each swatch type has different parameters depending on whether it's a latitude band
 * (desert belt, rainbelt), geographic feature (archipelago), or terrain type (plains, mountains).
 *
 * @typedef {Object} SwatchType
 * @property {number} [weight] - Lottery weight for selection; higher = more likely to be chosen (typically 1-10)
 * @property {number} [latitudeCenterDeg] - Center latitude for banded swatches; e.g., 25 for subtropical deserts (degrees)
 * @property {number} [halfWidthDeg] - Band half-width from center; wider = more spread (typically 5-15 degrees)
 * @property {number} [wetnessDelta] - Rainfall increase within swatch zone (typically 20-50 units for rainbelts)
 * @property {number} [drynessDelta] - Rainfall decrease within swatch zone (typically -20 to -40 units for desert belts)
 * @property {number} [dryDelta] - Alternative dryness parameter used by some swatches (units)
 * @property {number} [lowlandMaxElevation] - Elevation ceiling for "lowland" designation; plains swatches ignore highlands (typically 30-50)
 * @property {number} [islandBias] - Strength multiplier near coasts/islands for archipelago swatches (typically 1.0-2.5)
 * @property {number} [reefBias] - Coral reef probability multiplier in warm shallows (typically 1.0-2.0)
 * @property {boolean} [coupleToOrogeny] - Link to mountain rain shadow system for coherent wind patterns
 * @property {number} [windwardBonus] - Extra rainfall on windward mountain slopes (typically 10-25 units)
 * @property {number} [leePenalty] - Rainfall reduction on leeward mountain slopes (typically 5-15 units)
 * @property {number} [bleedRadius] - Edge softening distance for gradual transitions (typically 5-12 tiles)
 */

/**
 * Paleo-hydrology overlays (ancient water features that no longer flow).
 *
 * Adds traces of past hydrological activity: dried riverbeds in deserts, oxbow lakes from ancient
 * meanders, wetland deltas. These features add historical depth and subtle humidity/resource bonuses.
 * Think: Australian dry lakes, Saharan wadis, abandoned Mississippi oxbows.
 *
 * @typedef {Object} PaleoHydrology
 * @property {number} [maxDeltas] - Maximum river deltas to create (wetland fans at river mouths; typically 2-5)
 * @property {number} [deltaFanRadius] - Size of delta wetland spread inland from river mouth (typically 3-6 tiles)
 * @property {number} [deltaMarshChance] - Probability delta tiles become marshland (0..1, typically 0.4-0.7)
 * @property {number} [maxOxbows] - Maximum oxbow lakes (isolated crescent lakes from old meanders; typically 3-8)
 * @property {number} [oxbowElevationMax] - Only create oxbows in lowlands below this elevation (typically 30-50)
 * @property {number} [maxFossilChannels] - Maximum fossil riverbeds (dry channels in deserts; typically 2-6)
 * @property {number} [fossilChannelLengthTiles] - Length of each fossil channel before scaling (typically 15-30 tiles)
 * @property {number} [fossilChannelStep] - Spacing between channel points; lower = more sinuous (typically 2-4)
 * @property {number} [fossilChannelHumidity] - Small humidity bonus along dry channels (typically 5-15 units)
 * @property {number} [fossilChannelMinDistanceFromCurrentRivers] - Keep fossil channels away from active rivers (typically 10+ tiles)
 * @property {number} [minDistanceFromStarts] - Keep paleo features away from player starts for fairness (typically 15+ tiles)
 * @property {Object} [sizeScaling] - Size-aware scaling for fossil channel length (unitless scalar based on sqrt(area))
 * @property {number} [sizeScaling.lengthMulSqrt] - Length multiplier based on sqrt(map area) (scalar)
 * @property {Object} [elevationCarving] - Optional canyon rim contrast (very subtle)
 * @property {boolean} [elevationCarving.enableCanyonRim] - Whether to apply slight dryness on canyon floor and dampen rims
 * @property {number} [elevationCarving.rimWidth] - Rim width around fossil centerline (tiles)
 * @property {number} [elevationCarving.canyonDryBonus] - Extra dryness on canyon floor (rainfall units)
 * @property {number} [elevationCarving.bluffWetReduction] - Optional wetness reduction on bluffs (rainfall units)
 */

/**
 * Microclimate adjustments near story elements (localized bonuses).
 *
 * Applies targeted rainfall and feature bonuses around narrative features like rifts and hotspots.
 * These create distinctive local environments: lush rift valleys, tropical paradise islands,
 * forested volcanic slopes. Subtle but noticeable effects that reward exploration.
 *
 * @typedef {Object} Microclimate
 * @property {Object} [rainfall] - Localized rainfall adjustments
 * @property {number} [rainfall.riftBoost] - Humidity bonus along rift valley shoulders (typically 15-30 units)
 * @property {number} [rainfall.riftRadius] - Distance from rift centerline to apply boost (typically 2-5 tiles)
 * @property {number} [rainfall.paradiseDelta] - Humidity bonus near tropical paradise hotspots (typically 10-20 units)
 * @property {number} [rainfall.volcanicDelta] - Humidity bonus near volcanic hotspots from geothermal moisture (typically 8-15 units)
 * @property {Object} [features] - Localized feature bonuses
 * @property {number} [features.paradiseReefChance] - Extra coral reef probability near paradise islands (percent 0..100, typically 30-60%)
 * @property {number} [features.volcanicForestChance] - Extra forest near volcanic slopes in warm climates (percent 0..100, typically 25-50%)
 * @property {number} [features.volcanicTaigaChance] - Extra coniferous forest near volcanoes in cold climates (percent 0..100, typically 20-40%)
 */

/**
 * Landmass shaping (continental size, shape, and curvature).
 *
 * Controls the land/water ratio and how continents are shaped via fractal noise, jitter, and curvature.
 * Water percentage: 60-65% = Earth-like, 70-75% = archipelago world, 50-55% = Pangaea-like.
 *
 * @typedef {Object} Landmass
 * @property {number} [baseWaterPercent] - Target water coverage; 65 = Earth-like, 75 = island world (percent 0..100, typically 55-75)
 * @property {number} [waterThumbOnScale] - Water adjustment on larger maps; negative = less water (typically -5 to +5)
 * @property {number} [jitterAmpFracBase] - Base coastline waviness as fraction of width; higher = more irregular (typically 0.02-0.08)
 * @property {number} [jitterAmpFracScale] - Extra jitter on larger maps (typically 0.01-0.04)
 * @property {number} [curveAmpFrac] - Continental bowing/curvature; higher = more crescent-shaped landmasses (typically 0.1-0.3)
 * @property {number} [boundaryBias] - Mild closeness assist for boundary tiles (0..1, typically 0.2-0.3); higher values hug boundaries more
 * @property {number} [boundaryShareTarget] - Soft backstop: desired share of land inside the high-closeness band (0..1, typically ~0.15)
 * @property {LandmassTectonics} [tectonics] - Tectonic noise and arc weighting controls
 * @property {LandmassGeometry} [geometry] - Post-processing adjustments applied after plate-driven layout
 */

/**
 * Tectonic knobs for landmass scoring.
 *
 * `interiorNoiseWeight` blends coarse fractal noise into plate interiors so continents have thick/thin spots.
 * `boundaryArcWeight` controls uplift along convergent boundaries; lower = fewer boundary arcs, higher = stronger arcs.
 * `boundaryArcNoiseWeight` roughens arcs to avoid perfect straight lines.
 *
 * @typedef {Object} LandmassTectonics
 * @property {number} [interiorNoiseWeight] - 0..1 weight for plate-interior fractal noise (default ~0.3)
 * @property {number} [fractalGrain] - Grain for the tectonic fractal; higher = finer noise (default 4)
 * @property {number} [boundaryArcWeight] - Multiplier for convergent arc score (0..2, default ~0.8)
 * @property {number} [boundaryArcNoiseWeight] - 0..1 multiplier for arc raggedness (default ~0.5)
 */

/**
 * Landmass geometry post-processing.
 *
 * Provides fine-grained adjustments applied after the plate-driven landmask is computed.
 *
 * @typedef {Object} LandmassGeometry
 * @property {LandmassGeometryPost} [post] - Fine-tuning adjustments applied after initial layout
 */

/**
 * Post-processing adjustments for derived landmass windows.
 * Values are applied after either preset bands or plate-derived windows are computed.
 * @typedef {Object} LandmassGeometryPost
 * @property {number} [expandTiles] - Expand each landmass west/east by this many tiles (applied before individual offsets)
 * @property {number} [expandWestTiles] - Additional west-side expansion per landmass (tiles)
 * @property {number} [expandEastTiles] - Additional east-side expansion per landmass (tiles)
 * @property {number} [clampWestMin] - Minimum west boundary allowed (tiles, 0-based)
 * @property {number} [clampEastMax] - Maximum east boundary allowed (tiles, inclusive)
 * @property {number} [overrideSouth] - Override south boundary for all landmasses (tiles)
 * @property {number} [overrideNorth] - Override north boundary for all landmasses (tiles)
 * @property {number} [minWidthTiles] - Ensure each landmass spans at least this many tiles horizontally (tiles)
 */

/**
 * Coastline ruggedization (creates natural, irregular coasts).
 *
 * Transforms smooth generated coastlines into realistic features like bays and fjords.
 * Active margins get more dramatic features (fjords, cliffs), passive margins get gentler ones.
 * Respects strategic corridors to avoid blocking sea lanes.
 *
 * @typedef {Object} Coastlines
 * @property {Object} [bay] - Bay configuration (gentle coastal indentations)
 * @property {number} [bay.noiseGateAdd] - Extra noise threshold on larger maps; higher = fewer/larger bays (typically 0-3)
 * @property {number} [bay.rollDenActive] - Bay frequency on active margins; lower = more bays (typically 8-15)
 * @property {number} [bay.rollDenDefault] - Bay frequency elsewhere; lower = more bays (typically 12-20)
 * @property {Object} [fjord] - Fjord configuration (deep, narrow inlets like Norway/New Zealand)
 * @property {number} [fjord.baseDenom] - Base fjord frequency; lower = more fjords (typically 15-25)
 * @property {number} [fjord.activeBonus] - Extra fjords on active margins (converging plates); subtracts from baseDenom (typically 3-8)
 * @property {number} [fjord.passiveBonus] - Fjords near passive shelves; subtracts from baseDenom (typically 0-2)
 * @property {number} [minSeaLaneWidth] - Minimum channel width to preserve for naval passage (typically 3-6 tiles)
 * @property {CoastlinePlateBias} [plateBias] - Plate-aware weighting for bay/fjord odds based on boundary closeness
 */

/**
 * Plate-aware coastline weighting (optional).
 *
 * Provides continuous control over how plate-boundary closeness and boundary type
 * influence bay and fjord chances. Positive values make denominators smaller
 * (more edits); negative values make them larger (fewer edits).
 *
 * @typedef {Object} CoastlinePlateBias
 * @property {number} [threshold] - Normalized plate-boundary closeness threshold (0..1) where influence starts (default 0.45)
 * @property {number} [power] - Exponent shaping how quickly influence ramps after the threshold (default 1.25)
 * @property {number} [convergent] - Multiplier for convergent boundaries (default 1.0)
 * @property {number} [transform] - Multiplier for transform boundaries (default 0.4)
 * @property {number} [divergent] - Multiplier for divergent boundaries (negative to reduce edits, default -0.6)
 * @property {number} [interior] - Residual influence for interior coasts (default 0)
 * @property {number} [bayWeight] - Strength applied to bay denominators (default 0.35)
 * @property {number} [bayNoiseBonus] - Extra noise gate reduction when bias is positive (default 1.0)
 * @property {number} [fjordWeight] - Strength applied to fjord denominators (default 0.8)
 */

/**
 * Continental margins tagging (tectonic boundary classification).
 *
 * ACTIVE margins: Convergent plate boundaries with subduction, volcanism, mountains, fjords, earthquakes.
 *   Examples: Pacific Ring of Fire (Andes, Japan, Cascades), steep/dramatic coasts.
 *
 * PASSIVE margins: Divergent or stable boundaries with wide continental shelves, gentle slopes, coral reefs.
 *   Examples: US Atlantic coast, most of Africa, broad coastal plains.
 *
 * @typedef {Object} Margins
 * @property {number} [activeFraction] - Fraction of coasts as active margins; higher = more mountainous/volcanic coasts (typically 0.2-0.4)
 * @property {number} [passiveFraction] - Fraction of coasts as passive shelves; higher = more gentle/reef coasts (typically 0.3-0.5)
 * @property {number} [minSegmentLength] - Minimum coastal stretch length to classify as a margin type (typically 8-15 tiles)
 */

/**
 * Island chain placement (offshore archipelagos and volcanic islands).
 *
 * Uses fractal noise to seed islands in appropriate locations. Lower fractal threshold = more islands.
 * Active margins (like Japan, Philippines) get more volcanic islands than passive margins.
 * Hotspot trails automatically bias toward island formation (like Hawaii, Galapagos).
 *
 * @typedef {Object} Islands
 * @property {number} [fractalThresholdPercent] - Noise cutoff for island seeds; higher = fewer islands (typically 75-90 for sparse, 60-75 for moderate)
 * @property {number} [baseIslandDenNearActive] - Island frequency near active margins; lower = more islands (typically 6-12)
 * @property {number} [baseIslandDenElse] - Island frequency elsewhere; lower = more islands (typically 15-30)
 * @property {number} [hotspotSeedDenom] - Island frequency on hotspot trails; lower = more islands (typically 3-8)
 * @property {number} [clusterMax] - Maximum tiles per island cluster; creates small archipelagos (typically 3-8 tiles)
 * @property {number} [minDistFromLandRadius] - Minimum spacing from continents; prevents coastal clutter (typically 4-8 tiles)
 */

/**
 * Strategic corridors (protected travel routes for gameplay).
 *
 * Identifies and preserves key routes that should remain passable and unobstructed.
 * Prevents map generation from accidentally creating chokepoints or blocked passages.
 * Useful for ensuring naval mobility, island hopping chains, and cross-continent land routes.
 *
 * @typedef {Object} Corridors
 * @property {CorridorSea} [sea] - Open-water naval lanes (e.g., trans-oceanic shipping routes)
 * @property {CorridorIslandHop} [islandHop] - Island-hopping chains along hotspot trails (e.g., Polynesian triangle)
 * @property {CorridorLand} [land] - Overland corridors through rift valleys or grassland belts
 * @property {CorridorRiver} [river] - River valley routes connecting coasts through lowlands
 * @property {CorridorPolicy} [policy] - How strictly to enforce corridor protection (hard vs soft blocking)
 * @property {CorridorKinds} [kinds] - Biome and feature preferences within corridor zones
 */

/**
 * Sea lane corridor configuration
 * @typedef {Object} CorridorSea
 * @property {number} [maxLanes] - Max number of sea lanes to tag across the map (count)
 * @property {number} [minLengthFrac] - Minimum fraction of map span a lane must cover to qualify (ratio 0..1)
 * @property {number} [scanStride] - Sampling stride when scanning for lanes (tiles)
 * @property {number} [avoidRadius] - Radius to keep islands away from protected lanes (tiles)
 * @property {boolean} [preferDiagonals] - Whether to consider diagonal lanes in selection/scoring
 * @property {number} [laneSpacing] - Minimum spacing enforced between selected lanes (tiles)
 * @property {number} [minChannelWidth] - Minimum channel width measured orthogonal to the lane (tiles)
 */

/**
 * Island-hop corridor configuration
 * @typedef {Object} CorridorIslandHop
 * @property {boolean} [useHotspots] - Whether to promote hotspot trails into island-hop lanes
 * @property {number} [maxArcs] - Max number of promoted arcs (count)
 */

/**
 * Land corridor configuration
 * @typedef {Object} CorridorLand
 * @property {boolean} [useRiftShoulders] - Whether to derive land corridors from rift shoulders
 * @property {number} [maxCorridors] - Cap on distinct land-open corridors (count)
 * @property {number} [minRunLength] - Minimum contiguous shoulder run length eligible (tiles)
 * @property {number} [spacing] - Minimum spacing enforced between selected land corridor segments (tiles)
 */

/**
 * River corridor configuration
 * @typedef {Object} CorridorRiver
 * @property {number} [maxChains] - Max number of river chain corridors (count)
 * @property {number} [maxSteps] - Max greedy steps while following river-adjacent path (steps; ~tiles)
 * @property {number} [preferLowlandBelow] - Elevation threshold treated as lowland preference (elevation units)
 * @property {number} [coastSeedRadius] - Coast seed radius for initial river-adjacent seed near coast (tiles)
 * @property {number} [minTiles] - Minimum tiles that must be tagged for a chain to qualify (tiles)
 * @property {boolean} [mustEndNearCoast] - Require the chain to end near a coast or river mouth
 */

/**
 * Per-consumer policy strengths and behaviors for corridors
 * @typedef {Object} CorridorPolicy
 * @property {CorridorPolicySea} [sea] - Sea-lane policies (coastline/island interactions)
 * @property {CorridorPolicyLand} [land] - Land-open corridor policies (biome bias strength)
 * @property {CorridorPolicyRiver} [river] - River-chain corridor policies (biome bias strength)
 */

/**
 * Sea-lane policy
 * @typedef {Object} CorridorPolicySea
 * @property {"hard"|"soft"} [protection] - 'hard' = never edit on lanes; 'soft' = reduce chance instead of skip
 * @property {number} [softChanceMultiplier] - When protection is 'soft', multiply coast edit probabilities by this factor (ratio 0..1)
 */

/**
 * Land-open corridor policy
 * @typedef {Object} CorridorPolicyLand
 * @property {number} [biomesBiasStrength] - Scales grassland bias strength on land-open corridors (ratio 0..1)
 */

/**
 * River-chain corridor policy
 * @typedef {Object} CorridorPolicyRiver
 * @property {number} [biomesBiasStrength] - Scales grassland bias strength on river-chain corridors (ratio 0..1)
 */

/**
 * Corridor kinds/styles (open schema with known areas for sea/islandHop/land/river)
 * @typedef {Object} CorridorKinds
 * @property {Object} [sea] - Sea-lane kinds and styles
 * @property {Object.<string, CorridorStyle>} [sea.styles] - Mapping of style-name to style config
 * @property {Object} [islandHop] - Island-hop kinds and styles
 * @property {Object.<string, CorridorStyle>} [islandHop.styles] - Mapping of style-name to style config
 * @property {Object} [land] - Land corridor kinds and styles
 * @property {Object.<string, CorridorStyle>} [land.styles] - Mapping of style-name to style config
 * @property {Object} [river] - River corridor kinds and styles
 * @property {Object.<string, CorridorStyle>} [river.styles] - Mapping of style-name to style config
 */

/**
 * A generic corridor style configuration container
 * @typedef {Object} CorridorStyle
 * @property {Object.<string, number>} [biomes] - Biome mixture biases where values represent weights or fractions for biome tendencies. Values are unitless weights or ratios (0..1 typical). Keys are biome names as consumed by the layer.
 * @property {Object.<string, number>} [features] - Feature biases where numeric values represent probabilities (ratios 0..1) or multipliers (scalars). Example keys (not exhaustive): reefBias (scalar), floodplainBias (scalar), forestBias (scalar).
 * @property {Object.<string, number>} [edge] - Edge-shaping hints where numeric values are probabilities (ratios 0..1) or multipliers (scalars). Example keys (not exhaustive): cliffsChance (ratio), fjordChance (ratio), bayCarveMultiplier (scalar), shelfReefMultiplier (scalar), mountainRimChance (ratio), forestRimChance (ratio), hillRimChance (ratio), cliffChance (ratio), escarpmentChance (ratio).
 */

/**
 * Aggregated climate configuration grouping baseline, refinement, and macro swatch knobs.
 * @typedef {Object} Climate
 * @property {ClimateBaseline} [baseline]
 * @property {ClimateRefine} [refine]
 * @property {Swatches} [swatches]
 */

/**
 * Baseline rainfall and local bonuses.
 *
 * Establishes fundamental rainfall distribution based on latitude (distance from equator).
 * Mimics Earth's climate zones: wet tropics, dry subtropics, temperate mid-latitudes, cold poles.
 *
 * @typedef {Object} ClimateBaseline
 * @property {Object} [blend] - How to mix engine default rainfall with latitude-based targets
 * @property {number} [blend.baseWeight] - Weight for engine's base rainfall (0..1; typically 0.5-0.7)
 * @property {number} [blend.bandWeight] - Weight for latitude band targets (0..1; typically 0.3-0.5)
 * @property {Object} [bands] - Rainfall targets by latitude zone (units 0..200)
 * @property {number} [bands.deg0to10] - Equatorial zone (rainforests, monsoons; typically 110-130)
 * @property {number} [bands.deg10to20] - Tropical zone (wet but variable; typically 90-110)
 * @property {number} [bands.deg20to35] - Subtropical zone (deserts, Mediterranean; typically 60-80)
 * @property {number} [bands.deg35to55] - Temperate zone (moderate rainfall; typically 70-90)
 * @property {number} [bands.deg55to70] - Subpolar zone (cool, moderate moisture; typically 55-70)
 * @property {number} [bands.deg70plus] - Polar zone (cold deserts, ice; typically 40-50)
 * @property {Object} [orographic] - Orographic lift bonuses (mountains force air upward, causing condensation and rain)
 * @property {number} [orographic.hi1Threshold] - Elevation for modest rain increase (hills get some extra moisture)
 * @property {number} [orographic.hi1Bonus] - Rainfall bonus at first threshold in units (typically 5-15)
 * @property {number} [orographic.hi2Threshold] - Elevation for strong rain increase (mountains get significant moisture)
 * @property {number} [orographic.hi2Bonus] - Rainfall bonus at second threshold in units (typically 10-25)
 * @property {Object} [coastal] - Coastal bonuses
 * @property {number} [coastal.coastalLandBonus] - Bonus rainfall on coastal land tiles (rainfall units)
 * @property {number} [coastal.shallowAdjBonus] - Bonus rainfall when adjacent to shallow water (rainfall units)
 * @property {Object} [noise] - Rainfall noise/jitter
 * @property {number} [noise.baseSpanSmall] - Base +/-jitter span used on smaller maps (rainfall units)
 * @property {number} [noise.spanLargeScaleFactor] - Extra jitter span applied on larger maps (unitless scalar applied via sqrt(area))
 */

/**
 * Earthlike refinement parameters (realistic climate adjustments).
 *
 * Adds physically motivated climate effects on top of baseline latitude patterns:
 * - Continental effect: interiors are drier than coasts
 * - Rain shadows: mountains block moisture from reaching leeward areas
 * - River corridors: valleys retain moisture and support greenery
 * - Enclosed basins: low areas trap humidity
 *
 * @typedef {Object} ClimateRefine
 * @property {Object} [waterGradient] - Continental effect (distance from ocean impacts humidity)
 * @property {number} [waterGradient.radius] - How far inland to measure water proximity (typically 8-15 tiles)
 * @property {number} [waterGradient.perRingBonus] - Humidity per tile closer to water; creates coastalinterior gradient (typically 1-3 units/tile)
 * @property {number} [waterGradient.lowlandBonus] - Extra humidity in low-elevation areas near water (typically 5-12 units)
 * @property {Object} [orographic] - Orographic rain shadow simulation (leeward drying effect)
 * @property {number} [orographic.steps] - How far upwind to scan for blocking mountains (typically 4-8 tiles)
 * @property {number} [orographic.reductionBase] - Base rainfall loss in rain shadow (typically 8-20 units)
 * @property {number} [orographic.reductionPerStep] - Extra drying per tile closer to mountain barrier (typically 1-3 units/tile)
 * @property {Object} [riverCorridor] - River valley humidity (water channels transport moisture inland)
 * @property {number} [riverCorridor.lowlandAdjacencyBonus] - Humidity bonus next to rivers in lowlands (typically 8-18 units)
 * @property {number} [riverCorridor.highlandAdjacencyBonus] - Humidity bonus next to rivers in highlands; less than lowlands (typically 3-8 units)
 * @property {Object} [lowBasin] - Enclosed basin humidity retention (valleys trap moisture)
 * @property {number} [lowBasin.radius] - Search radius to detect if a lowland is surrounded by higher ground (typically 3-6 tiles)
 * @property {number} [lowBasin.delta] - Humidity bonus in enclosed lowland basins like oases (typically 10-25 units)
 */

/**
 * Mountain and hill placement tuning (WorldModel-driven orogeny).
 *
 * ARCHITECTURE: Physics-threshold based (not quota based).
 * Mountains appear only where physics score exceeds threshold - no forced quotas.
 * The tectonicIntensity dial scales physics effects to control mountain prevalence.
 *
 * @typedef {Object} Mountains
 * @property {number} [tectonicIntensity] - Scales all tectonic effects (1.0 = standard, higher = more mountains). This is the primary dial for mountain prevalence.
 * @property {number} [mountainThreshold] - Score threshold for mountain placement (0..1, typically 0.4-0.5). Lower = more permissive.
 * @property {number} [hillThreshold] - Score threshold for hill placement (0..1, typically 0.2-0.3). Lower = more hills.
 * @property {number} [upliftWeight] - Weight (0..1) applied to `WorldModel.upliftPotential`; higher = mountains stick to convergent zones
 * @property {number} [fractalWeight] - Weight (0..1) applied to fractal noise; higher = more natural variation in mountain chains
 * @property {number} [riftDepth] - 0..1 depression severity at divergent boundaries (1 = completely flatten divergent zones)
 * @property {number} [boundaryWeight] - Additional mountain weight contributed by plate-boundary closeness (unitless multiplier, typically 0..2)
 * @property {number} [boundaryExponent] - Exponent (>=0.25) shaping how quickly the boundary bonus decays with distance from a plate boundary (1.0 = linear)
 * @property {number} [interiorPenaltyWeight] - Amount subtracted from mountains deep inside plates; nudges belts toward margins (0..1)
 * @property {number} [convergenceBonus] - Extra additive weight for convergent tiles (0..1.5 typical) creating high orogeny ridges
 * @property {number} [transformPenalty] - Multiplier penalty applied along transform boundaries (0..1; 0.3 softens shearing ridges)
 * @property {number} [riftPenalty] - Multiplier penalty applied along divergent boundaries before `riftDepth` carve (0..1.5)
 * @property {number} [hillBoundaryWeight] - Hill weight contributed by plate-boundary closeness (0..1; creates foothill skirts)
 * @property {number} [hillRiftBonus] - Hill bonus for divergent belts (0..1; creates uplifted shoulders beside rifts)
 * @property {number} [hillConvergentFoothill] - Extra foothill weight on convergent tiles (0..0.5 typical)
 * @property {number} [hillInteriorFalloff] - Penalty for hills deep inside plates (0..0.5; higher keeps hills near action)
 * @property {number} [hillUpliftWeight] - Residual uplift contribution to hills (0..1; balances foothills + basins)
 */

/**
 * Volcano placement controls (plate-aware arcs + hotspots).
 *
 * Shapes how many volcanoes spawn, how tightly they track convergent margins,
 * and how much room is left for inland hotspot mechanics.
 *
 * @typedef {Object} Volcanoes
 * @property {boolean} [enabled] - Toggle volcano placement (default true)
 * @property {number} [baseDensity] - Volcanoes per land tile (e.g., 1/170  0.0059)
 * @property {number} [minSpacing] - Minimum Euclidean distance between volcanoes (tiles)
 * @property {number} [boundaryThreshold] - Plate-boundary closeness threshold (0..1) for treating a tile as margin adjacent
 * @property {number} [boundaryWeight] - Base weight applied to tiles within the plate-boundary band (0..3 typical)
 * @property {number} [convergentMultiplier] - Weight multiplier for convergent boundaries (>=0)
 * @property {number} [transformMultiplier] - Weight multiplier for transform boundaries (>=0)
 * @property {number} [divergentMultiplier] - Weight multiplier for divergent boundaries (>=0; usually <1 to discourage)
 * @property {number} [hotspotWeight] - Weight contributed to interior (non-boundary) hotspots (0..1)
 * @property {number} [shieldPenalty] - Penalty applied using shield stability (0..1; higher reduces interior volcanoes)
 * @property {number} [randomJitter] - Random additive jitter added per-tile (0..1) for variety
 * @property {number} [minVolcanoes] - Minimum volcano count target (integer)
 * @property {number} [maxVolcanoes] - Maximum volcano count target (integer; <=0 disables the cap)
 */

/**
 * Biome nudge thresholds (fine-tuning terrain assignment).
 *
 * Adjusts biome distribution to avoid unrealistic patterns and create interesting gameplay zones.
 * Example: prevent excessive tundra in temperate highlands, encourage tropical coasts near equator,
 * add grasslands along rivers and rift valleys for mobility and settlement opportunities.
 *
 * @typedef {Object} Biomes
 * @property {Object} [tundra] - Tundra constraints (prevent over-expansion of frozen terrain)
 * @property {number} [tundra.latMin] - Only allow tundra beyond this latitude; prevents equatorial tundra (typically 45-60)
 * @property {number} [tundra.elevMin] - Minimum elevation for tundra; prevents lowland tundra sprawl (typically 40-60)
 * @property {number} [tundra.rainMax] - Maximum rainfall for tundra; wet cold areas become taiga instead (typically 60-80)
 * @property {Object} [tropicalCoast] - Tropical coast encouragement (lush coastlines near equator)
 * @property {number} [tropicalCoast.latMax] - Latitude limit for tropical coast preference (typically 20-30 degrees)
 * @property {number} [tropicalCoast.rainMin] - Minimum humidity for tropical vegetation (typically 90-110 units)
 * @property {Object} [riverValleyGrassland] - River valley grassland bias (fertile flood plains)
 * @property {number} [riverValleyGrassland.latMax] - Latitude limit for temperate river grasslands (typically 45-60 degrees)
 * @property {number} [riverValleyGrassland.rainMin] - Minimum humidity for lush valley grasslands (typically 65-85 units)
 * @property {Object} [riftShoulder] - Rift shoulder biome preferences (elevated rift margins)
 * @property {number} [riftShoulder.grasslandLatMax] - Latitude limit for grassland on rift shoulders (typically 45-55 degrees)
 * @property {number} [riftShoulder.grasslandRainMin] - Minimum humidity for grassland rift shoulders (typically 60-80 units)
 * @property {number} [riftShoulder.tropicalLatMax] - Latitude limit for tropical rift shoulders (typically 25-35 degrees)
 * @property {number} [riftShoulder.tropicalRainMin] - Minimum humidity for tropical rift vegetation (typically 90-110 units)
 */

/**
 * Feature density controls (vegetation and reef prevalence).
 *
 * Fine-tunes how much forest, jungle, and reef coverage appears on the map.
 * Higher values create denser vegetation and more abundant natural features.
 * Affects visual variety and resource distribution.
 *
 * @typedef {Object} FeaturesDensity
 * @property {number} [rainforestExtraChance] - Bonus jungle/rainforest in wet tropics (percent 0..100, typically 15-40%)
 * @property {number} [forestExtraChance] - Bonus temperate forests in moderate rainfall zones (percent 0..100, typically 20-45%)
 * @property {number} [taigaExtraChance] - Bonus coniferous forests in cold regions (percent 0..100, typically 15-35%)
 * @property {number} [shelfReefMultiplier] - Coral reef density on passive continental shelves (multiplier, typically 0.8-1.5)
 */

/**
 * Late-stage placement (final touches and special features).
 *
 * Controls placement of natural wonders and floodplains along rivers.
 * Applied after all other generation is complete.
 *
 * @typedef {Object} Placement
 * @property {boolean} [wondersPlusOne] - Add one extra natural wonder beyond map size default for more variety
 * @property {Object} [floodplains] - River floodplain generation (fertile lowland strips)
 * @property {number} [floodplains.minLength] - Minimum floodplain segment length along rivers (typically 2-4 tiles)
 * @property {number} [floodplains.maxLength] - Maximum floodplain segment length along rivers (typically 4-8 tiles)
 */

/**
 * Developer logging toggles (keep false for release)
 * @typedef {Object} DevLogging
 * @property {boolean} [enabled] - Master switch for dev logging
 * @property {boolean} [logTiming] - Log per-section timings
 * @property {boolean} [logStoryTags] - Log StoryTags summary counts
 * @property {boolean} [rainfallHistogram] - Log coarse rainfall histogram over land
 */

/**
 * Unified world foundation configuration replacing the legacy `worldModel` + `landmass` split.
 *
 * @typedef {Object} FoundationConfig
 * @property {FoundationSeedConfig} [seed] - Deterministic seed controls shared by plates/dynamics.
 * @property {FoundationPlatesConfig} [plates] - Voronoi plate generation controls.
 * @property {FoundationDynamicsConfig} [dynamics] - Atmospheric/oceanic drivers and mantle pressure.
 * @property {FoundationSurfaceConfig} [surface] - Landmass targets and ocean separation policy.
 * @property {FoundationPolicyConfig} [policy] - Consumer-facing policy multipliers.
 * @property {FoundationDiagnosticsConfig} [diagnostics] - Logging + replay toggles for foundations.
 */

/**
 * Voronoi plate layout controls for the world foundation.
 *
 * @typedef {Object} FoundationPlatesConfig
 * @property {number} [count] - Number of tectonic plates; 8=Pangaea, 15-20=Earth-like, 25+=fragmented (typically 12-18).
 * @property {ReadonlyArray<number>} [axisAngles] - **Deprecated** legacy axis hints retained for compatibility.
 * @property {number} [convergenceMix] - Ratio of convergent vs divergent boundaries (0..1, typically 0.4-0.6).
 * @property {number} [relaxationSteps] - Lloyd relaxation iterations to smooth plate shapes (0=random, 5=balanced, 10+=uniform).
 * @property {number} [seedJitter] - Random offset applied to initial plate seeds in tiles (0-8 typical).
 * @property {number} [interiorSmooth] - Shield interior smoothing steps (iterations).
 * @property {number} [plateRotationMultiple] - Multiplier for plate rotation weighting along boundaries.
 * @property {"engine"|"fixed"} [seedMode] - Use Civ engine seed ("engine") or a fixed seed ("fixed").
 * @property {number} [fixedSeed] - Explicit plate seed used when `seedMode === "fixed"`.
 * @property {number} [seedOffset] - Integer added to the base seed before plate generation for deterministic reruns.
 */

/**
 * Prevailing wind configuration for rainfall/orographic modelling.
 *
 * @typedef {Object} FoundationWindConfig
 * @property {number} [jetStreaks] - Number of jet stream bands influencing storm tracks (typically 2-5).
 * @property {number} [jetStrength] - Jet stream intensity multiplier (typically 0.8-2.0).
 * @property {number} [variance] - Directional variance for winds (0..1, typically 0.2-0.6).
 * @property {number} [coriolisZonalScale] - Coriolis effect strength on zonal (east/west) flow (typically 0.8-1.5).
 */

/**
 * Ocean circulation configuration for humidity and coastal climate effects.
 *
 * @typedef {Object} FoundationCurrentsConfig
 * @property {number} [basinGyreCountMax] - Maximum gyre systems to model (typically 3-6).
 * @property {number} [westernBoundaryBias] - Strength of western boundary currents (unitless multiplier, typically 1.0-2.0).
 * @property {number} [currentStrength] - Overall ocean current strength multiplier (typically 0.8-1.5).
 */

/**
 * Mantle convection hotspot configuration used for uplift potential.
 *
 * @typedef {Object} FoundationMantleConfig
 * @property {number} [bumps] - Number of mantle plume hotspots (typically 3-8).
 * @property {number} [amplitude] - Uplift strength from mantle pressure (typically 0.5-1.5).
 * @property {number} [scale] - Spatial scale of pressure effects (typically 0.8-1.5).
 */

/**
 * Alignment and interplay controls for plates, winds, and currents.
 *
 * @typedef {Object} FoundationDirectionalityConfig
 * @property {number} [cohesion] - Global alignment strength (0..1, typically 0.3-0.7).
 * @property {Object} [primaryAxes] - Preferred axes for each subsystem (degrees, 0=east).
 * @property {number} [primaryAxes.plateAxisDeg] - Primary plate movement direction.
 * @property {number} [primaryAxes.windBiasDeg] - Wind direction bias offset from zonal flow.
 * @property {number} [primaryAxes.currentBiasDeg] - Ocean gyre rotation bias.
 * @property {Object} [interplay] - Cross-system coupling strengths controlling mutual influence.
 * @property {number} [interplay.windsFollowPlates] - Jet streams align with plate motion (0..1).
 * @property {number} [interplay.currentsFollowWinds] - Ocean currents align with winds (0..1).
 * @property {number} [interplay.riftsFollowPlates] - Rift valleys align with divergent plate boundaries (0..1).
 * @property {number} [interplay.orogenyOpposesRifts] - Mountain ranges oppose rift direction (0..1).
 * @property {Object} [hemispheres] - Hemisphere-specific behaviour.
 * @property {boolean} [hemispheres.southernFlip] - Flip directionality in the southern hemisphere (Coriolis realism).
 * @property {number} [hemispheres.equatorBandDeg] - Symmetric latitude band around the equator (degrees).
 * @property {number} [hemispheres.monsoonBias] - Seasonal wind variation strength (0..1).
 * @property {Object} [variability] - Randomness injection to avoid uniform patterns.
 * @property {number} [variability.angleJitterDeg] - Random deviation from preferred axes (degrees).
 * @property {number} [variability.magnitudeVariance] - Strength variation multiplier (0..1).
 * @property {number} [variability.seedOffset] - Seed offset for reproducible variability.
 */

/**
 * Policy multipliers exposed to downstream stages (story overlays, coastlines, etc.).
 *
 * @typedef {Object} FoundationPolicyConfig
 * @property {number} [windInfluence] - Wind impact on rain shadow calculations (multiplier, typically 0.5-1.5).
 * @property {number} [currentHumidityBias] - Coastal humidity bias from currents (multiplier, typically 0.5-1.5).
 * @property {number} [boundaryFjordBias] - Fjord frequency multiplier near convergent boundaries (typically 0.8-2.0).
 * @property {number} [shelfReefBias] - Coral reef density multiplier on passive shelves (typically 0.8-1.5).
 * @property {FoundationOceanSeparationConfig} [oceanSeparation] - Plate-aware ocean separation policy.
 */

/**
 * Plate-aware ocean separation policy controlling continental drift spacing.
 *
 * @typedef {Object} FoundationOceanSeparationConfig
 * @property {boolean} [enabled] - Enable plate-driven separation between continent bands.
 * @property {ReadonlyArray<ReadonlyArray<number>>} [bandPairs] - Pairs of continent indices to separate (e.g., [[0,1],[1,2]]).
 * @property {number} [baseSeparationTiles] - Baseline widening between continents in tiles (typically 2-8).
 * @property {number} [boundaryClosenessMultiplier] - Extra separation near active boundaries (multiplier 0..2).
 * @property {number} [maxPerRowDelta] - Maximum per-latitude variation in separation (tiles, typically 1-3).
 * @property {boolean} [respectSeaLanes] - Preserve strategic corridors when widening oceans.
 * @property {number} [minChannelWidth] - Minimum channel width to maintain for navigation (tiles, typically 4-8).
 * @property {Object} [edgeWest] - Optional overrides for the western map edge.
 * @property {boolean} [edgeWest.enabled] - Enable west-edge override.
 * @property {number} [edgeWest.baseTiles] - Baseline tiles at the west edge.
 * @property {number} [edgeWest.boundaryClosenessMultiplier] - Boundary multiplier at the west edge.
 * @property {number} [edgeWest.maxPerRowDelta] - Maximum per-row delta at the west edge.
 * @property {Object} [edgeEast] - Optional overrides for the eastern map edge.
 * @property {boolean} [edgeEast.enabled] - Enable east-edge override.
 * @property {number} [edgeEast.baseTiles] - Baseline tiles at the east edge.
 * @property {number} [edgeEast.boundaryClosenessMultiplier] - Boundary multiplier at the east edge.
 * @property {number} [edgeEast.maxPerRowDelta] - Maximum per-row delta at the east edge.
 */

/**
 * Deterministic seed configuration for world foundations.
 *
 * @typedef {Object} FoundationSeedConfig
 * @property {"engine"|"fixed"} [mode] - Use Civ engine seed or a fixed value.
 * @property {number} [fixed] - Explicit seed value when `mode === "fixed"`.
 * @property {number} [offset] - Global offset applied before deriving subsystem seeds.
 * @property {Object} [offsets] - Optional per-subsystem offsets (e.g., { plates, dynamics, surface }).
 * @property {number} [manifestHash] - Hash of the resolved manifest for replay diagnostics.
 */

/**
 * Atmospheric, oceanic, and mantle drivers for the foundation tensors.
 *
 * @typedef {Object} FoundationDynamicsConfig
 * @property {FoundationWindConfig} [wind] - Prevailing wind configuration.
 * @property {FoundationCurrentsConfig} [currents] - Ocean circulation settings.
 * @property {FoundationMantleConfig} [mantle] - Mantle pressure hotspot configuration.
 * @property {FoundationDirectionalityConfig} [directionality] - Cross-system alignment controls.
 */

/**
 * Surface targets derived from the world foundation seed.
 *
 * @typedef {Object} FoundationSurfaceConfig
 * @property {Landmass} [landmass] - Landmass targets and geometry preferences.
 * @property {FoundationOceanSeparationConfig} [oceanSeparation] - Plate-aware ocean separation policy.
 * @property {Object<string, any>} [overrides] - Additional surface overrides keyed by stage name.
 */

/**
 * Diagnostics and logging toggles for the foundation pipeline.
 *
 * @typedef {Object} FoundationDiagnosticsConfig
 * @property {boolean} [logSeed] - Emit plate seed + RNG metadata to diagnostics.
 * @property {boolean} [logPlates] - Log plate ASCII/summary output.
 * @property {boolean} [logDynamics] - Log wind/current summaries.
 * @property {boolean} [logSurface] - Log landmass window + separation summaries.
 */

// Export empty object to make this a proper ES module
export {};
</file>

<file path="mod/maps/bootstrap/resolved.js">
// @ts-check
/**
 * Resolved Config Provider
 *
 * Purpose
 * - Build a single, immutable configuration snapshot for the current run by
 *   composing, in order of increasing precedence:
 *     1) Explicit defaults (BASE_CONFIG)
 *     2) Named presets (optional, ordered)
 *     3) Per-entry overrides from runtime (set via setConfig in entry files)
 *
 * Usage
 * - Call refresh() once at the start of generation (e.g., top of generateMap()).
 * - Import and use the getters below to read resolved groups/fields.
 *
 * Notes
 * - Arrays are replaced (not merged); objects are deep-merged by key.
 * - The final snapshot is deeply frozen to prevent accidental mutation.
 * - Control keys (e.g., `presets`) are stripped from the final snapshot.
 */

/**
 * Type definitions for configuration objects (available at runtime).
 * @typedef {import('./map_config.types.js').MapConfig} MapConfig
 * @typedef {import('./map_config.types.js').Toggles} Toggles
 * @typedef {import('./map_config.types.js').Story} Story
 * @typedef {import('./map_config.types.js').Microclimate} Microclimate
 * @typedef {import('./map_config.types.js').Landmass} Landmass
 * @typedef {import('./map_config.types.js').Coastlines} Coastlines
 * @typedef {import('./map_config.types.js').Margins} Margins
 * @typedef {import('./map_config.types.js').Islands} Islands
 * @typedef {import('./map_config.types.js').ClimateBaseline} ClimateBaseline
 * @typedef {import('./map_config.types.js').ClimateRefine} ClimateRefine
 * @typedef {import('./map_config.types.js').Biomes} Biomes
 * @typedef {import('./map_config.types.js').FeaturesDensity} FeaturesDensity
 * @typedef {import('./map_config.types.js').Mountains} Mountains
 * @typedef {import('./map_config.types.js').Volcanoes} Volcanoes
 * @typedef {import('./map_config.types.js').Corridors} Corridors
 * @typedef {import('./map_config.types.js').Placement} Placement
 * @typedef {import('./map_config.types.js').DevLogging} DevLogging
 * @typedef {import('./map_config.types.js').FoundationConfig} FoundationConfig
 * @typedef {import('./map_config.types.js').StageManifest} StageManifest
 * @typedef {import('./map_config.types.js').StageDescriptor} StageDescriptor
 * @typedef {import('./map_config.types.js').StageName} StageName
 */

import { BASE_CONFIG } from "./defaults/base.js";
import { CLASSIC_PRESET } from "./presets/classic.js";
import { TEMPERATE_PRESET } from "./presets/temperate.js";
import { getConfig as getRuntimeConfig } from "./runtime.js";
/* -----------------------------------------------------------------------------
 * Internal state
 * -------------------------------------------------------------------------- */
/** @typedef {Record<string, any>} AnyObject */
/** @type {Record<string, AnyObject>} */
const PRESET_REGISTRY = Object.freeze({
    classic: CLASSIC_PRESET,
    temperate: TEMPERATE_PRESET,
});
/** @type {ReadonlyArray<string>} */
let ACTIVE_PRESETS = Object.freeze([]);
/** @type {Readonly<AnyObject>} */
let SNAPSHOT = BASE_CONFIG;
/** @type {StageManifest} */
const EMPTY_STAGE_MANIFEST = Object.freeze({
    order: Object.freeze([]),
    stages: Object.freeze({}),
});
/* -----------------------------------------------------------------------------
 * Merge and freeze helpers
 * -------------------------------------------------------------------------- */
/**
 * @param {any} v
 * @returns {v is AnyObject}
 */
function isPlainObject(v) {
    return (v != null &&
        typeof v === "object" &&
        (Object.getPrototypeOf(v) === Object.prototype ||
            Object.getPrototypeOf(v) === null));
}
/**
 * Deeply merge two values into a new value.
 * - Objects: merged per-key (recursively).
 * - Arrays: replaced by the source (no concat).
 * - Other types: replaced by the source.
 *
 * @template T
 * @param {T} base
 * @param {any} src
 * @returns {T}
 */
function deepMerge(base, src) {
    // Replace primitives and arrays directly
    if (!isPlainObject(base) || Array.isArray(src)) {
        return clone(src);
    }
    if (!isPlainObject(src)) {
        // If source is not a plain object, replace
        return clone(src);
    }
    /** @type {AnyObject} */
    const out = {};
    // Copy base keys first
    for (const k of Object.keys(base)) {
        out[k] = clone(base[k]);
    }
    // Merge/replace from source
    for (const k of Object.keys(src)) {
        const b = out[k];
        const s = src[k];
        if (isPlainObject(b) && isPlainObject(s)) {
            out[k] = deepMerge(b, s);
        }
        else {
            out[k] = clone(s);
        }
    }
    return /** @type {T} */ (out);
}
/**
 * Clone a value shallowly (objects/arrays produce new containers).
 * @param {any} v
 * @returns {any}
 */
function clone(v) {
    if (Array.isArray(v))
        return v.slice();
    if (isPlainObject(v)) {
        const o = {};
        for (const k of Object.keys(v))
            o[k] = v[k];
        return o;
    }
    return v;
}
/**
 * Deep-freeze an object graph (objects/arrays).
 * Loosened typing for @ts-check to avoid structural complaints in JS.
 * @param {any} v
 * @returns {any}
 */
function deepFreeze(v) {
    if (v == null)
        return v;
    if (typeof Object.isFrozen === "function" && Object.isFrozen(v))
        return v;
    if (Array.isArray(v)) {
        const arr = v.map((item) => deepFreeze(item));
        return Object.freeze(arr);
    }
    if (isPlainObject(v)) {
        /** @type {Record<string, any>} */
        const out = {};
        for (const k of Object.keys(v)) {
            out[k] = deepFreeze(v[k]);
        }
        return Object.freeze(out);
    }
    return v;
}
/**
 * @typedef {Object} StageState
 * @property {boolean} enabled
 * @property {boolean} requested
 * @property {Array<StageName>} requires
 * @property {Array<string>} legacyToggles
 * @property {Array<string>} provides
 * @property {string | undefined} blockedBy
 */
/**
 * @param {any} values
 * @returns {Array<string>}
 */
function normalizeStringArray(values) {
    if (!Array.isArray(values))
        return [];
    /** @type {Array<string>} */
    const out = [];
    const seen = new Set();
    for (const val of values) {
        if (typeof val !== "string")
            continue;
        if (seen.has(val))
            continue;
        seen.add(val);
        out.push(val);
    }
    return out;
}
/**
 * Normalize stage manifest metadata, enforce dependencies, and derive toggle state.
 *
 * @param {any} manifestInput
 * @param {AnyObject} togglesInput
 * @returns {{ manifest: StageManifest, toggles: Record<string, boolean>, warnings: Array<string> }}
 */
function normalizeStageManifest(manifestInput, togglesInput) {
    const manifestObj = isPlainObject(manifestInput) ? manifestInput : {};
    const rawOrder = Array.isArray(manifestObj.order) ? manifestObj.order : [];
    const rawStages = isPlainObject(manifestObj.stages) ? manifestObj.stages : {};
    /** @type {Array<StageName>} */
    const order = [];
    const seen = new Set();
    for (const entry of rawOrder) {
        if (typeof entry !== "string")
            continue;
        if (seen.has(entry))
            continue;
        order.push(entry);
        seen.add(entry);
    }
    for (const key of Object.keys(rawStages)) {
        if (seen.has(key))
            continue;
        order.push(key);
        seen.add(key);
    }
    /** @type {Record<string, StageState>} */
    const states = {};
    const toggles = isPlainObject(togglesInput) ? togglesInput : {};
    const orderIndex = new Map(order.map((name, idx) => [name, idx]));
    for (const name of order) {
        const rawDescriptor = rawStages[name];
        const descriptor = isPlainObject(rawDescriptor) ? rawDescriptor : {};
        const requires = normalizeStringArray(descriptor.requires);
        const provides = normalizeStringArray(descriptor.provides);
        const legacyToggles = normalizeStringArray(descriptor.legacyToggles);
        let enabled = descriptor.enabled !== false;
        let requested = enabled;
        for (const key of legacyToggles) {
            if (Object.prototype.hasOwnProperty.call(toggles, key) &&
                typeof toggles[key] === "boolean") {
                enabled = !!toggles[key];
                requested = !!toggles[key];
            }
        }
        states[name] = {
            enabled,
            requested,
            requires,
            legacyToggles,
            provides,
            blockedBy: undefined,
        };
    }
    for (const name of order) {
        const state = states[name];
        if (!state || !state.enabled)
            continue;
        for (const dep of state.requires) {
            const depState = states[dep];
            if (!depState) {
                if (!state.blockedBy)
                    state.blockedBy = `requires missing stage "${dep}"`;
                state.enabled = false;
                break;
            }
            if (!depState.enabled) {
                if (!state.blockedBy)
                    state.blockedBy = `requires disabled stage "${dep}"`;
                state.enabled = false;
                break;
            }
            const depIdx = orderIndex.get(dep);
            const stageIdx = orderIndex.get(name);
            if (depIdx != null && stageIdx != null && depIdx > stageIdx) {
                if (!state.blockedBy)
                    state.blockedBy = `dependency "${dep}" executes after stage`;
                state.enabled = false;
                break;
            }
        }
    }
    /** @type {Record<string, boolean>} */
    const derivedToggles = {};
    /** @type {Array<string>} */
    const warnings = [];
    /** @type {Record<string, StageDescriptor>} */
    const normalizedStages = {};
    for (const name of order) {
        const state = states[name];
        if (!state)
            continue;
        for (const key of state.legacyToggles) {
            derivedToggles[key] = !!state.enabled;
        }
        if (state.blockedBy && state.requested) {
            warnings.push(`Stage "${name}" disabled: ${state.blockedBy}.`);
        }
        const desc = /** @type {StageDescriptor} */ ({
            enabled: !!state.enabled,
        });
        if (state.requires.length)
            desc.requires = state.requires.slice();
        if (state.provides.length)
            desc.provides = state.provides.slice();
        if (state.legacyToggles.length)
            desc.legacyToggles = state.legacyToggles.slice();
        if (state.blockedBy)
            desc.blockedBy = state.blockedBy;
        normalizedStages[name] = desc;
    }
    return {
        manifest: {
            order: order.slice(),
            stages: normalizedStages,
        },
        toggles: derivedToggles,
        warnings,
    };
}

/**
 * Normalize stage configuration provider metadata from runtime entries.
 * @param {any} input
 * @returns {Record<string, boolean>}
 */
function normalizeStageConfigProviders(input) {
    if (!isPlainObject(input))
        return {};
    /** @type {Record<string, boolean>} */
    const out = {};
    for (const key of Object.keys(input)) {
        if (typeof key !== "string")
            continue;
        const value = input[key];
        if (typeof value === "boolean") {
            if (value)
                out[key] = true;
            continue;
        }
        if (value != null)
            out[key] = true;
    }
    return out;
}

/**
 * Derive warnings when overrides target disabled or missing stages.
 * @param {Record<string, boolean>} providers
 * @param {StageManifest} manifest
 * @returns {Array<string>}
 */
function deriveStageOverrideWarnings(providers, manifest) {
    /** @type {Array<string>} */
    const warnings = [];
    if (!providers)
        return warnings;
    const stages = manifest?.stages || {};
    for (const name of Object.keys(providers)) {
        if (!providers[name])
            continue;
        const desc = stages[name];
        if (!desc) {
            warnings.push(`Stage "${name}" not present in manifest; overrides will not run.`);
            continue;
        }
        if (desc.enabled)
            continue;
        const reason = desc.blockedBy ? ` (${desc.blockedBy})` : "";
        warnings.push(`Stage "${name}" disabled${reason}; overrides for this stage will be ignored.`);
    }
    return warnings;
}

/**
 * Normalize the foundation group and surface landmass metadata.
 * Mutates the supplied merged snapshot and returns any migration warnings.
 * @param {AnyObject} merged
 * @returns {Array<string>}
 */
function normalizeFoundationGroup(merged) {
    /** @type {Array<string>} */
    const warnings = [];
    const foundationInput = isPlainObject(merged.foundation) ? /** @type {AnyObject} */ (merged.foundation) : {};
    const landmassInput = isPlainObject(merged.landmass) ? /** @type {AnyObject} */ (merged.landmass) : {};
    /** @type {AnyObject} */
    const foundationNormalized = deepMerge({}, foundationInput || {});
    if (Object.keys(landmassInput).length > 0) {
        if (isPlainObject(foundationNormalized.surface)) {
            foundationNormalized.surface = deepMerge({ landmass: landmassInput }, foundationNormalized.surface);
        }
        else {
            foundationNormalized.surface = { landmass: landmassInput };
        }
    }
    merged.foundation = foundationNormalized;
    if (merged.worldModel && isPlainObject(merged.worldModel) && Object.keys(merged.worldModel).length > 0) {
        warnings.push("Legacy `worldModel` overrides are no longer supported; migrate overrides to `foundation.*`.");
    }
    if ("worldModel" in merged) {
        delete merged.worldModel;
    }
    return warnings;
}
/* -----------------------------------------------------------------------------
 * Resolution
 * -------------------------------------------------------------------------- */
/**
 * Build a new resolved snapshot by composing:
 *   BASE_CONFIG <- presets[] <- runtimeOverrides
 *
 * Runtime overrides may optionally include { presets: string[] } to select
 * named presets. The 'presets' control key is stripped from the final snapshot.
 *
 * @returns {{ snapshot: Readonly<AnyObject>, activePresetNames: ReadonlyArray<string> }}
 */
function buildSnapshot() {
    // Start from explicit defaults
    let merged = /** @type {AnyObject} */ (deepMerge({}, BASE_CONFIG));
    // Read per-entry overrides
    const rc = /** @type {AnyObject} */ (getRuntimeConfig() || {});
    // Resolve and apply presets (ordered)
    const presetNames = Array.isArray(rc.presets)
        ? rc.presets.filter((n) => typeof n === "string" && !!PRESET_REGISTRY[n])
        : [];
    for (const name of presetNames) {
        const presetObj = PRESET_REGISTRY[name];
        if (presetObj) {
            merged = deepMerge(merged, presetObj);
        }
    }
    const stageConfigProviders = normalizeStageConfigProviders(rc.stageConfig);
    // Strip control keys (e.g., 'presets') from overrides before merge
    /** @type {AnyObject} */
    const overrides = {};
    for (const k of Object.keys(rc)) {
        if (k === "presets" || k === "stageConfig")
            continue;
        overrides[k] = rc[k];
    }
    // Apply per-entry overrides last (highest precedence)
    merged = deepMerge(merged, overrides);
    if (Object.keys(stageConfigProviders).length > 0) {
        merged.stageConfig = stageConfigProviders;
    }
    const togglesBase = isPlainObject(merged.toggles) ? /** @type {AnyObject} */ (merged.toggles) : {};
    const { manifest: normalizedManifest, toggles: manifestToggles, warnings } = normalizeStageManifest(merged.stageManifest, togglesBase);
    const overrideWarnings = deriveStageOverrideWarnings(stageConfigProviders, normalizedManifest);
    merged.stageManifest = normalizedManifest;
    merged.toggles = { ...togglesBase, ...manifestToggles };
    for (const msg of [...warnings, ...overrideWarnings]) {
        try {
            console.warn(`[StageManifest] ${msg}`);
        }
        catch (_) {
            // Ignore console access issues in restrictive runtimes.
        }
    }
    const foundationWarnings = normalizeFoundationGroup(merged);
    for (const msg of foundationWarnings) {
        try {
            console.warn(`[Foundation] ${msg}`);
        }
        catch (_) {
            // Ignore console access issues in restrictive runtimes.
        }
    }
    // Freeze deeply for safety
    const frozen = deepFreeze(merged);
    return {
        snapshot: frozen,
        activePresetNames: Object.freeze(presetNames.slice()),
    };
}
/* -----------------------------------------------------------------------------
 * Public API
 * -------------------------------------------------------------------------- */
/**
 * Rebuild the resolved snapshot for the current run.
 * Should be called at the start of generation (e.g., in generateMap()).
 */
export function refresh() {
    const { snapshot, activePresetNames } = buildSnapshot();
    SNAPSHOT = snapshot;
    ACTIVE_PRESETS = activePresetNames;
}
/**
 * Get the current immutable snapshot (for diagnostics or advanced usage).
 * @returns {Readonly<AnyObject>}
 */
export function getSnapshot() {
    return SNAPSHOT;
}
/**
 * Get the currently active preset names (in application order).
 * @returns {ReadonlyArray<string>}
 */
export function currentActivePresets() {
    return ACTIVE_PRESETS;
}
/**
 * Generic group accessor with safe fallback to empty object.
 * @param {string} groupName
 * @returns {Readonly<AnyObject>}
 */
export function getGroup(groupName) {
    const g = SNAPSHOT && /** @type {AnyObject} */ (SNAPSHOT)[groupName];
    return /** @type {any} */ (isPlainObject(g) ? g : {});
}
/**
 * Retrieve the normalized stage manifest (order + descriptors).
 * @returns {Readonly<StageManifest>}
 */
export function STAGE_MANIFEST() {
    const manifest = SNAPSHOT && /** @type {AnyObject} */ (SNAPSHOT).stageManifest;
    return isPlainObject(manifest)
        ? /** @type {Readonly<StageManifest>} */ (manifest)
        : EMPTY_STAGE_MANIFEST;
}
/**
 * Dot-path getter for convenience (e.g., "foundation.dynamics.wind").
 * Returns undefined if not found.
 * @param {string} path
 * @returns {any}
 */
export function get(path) {
    if (!path || typeof path !== "string")
        return undefined;
    const parts = path.split(".");
    /** @type {any} */
    let cur = SNAPSHOT;
    for (const p of parts) {
        if (cur == null)
            return undefined;
        cur = cur[p];
    }
    return cur;
}
/* ---- Named helpers (common groups; return empty objects if missing) ---- */
/** @returns {Readonly<Toggles>} */
export function TOGGLES() {
    return /** @type {Readonly<Toggles>} */ (getGroup("toggles"));
}
/** @returns {Readonly<Story>} */
export function STORY() {
    return /** @type {Readonly<Story>} */ (getGroup("story"));
}
/** @returns {Readonly<Microclimate>} */
export function MICROCLIMATE() {
    return /** @type {Readonly<Microclimate>} */ (getGroup("microclimate"));
}
/** @returns {Readonly<Landmass>} */
export function LANDMASS_CFG() {
    return /** @type {Readonly<Landmass>} */ (getGroup("landmass"));
}
/** @returns {Readonly<Coastlines>} */
export function COASTLINES_CFG() {
    return /** @type {Readonly<Coastlines>} */ (getGroup("coastlines"));
}
/** @returns {Readonly<Margins>} */
export function MARGINS_CFG() {
    return /** @type {Readonly<Margins>} */ (getGroup("margins"));
}
/** @returns {Readonly<Islands>} */
export function ISLANDS_CFG() {
    return /** @type {Readonly<Islands>} */ (getGroup("islands"));
}
/** @returns {Readonly<any>} */
export function CLIMATE_CFG() {
    return /** @type {Readonly<any>} */ (getGroup("climate"));
}
/** @returns {Readonly<Mountains>} */
export function MOUNTAINS_CFG() {
    return /** @type {Readonly<Mountains>} */ (getGroup("mountains"));
}
/** @returns {Readonly<Volcanoes>} */
export function VOLCANOES_CFG() {
    return /** @type {Readonly<Volcanoes>} */ (getGroup("volcanoes"));
}
/** @returns {Readonly<Biomes>} */
export function BIOMES_CFG() {
    return /** @type {Readonly<Biomes>} */ (getGroup("biomes"));
}
/** @returns {Readonly<FeaturesDensity>} */
export function FEATURES_DENSITY_CFG() {
    return /** @type {Readonly<FeaturesDensity>} */ (getGroup("featuresDensity"));
}
/** @returns {Readonly<Corridors>} */
export function CORRIDORS_CFG() {
    return /** @type {Readonly<Corridors>} */ (getGroup("corridors"));
}
/** @returns {Readonly<Placement>} */
export function PLACEMENT_CFG() {
    return /** @type {Readonly<Placement>} */ (getGroup("placement"));
}
/** @returns {Readonly<DevLogging>} */
export function DEV_LOG_CFG() {
    return /** @type {Readonly<DevLogging>} */ (getGroup("dev"));
}
/** @returns {Readonly<FoundationConfig>} */
export function FOUNDATION_CFG() {
    return /** @type {Readonly<FoundationConfig>} */ (getGroup("foundation"));
}
/* ---- Foundation helpers ---- */
export function FOUNDATION_SEED() {
    return /** @type {any} */ (get("foundation.seed") || {});
}
export function FOUNDATION_PLATES() {
    return /** @type {any} */ (get("foundation.plates") || {});
}
export function FOUNDATION_DYNAMICS() {
    return /** @type {any} */ (get("foundation.dynamics") || {});
}
export function FOUNDATION_SURFACE() {
    return /** @type {any} */ (get("foundation.surface") || {});
}
export function FOUNDATION_POLICY() {
    return /** @type {any} */ (get("foundation.policy") || {});
}
export function FOUNDATION_DIAGNOSTICS() {
    return /** @type {any} */ (get("foundation.diagnostics") || {});
}
export function FOUNDATION_DIRECTIONALITY() {
    return /** @type {any} */ (get("foundation.dynamics.directionality") || {});
}
export function FOUNDATION_OCEAN_SEPARATION() {
    return /** @type {any} */ (get("foundation.surface.oceanSeparation") ||
        get("foundation.policy.oceanSeparation") ||
        {});
}

/* ---- Default export (optional convenience) ---- */
export default {
    refresh,
    getSnapshot,
    currentActivePresets,
    getGroup,
    get,
    STAGE_MANIFEST,
    // Groups
    TOGGLES,
    STORY,
    MICROCLIMATE,
    LANDMASS_CFG,
    COASTLINES_CFG,
    MARGINS_CFG,
    ISLANDS_CFG,
    CLIMATE_CFG,
    BIOMES_CFG,
    FEATURES_DENSITY_CFG,
    CORRIDORS_CFG,
    PLACEMENT_CFG,
    DEV_LOG_CFG,
    FOUNDATION_CFG,
    // Foundation subsets
    FOUNDATION_SEED,
    FOUNDATION_PLATES,
    FOUNDATION_DYNAMICS,
    FOUNDATION_SURFACE,
    FOUNDATION_POLICY,
    FOUNDATION_DIAGNOSTICS,
    FOUNDATION_DIRECTIONALITY,
    FOUNDATION_OCEAN_SEPARATION,
};
</file>

<file path="mod/maps/bootstrap/runtime.js">
// @ts-nocheck
/**
 * Minimal runtime config store for per-map inline configuration.
 *
 * Intent
 * - Each map entry file defines a plain JS object (MAP_CONFIG) inline and calls setConfig(MAP_CONFIG).
 * - The generator/orchestrator imports this module and calls getConfig() at runtime (e.g., inside generateMap()).
 * - No dynamic imports, no registries, no evaluation-time side effects. Dead simple and explicit.
 *
 * Usage (in a map entry file):
 *   import { setConfig } from "./config/runtime.js";
 *   import "./map_orchestrator.js"; // or your generator module that reads getConfig() at runtime
 *
 *   setConfig({
 *     landmass: { /* ... *\/ },
 *     foundation: { /* ... *\/ },
 *     /* other groups ... *\/
 *   });
 *
 * Usage (in the orchestrator/generator):
 *   import { getConfig } from "./config/runtime.js";
 *   function generateMap() {
 *     const cfg = getConfig();
 *     // read cfg.toggles, cfg.landmass, etc., and proceed
 *   }
 */
const GLOBAL_KEY = "__EPIC_MAP_CONFIG__";
/**
 * Store the per-map configuration for this run.
 * Accepts any plain object. Non-objects are coerced to an empty object.
 * The stored object is shallow-frozen to prevent accidental mutation.
 * @param {object} config
 */
export function setConfig(config) {
    const obj = isObject(config) ? config : {};
    const frozen = shallowFreeze(obj);
    try {
        // Use a single well-known global key so all modules can access the same config
        // without import-time coupling or registries.
        globalThis[GLOBAL_KEY] = frozen;
    }
    catch {
        // In restricted environments, fall back to a local static (unlikely in Civ VM).
        __localStore.value = frozen;
    }
}
/**
 * Retrieve the current per-map configuration.
 * Returns an empty frozen object if none was set.
 * @returns {object}
 */
export function getConfig() {
    try {
        const v = globalThis[GLOBAL_KEY];
        return isObject(v) ? v : EMPTY_FROZEN_OBJECT;
    }
    catch {
        return isObject(__localStore.value) ? __localStore.value : EMPTY_FROZEN_OBJECT;
    }
}
/* -----------------------------------------------------------------------------
 * Internal helpers
 * -------------------------------------------------------------------------- */
const EMPTY_FROZEN_OBJECT = Object.freeze({});
/** @type {{ value: object }} */
const __localStore = { value: EMPTY_FROZEN_OBJECT };
/**
 * Shallow-freeze an object (freezes only the first level).
 * @template T extends object
 * @param {T} obj
 * @returns {Readonly<T>}
 */
function shallowFreeze(obj) {
    try {
        return Object.freeze(obj);
    }
    catch {
        return obj;
    }
}
/**
 * @param {any} v
 * @returns {v is object}
 */
function isObject(v) {
    return v != null && typeof v === "object";
}
</file>

<file path="mod/maps/bootstrap/tunables.js">
/**
 * Unified Tunables  Live bindings with runtime rebind()
 *
 * Intent
 * - Provide a single import surface for all generator tunables (toggles and groups)
 *   backed by the resolved config snapshot.
 * - Export live ES module bindings (let variables) so callers see updated values
 *   after a call to rebind().
 *
 * Usage
 *   // Import once anywhere (bindings are live)
 *   import {
 *     rebind,
 *     LANDMASS_CFG,
 *     FOUNDATION_DIRECTIONALITY,
 *     // ...
 *   } from "./config/tunables.js";
 *
 *   // Call rebind() at the start of a generation (or when the active entry changes)
 *   rebind();
 *
 * Notes
 * - rebind() calls resolved.refresh() internally, then updates all exported bindings.
 * - A besteffort initial rebind() is performed at module load for safety.
 * - Arrays and objects returned from the resolver are treated as readonly.
 */
// @ts-check
import {
    refresh as __refreshResolved__,
    // group getters
    TOGGLES as __TOGGLES__,
    STORY as __STORY__,
    MICROCLIMATE as __MICROCLIMATE__,
    LANDMASS_CFG as __LANDMASS__,
    COASTLINES_CFG as __COASTLINES__,
    MARGINS_CFG as __MARGINS__,
    ISLANDS_CFG as __ISLANDS__,
    CLIMATE_CFG as __CLIMATE__,
    MOUNTAINS_CFG as __MOUNTAINS__,
    VOLCANOES_CFG as __VOLCANOES__,
    BIOMES_CFG as __BIOMES__,
    FEATURES_DENSITY_CFG as __FEATURES_DENSITY__,
    CORRIDORS_CFG as __CORRIDORS__,
    PLACEMENT_CFG as __PLACEMENT__,
    DEV_LOG_CFG as __DEV__,
    FOUNDATION_CFG as __FOUNDATION__,
    STAGE_MANIFEST as __STAGE_MANIFEST__,
    // foundation helpers
    FOUNDATION_SEED as __FOUNDATION_SEED__,
    FOUNDATION_PLATES as __FOUNDATION_PLATES__,
    FOUNDATION_DYNAMICS as __FOUNDATION_DYNAMICS__,
    FOUNDATION_SURFACE as __FOUNDATION_SURFACE__,
    FOUNDATION_POLICY as __FOUNDATION_POLICY__,
    FOUNDATION_DIAGNOSTICS as __FOUNDATION_DIAGNOSTICS__,
    FOUNDATION_DIRECTIONALITY as __FOUNDATION_DIR__,
    FOUNDATION_OCEAN_SEPARATION as __FOUNDATION_OSEPARATION__,
} from "./resolved.js";
/**
 * Type definitions for configuration objects (available at runtime).
 * @typedef {import('./map_config.types.js').Landmass} Landmass
 * @typedef {import('./map_config.types.js').LandmassGeometry} LandmassGeometry
 * @typedef {import('./map_config.types.js').Coastlines} CoastlinesCfg
 * @typedef {import('./map_config.types.js').Margins} MarginsCfg
 * @typedef {import('./map_config.types.js').Islands} IslandsCfg
 * @typedef {import('./map_config.types.js').ClimateBaseline} ClimateBaseline
 * @typedef {import('./map_config.types.js').ClimateRefine} ClimateRefine
 * @typedef {import('./map_config.types.js').Mountains} MountainsCfg
 * @typedef {import('./map_config.types.js').Biomes} Biomes
 * @typedef {import('./map_config.types.js').Volcanoes} VolcanoesCfg
 * @typedef {import('./map_config.types.js').FeaturesDensity} FeaturesDensity
 * @typedef {import('./map_config.types.js').Corridors} Corridors
 * @typedef {import('./map_config.types.js').CorridorPolicy} CorridorPolicy
 * @typedef {import('./map_config.types.js').CorridorKinds} CorridorKinds
 * @typedef {import('./map_config.types.js').Placement} Placement
 * @typedef {import('./map_config.types.js').DevLogging} DevLogging
 * @typedef {import('./map_config.types.js').FoundationConfig} FoundationConfig
 * @typedef {import('./map_config.types.js').FoundationSeedConfig} FoundationSeedConfig
 * @typedef {import('./map_config.types.js').FoundationPlatesConfig} FoundationPlatesConfig
 * @typedef {import('./map_config.types.js').FoundationDynamicsConfig} FoundationDynamicsConfig
 * @typedef {import('./map_config.types.js').FoundationDirectionalityConfig} FoundationDirectionalityConfig
 * @typedef {import('./map_config.types.js').FoundationPolicyConfig} FoundationPolicyConfig
 * @typedef {import('./map_config.types.js').FoundationOceanSeparationConfig} FoundationOceanSeparationConfig
 * @typedef {import('./map_config.types.js').FoundationSurfaceConfig} FoundationSurfaceConfig
 * @typedef {import('./map_config.types.js').FoundationDiagnosticsConfig} FoundationDiagnosticsConfig
 * @typedef {import('./map_config.types.js').StageManifest} StageManifest
 * @typedef {import('./map_config.types.js').StageDescriptor} StageDescriptor
 * @typedef {import('./map_config.types.js').StageName} StageName
 */
/**
 * @typedef {Readonly<Partial<Record<string, StageDescriptor>>>} StageDescriptorMap
 * @typedef {Readonly<{
 *   order: ReadonlyArray<string>;
 *   stages: StageDescriptorMap;
 * }>} StageManifestSnapshot
 */
const EMPTY_OBJECT = /** @type {Readonly<any>} */ (Object.freeze({}));
const EMPTY_ARRAY = /** @type {ReadonlyArray<any>} */ (Object.freeze([]));
const EMPTY_STAGE_ORDER = /** @type {ReadonlyArray<string>} */ (Object.freeze([]));
const EMPTY_STAGE_MANIFEST = /** @type {StageManifestSnapshot} */ (Object.freeze({
    order: EMPTY_STAGE_ORDER,
    stages: Object.freeze(
        /** @type {Partial<Record<string, StageDescriptor>>} */ ({})
    ),
}));
const EMPTY_CLIMATE_BASELINE = /** @type {Readonly<ClimateBaseline>} */ (Object.freeze({}));
const EMPTY_CLIMATE_REFINE = /** @type {Readonly<ClimateRefine>} */ (Object.freeze({}));
/* -----------------------------------------------------------------------------
 * Exported live bindings (updated by rebind)
 * -------------------------------------------------------------------------- */
/** @type {StageManifestSnapshot} */
export let STAGE_MANIFEST = EMPTY_STAGE_MANIFEST;
/**
 * Check whether a manifest stage is enabled after dependency evaluation.
 * @param {StageName} stage
 * @returns {boolean}
 */
export function stageEnabled(stage) {
    if (!STAGE_MANIFEST || typeof STAGE_MANIFEST !== "object")
        return false;
    const stages = STAGE_MANIFEST.stages || {};
    const entry = stages && stages[stage];
    return !!(entry && entry.enabled !== false);
}
// Master toggles
export let STORY_ENABLE_HOTSPOTS = true;
export let STORY_ENABLE_RIFTS = true;
export let STORY_ENABLE_OROGENY = true;
export let STORY_ENABLE_SWATCHES = true;
export let STORY_ENABLE_PALEO = true;
export let STORY_ENABLE_CORRIDORS = true;
// Merged story+micro tunables convenience view
export let STORY_TUNABLES = Object.freeze({
    hotspot: Object.freeze({}),
    rift: Object.freeze({}),
    orogeny: Object.freeze({}),
    swatches: Object.freeze({}),
    paleo: Object.freeze({}),
    rainfall: Object.freeze({}),
    features: Object.freeze({}),
});
// Group objects (treat as readonly from callers)
/** @type {Readonly<Landmass>} */
export let LANDMASS_CFG = Object.freeze({});
/** @type {Readonly<LandmassGeometry>} */
export let LANDMASS_GEOMETRY = Object.freeze({});
/** @type {Readonly<CoastlinesCfg>} */
export let COASTLINES_CFG = Object.freeze({});
/** @type {Readonly<MarginsCfg>} */
export let MARGINS_CFG = Object.freeze({});
/** @type {Readonly<IslandsCfg>} */
export let ISLANDS_CFG = Object.freeze({});
/** @type {Readonly<any>} */
export let CLIMATE_CFG = Object.freeze({});
/**
 * Shared climate primitives exposed to layers and narrative overlays.
 *
 * climate.drivers  canonical baseline/refinement parameter blocks.
 * climate.moistureAdjustments  targeted adjustments used by layers and overlays.
 */
export let CLIMATE = Object.freeze({
    drivers: Object.freeze({
        baseline: Object.freeze({}),
        refine: Object.freeze({}),
    }),
    moistureAdjustments: Object.freeze({
        baseline: Object.freeze({}),
        refine: Object.freeze({}),
        story: Object.freeze({}),
        micro: Object.freeze({}),
    }),
});
export let CLIMATE_DRIVERS = CLIMATE.drivers;
export let MOISTURE_ADJUSTMENTS = CLIMATE.moistureAdjustments;
/** @type {Readonly<FoundationConfig>} */
export let FOUNDATION_CFG = Object.freeze({});
/**
 * Consolidated view of the world foundation configuration (seed, plates, dynamics, surface, policy).
 */
export let FOUNDATION = Object.freeze({
    core: Object.freeze({}),
    seed: Object.freeze({}),
    plates: Object.freeze({}),
    dynamics: Object.freeze({}),
    surface: Object.freeze({}),
    policy: Object.freeze({}),
    diagnostics: Object.freeze({}),
});
/** @type {Readonly<FoundationSeedConfig>} */
export let FOUNDATION_SEED = Object.freeze({});
/** @type {Readonly<FoundationPlatesConfig>} */
export let FOUNDATION_PLATES = Object.freeze({});
/** @type {Readonly<FoundationDynamicsConfig>} */
export let FOUNDATION_DYNAMICS = Object.freeze({});
/** @type {Readonly<FoundationSurfaceConfig>} */
export let FOUNDATION_SURFACE = Object.freeze({});
/** @type {Readonly<FoundationPolicyConfig>} */
export let FOUNDATION_POLICY = Object.freeze({});
/** @type {Readonly<FoundationDiagnosticsConfig>} */
export let FOUNDATION_DIAGNOSTICS = Object.freeze({});
/** @type {Readonly<FoundationDirectionalityConfig>} */
export let FOUNDATION_DIRECTIONALITY = Object.freeze({});
/** @type {Readonly<FoundationOceanSeparationConfig>} */
export let FOUNDATION_OCEAN_SEPARATION = Object.freeze({});
/** @type {Readonly<MountainsCfg>} */
export let MOUNTAINS_CFG = Object.freeze({});
/** @type {Readonly<VolcanoesCfg>} */
export let VOLCANOES_CFG = Object.freeze({});
/** @type {Readonly<Biomes>} */
export let BIOMES_CFG = Object.freeze({});
/** @type {Readonly<FeaturesDensity>} */
export let FEATURES_DENSITY_CFG = Object.freeze({});
/** @type {Readonly<Corridors>} */
export let CORRIDORS_CFG = Object.freeze({});
/** @type {Readonly<Placement>} */
export let PLACEMENT_CFG = Object.freeze({});
/** @type {Readonly<DevLogging>} */
export let DEV_LOG_CFG = Object.freeze({});
// Corridor sub-groups
/** @type {Readonly<CorridorPolicy>} */
export let CORRIDOR_POLICY = Object.freeze({});
/** @type {Readonly<CorridorKinds>} */
export let CORRIDOR_KINDS = Object.freeze({});
/* -----------------------------------------------------------------------------
 * Namespaced views (lightweight import helpers)
 * -------------------------------------------------------------------------- */
/**
 * Focused accessor bundle for climate-related tunables.
 * Uses getters so consumers always see the most recent rebind() snapshot.
 */
export const CLIMATE_TUNABLES = Object.freeze({
    get config() {
        return CLIMATE_CFG;
    },
    get snapshot() {
        return CLIMATE;
    },
    get drivers() {
        return CLIMATE_DRIVERS;
    },
    get moistureAdjustments() {
        return MOISTURE_ADJUSTMENTS;
    },
});
/**
 * Focused accessor bundle for foundation/world settings.
 */
export const FOUNDATION_TUNABLES = Object.freeze({
    get config() {
        return FOUNDATION_CFG;
    },
    get snapshot() {
        return FOUNDATION;
    },
    get seed() {
        return FOUNDATION_SEED;
    },
    get plates() {
        return FOUNDATION_PLATES;
    },
    get dynamics() {
        return FOUNDATION_DYNAMICS;
    },
    get surface() {
        return FOUNDATION_SURFACE;
    },
    get policy() {
        return FOUNDATION_POLICY;
    },
    get diagnostics() {
        return FOUNDATION_DIAGNOSTICS;
    },
    get directionality() {
        return FOUNDATION_DIRECTIONALITY;
    },
    get oceanSeparation() {
        return FOUNDATION_OCEAN_SEPARATION;
    },
});
/* -----------------------------------------------------------------------------
 * Rebind implementation
 * -------------------------------------------------------------------------- */
/**
 * Refresh the resolved snapshot then update all exported bindings.
 * Call this at the start of a generation (or whenever the active entry changes).
 */
export function rebind() {
    // 1) Resolve the current snapshot from defaults + presets + per-entry overrides
    __refreshResolved__();
    STAGE_MANIFEST = coerceStageManifest(__STAGE_MANIFEST__());
    const manifestToggleMap = deriveManifestToggleMap(STAGE_MANIFEST);
    const resolvedToggleSnapshot = /** @type {Readonly<Record<string, unknown>>} */ (safeObj(__TOGGLES__()));
    /**
     * Resolve a toggle key using manifest overrides, then runtime toggles.
     * @param {string} key
     * @param {boolean} fallback
     * @returns {boolean}
     */
    const toggleValue = (key, fallback) => {
        if (Object.prototype.hasOwnProperty.call(manifestToggleMap, key))
            return manifestToggleMap[key];
        const raw = resolvedToggleSnapshot[key];
        return typeof raw === "boolean" ? raw : fallback;
    };
    // 2) Toggles
    STORY_ENABLE_HOTSPOTS = toggleValue("STORY_ENABLE_HOTSPOTS", true);
    STORY_ENABLE_RIFTS = toggleValue("STORY_ENABLE_RIFTS", true);
    STORY_ENABLE_OROGENY = toggleValue("STORY_ENABLE_OROGENY", true);
    STORY_ENABLE_SWATCHES = toggleValue("STORY_ENABLE_SWATCHES", true);
    STORY_ENABLE_PALEO = toggleValue("STORY_ENABLE_PALEO", true);
    STORY_ENABLE_CORRIDORS = toggleValue("STORY_ENABLE_CORRIDORS", true);
    // 3) Story+Micro merged convenience
    const S = safeObj(__STORY__());
    const M = safeObj(__MICROCLIMATE__());
    STORY_TUNABLES = Object.freeze({
        hotspot: safeObj(S.hotspot),
        rift: safeObj(S.rift),
        orogeny: safeObj(S.orogeny),
        swatches: safeObj(S.swatches),
        paleo: safeObj(S.paleo),
        rainfall: safeObj(M.rainfall),
        features: safeObj(M.features),
    });
    // 4) Groups
    LANDMASS_CFG = safeObj(__LANDMASS__());
    LANDMASS_GEOMETRY = safeObj(LANDMASS_CFG.geometry);
    COASTLINES_CFG = safeObj(__COASTLINES__());
    MARGINS_CFG = safeObj(__MARGINS__());
    ISLANDS_CFG = safeObj(__ISLANDS__());
    CLIMATE_CFG = safeObj(__CLIMATE__());
    const climateBaselineRaw = safeObj(CLIMATE_CFG.baseline, EMPTY_CLIMATE_BASELINE);
    const climateRefineRaw = safeObj(CLIMATE_CFG.refine, EMPTY_CLIMATE_REFINE);
    const climateSwatches = safeObj(CLIMATE_CFG.swatches);
    const climateBaseline = Object.keys(climateBaselineRaw).length > 0 ? climateBaselineRaw : EMPTY_CLIMATE_BASELINE;
    const climateRefine = Object.keys(climateRefineRaw).length > 0 ? climateRefineRaw : EMPTY_CLIMATE_REFINE;
    MOUNTAINS_CFG = safeObj(__MOUNTAINS__());
    VOLCANOES_CFG = safeObj(__VOLCANOES__());
    BIOMES_CFG = safeObj(__BIOMES__());
    FEATURES_DENSITY_CFG = safeObj(__FEATURES_DENSITY__());
    CORRIDORS_CFG = safeObj(__CORRIDORS__());
    PLACEMENT_CFG = safeObj(__PLACEMENT__());
    DEV_LOG_CFG = safeObj(__DEV__());
    // 5) Foundation config (new unified world settings)
    FOUNDATION_CFG = safeObj(__FOUNDATION__());
    FOUNDATION_SEED = safeObj(__FOUNDATION_SEED__());
    FOUNDATION_PLATES = safeObj(__FOUNDATION_PLATES__());
    FOUNDATION_DYNAMICS = safeObj(__FOUNDATION_DYNAMICS__());
    const foundationDirResolved = safeObj(__FOUNDATION_DIR__());
    const foundationSurfaceRaw = safeObj(__FOUNDATION_SURFACE__());
    FOUNDATION_SURFACE = foundationSurfaceRaw;
    const foundationPolicyRaw = safeObj(__FOUNDATION_POLICY__());
    FOUNDATION_POLICY = foundationPolicyRaw;
    FOUNDATION_DIAGNOSTICS = safeObj(__FOUNDATION_DIAGNOSTICS__());
    const foundationDirectionalityFromDynamics = safeObj(FOUNDATION_DYNAMICS.directionality);
    FOUNDATION_DIRECTIONALITY =
        Object.keys(foundationDirectionalityFromDynamics).length > 0
            ? foundationDirectionalityFromDynamics
            : foundationDirResolved;
    const foundationSurfaceOcean = safeObj(foundationSurfaceRaw.oceanSeparation);
    const foundationPolicyOcean = safeObj(foundationPolicyRaw.oceanSeparation);
    const foundationOceanResolved = safeObj(__FOUNDATION_OSEPARATION__());
    FOUNDATION_OCEAN_SEPARATION =
        Object.keys(foundationSurfaceOcean).length > 0
            ? foundationSurfaceOcean
            : Object.keys(foundationPolicyOcean).length > 0
                ? foundationPolicyOcean
                : foundationOceanResolved;
    FOUNDATION = Object.freeze({
        core: FOUNDATION_CFG,
        seed: FOUNDATION_SEED,
        plates: FOUNDATION_PLATES,
        dynamics: FOUNDATION_DYNAMICS,
        surface: FOUNDATION_SURFACE,
        policy: FOUNDATION_POLICY,
        diagnostics: FOUNDATION_DIAGNOSTICS,
    });
    // Corridor sub-groups
    CORRIDOR_POLICY = safeObj(CORRIDORS_CFG.policy);
    CORRIDOR_KINDS = safeObj(CORRIDORS_CFG.kinds);
    // 7) Climate primitives (drivers + shared adjustments)
    const baselineDrivers = Object.freeze({
        bands: safeObj(climateBaseline.bands),
        blend: safeObj(climateBaseline.blend),
    });
    const refineDrivers = Object.freeze({
        waterGradient: safeObj(climateRefine.waterGradient),
        orographic: safeObj(climateRefine.orographic),
        riverCorridor: safeObj(climateRefine.riverCorridor),
        lowBasin: safeObj(climateRefine.lowBasin),
        pressure: safeObj(climateRefine.pressure),
    });
    const storyMoisture = Object.freeze({
        swatches: Object.keys(climateSwatches).length > 0 ? climateSwatches : safeObj(S.swatches),
        paleo: safeObj(S.paleo),
        rainfall: safeObj(M.rainfall),
        orogeny: safeObj(S.orogeny),
    });
    const baselineMoisture = Object.freeze({
        orographic: safeObj(climateBaseline.orographic),
        coastal: safeObj(climateBaseline.coastal),
        noise: safeObj(climateBaseline.noise),
        bands: baselineDrivers.bands,
        blend: baselineDrivers.blend,
    });
    const refineMoisture = Object.freeze({
        waterGradient: refineDrivers.waterGradient,
        orographic: refineDrivers.orographic,
        riverCorridor: refineDrivers.riverCorridor,
        lowBasin: refineDrivers.lowBasin,
        pressure: refineDrivers.pressure,
    });
    const microMoisture = Object.freeze({
        rainfall: safeObj(M.rainfall),
        features: safeObj(M.features),
    });
    CLIMATE = Object.freeze({
        drivers: Object.freeze({
            baseline: Object.freeze({
                ...baselineDrivers,
                orographic: baselineMoisture.orographic,
                coastal: baselineMoisture.coastal,
                noise: baselineMoisture.noise,
            }),
            refine: Object.freeze({
                ...refineDrivers,
            }),
        }),
        moistureAdjustments: Object.freeze({
            baseline: baselineMoisture,
            refine: refineMoisture,
            story: storyMoisture,
            micro: microMoisture,
        }),
    });
    CLIMATE_DRIVERS = CLIMATE.drivers;
    MOISTURE_ADJUSTMENTS = CLIMATE.moistureAdjustments;
}
/* -----------------------------------------------------------------------------
 * Helpers
 * -------------------------------------------------------------------------- */
/**
 * Normalize a resolver-provided manifest into a frozen snapshot with safe defaults.
 * @param {Readonly<StageManifest> | StageManifestSnapshot | null | undefined} manifest
 * @returns {StageManifestSnapshot}
 */
function coerceStageManifest(manifest) {
    if (!manifest || typeof manifest !== "object")
        return EMPTY_STAGE_MANIFEST;
    const rawOrder = Array.isArray(manifest.order) ? manifest.order : EMPTY_ARRAY;
    /** @type {Array<string>} */
    const order = [];
    for (const entry of rawOrder) {
        if (typeof entry === "string")
            order.push(entry);
    }
    const rawStages = manifest.stages && typeof manifest.stages === "object"
        ? /** @type {Record<string, any>} */ (manifest.stages)
        : {};
    /** @type {Partial<Record<string, StageDescriptor>>} */
    const normalizedStages = {};
    for (const name of Object.keys(rawStages)) {
        const descriptor = rawStages[name];
        if (!descriptor || typeof descriptor !== "object")
            continue;
        normalizedStages[name] = /** @type {StageDescriptor} */ (Object.isFrozen(descriptor)
            ? descriptor
            : Object.freeze({ ...descriptor }));
    }
    if (!order.length && !Object.keys(normalizedStages).length) {
        return EMPTY_STAGE_MANIFEST;
    }
    return /** @type {StageManifestSnapshot} */ (Object.freeze({
        order: /** @type {ReadonlyArray<string>} */ (Object.freeze(order)),
        stages: Object.freeze(normalizedStages),
    }));
}
/**
 * Build a lookup of legacy toggle keys derived from the stage manifest.
 * @param {StageManifestSnapshot} manifest
 * @returns {Record<string, boolean>}
 */
function deriveManifestToggleMap(manifest) {
    /** @type {Record<string, boolean>} */
    const out = {};
    if (!manifest || typeof manifest !== "object")
        return out;
    const stages = manifest?.stages
        ? /** @type {Partial<Record<string, StageDescriptor>>} */ (manifest.stages)
        : {};
    const order = manifest?.order && manifest.order.length > 0
        ? Array.from(manifest.order)
        : Object.keys(stages);
    for (const name of order) {
        const stage = stages && stages[name];
        if (!stage)
            continue;
        const toggles = Array.isArray(stage.legacyToggles) ? stage.legacyToggles : [];
        for (const key of toggles) {
            if (typeof key !== "string")
                continue;
            out[key] = stage.enabled !== false;
        }
    }
    for (const name of Object.keys(stages)) {
        const stage = stages[name];
        if (!stage)
            continue;
        const toggles = Array.isArray(stage.legacyToggles) ? stage.legacyToggles : [];
        for (const key of toggles) {
            if (typeof key !== "string" || Object.prototype.hasOwnProperty.call(out, key))
                continue;
            out[key] = stage.enabled !== false;
        }
    }
    return out;
}
/**
 * Ensure we always return a frozen object of the expected shape for TS consumers.
 * Falls back to an empty frozen object when input is null/undefined or not an object.
 * @template {object | ReadonlyArray<any>} T
 * @param {T | null | undefined} value
 * @param {Readonly<T>} [fallback]
 * @returns {Readonly<T>}
 */
function safeObj(value, fallback) {
    if (!value || typeof value !== "object") {
        if (fallback)
            return fallback;
        return /** @type {Readonly<T>} */ (EMPTY_OBJECT);
    }
    if (Object.isFrozen(value))
        return /** @type {Readonly<T>} */ (value);
    if (Array.isArray(value)) {
        const clone = value.slice();
        return /** @type {Readonly<T>} */ (/** @type {unknown} */ (Object.freeze(clone)));
    }
    return /** @type {Readonly<T>} */ (Object.freeze({ ...value }));
}
/* -----------------------------------------------------------------------------
 * Module-load bootstrap
 * -------------------------------------------------------------------------- */
// Perform an initial bind so imports have sane values even if callers forget to rebind().
// Callers should still rebind() at the start of each GenerateMap to ensure the
// snapshot reflects the active entrys presets and overrides.
try {
    rebind();
}
catch {
    // Keep imports resilient even if resolution fails very early in a cold VM.
    // Bindings already hold conservative defaults above.
}
export default {
    rebind,
    // expose current group snapshots (optional convenience mirror)
    get LANDMASS() {
        return LANDMASS_CFG;
    },
    get CORRIDORS() {
        return CORRIDORS_CFG;
    },
    get FOUNDATION() {
        return FOUNDATION;
    },
    get CLIMATE() {
        return CLIMATE;
    },
};
</file>

<file path="mod/maps/core/adapters.js">
/**
 * Engine Adapter  CivEngineAdapter
 *
 * Purpose:
 * - CivEngineAdapter: production adapter using Civ7 engine APIs (GameplayMap, TerrainBuilder, etc.)
 *
 * All passes should interact with the map ONLY via this adapter, never directly.
 */

import { idx } from "./types.js";

/**
 * CivEngineAdapter  production implementation using Civ7 engine APIs
 *
 * Wraps all GameplayMap, TerrainBuilder, FeatureTypes, and other engine calls.
 * This is the adapter used during actual map generation in the game.
 *
 * @implements {import('./types.js').EngineAdapter}
 */
export class CivEngineAdapter {
  /**
   * @param {number} width
   * @param {number} height
   */
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  // ==================== TERRAIN READS ====================

  /**
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isWater(x, y) {
    return GameplayMap.isWater(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isMountain(x, y) {
    if (typeof GameplayMap.isMountain === "function") {
      return GameplayMap.isMountain(x, y);
    }
    // Fallback: check elevation >= 500
    return GameplayMap.getElevation(x, y) >= 500;
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} radius
   * @returns {boolean}
   */
  isAdjacentToRivers(x, y, radius) {
    return GameplayMap.isAdjacentToRivers(x, y, radius);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getElevation(x, y) {
    return GameplayMap.getElevation(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getTerrainType(x, y) {
    return GameplayMap.getTerrainType(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getRainfall(x, y) {
    return GameplayMap.getRainfall(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getTemperature(x, y) {
    return GameplayMap.getTemperature(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getLatitude(x, y) {
    return GameplayMap.getPlotLatitude(x, y);
  }

  // ==================== TERRAIN WRITES ====================

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} terrainTypeId
   */
  setTerrainType(x, y, terrainTypeId) {
    TerrainBuilder.setTerrainType(x, y, terrainTypeId);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} rainfall
   */
  setRainfall(x, y, rainfall) {
    TerrainBuilder.setRainfall(x, y, rainfall);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} elevation
   */
  setElevation(x, y, elevation) {
    // Note: Engine may not expose direct elevation setter; use with caution
    if (typeof TerrainBuilder.setElevation === "function") {
      TerrainBuilder.setElevation(x, y, elevation);
    }
  }

  // ==================== FEATURE READS/WRITES ====================

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getFeatureType(x, y) {
    return GameplayMap.getFeatureType(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {{Feature: number, Direction: number, Elevation: number}} featureData
   */
  setFeatureType(x, y, featureData) {
    TerrainBuilder.setFeatureType(x, y, featureData);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} featureTypeId
   * @returns {boolean}
   */
  canHaveFeature(x, y, featureTypeId) {
    return TerrainBuilder.canHaveFeature(x, y, featureTypeId);
  }

  // ==================== RANDOM NUMBER GENERATION ====================

  /**
   * @param {number} max
   * @param {string} label
   * @returns {number}
   */
  getRandomNumber(max, label) {
    return TerrainBuilder.getRandomNumber(max, label);
  }

  // ==================== UTILITIES ====================

  validateAndFixTerrain() {
    TerrainBuilder.validateAndFixTerrain();
  }

  recalculateAreas() {
    AreaBuilder.recalculateAreas();
  }

  /**
   * @param {number} fractalId
   * @param {number} width
   * @param {number} height
   * @param {number} grain
   * @param {number} flags
   */
  createFractal(fractalId, width, height, grain, flags) {
    FractalBuilder.create(fractalId, width, height, grain, flags);
  }

  /**
   * @param {number} fractalId
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getFractalHeight(fractalId, x, y) {
    return FractalBuilder.getHeight(fractalId, x, y);
  }

  // ==================== BIOME/CONTINENTS ====================

  stampContinents() {
    TerrainBuilder.stampContinents();
  }

  buildElevation() {
    TerrainBuilder.buildElevation();
  }

  /**
   * @param {number} minLength
   * @param {number} maxLength
   * @param {number} navigableTerrain
   */
  modelRivers(minLength, maxLength, navigableTerrain) {
    TerrainBuilder.modelRivers(minLength, maxLength, navigableTerrain);
  }

  defineNamedRivers() {
    TerrainBuilder.defineNamedRivers();
  }

  storeWaterData() {
    TerrainBuilder.storeWaterData();
  }
}
</file>

<file path="mod/maps/core/plot_tags.js">
import * as globals from "/base-standard/maps/map-globals.js";

/**
 * Maintain plot tagging (land/water + east/west) independently of Civ7 updates.
 * The base-standard map-utilities no longer ships addPlotTags, so we keep a stable copy here.
 *
 * @param {number} iHeight
 * @param {number} iWidth
 * @param {number} iEastContinentLeftCol - column separating west/east landmasses
 */
export function addPlotTags(iHeight, iWidth, iEastContinentLeftCol) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      const terrain = GameplayMap.getTerrainType(iX, iY);
      const isLand = terrain != globals.g_OceanTerrain && terrain != globals.g_CoastTerrain;
      if (isLand) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_LANDMASS);
        if (iX >= iEastContinentLeftCol) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_LANDMASS);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_LANDMASS);
        }
      } else {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iX >= iEastContinentLeftCol - 1) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
        }
      }
    }
  }
}
</file>

<file path="mod/maps/core/types.js">
/**
 * Core Types  MapContext, EngineAdapter, and data contracts
 *
 * Purpose:
 * - Define the seam between pure logic and engine coupling
 * - MapContext holds all data dependencies for passes (fields, worldModel, rng, config)
 * - EngineAdapter abstracts read/write operations (enables testing, replay, diffing)
 *
 * Invariants:
 * - Passes should ONLY access engine APIs via the adapter
 * - RNG calls should go through ctx.rng() for deterministic replay
 * - Context is immutable reference (but fields are mutable for performance)
 */

/**
 * @typedef {Object} MapDimensions
 * @property {number} width - Map width in tiles
 * @property {number} height - Map height in tiles
 */

/**
 * @typedef {Object} MapFields
 * @property {Uint8Array|null} rainfall - Rainfall per tile (0..200)
 * @property {Int16Array|null} elevation - Elevation per tile
 * @property {Uint8Array|null} temperature - Temperature per tile (0..255)
 * @property {Uint8Array|null} biomeId - Biome type ID per tile
 * @property {Int16Array|null} featureType - Feature type ID per tile
 * @property {Uint8Array|null} terrainType - Terrain type ID per tile
 */

/**
 * Primary morphology staging buffer.
 *
 * These arrays capture the heightfield (terrain + elevation) before it is
 * flushed back to the engine so plates/coastlines/mountains operate on a
 * consistent in-memory surface.
 *
 * @typedef {Object} HeightfieldBuffer
 * @property {Int16Array} elevation - Elevation values staged for morphology
 * @property {Uint8Array} terrain - Terrain type IDs staged for morphology
 * @property {Uint8Array} landMask - Binary land/water mask derived from the heightfield (1 = land)
 */

/**
 * Staged climate buffer for rainfall and humidity fields. Mirrors the heightfield
 * staging approach so climate passes can operate without mutating GameplayMap
 * directly.
 *
 * @typedef {Object} ClimateFieldBuffer
 * @property {Uint8Array} rainfall - Rainfall values staged for climate passes (0..200)
 * @property {Uint8Array} humidity - Relative humidity or derived moisture metrics (0..255)
 */

/**
 * Collection of reusable buffers shared across generation stages.
 * Additional staging arrays (shore masks, coast metrics, etc.) can be added in
 * later phases.
 *
 * @typedef {Object} MapBuffers
 * @property {HeightfieldBuffer} heightfield - Canonical heightfield staging buffers
 * @property {ClimateFieldBuffer} climate - Staged rainfall/humidity buffers for climate + narrative
 * @property {Map<string, Uint8Array>} scratchMasks - Named scratch masks reused across stages
 */

/**
 * Immutable snapshot describing a sparse narrative overlay.
 * Overlays capture derived storytelling metadata (margins, corridors, etc.)
 * produced during generation so downstream stages can consume consistent
 * products without rerunning expensive passes.
 *
 * @typedef {Object} StoryOverlaySnapshot
 * @property {string} key - Overlay registry key (e.g., "margins")
 * @property {string} kind - Overlay kind identifier
 * @property {number} version - Schema version for the overlay payload
 * @property {number} width - Map width in tiles
 * @property {number} height - Map height in tiles
 * @property {ReadonlyArray<string>} [active] - Active tile identifiers ("x,y" form) when applicable
 * @property {ReadonlyArray<string>} [passive] - Passive tile identifiers ("x,y" form) when applicable
 * @property {Readonly<Record<string, any>>} summary - Overlay summary metadata (counts, thresholds, etc.)
 */

/**
 * Registry of immutable story overlays published during generation.
 * Keys map to overlay snapshots (see StoryOverlaySnapshot).
 *
 * @typedef {Map<string, StoryOverlaySnapshot>} StoryOverlayRegistry
 */

/**
 * Snapshot of the configuration objects that informed the current foundation run.
 * Mirrors come from the resolved tunables so downstream consumers can reason
 * about the knobs that produced the published tensors.
 *
 * @typedef {Object} FoundationConfigSnapshot
 * @property {Readonly<any>} seed
 * @property {Readonly<any>} plates
 * @property {Readonly<any>} dynamics
 * @property {Readonly<any>} surface
 * @property {Readonly<any>} policy
 * @property {Readonly<any>} diagnostics
 */

/**
 * Plate-centric tensors emitted by the WorldModel. All arrays share the map
 * dimensions (width  height) and are treated as read-only snapshots.
 *
 * @typedef {Object} FoundationPlateFields
 * @property {Int16Array} id
 * @property {Uint8Array} boundaryCloseness
 * @property {Uint8Array} boundaryType
 * @property {Uint8Array} tectonicStress
 * @property {Uint8Array} upliftPotential
 * @property {Uint8Array} riftPotential
 * @property {Uint8Array} shieldStability
 * @property {Int8Array} movementU
 * @property {Int8Array} movementV
 * @property {Int8Array} rotation
 */

/**
 * Atmospheric and oceanic tensors emitted by the WorldModel.
 *
 * @typedef {Object} FoundationDynamicsFields
 * @property {Int8Array} windU
 * @property {Int8Array} windV
 * @property {Int8Array} currentU
 * @property {Int8Array} currentV
 * @property {Uint8Array} pressure
 */

/**
 * Diagnostics payload accompanying the foundation tensors.
 *
 * @typedef {Object} FoundationDiagnosticsFields
 * @property {any|null} boundaryTree
 */

/**
 * Immutable data product emitted by the foundation stage.
 * Downstream stages rely on this object instead of touching WorldModel directly.
 *
 * @typedef {Object} FoundationContext
 * @property {{ width: number, height: number, size: number }} dimensions
 * @property {Readonly<any>|null} plateSeed
 * @property {FoundationPlateFields} plates
 * @property {FoundationDynamicsFields} dynamics
 * @property {FoundationDiagnosticsFields} diagnostics
 * @property {FoundationConfigSnapshot} config
 */

const EMPTY_FROZEN_OBJECT = Object.freeze({});

/**
 * @typedef {Object} RNGState
 * @property {Map<string, number>} callCounts - Tracks RNG calls per label for determinism
 * @property {number|null} seed - Optional seed for replay
 */

/**
 * @typedef {Object} GenerationMetrics
 * @property {Map<string, number>} timings - Pass execution times (ms)
 * @property {Map<string, any>} histograms - Field histograms for validation
 * @property {Array<string>} warnings - Validation warnings
 */

/**
 * MapContext  unified data container passed through the generation pipeline
 *
 * All passes receive a MapContext and may:
 * - Read fields (rainfall, elevation, worldModel data)
 * - Write fields (via adapter)
 * - Call rng() for deterministic randomness
 * - Log metrics
 *
 * @typedef {Object} MapContext
 * @property {MapDimensions} dimensions - Map size
 * @property {MapFields} fields - Typed arrays for terrain data
 * @property {import('../world/model.js').WorldModel|null} worldModel - Physics/tectonics model (attached after init)
 * @property {RNGState} rng - RNG state tracker
 * @property {any} config - Resolved configuration object
 * @property {GenerationMetrics} metrics - Performance and validation metrics
 * @property {EngineAdapter} adapter - Abstraction layer for engine operations
 * @property {FoundationContext|null} foundation - Shared world foundations (immutable data product)
 * @property {MapBuffers} buffers - Shared staging buffers
 * @property {StoryOverlayRegistry} overlays - Published story overlays keyed by overlay id
 */

/**
 * EngineAdapter  abstraction for all engine/surface interactions
 *
 * All terrain/feature reads and writes MUST go through this interface.
 * Two implementations:
 * - CivEngineAdapter: uses GameplayMap, TerrainBuilder, etc. (production)
 *
 * @interface
 * @typedef {Object} EngineAdapter
 *
 * === TERRAIN READS ===
 * @property {(x: number, y: number) => boolean} isWater - Check if tile is water
 * @property {(x: number, y: number) => boolean} isMountain - Check if tile is mountain
 * @property {(x: number, y: number, radius: number) => boolean} isAdjacentToRivers - Check if tile is near rivers
 * @property {(x: number, y: number) => number} getElevation - Get tile elevation
 * @property {(x: number, y: number) => number} getTerrainType - Get terrain type ID
 * @property {(x: number, y: number) => number} getRainfall - Get rainfall (0..200)
 * @property {(x: number, y: number) => number} getTemperature - Get temperature
 * @property {(x: number, y: number) => number} getLatitude - Get latitude in degrees
 *
 * === TERRAIN WRITES ===
 * @property {(x: number, y: number, terrainTypeId: number) => void} setTerrainType - Set terrain type
 * @property {(x: number, y: number, rainfall: number) => void} setRainfall - Set rainfall (0..200)
 * @property {(x: number, y: number, elevation: number) => void} setElevation - Set elevation
 *
 * === FEATURE READS/WRITES ===
 * @property {(x: number, y: number) => number} getFeatureType - Get feature type ID
 * @property {(x: number, y: number, featureData: {Feature: number, Direction: number, Elevation: number}) => void} setFeatureType - Set feature
 * @property {(x: number, y: number, featureTypeId: number) => boolean} canHaveFeature - Validate feature placement
 *
 * === RANDOM NUMBER GENERATION ===
 * @property {(max: number, label: string) => number} getRandomNumber - Seeded RNG (0..max-1)
 *
 * === UTILITIES ===
 * @property {() => void} validateAndFixTerrain - Run engine validation pass
 * @property {() => void} recalculateAreas - Rebuild continent/area data
 * @property {(fractalId: number, width: number, height: number, grain: number, flags: number) => void} createFractal - Initialize fractal
 * @property {(fractalId: number, x: number, y: number) => number} getFractalHeight - Sample fractal value
 */

/**
 * Create a new MapContext with default/empty fields.
 *
 * @param {MapDimensions} dimensions
 * @param {EngineAdapter} adapter
 * @param {any} config
 * @returns {MapContext}
 */
export function createMapContext(dimensions, adapter, config) {
  const { width, height } = dimensions;
  const size = width * height;

  const heightfield = {
    elevation: new Int16Array(size),
    terrain: new Uint8Array(size),
    landMask: new Uint8Array(size),
  };

  const rainfall = new Uint8Array(size);
  const climate = {
    rainfall,
    humidity: new Uint8Array(size),
  };

  return {
    dimensions,
    fields: {
      rainfall,
      elevation: new Int16Array(size),
      temperature: new Uint8Array(size),
      biomeId: new Uint8Array(size),
      featureType: new Int16Array(size),
      terrainType: new Uint8Array(size),
    },
    worldModel: null, // Initialized later if enabled
    rng: {
      callCounts: new Map(),
      seed: null,
    },
    config,
    metrics: {
      timings: new Map(),
      histograms: new Map(),
      warnings: [],
    },
    adapter,
    foundation: null,
    buffers: {
      heightfield,
      climate,
      scratchMasks: new Map(),
    },
    overlays: new Map(),
  };
}

/**
 * Deterministic RNG helper for MapContext.
 * Tracks call counts per label for debugging and replay.
 *
 * @param {MapContext} ctx
 * @param {string} label - Unique label for this RNG call site
 * @param {number} max - Return value in [0, max)
 * @returns {number}
 */
export function ctxRandom(ctx, label, max) {
  const count = ctx.rng.callCounts.get(label) || 0;
  ctx.rng.callCounts.set(label, count + 1);

  // Delegate to adapter (which may use seed or engine RNG)
  return ctx.adapter.getRandomNumber(max, `${label}_${count}`);
}

/**
 * Utility: Get linear index from (x, y) coordinates.
 *
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @returns {number}
 */
export function idx(x, y, width) {
  return y * width + x;
}

/**
 * Utility: Check if coordinates are in bounds.
 *
 * @param {number} x
 * @param {number} y
 * @param {MapDimensions} dimensions
 * @returns {boolean}
 */
export function inBounds(x, y, dimensions) {
  return x >= 0 && x < dimensions.width && y >= 0 && y < dimensions.height;
}

/**
 * Write staged heightfield values (terrain/elevation/landMask) and mirror the
 * change to the engine adapter when provided.
 *
 * @param {MapContext} ctx
 * @param {number} x
 * @param {number} y
 * @param {{ terrain?: number, elevation?: number, isLand?: boolean }} options
 */
export function writeHeightfield(ctx, x, y, options) {
  if (!ctx || !options) return;
  const { width } = ctx.dimensions;
  const idxValue = y * width + x;
  const hf = ctx.buffers?.heightfield;

  if (hf) {
    if (typeof options.terrain === "number") {
      hf.terrain[idxValue] = options.terrain & 0xff;
    }
    if (typeof options.elevation === "number") {
      hf.elevation[idxValue] = options.elevation | 0;
    }
    if (typeof options.isLand === "boolean") {
      hf.landMask[idxValue] = options.isLand ? 1 : 0;
    }
  }

  if (typeof options.terrain === "number" && ctx.adapter?.setTerrainType) {
    ctx.adapter.setTerrainType(x, y, options.terrain);
  }

  if (typeof options.elevation === "number" && ctx.adapter?.setElevation) {
    ctx.adapter.setElevation(x, y, options.elevation);
  }
}

/**
 * Write staged climate values (rainfall/humidity) and mirror the
 * change to the engine adapter when provided.
 *
 * @param {MapContext} ctx
 * @param {number} x
 * @param {number} y
 * @param {{ rainfall?: number, humidity?: number }} options
 */
export function writeClimateField(ctx, x, y, options) {
  if (!ctx || !options) return;
  const { width } = ctx.dimensions;
  const idxValue = y * width + x;
  const climate = ctx.buffers?.climate;

  if (climate) {
    if (typeof options.rainfall === "number") {
      const rf = Math.max(0, Math.min(200, options.rainfall)) | 0;
      climate.rainfall[idxValue] = rf & 0xff;
      if (ctx.fields?.rainfall) {
        ctx.fields.rainfall[idxValue] = rf & 0xff;
      }
    }
    if (typeof options.humidity === "number") {
      const hum = Math.max(0, Math.min(255, options.humidity)) | 0;
      climate.humidity[idxValue] = hum & 0xff;
    }
  }

  if (typeof options.rainfall === "number" && ctx.adapter?.setRainfall) {
    ctx.adapter.setRainfall(x, y, Math.max(0, Math.min(200, options.rainfall)) | 0);
  }
}

function freezeConfigSnapshot(value) {
  if (!value || typeof value !== "object") return EMPTY_FROZEN_OBJECT;
  try {
    return Object.freeze(value);
  } catch {
    return value;
  }
}

function ensureTensor(name, tensor, size) {
  if (!tensor || typeof tensor.length !== "number") {
    throw new Error(`[FoundationContext] Missing ${name} tensor.`);
  }
  if (tensor.length !== size) {
    throw new Error(
      `[FoundationContext] ${name} tensor length mismatch (expected ${size}, received ${tensor.length}).`
    );
  }
  return tensor;
}

/**
 * Create an immutable FoundationContext snapshot from the active WorldModel.
 *
 * @param {import('../world/model.js').WorldModel} worldModel
 * @param {{ dimensions: MapDimensions, config?: Partial<FoundationConfigSnapshot> }} options
 * @returns {FoundationContext}
 */
export function createFoundationContext(worldModel, options) {
  if (!worldModel || typeof worldModel.isEnabled !== "function" || !worldModel.isEnabled()) {
    throw new Error("[FoundationContext] WorldModel is not initialized or disabled.");
  }
  if (!options || !options.dimensions) {
    throw new Error("[FoundationContext] Map dimensions are required to build the context.");
  }
  const width = options.dimensions.width | 0;
  const height = options.dimensions.height | 0;
  const size = Math.max(0, width * height) | 0;
  if (size <= 0) {
    throw new Error("[FoundationContext] Invalid map dimensions.");
  }

  const plateId = ensureTensor("plateId", worldModel.plateId, size);
  const boundaryCloseness = ensureTensor("boundaryCloseness", worldModel.boundaryCloseness, size);
  const boundaryType = ensureTensor("boundaryType", worldModel.boundaryType, size);
  const tectonicStress = ensureTensor("tectonicStress", worldModel.tectonicStress, size);
  const upliftPotential = ensureTensor("upliftPotential", worldModel.upliftPotential, size);
  const riftPotential = ensureTensor("riftPotential", worldModel.riftPotential, size);
  const shieldStability = ensureTensor("shieldStability", worldModel.shieldStability, size);
  const plateMovementU = ensureTensor("plateMovementU", worldModel.plateMovementU, size);
  const plateMovementV = ensureTensor("plateMovementV", worldModel.plateMovementV, size);
  const plateRotation = ensureTensor("plateRotation", worldModel.plateRotation, size);
  const windU = ensureTensor("windU", worldModel.windU, size);
  const windV = ensureTensor("windV", worldModel.windV, size);
  const currentU = ensureTensor("currentU", worldModel.currentU, size);
  const currentV = ensureTensor("currentV", worldModel.currentV, size);
  const pressure = ensureTensor("pressure", worldModel.pressure, size);

  const configInput = options.config || {};
  const configSnapshot = {
    seed: freezeConfigSnapshot(configInput.seed),
    plates: freezeConfigSnapshot(configInput.plates),
    dynamics: freezeConfigSnapshot(configInput.dynamics),
    surface: freezeConfigSnapshot(configInput.surface),
    policy: freezeConfigSnapshot(configInput.policy),
    diagnostics: freezeConfigSnapshot(configInput.diagnostics),
  };

  return Object.freeze({
    dimensions: Object.freeze({ width, height, size }),
    plateSeed: worldModel.plateSeed || null,
    plates: Object.freeze({
      id: plateId,
      boundaryCloseness,
      boundaryType,
      tectonicStress,
      upliftPotential,
      riftPotential,
      shieldStability,
      movementU: plateMovementU,
      movementV: plateMovementV,
      rotation: plateRotation,
    }),
    dynamics: Object.freeze({ windU, windV, currentU, currentV, pressure }),
    diagnostics: Object.freeze({ boundaryTree: worldModel.boundaryTree || null }),
    config: Object.freeze(configSnapshot),
  });
}

/**
 * Check whether the provided MapContext already carries a FoundationContext.
 *
 * @param {MapContext} ctx
 * @returns {ctx is MapContext & { foundation: FoundationContext }}
 */
export function hasFoundationContext(ctx) {
  return !!(ctx && ctx.foundation && typeof ctx.foundation === "object");
}

/**
 * Assert that a FoundationContext exists on the provided MapContext.
 * Throws when absent so stages fail loudly instead of running with stale data.
 *
 * @param {MapContext} ctx
 * @param {string} [stage]
 * @returns {FoundationContext}
 */
export function assertFoundationContext(ctx, stage) {
  if (hasFoundationContext(ctx)) {
    return /** @type {FoundationContext} */ (ctx.foundation);
  }
  const message = stage
    ? `[StageManifest] Stage "${stage}" requires FoundationContext but it is unavailable.`
    : "[StageManifest] Required FoundationContext is unavailable.";
  console.error(message);
  throw new Error(message);
}

/**
 * Convenience helper to fill an entire buffer with a value (used for resets).
 *
 * @param {TypedArray} buffer
 * @param {number} value
 */
export function fillBuffer(buffer, value) {
  if (!buffer || typeof buffer.fill !== "function") return;
  buffer.fill(value);
}

/**
 * Synchronize the staged heightfield buffers from the current engine surface.
 * Useful after invoking legacy generators (lakes, rivers) that mutate the
 * gameplay surface directly.
 *
 * @param {MapContext} ctx
 */
export function syncHeightfield(ctx) {
  if (!ctx || !ctx.adapter) return;
  const hf = ctx.buffers?.heightfield;
  if (!hf) return;
  const { width, height } = ctx.dimensions;
  const hasElevation = typeof ctx.adapter.getElevation === "function";
  const hasWaterCheck = typeof ctx.adapter.isWater === "function";
  const hasTerrainGetter = typeof ctx.adapter.getTerrainType === "function";

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idxValue = y * width + x;
      if (hasTerrainGetter) {
        const terrain = ctx.adapter.getTerrainType(x, y);
        if (terrain != null) {
          hf.terrain[idxValue] = terrain & 0xff;
        }
      }
      if (hasElevation) {
        const elevation = ctx.adapter.getElevation(x, y);
        if (Number.isFinite(elevation)) {
          hf.elevation[idxValue] = elevation | 0;
        }
      }
      if (hasWaterCheck) {
        hf.landMask[idxValue] = ctx.adapter.isWater(x, y) ? 0 : 1;
      }
    }
  }
}

/**
 * Synchronize the staged climate buffers from the current engine surface.
 * Useful after invoking legacy generators (rivers, swatches) that mutate the
 * gameplay surface directly.
 *
 * @param {MapContext} ctx
 */
export function syncClimateField(ctx) {
  if (!ctx || !ctx.adapter) return;
  const climate = ctx.buffers?.climate;
  if (!climate) return;
  const { width, height } = ctx.dimensions;
  const hasRainfall = typeof ctx.adapter.getRainfall === "function";

  if (!hasRainfall) return;

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idxValue = y * width + x;
      const rf = ctx.adapter.getRainfall(x, y);
      if (Number.isFinite(rf)) {
        const rfClamped = Math.max(0, Math.min(200, rf)) | 0;
        climate.rainfall[idxValue] = rfClamped & 0xff;
        if (ctx.fields?.rainfall) {
          ctx.fields.rainfall[idxValue] = rfClamped & 0xff;
        }
      }
    }
  }
}

export default {
  createMapContext,
  ctxRandom,
  idx,
  inBounds,
  writeHeightfield,
  writeClimateField,
  createFoundationContext,
  hasFoundationContext,
  assertFoundationContext,
  fillBuffer,
  syncHeightfield,
  syncClimateField,
};
</file>

<file path="mod/maps/core/utils.js">
// @ts-nocheck
/**
 * Core utilities for the Epic Diverse Huge map generator.
 * These helpers centralize common operations so layers can share consistent logic.
 *
 * Exports:
 *  - clamp(v, min, max)
 *  - inBounds(x, y)
 *  - storyKey(x, y)
 *  - isAdjacentToLand(x, y, radius)
 *  - getFeatureTypeIndex(name)
 */
/**
 * Clamp a number between min and max (inclusive).
 * @param {number} v
 * @param {number} [min=0]
 * @param {number} [max=200]
 * @returns {number}
 */
export function clamp(v, min = 0, max = 200) {
    if (v < min)
        return min;
    if (v > max)
        return max;
    return v;
}
/**
 * Check if coordinates are within the current map bounds.
 * @param {number} x
 * @param {number} y
 * @returns {boolean}
 */
export function inBounds(x, y) {
    // GameplayMap is provided by the game engine at runtime.
    const width = GameplayMap && typeof GameplayMap.getGridWidth === "function" ? GameplayMap.getGridWidth() : 0;
    const height = GameplayMap && typeof GameplayMap.getGridHeight === "function" ? GameplayMap.getGridHeight() : 0;
    return x >= 0 && x < width && y >= 0 && y < height;
}
/**
 * Produce a stable string key for a tile coordinate.
 * @param {number} x
 * @param {number} y
 * @returns {string}
 */
export function storyKey(x, y) {
    return `${x},${y}`;
}
/**
 * Determine whether any tile within a Chebyshev radius of (x, y) is land.
 * Radius of 1 checks 8-neighborhood; larger radii expand the search square.
 * @param {number} x
 * @param {number} y
 * @param {number} [radius=1]
 * @returns {boolean}
 */
export function isAdjacentToLand(x, y, radius = 1) {
    if (radius <= 0)
        return false;
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            if (dx === 0 && dy === 0)
                continue;
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                if (!GameplayMap.isWater(nx, ny)) {
                    return true;
                }
            }
        }
    }
    return false;
}
/**
 * Resolve a feature type index from its ruleset name using engine lookups.
 * Returns -1 if the feature is not found (caller should then skip placement).
 * @param {string} name
 * @returns {number}
 */
export function getFeatureTypeIndex(name) {
    if (!name || !GameInfo || !GameInfo.Features || typeof GameInfo.Features.lookup !== "function") {
        return -1;
    }
    const def = GameInfo.Features.lookup(name);
    if (def && typeof def.$index === "number") {
        return def.$index;
    }
    return -1;
}
</file>

<file path="mod/maps/layers/biomes.js">
// @ts-nocheck
/**
 * Biomes Layer  designateEnhancedBiomes
 *
 * Purpose
 * - Start with base-standard biome assignment, then apply light, climate-aware
 *   nudges for playability and realism.
 * - Includes a narrow preference along rift shoulders to suggest fertile
 *   corridor edges without overriding vanilla eligibility rules.
 *
 * Behavior
 * - Base biomes: delegated to engine (vanilla-compatible).
 * - Tundra restraint: only at very high latitude or extreme elevation when dry.
 * - Tropical encouragement: wet, warm coasts near the equator.
 * - River-valley playability: temperate/warm river-adjacent tiles trend grassland.
 * - Rift shoulder bias: temperate/warm shoulder tiles prefer grassland when moist.
 *
 * Invariants
 * - Does not bypass engine constraints beyond setting biome types.
 * - Keeps adjustments modest; does not interfere with feature validation rules.
 * - O(width  height) with simple local checks.
 */
import { designateBiomes as baseDesignateBiomes } from "/base-standard/maps/feature-biome-generator.js";
import * as globals from "/base-standard/maps/map-globals.js";
import { StoryTags } from "../story/tags.js";
import { STORY_ENABLE_RIFTS, BIOMES_CFG, CORRIDOR_POLICY, } from "../bootstrap/tunables.js";
/**
 * Enhanced biome designation with gentle, readable nudges.
 * @param {number} iWidth
 * @param {number} iHeight
 */
export function designateEnhancedBiomes(iWidth, iHeight) {
    console.log("Creating enhanced biome diversity (climate-aware)...");
    // Start with vanilla-consistent biomes
    baseDesignateBiomes(iWidth, iHeight);
    // Apply small, climate-aware preferences
    const _bcfg = BIOMES_CFG || {};
    const _tundra = _bcfg.tundra || {};
    const TUNDRA_LAT_MIN = Number.isFinite(_tundra.latMin)
        ? _tundra.latMin
        : 70;
    const TUNDRA_ELEV_MIN = Number.isFinite(_tundra.elevMin)
        ? _tundra.elevMin
        : 850;
    const TUNDRA_RAIN_MAX = Number.isFinite(_tundra.rainMax)
        ? _tundra.rainMax
        : 90;
    const _tcoast = _bcfg.tropicalCoast || {};
    const TCOAST_LAT_MAX = Number.isFinite(_tcoast.latMax)
        ? _tcoast.latMax
        : 18;
    const TCOAST_RAIN_MIN = Number.isFinite(_tcoast.rainMin)
        ? _tcoast.rainMin
        : 105;
    const _rv = _bcfg.riverValleyGrassland || {};
    const RV_LAT_MAX = Number.isFinite(_rv.latMax) ? _rv.latMax : 50;
    const RV_RAIN_MIN = Number.isFinite(_rv.rainMin) ? _rv.rainMin : 75;
    const _rs = _bcfg.riftShoulder || {};
    const RS_GRASS_LAT_MAX = Number.isFinite(_rs.grasslandLatMax)
        ? _rs.grasslandLatMax
        : 50;
    const RS_GRASS_RAIN_MIN = Number.isFinite(_rs.grasslandRainMin)
        ? _rs.grasslandRainMin
        : 75;
    const RS_TROP_LAT_MAX = Number.isFinite(_rs.tropicalLatMax)
        ? _rs.tropicalLatMax
        : 18;
    const RS_TROP_RAIN_MIN = Number.isFinite(_rs.tropicalRainMin)
        ? _rs.tropicalRainMin
        : 100;
    const LAND_BIAS_STRENGTH = Math.max(0, Math.min(1, CORRIDOR_POLICY?.land?.biomesBiasStrength ?? 0.6));
    const RIVER_BIAS_STRENGTH = Math.max(0, Math.min(1, CORRIDOR_POLICY?.river?.biomesBiasStrength ?? 0.5));
    for (let y = 0; y < iHeight; y++) {
        for (let x = 0; x < iWidth; x++) {
            if (GameplayMap.isWater(x, y))
                continue;
            const lat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            const elevation = GameplayMap.getElevation(x, y);
            const rainfall = GameplayMap.getRainfall(x, y);
            // Tundra restraint: require very high lat or extreme elevation and dryness
            if ((lat > TUNDRA_LAT_MIN || elevation > TUNDRA_ELEV_MIN) &&
                rainfall < TUNDRA_RAIN_MAX) {
                TerrainBuilder.setBiomeType(x, y, globals.g_TundraBiome);
                continue; // lock this decision; skip other nudges
            }
            // Wet, warm coasts near the equator tend tropical
            if (lat < TCOAST_LAT_MAX &&
                GameplayMap.isCoastalLand(x, y) &&
                rainfall > TCOAST_RAIN_MIN) {
                TerrainBuilder.setBiomeType(x, y, globals.g_TropicalBiome);
            }
            // Temperate/warm river valleys prefer grassland for playability
            if (GameplayMap.isAdjacentToRivers(x, y, 1) &&
                rainfall > RV_RAIN_MIN &&
                lat < RV_LAT_MAX) {
                TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
            }
            // Strategic Corridors: land-open corridor tiles gently bias to grassland (policy-scaled)
            if (StoryTags.corridorLandOpen &&
                StoryTags.corridorLandOpen.has(`${x},${y}`)) {
                if (rainfall > 80 &&
                    lat < 55 &&
                    TerrainBuilder.getRandomNumber(100, "Corridor Land-Open Biome") < Math.round(LAND_BIAS_STRENGTH * 100)) {
                    TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
                }
            }
            // Strategic Corridors: river-chain tiles gently bias to grassland (policy-scaled)
            if (StoryTags.corridorRiverChain &&
                StoryTags.corridorRiverChain.has(`${x},${y}`)) {
                if (rainfall > 75 &&
                    lat < 55 &&
                    TerrainBuilder.getRandomNumber(100, "Corridor River-Chain Biome") < Math.round(RIVER_BIAS_STRENGTH * 100)) {
                    TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
                }
            }
            // Edge hints near land/river corridors: light vegetation/mountain rim cues (biome-only)
            // Applies to tiles adjacent to a land-open or river-chain corridor, not the corridor tile itself
            {
                if (!(StoryTags.corridorLandOpen?.has?.(`${x},${y}`) ||
                    StoryTags.corridorRiverChain?.has?.(`${x},${y}`))) {
                    let edgeAttr = null;
                    for (let ddy = -1; ddy <= 1 && !edgeAttr; ddy++) {
                        for (let ddx = -1; ddx <= 1; ddx++) {
                            if (ddx === 0 && ddy === 0)
                                continue;
                            const nx = x + ddx;
                            const ny = y + ddy;
                            const nk = `${nx},${ny}`;
                            if (!StoryTags)
                                continue;
                            if (StoryTags.corridorLandOpen?.has?.(nk) ||
                                StoryTags.corridorRiverChain?.has?.(nk)) {
                                const attr = StoryTags.corridorAttributes?.get?.(nk);
                                if (attr && attr.edge)
                                    edgeAttr = attr;
                            }
                        }
                    }
                    if (edgeAttr && edgeAttr.edge) {
                        const edgeCfg = edgeAttr.edge;
                        // Forest rim: bias toward forest-friendly biomes (grassland/tropical) when moist
                        const forestRimChance = Math.max(0, Math.min(1, edgeCfg.forestRimChance ?? 0));
                        if (forestRimChance > 0 &&
                            rainfall > 90 &&
                            TerrainBuilder.getRandomNumber(100, "Corr Forest Rim") < Math.round(forestRimChance * 100)) {
                            const target = lat < 22 && rainfall > 110
                                ? globals.g_TropicalBiome
                                : globals.g_GrasslandBiome;
                            TerrainBuilder.setBiomeType(x, y, target);
                        }
                        // Hill/mountain rim: suggest drier, relief-friendly biomes (plains/tundra in cold/high)
                        const hillRimChance = Math.max(0, Math.min(1, edgeCfg.hillRimChance ?? 0));
                        const mountainRimChance = Math.max(0, Math.min(1, edgeCfg.mountainRimChance ?? 0));
                        const escarpmentChance = Math.max(0, Math.min(1, edgeCfg.escarpmentChance ?? 0));
                        const reliefChance = Math.max(0, Math.min(1, hillRimChance +
                            mountainRimChance +
                            escarpmentChance));
                        if (reliefChance > 0 &&
                            TerrainBuilder.getRandomNumber(100, "Corr Relief Rim") < Math.round(reliefChance * 100)) {
                            // Prefer tundra when very cold/high, else plains (playable with hills)
                            const elev = GameplayMap.getElevation(x, y);
                            const target = (lat > 62 || elev > 800) && rainfall < 95
                                ? globals.g_TundraBiome
                                : globals.g_PlainsBiome;
                            TerrainBuilder.setBiomeType(x, y, target);
                        }
                    }
                }
            }
            // Strategic Corridors: kind/style biome bias (very gentle; policy-scaled)
            {
                const cKey = `${x},${y}`;
                const attr = StoryTags.corridorAttributes?.get?.(cKey);
                const cKind = attr?.kind || (StoryTags.corridorKind && StoryTags.corridorKind.get(cKey));
                const biomesCfg = attr?.biomes;
                if ((cKind === "land" || cKind === "river") && biomesCfg) {
                    const strength = cKind === "land"
                        ? LAND_BIAS_STRENGTH
                        : RIVER_BIAS_STRENGTH;
                    if (strength > 0 &&
                        TerrainBuilder.getRandomNumber(100, "Corridor Kind Bias") < Math.round(strength * 100)) {
                        const entries = Object.keys(biomesCfg);
                        let totalW = 0;
                        for (const k of entries)
                            totalW += Math.max(0, biomesCfg[k] || 0);
                        if (totalW > 0) {
                            let roll = TerrainBuilder.getRandomNumber(totalW, "Corridor Kind Pick");
                            let chosen = entries[0];
                            for (const k of entries) {
                                const w = Math.max(0, biomesCfg[k] || 0);
                                if (roll < w) {
                                    chosen = k;
                                    break;
                                }
                                roll -= w;
                            }
                            let target = null;
                            if (chosen === "desert")
                                target = globals.g_DesertBiome;
                            else if (chosen === "plains")
                                target = globals.g_PlainsBiome;
                            else if (chosen === "grassland")
                                target = globals.g_GrasslandBiome;
                            else if (chosen === "tropical")
                                target = globals.g_TropicalBiome;
                            else if (chosen === "tundra")
                                target = globals.g_TundraBiome;
                            else if (chosen === "snow")
                                target = globals.g_SnowBiome;
                            if (target != null) {
                                // Light sanity gates to avoid extreme mismatches
                                let ok = true;
                                if (target === globals.g_DesertBiome &&
                                    rainfall > 110)
                                    ok = false;
                                if (target === globals.g_TropicalBiome &&
                                    !(lat < 25 && rainfall > 95))
                                    ok = false;
                                if (target === globals.g_TundraBiome &&
                                    !(lat > 60 || elevation > 800))
                                    ok = false;
                                if (target === globals.g_SnowBiome &&
                                    !(lat > 70 || elevation > 900))
                                    ok = false;
                                if (ok) {
                                    TerrainBuilder.setBiomeType(x, y, target);
                                }
                            }
                        }
                    }
                }
            }
            // Climate Story: rift shoulder preference (narrow, moisture-aware)
            if (STORY_ENABLE_RIFTS && StoryTags.riftShoulder.size > 0) {
                const key = `${x},${y}`;
                if (StoryTags.riftShoulder.has(key)) {
                    // Temperate/warm shoulders: prefer grassland when sufficiently moist
                    if (lat < RS_GRASS_LAT_MAX &&
                        rainfall > RS_GRASS_RAIN_MIN) {
                        TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
                    }
                    else if (lat < RS_TROP_LAT_MAX &&
                        rainfall > RS_TROP_RAIN_MIN) {
                        // In very warm & wet shoulders, allow tropical bias (still gentle)
                        TerrainBuilder.setBiomeType(x, y, globals.g_TropicalBiome);
                    }
                }
            }
        }
    }
}
export default designateEnhancedBiomes;
</file>

<file path="mod/maps/layers/climate-engine.js">
// @ts-nocheck
/**
 * Climate Engine  centralizes rainfall staging passes so the orchestrator and
 * narrative overlays operate against a single shared module.
 */
import { buildRainfallMap } from "/base-standard/maps/elevation-terrain-generator.js";
import { clamp, inBounds } from "../core/utils.js";
import { CLIMATE_DRIVERS, MOISTURE_ADJUSTMENTS, STORY_TUNABLES, STORY_ENABLE_OROGENY, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { ctxRandom, writeClimateField, syncClimateField } from "../core/types.js";
import { WorldModel } from "../world/model.js";
import { StoryTags } from "../story/tags.js";

/**
 * Resolve an engine adapter for rainfall operations. Falls back to GameplayMap
 * when no MapContext adapter is available.
 * @param {import('../core/types.js').MapContext|null} ctx
 */
function resolveAdapter(ctx) {
    if (ctx && ctx.adapter) {
        return ctx.adapter;
    }
    return {
        isWater: (x, y) => GameplayMap.isWater(x, y),
        isMountain: (x, y) => (GameplayMap.isMountain ? GameplayMap.isMountain(x, y) : GameplayMap.getElevation(x, y) >= 500),
        isCoastalLand: (x, y) => (GameplayMap.isCoastalLand ? GameplayMap.isCoastalLand(x, y) : false),
        isAdjacentToShallowWater: (x, y) => (GameplayMap.isAdjacentToShallowWater ? GameplayMap.isAdjacentToShallowWater(x, y) : false),
        isAdjacentToRivers: (x, y, radius) => GameplayMap.isAdjacentToRivers(x, y, radius),
        getRainfall: (x, y) => GameplayMap.getRainfall(x, y),
        setRainfall: (x, y, rf) => TerrainBuilder.setRainfall(x, y, rf),
        getElevation: (x, y) => GameplayMap.getElevation(x, y),
        getLatitude: (x, y) => GameplayMap.getPlotLatitude(x, y),
        getRandomNumber: (max, label) => TerrainBuilder.getRandomNumber(max, label),
    };
}

/**
 * Create shared IO helpers for rainfall passes.
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 */
function createClimateRuntime(width, height, ctx) {
    const adapter = resolveAdapter(ctx);
    const rainfallBuf = ctx?.buffers?.climate?.rainfall || null;
    const idx = (x, y) => y * width + x;
    const readRainfall = (x, y) => {
        if (ctx && rainfallBuf) {
            return rainfallBuf[idx(x, y)] | 0;
        }
        return adapter.getRainfall(x, y);
    };
    const writeRainfall = (x, y, rainfall) => {
        const clamped = clamp(rainfall, 0, 200);
        if (ctx) {
            writeClimateField(ctx, x, y, { rainfall: clamped });
        }
        else {
            adapter.setRainfall(x, y, clamped);
        }
    };
    const rand = (max, label) => {
        if (ctx) {
            return ctxRandom(ctx, label || "ClimateRand", max);
        }
        return adapter.getRandomNumber(max, label || "ClimateRand");
    };
    return {
        adapter,
        readRainfall,
        writeRainfall,
        rand,
        idx,
    };
}

/**
 * Baseline rainfall generation (latitude bands + coastal/orographic modifiers).
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 */
export function applyClimateBaseline(width, height, ctx = null) {
    console.log("Building enhanced rainfall patterns...");
    buildRainfallMap(width, height);
    if (ctx) {
        syncClimateField(ctx);
    }
    const runtime = createClimateRuntime(width, height, ctx);
    const { adapter, readRainfall, writeRainfall, rand } = runtime;
    const BASE_AREA = 10000;
    const sqrt = Math.min(2.0, Math.max(0.6, Math.sqrt(Math.max(1, width * height) / BASE_AREA)));
    const equatorPlus = Math.round(12 * (sqrt - 1));
    const drivers = CLIMATE_DRIVERS?.baseline || {};
    const adjustments = MOISTURE_ADJUSTMENTS?.baseline || {};
    const bands = drivers.bands || {};
    const blend = drivers.blend || {};
    const orographic = adjustments.orographic || {};
    const coastalCfg = adjustments.coastal || {};
    const noiseCfg = adjustments.noise || {};
    const noiseBase = Number.isFinite(noiseCfg?.baseSpanSmall) ? noiseCfg.baseSpanSmall : 3;
    const noiseSpan = sqrt > 1
        ? noiseBase + Math.round(Number.isFinite(noiseCfg?.spanLargeScaleFactor) ? noiseCfg.spanLargeScaleFactor : 1)
        : noiseBase;
    const isCoastalLand = (x, y) => {
        if (adapter.isCoastalLand)
            return adapter.isCoastalLand(x, y);
        if (typeof GameplayMap?.isCoastalLand === "function")
            return GameplayMap.isCoastalLand(x, y);
        if (adapter.isWater(x, y))
            return false;
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0)
                    continue;
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                    continue;
                if (adapter.isWater(nx, ny))
                    return true;
            }
        }
        return false;
    };
    const isAdjacentToShallowWater = (x, y) => {
        if (adapter.isAdjacentToShallowWater)
            return adapter.isAdjacentToShallowWater(x, y);
        if (typeof GameplayMap?.isAdjacentToShallowWater === "function")
            return GameplayMap.isAdjacentToShallowWater(x, y);
        return false;
    };
    const rollNoise = () => rand(noiseSpan * 2 + 1, "RainNoise") - noiseSpan;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (adapter.isWater(x, y))
                continue;
            const base = readRainfall(x, y);
            const elevation = adapter.getElevation(x, y);
            const lat = Math.abs(adapter.getLatitude(x, y));
            const b0 = Number.isFinite(bands.deg0to10) ? bands.deg0to10 : 120;
            const b1 = Number.isFinite(bands.deg10to20) ? bands.deg10to20 : 104;
            const b2 = Number.isFinite(bands.deg20to35) ? bands.deg20to35 : 75;
            const b3 = Number.isFinite(bands.deg35to55) ? bands.deg35to55 : 70;
            const b4 = Number.isFinite(bands.deg55to70) ? bands.deg55to70 : 60;
            const b5 = Number.isFinite(bands.deg70plus) ? bands.deg70plus : 45;
            let bandRain = 0;
            if (lat < 10)
                bandRain = b0 + equatorPlus;
            else if (lat < 20)
                bandRain = b1 + Math.floor(equatorPlus * 0.6);
            else if (lat < 35)
                bandRain = b2;
            else if (lat < 55)
                bandRain = b3;
            else if (lat < 70)
                bandRain = b4;
            else
                bandRain = b5;
            const baseW = Number.isFinite(blend?.baseWeight) ? blend.baseWeight : 0.6;
            const bandW = Number.isFinite(blend?.bandWeight) ? blend.bandWeight : 0.4;
            let currentRainfall = Math.round(base * baseW + bandRain * bandW);
            const hi1T = Number.isFinite(orographic?.hi1Threshold) ? orographic.hi1Threshold : 350;
            const hi1B = Number.isFinite(orographic?.hi1Bonus) ? orographic.hi1Bonus : 8;
            const hi2T = Number.isFinite(orographic?.hi2Threshold) ? orographic.hi2Threshold : 600;
            const hi2B = Number.isFinite(orographic?.hi2Bonus) ? orographic.hi2Bonus : 7;
            if (elevation > hi1T)
                currentRainfall += hi1B;
            if (elevation > hi2T)
                currentRainfall += hi2B;
            const coastalBonus = Number.isFinite(coastalCfg.coastalLandBonus) ? coastalCfg.coastalLandBonus : 24;
            const shallowBonus = Number.isFinite(coastalCfg.shallowAdjBonus) ? coastalCfg.shallowAdjBonus : 16;
            if (isCoastalLand(x, y))
                currentRainfall += coastalBonus;
            if (isAdjacentToShallowWater(x, y))
                currentRainfall += shallowBonus;
            currentRainfall += rollNoise();
            writeRainfall(x, y, currentRainfall);
        }
    }
}

/**
 * Apply macro climate swatches to the rainfall field.
 * Returns a lightweight summary that callers can extend.
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 * @param {{ orogenyCache?: any }} [options]
 */
export function applyClimateSwatches(width, height, ctx = null, options = {}) {
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    const cfg = storyMoisture.swatches;
    if (!cfg)
        return { applied: false, kind: "missing-config" };
    const area = Math.max(1, width * height);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    if (ctx) {
        syncClimateField(ctx);
    }
    const runtime = createClimateRuntime(width, height, ctx);
    const { adapter, readRainfall, writeRainfall, rand, idx } = runtime;
    const orogenyCache = options?.orogenyCache || {};
    const clamp200 = (v) => clamp(v, 0, 200);
    const inLocalBounds = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
    const isWater = (x, y) => adapter.isWater(x, y);
    const getElevation = (x, y) => adapter.getElevation(x, y);
    const signedLatitudeAt = (y) => adapter.getLatitude(0, y);
    const isCoastalLand = (x, y) => {
        if (adapter.isCoastalLand)
            return adapter.isCoastalLand(x, y);
        if (typeof GameplayMap?.isCoastalLand === "function")
            return GameplayMap.isCoastalLand(x, y);
        if (isWater(x, y))
            return false;
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0)
                    continue;
                const nx = x + dx;
                const ny = y + dy;
                if (!inLocalBounds(nx, ny))
                    continue;
                if (isWater(nx, ny))
                    return true;
            }
        }
        return false;
    };
    const isAdjacentToShallowWater = (x, y) => {
        if (adapter.isAdjacentToShallowWater)
            return adapter.isAdjacentToShallowWater(x, y);
        if (typeof GameplayMap?.isAdjacentToShallowWater === "function")
            return GameplayMap.isAdjacentToShallowWater(x, y);
        return false;
    };
    const types = cfg.types || {};
    let entries = Object.keys(types).map((key) => ({
        key,
        w: Math.max(0, types[key].weight | 0),
    }));
    try {
        const DIR = FOUNDATION_DIRECTIONALITY || {};
        const COH = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
        if (COH > 0) {
            const windDeg = (DIR?.primaryAxes?.windBiasDeg ?? 0) | 0;
            const plateDeg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
            const wRad = (windDeg * Math.PI) / 180;
            const pRad = (plateDeg * Math.PI) / 180;
            const alignZonal = Math.abs(Math.cos(wRad));
            const alignPlate = Math.abs(Math.cos(pRad));
            entries = entries.map((entry) => {
                let mul = 1;
                if (entry.key === "macroDesertBelt") {
                    mul *= 1 + 0.4 * COH * alignZonal;
                }
                else if (entry.key === "equatorialRainbelt") {
                    mul *= 1 + 0.25 * COH * alignZonal;
                }
                else if (entry.key === "mountainForests") {
                    mul *= 1 + 0.2 * COH * alignPlate;
                }
                else if (entry.key === "greatPlains") {
                    mul *= 1 + 0.2 * COH * alignZonal;
                }
                return { key: entry.key, w: Math.max(0, Math.round(entry.w * mul)) };
            });
        }
    }
    catch (_err) {
        /* keep default weights on any error */
    }
    const totalW = entries.reduce((sum, entry) => sum + entry.w, 0) || 1;
    let roll = rand(totalW, "SwatchType");
    let chosenKey = entries[0]?.key || "macroDesertBelt";
    for (const entry of entries) {
        if (roll < entry.w) {
            chosenKey = entry.key;
            break;
        }
        roll -= entry.w;
    }
    const kind = chosenKey;
    const t = types[kind] || {};
    const widthMul = 1 + (cfg.sizeScaling?.widthMulSqrt || 0) * (sqrtScale - 1);
    const latBandCenter = () => t.latitudeCenterDeg ?? 0;
    const halfWidthDeg = () => Math.max(4, Math.round((t.halfWidthDeg ?? 10) * widthMul));
    const falloff = (value, radius) => Math.max(0, 1 - value / Math.max(1, radius));
    let applied = 0;
    for (let y = 0; y < height; y++) {
        const latDegAbs = Math.abs(signedLatitudeAt(y));
        for (let x = 0; x < width; x++) {
            if (isWater(x, y))
                continue;
            let rf = readRainfall(x, y);
            const elev = getElevation(x, y);
            let tileAdjusted = false;
            if (kind === "macroDesertBelt") {
                const center = latBandCenter();
                const hw = halfWidthDeg();
                const f = falloff(Math.abs(latDegAbs - center), hw);
                if (f > 0) {
                    const base = t.drynessDelta ?? 28;
                    const lowlandBonus = elev < 250 ? 4 : 0;
                    const delta = Math.round((base + lowlandBonus) * f);
                    rf = clamp200(rf - delta);
                    applied++;
                    tileAdjusted = true;
                }
            }
            else if (kind === "equatorialRainbelt") {
                const center = latBandCenter();
                const hw = halfWidthDeg();
                const f = falloff(Math.abs(latDegAbs - center), hw);
                if (f > 0) {
                    const base = t.wetnessDelta ?? 24;
                    let coastBoost = 0;
                    if (isCoastalLand(x, y))
                        coastBoost += 6;
                    if (isAdjacentToShallowWater(x, y))
                        coastBoost += 4;
                    const delta = Math.round((base + coastBoost) * f);
                    rf = clamp200(rf + delta);
                    applied++;
                    tileAdjusted = true;
                }
            }
            else if (kind === "rainforestArchipelago") {
                const fTropics = latDegAbs < 23 ? 1 : latDegAbs < 30 ? 0.5 : 0;
                if (fTropics > 0) {
                    let islandy = 0;
                    if (isCoastalLand(x, y))
                        islandy += 1;
                    if (isAdjacentToShallowWater(x, y))
                        islandy += 0.5;
                    if (islandy > 0) {
                        const base = t.wetnessDelta ?? 18;
                        const delta = Math.round(base * fTropics * islandy);
                        rf = clamp200(rf + delta);
                        applied++;
                        tileAdjusted = true;
                    }
                }
            }
            else if (kind === "mountainForests") {
                const windward = !!orogenyCache?.windward?.has?.(`${x},${y}`);
                const lee = !!orogenyCache?.lee?.has?.(`${x},${y}`);
                if (windward) {
                    const base = t.windwardBonus ?? 6;
                    const delta = base + (elev < 300 ? 2 : 0);
                    rf = clamp200(rf + delta);
                    applied++;
                    tileAdjusted = true;
                }
                else if (lee) {
                    const base = t.leePenalty ?? 2;
                    rf = clamp200(rf - base);
                    applied++;
                    tileAdjusted = true;
                }
            }
            else if (kind === "greatPlains") {
                const center = t.latitudeCenterDeg ?? 45;
                const hw = Math.max(6, Math.round((t.halfWidthDeg ?? 8) * widthMul));
                const f = falloff(Math.abs(latDegAbs - center), hw);
                if (f > 0 && elev <= (t.lowlandMaxElevation ?? 300)) {
                    const dry = t.dryDelta ?? 12;
                    const delta = Math.round(dry * f);
                    rf = clamp200(rf - delta);
                    applied++;
                    tileAdjusted = true;
                }
            }
            if (tileAdjusted) {
                writeRainfall(x, y, rf);
            }
        }
    }
    try {
        const DIR = FOUNDATION_DIRECTIONALITY || {};
        const monsoonBias = Math.max(0, Math.min(1, DIR?.hemispheres?.monsoonBias ?? 0));
        const COH = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
        const eqBand = Math.max(0, (DIR?.hemispheres?.equatorBandDeg ?? 12) | 0);
        if (monsoonBias > 0 && COH > 0 && WorldModel?.isEnabled?.() && WorldModel.windU && WorldModel.windV) {
            const baseDelta = Math.max(1, Math.round(3 * COH * monsoonBias));
            for (let y = 0; y < height; y++) {
                const latSigned = signedLatitudeAt(y);
                const absLat = Math.abs(latSigned);
                if (absLat > eqBand + 18)
                    continue;
                for (let x = 0; x < width; x++) {
                    if (isWater(x, y))
                        continue;
                    if (!isCoastalLand(x, y) && !isAdjacentToShallowWater(x, y))
                        continue;
                    const i = idx(x, y);
                    const u = WorldModel.windU[i] | 0;
                    const v = WorldModel.windV[i] | 0;
                    let ux = 0, vy = 0;
                    if (Math.abs(u) >= Math.abs(v)) {
                        ux = u === 0 ? 0 : u > 0 ? 1 : -1;
                        vy = 0;
                    }
                    else {
                        ux = 0;
                        vy = v === 0 ? 0 : v > 0 ? 1 : -1;
                    }
                    const dnX = x - ux;
                    const dnY = y - vy;
                    if (!inLocalBounds(dnX, dnY))
                        continue;
                    let rf = readRainfall(x, y);
                    let baseDeltaAdj = baseDelta;
                    if (absLat <= eqBand)
                        baseDeltaAdj += 2;
                    if (isWater(dnX, dnY))
                        baseDeltaAdj += 2;
                    rf = clamp(rf + baseDeltaAdj, 0, 200);
                    writeRainfall(x, y, rf);
                    const upX = x + ux;
                    const upY = y + vy;
                    if (inLocalBounds(upX, upY) && isWater(dnX, dnY)) {
                        const rf0 = readRainfall(x, y);
                        const rf1 = Math.max(0, Math.min(200, rf0 - 1));
                        writeRainfall(x, y, rf1);
                    }
                }
            }
        }
    }
    catch (_err) {
        /* keep resilient */
    }
    return { applied: applied > 0, kind, tiles: applied };
}

/**
 * Earthlike rainfall refinements (post-rivers).
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 * @param {{ orogenyCache?: any }} [options]
 */
export function refineClimateEarthlike(width, height, ctx = null, options = {}) {
    const runtime = createClimateRuntime(width, height, ctx);
    const { adapter, readRainfall, writeRainfall } = runtime;
    const worldModel = ctx && ctx.worldModel ? ctx.worldModel : WorldModel;
    const refineAdjust = MOISTURE_ADJUSTMENTS?.refine || {};
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    const storyRain = storyMoisture.rainfall || {};
    const orogenyCache = options?.orogenyCache || null;
    console.log(`[Climate Refinement] Using ${ctx ? "MapContext adapter" : "direct engine calls"}`);
    // Pass A: coastal and lake humidity gradient
    {
        const waterGradient = refineAdjust.waterGradient || {};
        const maxR = (waterGradient?.radius ?? 5) | 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (adapter.isWater(x, y))
                    continue;
                let rf = readRainfall(x, y);
                const dist = distanceToNearestWater(x, y, maxR, adapter, width, height);
                if (dist >= 0) {
                    const elev = adapter.getElevation(x, y);
                    let bonus = Math.max(0, maxR - dist) * (waterGradient?.perRingBonus ?? 5);
                    if (elev < 150)
                        bonus += waterGradient?.lowlandBonus ?? 3;
                    rf += bonus;
                    writeRainfall(x, y, rf);
                }
            }
        }
    }
    // Pass B: orographic rain shadows with wind model
    {
        const orographic = refineAdjust.orographic || {};
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (adapter.isWater(x, y))
                    continue;
                const baseSteps = (orographic?.steps ?? 4) | 0;
                let steps = baseSteps;
                try {
                    const DIR = FOUNDATION_DIRECTIONALITY || {};
                    const coh = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                    const windC = Math.max(0, Math.min(1, DIR?.interplay?.windsFollowPlates ?? 0));
                    const extra = Math.round(coh * windC);
                    steps = Math.max(1, baseSteps + extra);
                }
                catch (_) {
                    steps = baseSteps;
                }
                let barrier = 0;
                if (worldModel?.isEnabled?.() && worldModel.windU && worldModel.windV) {
                    barrier = hasUpwindBarrierWM(x, y, steps, adapter, width, height, worldModel);
                }
                else {
                    const lat = Math.abs(adapter.getLatitude(x, y));
                    const dx = lat < 30 || lat >= 60 ? -1 : 1;
                    const dy = 0;
                    barrier = hasUpwindBarrier(x, y, dx, dy, steps, adapter, width, height);
                }
                if (barrier) {
                    const rf = readRainfall(x, y);
                    const reduction = (orographic?.reductionBase ?? 8) + barrier * (orographic?.reductionPerStep ?? 6);
                    writeRainfall(x, y, rf - reduction);
                }
            }
        }
    }
    // Pass C: river corridor greening and basin humidity
    {
        const riverCorridor = refineAdjust.riverCorridor || {};
        const lowBasinCfg = refineAdjust.lowBasin || {};
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (adapter.isWater(x, y))
                    continue;
                let rf = readRainfall(x, y);
                const elev = adapter.getElevation(x, y);
                if (adapter.isAdjacentToRivers(x, y, 1)) {
                    rf += elev < 250
                        ? (riverCorridor?.lowlandAdjacencyBonus ?? 14)
                        : (riverCorridor?.highlandAdjacencyBonus ?? 10);
                }
                let lowBasinClosed = true;
                const basinRadius = lowBasinCfg?.radius ?? 2;
                for (let dy = -basinRadius; dy <= basinRadius && lowBasinClosed; dy++) {
                    for (let dx = -basinRadius; dx <= basinRadius; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (inBounds(nx, ny)) {
                            if (adapter.getElevation(nx, ny) < elev + 20) {
                                lowBasinClosed = false;
                                break;
                            }
                        }
                    }
                }
                if (lowBasinClosed && elev < 200)
                    rf += lowBasinCfg?.delta ?? 6;
                writeRainfall(x, y, rf);
            }
        }
    }
    // Pass D: Rift humidity boost
    {
        const riftR = storyRain?.riftRadius ?? 2;
        const riftBoost = storyRain?.riftBoost ?? 8;
        if (StoryTags.riftLine.size > 0 && riftR > 0 && riftBoost !== 0) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (adapter.isWater(x, y))
                        continue;
                    let nearRift = false;
                    for (let dy = -riftR; dy <= riftR && !nearRift; dy++) {
                        for (let dx = -riftR; dx <= riftR; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (!inBounds(nx, ny))
                                continue;
                            if (StoryTags.riftLine.has(`${nx},${ny}`)) {
                                nearRift = true;
                                break;
                            }
                        }
                    }
                    if (nearRift) {
                        const rf = readRainfall(x, y);
                        const elev = adapter.getElevation(x, y);
                        const penalty = Math.max(0, Math.floor((elev - 200) / 150));
                        const delta = Math.max(0, riftBoost - penalty);
                        writeRainfall(x, y, rf + delta);
                    }
                }
            }
        }
    }
    // Pass E: Orogeny belts (windward/lee)
    {
        if (STORY_ENABLE_OROGENY && typeof orogenyCache === "object") {
            const hasWindward = orogenyCache?.windward?.size > 0;
            const hasLee = orogenyCache?.lee?.size > 0;
            if (hasWindward || hasLee) {
                const windwardBoost = STORY_TUNABLES?.orogeny?.windwardBoost ?? 5;
                const leeAmp = STORY_TUNABLES?.orogeny?.leeDrynessAmplifier ?? 1.2;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (adapter.isWater(x, y))
                            continue;
                        let rf = readRainfall(x, y);
                        const key = `${x},${y}`;
                        if (hasWindward && orogenyCache.windward.has(key)) {
                            rf = clamp(rf + windwardBoost, 0, 200);
                        }
                        if (hasLee && orogenyCache.lee.has(key)) {
                            const baseSubtract = 8;
                            const extra = Math.max(0, Math.round(baseSubtract * (leeAmp - 1)));
                            rf = clamp(rf - (baseSubtract + extra), 0, 200);
                        }
                        writeRainfall(x, y, rf);
                    }
                }
            }
        }
    }
    // Pass F: Hotspot island microclimates
    {
        const paradiseDelta = storyRain?.paradiseDelta ?? 6;
        const volcanicDelta = storyRain?.volcanicDelta ?? 8;
        const radius = 2;
        const hasParadise = StoryTags.hotspotParadise.size > 0;
        const hasVolcanic = StoryTags.hotspotVolcanic.size > 0;
        if (hasParadise || hasVolcanic) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (adapter.isWater(x, y))
                        continue;
                    let nearParadise = false;
                    let nearVolcanic = false;
                    for (let dy = -radius; dy <= radius && (!nearParadise || !nearVolcanic); dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (!inBounds(nx, ny))
                                continue;
                            const key = `${nx},${ny}`;
                            if (!nearParadise && hasParadise && StoryTags.hotspotParadise.has(key))
                                nearParadise = true;
                            if (!nearVolcanic && hasVolcanic && StoryTags.hotspotVolcanic.has(key))
                                nearVolcanic = true;
                            if (nearParadise && nearVolcanic)
                                break;
                        }
                    }
                    if (nearParadise || nearVolcanic) {
                        const rf = readRainfall(x, y);
                        let delta = 0;
                        if (nearParadise)
                            delta += paradiseDelta;
                        if (nearVolcanic)
                            delta += volcanicDelta;
                        writeRainfall(x, y, rf + delta);
                    }
                }
            }
        }
    }
}

/**
 * Distance helper for the refinement pass.
 */
function distanceToNearestWater(x, y, maxR, adapter, width, height) {
    for (let r = 1; r <= maxR; r++) {
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                if (dx === 0 && dy === 0)
                    continue;
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    if (adapter.isWater(nx, ny))
                        return r;
                }
            }
        }
    }
    return -1;
}

/**
 * Upwind barrier utility (legacy helper copied from refinement layer).
 */
function hasUpwindBarrier(x, y, dx, dy, steps, adapter, width, height) {
    for (let s = 1; s <= steps; s++) {
        const nx = x + dx * s;
        const ny = y + dy * s;
        if (nx < 0 || nx >= width || ny < 0 || ny >= height)
            break;
        if (!adapter.isWater(nx, ny)) {
            if (adapter.isMountain && adapter.isMountain(nx, ny))
                return s;
            const elev = adapter.getElevation(nx, ny);
            if (elev >= 500)
                return s;
        }
    }
    return 0;
}

/**
 * Upwind barrier using world model wind vectors.
 */
function hasUpwindBarrierWM(x, y, steps, adapter, width, height, worldModel) {
    const U = worldModel.windU;
    const V = worldModel.windV;
    if (!U || !V)
        return 0;
    let cx = x;
    let cy = y;
    for (let s = 1; s <= steps; s++) {
        const i = cy * width + cx;
        let ux = 0, vy = 0;
        if (i >= 0 && i < U.length) {
            const u = U[i] | 0;
            const v = V[i] | 0;
            if (Math.abs(u) >= Math.abs(v)) {
                ux = u === 0 ? 0 : u > 0 ? 1 : -1;
                vy = 0;
            }
            else {
                ux = 0;
                vy = v === 0 ? 0 : v > 0 ? 1 : -1;
            }
            if (ux === 0 && vy === 0) {
                const lat = Math.abs(adapter.getLatitude(cx, cy));
                ux = lat < 30 || lat >= 60 ? -1 : 1;
                vy = 0;
            }
        }
        else {
            const lat = Math.abs(adapter.getLatitude(cx, cy));
            ux = lat < 30 || lat >= 60 ? -1 : 1;
            vy = 0;
        }
        const nx = cx + ux;
        const ny = cy + vy;
        if (nx < 0 || nx >= width || ny < 0 || ny >= height)
            break;
        if (!adapter.isWater(nx, ny)) {
            if (adapter.isMountain && adapter.isMountain(nx, ny))
                return s;
            const elev = adapter.getElevation(nx, ny);
            if (elev >= 500)
                return s;
        }
        cx = nx;
        cy = ny;
    }
    return 0;
}

export default {
    applyClimateBaseline,
    applyClimateSwatches,
    refineClimateEarthlike,
};
</file>

<file path="mod/maps/layers/coastlines.js">
// @ts-nocheck
/**
 * Coastlines Layer  addRuggedCoasts
 *
 * Light-touch coastal reshaping that carves occasional bays and creates sparse
 * fjord-like peninsulas while preserving open sea lanes. Uses a low-frequency
 * fractal mask and conservative randomness to avoid chokepoint proliferation.
 *
 * Dependencies: engine-provided GameplayMap, TerrainBuilder, FractalBuilder, and globals.
 */
import * as globals from "/base-standard/maps/map-globals.js";
import { isAdjacentToLand } from "../core/utils.js";
import { StoryTags } from "../story/tags.js";
import { COASTLINES_CFG, CORRIDOR_POLICY, } from "../bootstrap/tunables.js";
import { ctxRandom, writeHeightfield } from "../core/types.js";
import { WorldModel } from "../world/model.js";

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

function clamp(v, lo, hi) {
    if (v < lo)
        return lo;
    if (v > hi)
        return hi;
    return v;
}

function computePlateBias(closenessNorm, boundaryType, cfg) {
    if (closenessNorm == null || Number.isNaN(closenessNorm))
        closenessNorm = 0;
    const threshold = cfg.threshold;
    const power = cfg.power;
    let weight = 0;
    if (closenessNorm >= threshold) {
        const span = Math.max(1e-3, 1 - threshold);
        const normalized = clamp((closenessNorm - threshold) / span, 0, 1);
        const ramp = Math.pow(normalized, power);
        let typeMul = 0;
        if (boundaryType === ENUM_BOUNDARY.convergent)
            typeMul = cfg.convergent;
        else if (boundaryType === ENUM_BOUNDARY.transform)
            typeMul = cfg.transform;
        else if (boundaryType === ENUM_BOUNDARY.divergent)
            typeMul = cfg.divergent;
        weight = ramp * typeMul;
    }
    else if (cfg.interior !== 0 && threshold > 0) {
        const normalized = clamp(1 - closenessNorm / threshold, 0, 1);
        weight = Math.pow(normalized, power) * cfg.interior;
    }
    return weight;
}
/**
 * Ruggedize coasts in a sparse, performance-friendly pass.
 * - Occasionally converts coastal land to shallow water (bays).
 * - Occasionally converts adjacent ocean to coast (peninsulas/fjords).
 * - Only operates near current coastlines; does not perform heavy flood fills.
 *
 * Invariants:
 * - Keeps oceans truly open; very low probabilities to avoid chokepoints.
 * - O(width  height) with constant-time local checks.
 *
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {import('../core/types.js').MapContext} [ctx] - Optional MapContext for adapter-based operations
 */
export function addRuggedCoasts(iWidth, iHeight, ctx) {
    // Size-aware modifiers (gentle; keep lanes open)
    const area = Math.max(1, iWidth * iHeight);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    // Use hill fractal as a sparse noise mask to drive rare edits
    FractalBuilder.create(globals.g_HillFractal, iWidth, iHeight, 4, 0);

    // Phase 2: WorldModel plate boundary integration
    const worldModelEnabled = WorldModel.isEnabled();
    const boundaryCloseness = worldModelEnabled ? WorldModel.boundaryCloseness : null;
    const boundaryType = worldModelEnabled ? WorldModel.boundaryType : null;
    // Probability tuning: on larger maps, allow a touch more edits
    const cfg = COASTLINES_CFG || {};
    const cfgBay = (cfg && cfg.bay) || {};
    const cfgFjord = (cfg && cfg.fjord) || {};
    const bayNoiseExtra = (sqrtScale > 1 ? 1 : 0) +
        (Number.isFinite(cfgBay.noiseGateAdd) ? cfgBay.noiseGateAdd : 0);
    const fjordBaseDenom = Math.max(6, (Number.isFinite(cfgFjord.baseDenom) ? cfgFjord.baseDenom : 12) -
        (sqrtScale > 1.3 ? 1 : 0));
    const fjordActiveBonus = Number.isFinite(cfgFjord.activeBonus)
        ? cfgFjord.activeBonus
        : 1;
    const fjordPassiveBonus = Number.isFinite(cfgFjord.passiveBonus)
        ? cfgFjord.passiveBonus
        : 2;
    const bayRollDenActive = Number.isFinite(cfgBay.rollDenActive)
        ? cfgBay.rollDenActive
        : 4;
    const bayRollDenDefault = Number.isFinite(cfgBay.rollDenDefault)
        ? cfgBay.rollDenDefault
        : 5;
    const minSeaLaneWidth = Number.isFinite(cfg.minSeaLaneWidth)
        ? cfg.minSeaLaneWidth
        : 4; // reserved for future shelf/trench guards
    const plateBiasRaw = (cfg && cfg.plateBias) || {};
    const plateBiasCfg = {
        threshold: clamp(Number.isFinite(plateBiasRaw.threshold) ? plateBiasRaw.threshold : 0.45, 0, 1),
        power: Math.max(0.1, Number.isFinite(plateBiasRaw.power) ? plateBiasRaw.power : 1.25),
        convergent: Number.isFinite(plateBiasRaw.convergent) ? plateBiasRaw.convergent : 1.0,
        transform: Number.isFinite(plateBiasRaw.transform) ? plateBiasRaw.transform : 0.4,
        divergent: Number.isFinite(plateBiasRaw.divergent) ? plateBiasRaw.divergent : -0.6,
        interior: Number.isFinite(plateBiasRaw.interior) ? plateBiasRaw.interior : 0,
        bayWeight: Math.max(0, Number.isFinite(plateBiasRaw.bayWeight) ? plateBiasRaw.bayWeight : 0.35),
        bayNoiseBonus: Math.max(0, Number.isFinite(plateBiasRaw.bayNoiseBonus) ? plateBiasRaw.bayNoiseBonus : 1.0),
        fjordWeight: Math.max(0, Number.isFinite(plateBiasRaw.fjordWeight) ? plateBiasRaw.fjordWeight : 0.8),
    };
    // Sea-lane policy (hard skip vs. soft probability reduction)
    const seaPolicy = (CORRIDOR_POLICY && CORRIDOR_POLICY.sea) || {};
    const SEA_PROTECTION = seaPolicy.protection || "hard";
    const SOFT_MULT = Math.max(0, Math.min(1, seaPolicy.softChanceMultiplier ?? 0.5));

    const applyTerrain = (x, y, terrain, isLand) => {
        if (ctx) {
            writeHeightfield(ctx, x, y, { terrain, isLand });
        }
        else {
            TerrainBuilder.setTerrainType(x, y, terrain);
        }
    };
    for (let y = 1; y < iHeight - 1; y++) {
        for (let x = 1; x < iWidth - 1; x++) {
            // Sea-lane policy: hard skip or soft probability reduction
            const _k = `${x},${y}`;
            const _onSeaLane = StoryTags.corridorSeaLane && StoryTags.corridorSeaLane.has(_k);
            const _softMult = _onSeaLane && SEA_PROTECTION === "soft" ? SOFT_MULT : 1;
            if (_onSeaLane && SEA_PROTECTION === "hard") {
                continue;
            }
            // Carve bays: coastal land -> coast water (very sparse)
            if (GameplayMap.isCoastalLand(x, y)) {
                const h = FractalBuilder.getHeight(globals.g_HillFractal, x, y);

                // Phase 2: Check boundary closeness for enhanced ruggedness
                const i = y * iWidth + x;
                const closenessByte = boundaryCloseness ? boundaryCloseness[i] | 0 : 0;
                const closenessNorm = closenessByte / 255;
                const bType = boundaryType ? boundaryType[i] | 0 : ENUM_BOUNDARY.none;
                const nearBoundary = closenessNorm >= plateBiasCfg.threshold;
                const plateBiasValue = boundaryCloseness
                    ? computePlateBias(closenessNorm, bType, plateBiasCfg)
                    : 0;

                // Margin-aware: slightly stronger bay carving on ACTIVE_MARGIN or near plate boundaries
                const isActive = StoryTags.activeMargin.has(`${x},${y}`) || nearBoundary;
                const noiseGateBonus = plateBiasValue > 0
                    ? Math.round(plateBiasValue * plateBiasCfg.bayNoiseBonus)
                    : 0;
                const noiseGate = 2 + bayNoiseExtra + (isActive ? 1 : 0) + noiseGateBonus;
                const bayRollDen = isActive
                    ? bayRollDenActive
                    : bayRollDenDefault;
                let bayRollDenUsed = _softMult !== 1
                    ? Math.max(1, Math.round(bayRollDen / _softMult))
                    : bayRollDen;
                if (plateBiasCfg.bayWeight > 0 && plateBiasValue !== 0) {
                    const scale = clamp(1 + plateBiasValue * plateBiasCfg.bayWeight, 0.25, 4);
                    bayRollDenUsed = Math.max(1, Math.round(bayRollDenUsed / scale));
                }
                // Corridor edge effect: if near a sea-lane, apply style-based bay carve bias
                const laneAttr = (function () {
                    for (let ddy = -1; ddy <= 1; ddy++) {
                        for (let ddx = -1; ddx <= 1; ddx++) {
                            if (ddx === 0 && ddy === 0)
                                continue;
                            const k = `${x + ddx},${y + ddy}`;
                            if (StoryTags.corridorSeaLane &&
                                StoryTags.corridorSeaLane.has(k)) {
                                return StoryTags.corridorAttributes?.get?.(k) || null;
                            }
                        }
                    }
                    return null;
                })();
                if (laneAttr && laneAttr.edge) {
                    const edgeCfg = laneAttr.edge;
                    const bayMult = Number.isFinite(edgeCfg.bayCarveMultiplier)
                        ? edgeCfg.bayCarveMultiplier
                        : 1;
                    if (bayMult && bayMult !== 1) {
                        bayRollDenUsed = Math.max(1, Math.round(bayRollDenUsed / bayMult));
                    }
                }
                if (h % 97 < noiseGate &&
                    (ctx ? ctxRandom(ctx, "Carve Bay", bayRollDenUsed) : TerrainBuilder.getRandomNumber(bayRollDenUsed, "Carve Bay")) === 0) {
                    applyTerrain(x, y, globals.g_CoastTerrain, false);
                    continue; // Avoid double-touching same tile in this pass
                }
            }
            // Fjord-like peninsulas: turn some adjacent ocean into coast (very sparse)
            if (GameplayMap.isWater(x, y)) {
                // Keep to near-land ocean only; deep ocean remains untouched
                if (isAdjacentToLand(x, y, 1)) {
                    {
                        // Phase 2: Check boundary closeness for enhanced ruggedness
                        const i = y * iWidth + x;
                        const closenessByte = boundaryCloseness ? boundaryCloseness[i] | 0 : 0;
                        const closenessNorm = closenessByte / 255;
                        const bType = boundaryType ? boundaryType[i] | 0 : ENUM_BOUNDARY.none;
                        const nearBoundary = closenessNorm >= plateBiasCfg.threshold;
                        const plateBiasValue = boundaryCloseness
                            ? computePlateBias(closenessNorm, bType, plateBiasCfg)
                            : 0;

                        // Margin-aware: widen shelf near PASSIVE_SHELF, deepen cuts near ACTIVE_MARGIN or plate boundaries
                        let nearActive = nearBoundary, nearPassive = false;
                        for (let ddy = -1; ddy <= 1 && (!nearActive || !nearPassive); ddy++) {
                            for (let ddx = -1; ddx <= 1; ddx++) {
                                if (ddx === 0 && ddy === 0)
                                    continue;
                                const nx = x + ddx, ny = y + ddy;
                                if (nx <= 0 ||
                                    nx >= iWidth - 1 ||
                                    ny <= 0 ||
                                    ny >= iHeight - 1)
                                    continue;
                                const k = `${nx},${ny}`;
                                if (!nearActive &&
                                    StoryTags.activeMargin.has(k))
                                    nearActive = true;
                                if (!nearPassive &&
                                    StoryTags.passiveShelf.has(k))
                                    nearPassive = true;
                            }
                        }
                        const denom = Math.max(4, fjordBaseDenom -
                            (nearPassive ? fjordPassiveBonus : 0) -
                            (nearActive ? fjordActiveBonus : 0));
                        let denomUsed = _softMult !== 1
                            ? Math.max(1, Math.round(denom / _softMult))
                            : denom;
                        if (plateBiasCfg.fjordWeight > 0 && plateBiasValue !== 0) {
                            const fjScale = clamp(1 + plateBiasValue * plateBiasCfg.fjordWeight, 0.2, 5);
                            denomUsed = Math.max(1, Math.round(denomUsed / fjScale));
                        }
                        // Corridor edge effect: if adjacent to a sea-lane tile, increase fjord/coast conversion chance
                        {
                            let edgeCfg = null;
                            for (let my = -1; my <= 1 && !edgeCfg; my++) {
                                for (let mx = -1; mx <= 1; mx++) {
                                    if (mx === 0 && my === 0)
                                        continue;
                                    const kk = `${x + mx},${y + my}`;
                                    if (StoryTags.corridorSeaLane &&
                                        StoryTags.corridorSeaLane.has(kk)) {
                                        const attr = StoryTags.corridorAttributes?.get?.(kk);
                                        edgeCfg = attr && attr.edge ? attr.edge : null;
                                        if (edgeCfg)
                                            break;
                                    }
                                }
                            }
                            if (edgeCfg) {
                                const fj = Number.isFinite(edgeCfg.fjordChance)
                                    ? edgeCfg.fjordChance
                                    : 0;
                                const cliffs = Number.isFinite(edgeCfg.cliffsChance)
                                    ? edgeCfg.cliffsChance
                                    : 0;
                                // Convert combined edge effect into a denom multiplier (cap to avoid aggression)
                                const effect = Math.max(0, Math.min(0.5, fj + cliffs * 0.5));
                                if (effect > 0) {
                                    denomUsed = Math.max(1, Math.round(denomUsed * (1 - effect)));
                                }
                            }
                        }
                        if ((ctx ? ctxRandom(ctx, "Fjord Coast", denomUsed) : TerrainBuilder.getRandomNumber(denomUsed, "Fjord Coast")) === 0) {
                            applyTerrain(x, y, globals.g_CoastTerrain, false);
                        }
                    }
                }
            }
        }
    }
}
export default addRuggedCoasts;
</file>

<file path="mod/maps/layers/features.js">
// @ts-nocheck
/**
 * Features Layer  addDiverseFeatures
 *
 * Purpose
 * - Run base-standard feature generation, then apply small, validated, and
 *   climate-aware embellishments that strengthen the narrative:
 *   - Paradise reefs near hotspot paradise centers
 *   - Volcanic vegetation around volcanic centers (forests in warm/wet, taiga in cold/wet)
 *   - Gentle density tweaks for rainforest/forest/taiga in appropriate biomes
 *
 * Guardrails
 * - Always validate placements via TerrainBuilder.canHaveFeature
 * - Resolve feature indices via lookups; skip if unavailable
 * - Keep probabilities conservative and local; never create chokepoints
 * - O(width  height); small neighborhood scans only
 */
import { addFeatures as baseAddFeatures } from "/base-standard/maps/feature-biome-generator.js";
import * as globals from "/base-standard/maps/map-globals.js";
import { StoryTags } from "../story/tags.js";
import { STORY_ENABLE_HOTSPOTS, STORY_TUNABLES, FEATURES_DENSITY_CFG, } from "../bootstrap/tunables.js";
import { getFeatureTypeIndex, inBounds } from "../core/utils.js";
import { ctxRandom } from "../core/types.js";
/**
 * Add diverse features with conservative, validated tweaks.
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {import('../core/types.js').MapContext} [ctx] - Optional MapContext for adapter-based operations
 */
export function addDiverseFeatures(iWidth, iHeight, ctx) {
    console.log("Adding diverse terrain features...");
    // 1) Base-standard features (vanilla-compatible baseline)
    baseAddFeatures(iWidth, iHeight);
    // 2) Paradise reefs near hotspot paradise centers
    const reefIndex = getFeatureTypeIndex("FEATURE_REEF");
    const paradiseReefChance = STORY_TUNABLES?.features?.paradiseReefChance ?? 18;
    if (STORY_ENABLE_HOTSPOTS &&
        reefIndex !== -1 &&
        StoryTags.hotspotParadise.size > 0 &&
        paradiseReefChance > 0) {
        for (const key of StoryTags.hotspotParadise) {
            const [cx, cy] = key.split(",").map(Number);
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    if (!inBounds(nx, ny))
                        continue;
                    if (!GameplayMap.isWater(nx, ny))
                        continue;
                    if (GameplayMap.getFeatureType(nx, ny) !==
                        FeatureTypes.NO_FEATURE)
                        continue;
                    if ((ctx ? ctxRandom(ctx, "Paradise Reef", 100) : TerrainBuilder.getRandomNumber(100, "Paradise Reef")) <
                        paradiseReefChance) {
                        const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(nx, ny, reefIndex) : TerrainBuilder.canHaveFeature(nx, ny, reefIndex);
                        if (canPlace) {
                            if (ctx && ctx.adapter) {
                                ctx.adapter.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            } else {
                                TerrainBuilder.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            }
                        }
                    }
                }
            }
        }
    }
    // 2b) Reefs along passive shelves (margin-aware, modest chance)
    if (reefIndex !== -1 &&
        StoryTags.passiveShelf &&
        StoryTags.passiveShelf.size > 0) {
        // Keep this lower than paradise reefs to stay subtle.
        const shelfMult = FEATURES_DENSITY_CFG?.shelfReefMultiplier ?? 0.6;
        const shelfReefChance = Math.max(1, Math.min(100, Math.floor((paradiseReefChance || 18) * shelfMult)));
        for (const key of StoryTags.passiveShelf) {
            const [sx, sy] = key.split(",").map(Number);
            // Tight radius; shelves are linear and we don't want clutter.
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = sx + dx;
                    const ny = sy + dy;
                    if (!inBounds(nx, ny))
                        continue;
                    if (!GameplayMap.isWater(nx, ny))
                        continue;
                    if (GameplayMap.getFeatureType(nx, ny) !==
                        FeatureTypes.NO_FEATURE)
                        continue;
                    if ((ctx ? ctxRandom(ctx, "Shelf Reef", 100) : TerrainBuilder.getRandomNumber(100, "Shelf Reef")) <
                        shelfReefChance) {
                        const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(nx, ny, reefIndex) : TerrainBuilder.canHaveFeature(nx, ny, reefIndex);
                        if (canPlace) {
                            if (ctx && ctx.adapter) {
                                ctx.adapter.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            } else {
                                TerrainBuilder.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            }
                        }
                    }
                }
            }
        }
    }
    // 3) Per-tile post-pass for gentle density tweaks and volcanic vegetation
    const baseVolcanicForestChance = STORY_TUNABLES?.features?.volcanicForestChance ?? 22;
    const baseVolcanicTaigaChance = STORY_TUNABLES?.features?.volcanicTaigaChance ?? 25;
    // Slight boost to rugged vegetation near volcanic centers (kept conservative)
    const volcanicForestChance = Math.min(100, baseVolcanicForestChance + 6);
    const volcanicTaigaChance = Math.min(100, baseVolcanicTaigaChance + 5);
    const rainforestIdx = getFeatureTypeIndex("FEATURE_RAINFOREST");
    const forestIdx = getFeatureTypeIndex("FEATURE_FOREST");
    const taigaIdx = getFeatureTypeIndex("FEATURE_TAIGA");
    const rainforestExtraChance = FEATURES_DENSITY_CFG?.rainforestExtraChance ?? 55;
    const forestExtraChance = FEATURES_DENSITY_CFG?.forestExtraChance ?? 30;
    const taigaExtraChance = FEATURES_DENSITY_CFG?.taigaExtraChance ?? 35;
    for (let y = 0; y < iHeight; y++) {
        for (let x = 0; x < iWidth; x++) {
            if (GameplayMap.isWater(x, y))
                continue;
            if (GameplayMap.getFeatureType(x, y) !== FeatureTypes.NO_FEATURE)
                continue;
            const biome = GameplayMap.getBiomeType(x, y);
            const elevation = GameplayMap.getElevation(x, y);
            const rainfall = GameplayMap.getRainfall(x, y);
            const plat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            // 3a) Volcanic vegetation near volcanic hotspot centers (radius 1)
            if (STORY_ENABLE_HOTSPOTS && StoryTags.hotspotVolcanic.size > 0) {
                let nearVolcanic = false;
                for (let vdy = -1; vdy <= 1 && !nearVolcanic; vdy++) {
                    for (let vdx = -1; vdx <= 1; vdx++) {
                        if (vdx === 0 && vdy === 0)
                            continue;
                        const vx = x + vdx;
                        const vy = y + vdy;
                        if (!inBounds(vx, vy))
                            continue;
                        if (StoryTags.hotspotVolcanic.has(`${vx},${vy}`)) {
                            nearVolcanic = true;
                            break;
                        }
                    }
                }
                if (nearVolcanic) {
                    // Warm/wet: bias forest on eligible land
                    if (forestIdx !== -1 &&
                        rainfall > 95 &&
                        (biome === globals.g_GrasslandBiome ||
                            biome === globals.g_TropicalBiome)) {
                        if ((ctx ? ctxRandom(ctx, "Volcanic Forest", 100) : TerrainBuilder.getRandomNumber(100, "Volcanic Forest")) < volcanicForestChance) {
                            const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, forestIdx) : TerrainBuilder.canHaveFeature(x, y, forestIdx);
                            if (canPlace) {
                                if (ctx && ctx.adapter) {
                                    ctx.adapter.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                                } else {
                                    TerrainBuilder.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                                }
                                continue; // placed a feature; skip other tweaks on this tile
                            }
                        }
                    }
                    // Cold/wet: bias taiga in suitable tundra pockets
                    if (taigaIdx !== -1 &&
                        plat >= 55 &&
                        biome === globals.g_TundraBiome &&
                        elevation < 400 &&
                        rainfall > 60) {
                        if ((ctx ? ctxRandom(ctx, "Volcanic Taiga", 100) : TerrainBuilder.getRandomNumber(100, "Volcanic Taiga")) < volcanicTaigaChance) {
                            const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, taigaIdx) : TerrainBuilder.canHaveFeature(x, y, taigaIdx);
                            if (canPlace) {
                                if (ctx && ctx.adapter) {
                                    ctx.adapter.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                                } else {
                                    TerrainBuilder.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                                }
                                continue;
                            }
                        }
                    }
                }
            }
            // 3b) Gentle density tweaks (validated)
            // Enhanced jungle in tropical high-rainfall areas
            if (rainforestIdx !== -1 &&
                biome === globals.g_TropicalBiome &&
                rainfall > 130) {
                if ((ctx ? ctxRandom(ctx, "Extra Jungle", 100) : TerrainBuilder.getRandomNumber(100, "Extra Jungle")) <
                    rainforestExtraChance) {
                    const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, rainforestIdx) : TerrainBuilder.canHaveFeature(x, y, rainforestIdx);
                    if (canPlace) {
                        if (ctx && ctx.adapter) {
                            ctx.adapter.setFeatureType(x, y, { Feature: rainforestIdx, Direction: -1, Elevation: 0 });
                        } else {
                            TerrainBuilder.setFeatureType(x, y, { Feature: rainforestIdx, Direction: -1, Elevation: 0 });
                        }
                        continue;
                    }
                }
            }
            // Enhanced forests in temperate grasslands
            if (forestIdx !== -1 &&
                biome === globals.g_GrasslandBiome &&
                rainfall > 100) {
                if ((ctx ? ctxRandom(ctx, "Extra Forest", 100) : TerrainBuilder.getRandomNumber(100, "Extra Forest")) <
                    forestExtraChance) {
                    const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, forestIdx) : TerrainBuilder.canHaveFeature(x, y, forestIdx);
                    if (canPlace) {
                        if (ctx && ctx.adapter) {
                            ctx.adapter.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                        } else {
                            TerrainBuilder.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                        }
                        continue;
                    }
                }
            }
            // Taiga in cold areas (low elevation)
            if (taigaIdx !== -1 &&
                biome === globals.g_TundraBiome &&
                elevation < 300) {
                if ((ctx ? ctxRandom(ctx, "Extra Taiga", 100) : TerrainBuilder.getRandomNumber(100, "Extra Taiga")) <
                    taigaExtraChance) {
                    const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, taigaIdx) : TerrainBuilder.canHaveFeature(x, y, taigaIdx);
                    if (canPlace) {
                        if (ctx && ctx.adapter) {
                            ctx.adapter.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                        } else {
                            TerrainBuilder.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                        }
                        continue;
                    }
                }
            }
        }
    }
}
export default addDiverseFeatures;
</file>

<file path="mod/maps/layers/islands.js">
// @ts-nocheck
/**
 * Islands Layer  addIslandChains
 *
 * Seeds tiny offshore island clusters using a sparse fractal mask, with
 * additional alignment/bias along previously tagged hotspot trails to create
 * legible chains. Some hotspot centers are classified as paradise (reeffriendly,
 * lusher), others as volcanic (occasional cone peeking above the sea; tougher
 * vegetation nearby). Feature/biome micro-tweaks occur in other layers; this
 * module only handles terrain placement and StoryTag classification.
 *
 * Guardrails
 * - Preserves open sea lanes by avoiding tiles within a small radius of land.
 * - Keeps clusters tiny (13 tiles; 12 when hotspotbiased).
 * - Leaves heavy validation to feature layers (reefs/vegetation are validated there).
 * - O(width  height) with constant-time local checks.
 */
import * as globals from "/base-standard/maps/map-globals.js";
import { StoryTags } from "../story/tags.js";
import { STORY_TUNABLES, ISLANDS_CFG, CORRIDORS_CFG, } from "../bootstrap/tunables.js";
import { isAdjacentToLand, storyKey } from "../core/utils.js";
import { ctxRandom, writeHeightfield } from "../core/types.js";
/**
 * Place small island clusters in deep water, with hotspot bias.
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {import('../core/types.js').MapContext} [ctx] - Optional MapContext for adapter-based operations
 */
export function addIslandChains(iWidth, iHeight, ctx) {
    // Sparse mask: use mountain fractal as a high-threshold trigger
    FractalBuilder.create(globals.g_HillFractal, iWidth, iHeight, 5, 0);
    const fracPct = (ISLANDS_CFG?.fractalThresholdPercent ?? 90) | 0;
    const threshold = FractalBuilder.getHeightFromPercent(globals.g_HillFractal, Math.max(0, Math.min(100, fracPct)));
    // Tunables for hotspot classification and cone peeking
    const paradiseWeight = (STORY_TUNABLES?.hotspot?.paradiseBias ?? 2) | 0; // default 2
    const volcanicWeight = (STORY_TUNABLES?.hotspot?.volcanicBias ?? 1) | 0; // default 1
    const peakPercent = Math.max(0, Math.min(100, Math.round((STORY_TUNABLES?.hotspot?.volcanicPeakChance ?? 0.33) * 100) + 10));
    const applyTerrain = (tileX, tileY, terrain, isLand) => {
        if (ctx) {
            writeHeightfield(ctx, tileX, tileY, { terrain, isLand });
        }
        else {
            TerrainBuilder.setTerrainType(tileX, tileY, terrain);
        }
    };
    for (let y = 2; y < iHeight - 2; y++) {
        for (let x = 2; x < iWidth - 2; x++) {
            if (!GameplayMap.isWater(x, y))
                continue;
            // Keep islands away from existing land to preserve lanes
            const minDist = (ISLANDS_CFG?.minDistFromLandRadius ?? 2) | 0;
            if (isAdjacentToLand(x, y, Math.max(0, minDist)))
                continue;
            // Respect strategic sea-lane corridors: skip tiles near protected lanes
            const laneRadius = (CORRIDORS_CFG?.sea?.avoidRadius ?? 2) | 0;
            if (laneRadius > 0 &&
                StoryTags.corridorSeaLane &&
                StoryTags.corridorSeaLane.size > 0) {
                let nearSeaLane = false;
                for (let my = -laneRadius; my <= laneRadius && !nearSeaLane; my++) {
                    for (let mx = -laneRadius; mx <= laneRadius; mx++) {
                        const kk = storyKey(x + mx, y + my);
                        if (StoryTags.corridorSeaLane.has(kk)) {
                            nearSeaLane = true;
                            break;
                        }
                    }
                }
                if (nearSeaLane)
                    continue;
            }
            const v = FractalBuilder.getHeight(globals.g_HillFractal, x, y);
            const isHotspot = StoryTags.hotspot.has(storyKey(x, y));
            // Margin context (adjacent coastal segments tagged by margins)
            let nearActive = false;
            let nearPassive = false;
            for (let my = -1; my <= 1 && (!nearActive || !nearPassive); my++) {
                for (let mx = -1; mx <= 1; mx++) {
                    if (mx === 0 && my === 0)
                        continue;
                    const k = storyKey(x + mx, y + my);
                    if (!nearActive &&
                        StoryTags.activeMargin &&
                        StoryTags.activeMargin.has(k))
                        nearActive = true;
                    if (!nearPassive &&
                        StoryTags.passiveShelf &&
                        StoryTags.passiveShelf.has(k))
                        nearPassive = true;
                }
            }
            // Base sparse placement vs. hotspot- and margin-biased placement
            const denActive = (ISLANDS_CFG?.baseIslandDenNearActive ?? 5) | 0;
            const denElse = (ISLANDS_CFG?.baseIslandDenElse ?? 7) | 0;
            const baseIslandDen = nearActive ? denActive : denElse; // slightly more islands along active margins
            const baseAllowed = v > threshold &&
                (ctx ? ctxRandom(ctx, "Island Seed", baseIslandDen) : TerrainBuilder.getRandomNumber(baseIslandDen, "Island Seed")) ===
                    0;
            const hotspotAllowed = isHotspot &&
                (ctx ? ctxRandom(ctx, "Hotspot Island Seed", Math.max(1, (ISLANDS_CFG?.hotspotSeedDenom ?? 2) | 0)) : TerrainBuilder.getRandomNumber(Math.max(1, (ISLANDS_CFG?.hotspotSeedDenom ?? 2) | 0), "Hotspot Island Seed")) === 0;
            if (!(baseAllowed || hotspotAllowed))
                continue;
            // Default to coast water; occasionally let a volcanic center peek as land
            let centerTerrain = globals.g_CoastTerrain;
            let classifyParadise = false;
            if (isHotspot) {
                // Along passive shelves, slightly bias toward "paradise" centers
                const pWeight = paradiseWeight + (nearPassive ? 1 : 0);
                const vWeight = volcanicWeight;
                const bucket = pWeight + vWeight;
                const roll = ctx ? ctxRandom(ctx, "HotspotKind", bucket || 1) : TerrainBuilder.getRandomNumber(bucket || 1, "HotspotKind");
                classifyParadise = roll < pWeight;
                if (!classifyParadise) {
                    // Volcanic: rare cone peeking above sea level
                    if ((ctx ? ctxRandom(ctx, "HotspotPeak", 100) : TerrainBuilder.getRandomNumber(100, "HotspotPeak")) <
                        peakPercent) {
                        centerTerrain = globals.g_FlatTerrain;
                    }
                }
            }
            // Place center tile
            const centerIsLand = centerTerrain !== globals.g_CoastTerrain && centerTerrain !== globals.g_OceanTerrain;
            applyTerrain(x, y, centerTerrain, centerIsLand);
            // Classify center for downstream microclimates/features
            if (isHotspot) {
                if (classifyParadise) {
                    StoryTags.hotspotParadise.add(storyKey(x, y));
                }
                else {
                    StoryTags.hotspotVolcanic.add(storyKey(x, y));
                }
            }
            // Create a tiny cluster around the center (smaller for hotspot-biased)
            const maxCluster = Math.max(1, (ISLANDS_CFG?.clusterMax ?? 3) | 0);
            const count = 1 + (ctx ? ctxRandom(ctx, "Island Size", maxCluster) : TerrainBuilder.getRandomNumber(maxCluster, "Island Size"));
            for (let n = 0; n < count; n++) {
                const dx = (ctx ? ctxRandom(ctx, "dx", 3) : TerrainBuilder.getRandomNumber(3, "dx")) - 1;
                const dy = (ctx ? ctxRandom(ctx, "dy", 3) : TerrainBuilder.getRandomNumber(3, "dy")) - 1;
                const nx = x + dx;
                const ny = y + dy;
                if (nx <= 0 || nx >= iWidth - 1 || ny <= 0 || ny >= iHeight - 1)
                    continue;
                if (!GameplayMap.isWater(nx, ny))
                    continue;
                applyTerrain(nx, ny, globals.g_CoastTerrain, false);
            }
        }
    }
}
export default addIslandChains;
</file>

<file path="mod/maps/layers/landmass_plate.js">
// @ts-nocheck
/**
 * Plate-driven landmass generator
 *
 * Uses Civ VII WorldModel plate fields to carve land and ocean before the
 * remainder of the Swooper pipeline runs. The algorithm ranks tiles by plate
 * interior "stability" (WorldModel.shieldStability) and selects the highest
 * scoring tiles until the configured land/sea ratio is satisfied, while also
 * respecting boundary closeness to preserve coastlines.
 */

import * as globals from "/base-standard/maps/map-globals.js";
import { LANDMASS_CFG } from "../bootstrap/tunables.js";
import { WorldModel } from "../world/model.js";
import { writeHeightfield } from "../core/types.js";

// Default closeness gating for land selection. We keep the full 0255 band so
// that boundary tiles remain eligible; presets can still clamp via geometry.post.
const DEFAULT_CLOSENESS_LIMIT = 255;
const CLOSENESS_STEP_PER_TILE = 8;
const MIN_CLOSENESS_LIMIT = 150;
const MAX_CLOSENESS_LIMIT = 255;

const BOUNDARY_TYPE = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});
// Reserve a dedicated tectonic fractal slot for interior noise and arc raggedness.
// Base-standard maps typically claim 0..2; we keep 3 for Swooper tectonics.
const FRACTAL_TECTONIC_ID = 3;

/**
 * Create landmasses using plate stability metrics.
 *
 * @param {number} width
 * @param {number} height
 * @param {import("../core/types.js").MapContext} [ctx]
 * @param {{ landmassCfg?: any, geometry?: any }} [options]
 * @returns {{ windows: Array<{west:number,east:number,south:number,north:number,continent:number}>, startRegions?: {westContinent?:any,eastContinent?:any}, landMask: Uint8Array }|null}
 */
export function createPlateDrivenLandmasses(width, height, ctx, options = {}) {
    if (!WorldModel || typeof WorldModel.isEnabled !== "function" || !WorldModel.isEnabled()) {
        return null;
    }
    const shield = WorldModel.shieldStability;
    const closeness = WorldModel.boundaryCloseness;
    const boundaryType = WorldModel.boundaryType;
    const plateIds = WorldModel.plateId;
    if (!shield || !closeness || !boundaryType || !plateIds) {
        return null;
    }
    const size = width * height;
    if (shield.length !== size || closeness.length !== size || boundaryType.length !== size || plateIds.length !== size) {
        return null;
    }
    const landmassCfg = options.landmassCfg || LANDMASS_CFG || {};
    // Keep a modest bias toward margins but clamp to a core-first band.
    const boundaryBias = clampInt(
        Number.isFinite(landmassCfg.boundaryBias) ? landmassCfg.boundaryBias : 0.25,
        0,
        0.4
    );
    const boundaryShareTarget = Number.isFinite(landmassCfg.boundaryShareTarget)
        ? Math.max(0, Math.min(1, landmassCfg.boundaryShareTarget))
        : 0.15;
    const tectonicsCfg = landmassCfg.tectonics || {};
    const interiorNoiseWeight = clamp01(tectonicsCfg.interiorNoiseWeight, 0.3);
    const arcWeight = clampRange(tectonicsCfg.boundaryArcWeight, 0.8, 0, 2);
    const arcNoiseWeight = clamp01(tectonicsCfg.boundaryArcNoiseWeight, 0.5);
    const fractalGrain = clampInt(
        Number.isFinite(tectonicsCfg.fractalGrain) ? tectonicsCfg.fractalGrain : 4,
        1,
        32
    );
    const geomCfg = options.geometry || {};
    const postCfg = geomCfg.post || {};

    // Earth-like baseline water coverage with a scalar to nudge wetter/drier worlds.
    const baseWaterPct = clampPct(landmassCfg.baseWaterPercent, 0, 100, 64);
    const waterScalar = clampPct(
        Number.isFinite(landmassCfg.waterScalar) ? landmassCfg.waterScalar * 100 : 100,
        25,
        175,
        100
    ) / 100;
    const waterPct = clampPct(baseWaterPct * waterScalar, 0, 100, baseWaterPct);
    const totalTiles = size || 1;
    const targetLandTiles = Math.max(1, Math.min(totalTiles - 1, Math.round(totalTiles * (1 - waterPct / 100))));

    // Allow high-closeness tiles to become land when scored high.
    const closenessLimit = computeClosenessLimit(postCfg);
    const adapter = ctx?.adapter;
    const useFractal = !!(
        adapter &&
        typeof adapter.createFractal === "function" &&
        typeof adapter.getFractalHeight === "function" &&
        (interiorNoiseWeight > 0 || arcNoiseWeight > 0)
    );
    if (useFractal) {
        adapter.createFractal(FRACTAL_TECTONIC_ID, width, height, fractalGrain, 0);
    }
    const baseInteriorWeight = 1 - interiorNoiseWeight;
    const interiorScore = new Uint16Array(size);
    const arcScore = new Uint16Array(size);
    const landScore = new Uint16Array(size);
    // Debug stats to validate score ranges before thresholding.
    let interiorMin = 255, interiorMax = 0, interiorSum = 0;
    let arcMin = 255, arcMax = 0, arcSum = 0;
    let landMin = 255, landMax = 0, landSum = 0;

    for (let y = 0; y < height; y++) {
        const rowOffset = y * width;
        for (let x = 0; x < width; x++) {
            const idx = rowOffset + x;
            const closenessVal = closeness[idx] | 0;
            const interiorBase = 255 - closenessVal;

            // --- Interior score: plate core + tectonic noise ---
            let noise255 = 128;
            if (useFractal && interiorNoiseWeight > 0) {
                const raw = adapter.getFractalHeight(FRACTAL_TECTONIC_ID, x, y) | 0;
                noise255 = raw >>> 8; // downscale 0..65535  0..255
            }
            const centeredNoise = noise255 - 128; // -128..127
            const noisyInterior = interiorBase * baseInteriorWeight + centeredNoise * interiorNoiseWeight;
            const clampedInterior = noisyInterior < 0 ? 0 : noisyInterior > 255 ? 255 : noisyInterior;
            const interiorVal = clampedInterior & 0xff;
            interiorScore[idx] = interiorVal;
            interiorMin = Math.min(interiorMin, interiorVal);
            interiorMax = Math.max(interiorMax, interiorVal);
            interiorSum += interiorVal;

            // --- Arc score: convergent uplift / island arcs ---
            const bType = boundaryType[idx] | 0;
            const rawArc = closenessVal;
            let arc = rawArc;
            if (bType === BOUNDARY_TYPE.convergent) {
                arc = rawArc * arcWeight;
            }
            else if (bType === BOUNDARY_TYPE.divergent) {
                arc = rawArc * 0.25;
            }
            else {
                arc = rawArc * 0.5;
            }
            if (useFractal && arcNoiseWeight > 0) {
                const raw = adapter.getFractalHeight(FRACTAL_TECTONIC_ID, x, y) | 0;
                const noiseNorm = (raw >>> 8) / 255; // 0..1
                const noiseMix = 1.0 + (noiseNorm - 0.5) * arcNoiseWeight; // ~[0.75, 1.25] scaled by weight
                arc *= noiseMix;
            }
            if (boundaryBias > 0) {
                arc += closenessVal * boundaryBias;
            }
            const clampedArc = arc < 0 ? 0 : arc > 255 ? 255 : arc;
            arcScore[idx] = clampedArc & 0xff;
            arcMin = Math.min(arcMin, arcScore[idx]);
            arcMax = Math.max(arcMax, arcScore[idx]);
            arcSum += arcScore[idx];

            // --- Final land score: core vs boundary uplift ---
            const l = interiorVal >= clampedArc ? interiorVal : clampedArc;
            landScore[idx] = l;
            landMin = Math.min(landMin, l);
            landMax = Math.max(landMax, l);
            landSum += l;
        }
    }

    const computeLandScore = (idx) => landScore[idx] | 0;

    const countTilesAboveTyped = (threshold) => {
        let count = 0;
        for (let i = 0; i < size; i++) {
            const score = computeLandScore(i);
            if (score >= threshold && closeness[i] <= closenessLimit) {
                count++;
            }
        }
        return count;
    };

    // Distribution and sanity logs to avoid zero-land failures.
    const thresholdsProbe = [32, 64, 96, 128, 160, 192, 224];
    const probeCounts = thresholdsProbe.map((t) => ({
        threshold: t,
        count: countTilesAboveTyped(t),
    }));

    console.log(
        "[Landmass][Debug] score ranges",
        JSON.stringify({
            width,
            height,
            targetLandTiles,
            closenessLimit,
            boundaryBias,
            boundaryShareTarget,
            interiorNoiseWeight,
            arcWeight,
            arcNoiseWeight,
            fractalGrain,
            useFractal,
            interior: {
                min: interiorMin,
                max: interiorMax,
                avg: Number((interiorSum / totalTiles).toFixed(2)),
            },
            arc: {
                min: arcMin,
                max: arcMax,
                avg: Number((arcSum / totalTiles).toFixed(2)),
            },
            land: {
                min: landMin,
                max: landMax,
                avg: Number((landSum / totalTiles).toFixed(2)),
            },
            probes: probeCounts,
        })
    );

    // Binary search threshold to hit target land count.
    let low = 0;
    let high = 255;
    let bestThreshold = 128;
    let bestDiff = Number.POSITIVE_INFINITY;
    let bestCount = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const count = countTilesAboveTyped(mid);
        const diff = Math.abs(count - targetLandTiles);
        if (diff < bestDiff || (diff === bestDiff && count > bestCount)) {
            bestDiff = diff;
            bestThreshold = mid;
            bestCount = count;
        }
        if (count > targetLandTiles) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    // Ensure a minimum share of land within the high-closeness band near boundaries.
    const boundaryBand = (closenessArr, idx) => (closenessArr[idx] | 0) >= 90;
    const computeShares = (threshold) => {
        let land = 0, boundaryLand = 0, convergentLand = 0;
        for (let i = 0; i < size; i++) {
            const score = computeLandScore(i);
            const isLand = score >= threshold && closeness[i] <= closenessLimit;
            if (isLand) {
                land++;
                if (boundaryBand(closeness, i)) boundaryLand++;
                if (boundaryType[i] === BOUNDARY_TYPE.convergent) convergentLand++;
            }
        }
        return { land, boundaryLand, convergentLand };
    };

    let { land: landCount, boundaryLand } = computeShares(bestThreshold);
    const minBoundary = Math.round(targetLandTiles * boundaryShareTarget);
    if (boundaryLand < minBoundary) {
        const maxAllowedLand = Math.round(targetLandTiles * 1.03);
        let t = bestThreshold - 5;
        while (t >= 0) {
            const shares = computeShares(t);
            landCount = shares.land;
            boundaryLand = shares.boundaryLand;
            if (boundaryLand >= minBoundary) {
                bestThreshold = t;
                break;
            }
            if (landCount > maxAllowedLand) {
                break;
            }
            t -= 5;
        }
    }

    const landMask = new Uint8Array(size);
    let finalLandTiles = 0;
    let convergentLandCount = 0;
    let divergentOceanCount = 0;
    for (let y = 0; y < height; y++) {
        const rowOffset = y * width;
        for (let x = 0; x < width; x++) {
            const idx = rowOffset + x;
            const score = computeLandScore(idx);
            const isLand = score >= bestThreshold && closeness[idx] <= closenessLimit;
            if (isLand) {
                if (boundaryType[idx] === BOUNDARY_TYPE.convergent) convergentLandCount++;
                landMask[idx] = 1;
                finalLandTiles++;
                if (ctx) {
                    writeHeightfield(ctx, x, y, {
                        terrain: globals.g_FlatTerrain,
                        elevation: 0,
                        isLand: true,
                    });
                }
                else {
                    setTerrain(null, x, y, globals.g_FlatTerrain);
                }
            }
            else {
                if (boundaryType[idx] === BOUNDARY_TYPE.divergent) divergentOceanCount++;
                landMask[idx] = 0;
                if (ctx) {
                    writeHeightfield(ctx, x, y, {
                        terrain: globals.g_OceanTerrain,
                        elevation: -1,
                        isLand: false,
                    });
                }
                else {
                    setTerrain(null, x, y, globals.g_OceanTerrain);
                }
            }
        }
    }

    console.log(
        `[Landmass] Core-vs-boundary scoring: threshold=${bestThreshold}, land=${finalLandTiles}, convergentLand=${convergentLandCount}, divergentOcean=${divergentOceanCount}, boundaryShare=${boundaryLand}/${Math.round(
            targetLandTiles * boundaryShareTarget
        )}`
    );

    // Derive bounding boxes per plate for downstream start placement heuristics.
    const plateStats = new Map();
    for (let idx = 0; idx < size; idx++) {
        if (!landMask[idx])
            continue;
        const plateId = plateIds[idx];
        if (plateId == null || plateId < 0)
            continue;
        const y = Math.floor(idx / width);
        const x = idx - y * width;
        let stat = plateStats.get(plateId);
        if (!stat) {
            stat = {
                plateId,
                count: 0,
                minX: width,
                maxX: -1,
                minY: height,
                maxY: -1,
            };
            plateStats.set(plateId, stat);
        }
        stat.count++;
        if (x < stat.minX)
            stat.minX = x;
        if (x > stat.maxX)
            stat.maxX = x;
        if (y < stat.minY)
            stat.minY = y;
        if (y > stat.maxY)
            stat.maxY = y;
    }

    const minWidth = postCfg.minWidthTiles ? Math.max(1, Math.trunc(postCfg.minWidthTiles)) : 0;
    const polarRows = globals.g_PolarWaterRows ?? 0;

    const windows = Array.from(plateStats.values())
        .filter((s) => s.count > 0 && s.maxX >= s.minX && s.maxY >= s.minY)
        .map((s) => {
        const expand = postCfg.expandTiles ? Math.trunc(postCfg.expandTiles) : 0;
        const expandWest = postCfg.expandWestTiles ? Math.trunc(postCfg.expandWestTiles) : 0;
        const expandEast = postCfg.expandEastTiles ? Math.trunc(postCfg.expandEastTiles) : 0;
        let west = Math.max(0, s.minX - Math.max(0, expand + expandWest));
        let east = Math.min(width - 1, s.maxX + Math.max(0, expand + expandEast));
        if (minWidth > 0) {
            const span = east - west + 1;
            if (span < minWidth) {
                const deficit = minWidth - span;
                const extraWest = Math.floor(deficit / 2);
                const extraEast = deficit - extraWest;
                west = Math.max(0, west - extraWest);
                east = Math.min(width - 1, east + extraEast);
            }
        }
        if (postCfg.clampWestMin != null) {
            west = Math.max(west, Math.max(0, Math.trunc(postCfg.clampWestMin)));
        }
        if (postCfg.clampEastMax != null) {
            east = Math.min(east, Math.min(width - 1, Math.trunc(postCfg.clampEastMax)));
        }
        const verticalPad = Math.max(0, expand);
        const baseSouth = Math.max(polarRows, s.minY - verticalPad);
        const baseNorth = Math.min(height - polarRows, s.maxY + verticalPad);
        const south = postCfg.overrideSouth != null
            ? clampInt(Math.trunc(postCfg.overrideSouth), 0, height - 1)
            : clampInt(baseSouth, 0, height - 1);
        const north = postCfg.overrideNorth != null
            ? clampInt(Math.trunc(postCfg.overrideNorth), 0, height - 1)
            : clampInt(baseNorth, 0, height - 1);
        return {
            plateId: s.plateId,
            west,
            east,
            south,
            north,
            centerX: (west + east) * 0.5,
            count: s.count,
        };
    })
        .sort((a, b) => a.centerX - b.centerX);

    const windowsOut = windows.map((win, index) => ({
        west: win.west,
        east: win.east,
        south: win.south,
        north: win.north,
        continent: index,
    }));

    let startRegions = null;
    if (windowsOut.length >= 2) {
        startRegions = {
            westContinent: Object.assign({}, windowsOut[0]),
            eastContinent: Object.assign({}, windowsOut[windowsOut.length - 1]),
        };
    }

    if (ctx?.buffers?.heightfield?.landMask) {
        ctx.buffers.heightfield.landMask.set(landMask);
    }

    return {
        windows: windowsOut,
        startRegions,
        landMask,
        landTiles: finalLandTiles,
        threshold: bestThreshold,
    };
}

function computeClosenessLimit(postCfg) {
    const expand = postCfg && postCfg.expandTiles ? Math.trunc(postCfg.expandTiles) : 0;
    const limit = DEFAULT_CLOSENESS_LIMIT + expand * CLOSENESS_STEP_PER_TILE;
    return clampInt(limit, MIN_CLOSENESS_LIMIT, MAX_CLOSENESS_LIMIT);
}

function countTilesAbove(shield, closeness, threshold, closenessLimit, boundaryBias = 0) {
    const bias = Math.max(0, boundaryBias);
    let count = 0;
    for (let i = 0; i < shield.length; i++) {
        const score = (shield[i] | 0) + Math.round((closeness[i] | 0) * bias);
        if (score >= threshold && closeness[i] <= closenessLimit) {
            count++;
        }
    }
    return count;
}

function setTerrain(adapter, x, y, terrainType) {
    if (adapter) {
        adapter.setTerrainType(x, y, terrainType);
    }
    else {
        TerrainBuilder.setTerrainType(x, y, terrainType);
    }
}

function clampPct(value, min, max, fallback) {
    if (!Number.isFinite(value))
        return fallback;
    const v = Math.max(min, Math.min(max, value));
    return v;
}

function clampInt(value, min, max) {
    if (!Number.isFinite(value))
        return min;
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

function clamp01(value, fallback = 0) {
    if (!Number.isFinite(value))
        return fallback;
    if (value < 0)
        return 0;
    if (value > 1)
        return 1;
    return value;
}

function clampRange(value, fallback, min, max) {
    if (!Number.isFinite(value))
        return fallback;
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

export default createPlateDrivenLandmasses;
</file>

<file path="mod/maps/layers/landmass_utils.js">
// @ts-nocheck
/* global TerrainBuilder */
/**
 * Shared helpers for landmass generation.
 */

import * as globals from "/base-standard/maps/map-globals.js";
import { FOUNDATION_OCEAN_SEPARATION } from "../bootstrap/tunables.js";
import { WorldModel } from "../world/model.js";
import { writeHeightfield } from "../core/types.js";

/**
 * Apply geometry post-processing adjustments defined in config.
 *
 * @param {Array<{west:number,east:number,south:number,north:number,continent:number}>} windows
 * @param {any} geometry
 * @param {number} width
 * @param {number} height
 */
export function applyLandmassPostAdjustments(windows, geometry, width, height) {
    if (!Array.isArray(windows) || windows.length === 0)
        return windows;
    const post = geometry?.post;
    if (!post || typeof post !== "object")
        return windows;
    const expandAll = Number.isFinite(post.expandTiles) ? Math.trunc(post.expandTiles) : 0;
    const expandWest = Number.isFinite(post.expandWestTiles) ? Math.trunc(post.expandWestTiles) : 0;
    const expandEast = Number.isFinite(post.expandEastTiles) ? Math.trunc(post.expandEastTiles) : 0;
    const clampWest = Number.isFinite(post.clampWestMin) ? Math.max(0, Math.trunc(post.clampWestMin)) : null;
    const clampEast = Number.isFinite(post.clampEastMax) ? Math.min(width - 1, Math.trunc(post.clampEastMax)) : null;
    const overrideSouth = Number.isFinite(post.overrideSouth) ? clampInt(Math.trunc(post.overrideSouth), 0, height - 1) : null;
    const overrideNorth = Number.isFinite(post.overrideNorth) ? clampInt(Math.trunc(post.overrideNorth), 0, height - 1) : null;
    const minWidth = Number.isFinite(post.minWidthTiles) ? Math.max(0, Math.trunc(post.minWidthTiles)) : null;
    let changed = false;
    const adjusted = windows.map((win) => {
        if (!win)
            return win;
        let west = clampInt(win.west | 0, 0, width - 1);
        let east = clampInt(win.east | 0, 0, width - 1);
        let south = clampInt(win.south | 0, 0, height - 1);
        let north = clampInt(win.north | 0, 0, height - 1);
        const expansionWest = expandAll + expandWest;
        const expansionEast = expandAll + expandEast;
        if (expansionWest > 0)
            west = clampInt(west - expansionWest, 0, width - 1);
        if (expansionEast > 0)
            east = clampInt(east + expansionEast, 0, width - 1);
        if (clampWest != null)
            west = Math.max(west, clampWest);
        if (clampEast != null)
            east = Math.min(east, clampEast);
        if (minWidth != null && minWidth > 0) {
            const span = east - west + 1;
            if (span < minWidth) {
                const deficit = minWidth - span;
                const extraWest = Math.floor(deficit / 2);
                const extraEast = deficit - extraWest;
                west = clampInt(west - extraWest, 0, width - 1);
                east = clampInt(east + extraEast, 0, width - 1);
            }
        }
        if (overrideSouth != null)
            south = overrideSouth;
        if (overrideNorth != null)
            north = overrideNorth;
        const mutated = west !== win.west || east !== win.east || south !== win.south || north !== win.north;
        if (mutated)
            changed = true;
        if (!mutated)
            return win;
        return {
            west,
            east,
            south,
            north,
            continent: win.continent,
        };
    });
    return changed ? adjusted : windows;
}

function clampInt(value, min, max) {
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

/**
 * Apply plate-aware ocean separation to landmasses after generation.
 *
 * Widens or narrows ocean channels based on WorldModel boundary closeness,
 * mutating both the supplied land mask (when available) and returning updated
 * landmass windows for downstream consumers.
 *
 * @param {{
 *   width: number,
 *   height: number,
 *   windows: ReadonlyArray<{west:number,east:number,south:number,north:number,continent?:number}>,
 *   landMask?: Uint8Array | null,
 *   context?: import("../core/types.js").MapContext | null,
 *   adapter?: { setTerrainType?(x:number,y:number,terrain:number):void } | null,
 *   policy?: any,
 *   worldModel?: typeof WorldModel | null,
 * }} params
 * @returns {{ windows: Array<{west:number,east:number,south:number,north:number,continent:number}>, landMask?: Uint8Array }}
 */
export function applyPlateAwareOceanSeparation(params) {
    const width = params?.width | 0;
    const height = params?.height | 0;
    const windows = Array.isArray(params?.windows) ? params.windows : [];
    if (!width || !height || windows.length === 0) {
        return { windows: windows.map((win, idx) => normalizeWindow(win, idx, width, height)) };
    }
    const ctx = params?.context ?? null;
    const adapter = params?.adapter && typeof params.adapter.setTerrainType === "function"
        ? params.adapter
        : null;
    const worldModel = params?.worldModel ?? WorldModel;
    const policy = params?.policy || worldModel?.policy?.oceanSeparation || FOUNDATION_OCEAN_SEPARATION;
    if (!policy || !policy.enabled || !worldModel || typeof worldModel.isEnabled !== "function" || !worldModel.isEnabled()) {
        return {
            windows: windows.map((win, idx) => normalizeWindow(win, idx, width, height)),
            landMask: params?.landMask ?? undefined,
        };
    }
    const closeness = worldModel.boundaryCloseness;
    if (!closeness || closeness.length !== width * height) {
        return {
            windows: windows.map((win, idx) => normalizeWindow(win, idx, width, height)),
            landMask: params?.landMask ?? undefined,
        };
    }
    const landMask = params?.landMask instanceof Uint8Array && params.landMask.length === width * height
        ? params.landMask
        : null;
    const heightfield = ctx?.buffers?.heightfield;
    const bandPairs = Array.isArray(policy.bandPairs) && policy.bandPairs.length
        ? policy.bandPairs
        : [
            [0, 1],
            [1, 2],
        ];
    const baseSeparation = Math.max(0, policy.baseSeparationTiles | 0 || 0);
    const closenessMultiplier = Number.isFinite(policy.boundaryClosenessMultiplier)
        ? policy.boundaryClosenessMultiplier
        : 1.0;
    const maxPerRow = Math.max(0, policy.maxPerRowDelta | 0 || 3);
    const rowStates = windows.map((win, idx) => createRowState(win, idx, width, height));
    const setTerrain = (x, y, terrain, isLand) => {
        if (x < 0 || x >= width || y < 0 || y >= height)
            return;
        const idx = y * width + x;
        if (landMask) {
            landMask[idx] = isLand ? 1 : 0;
        }
        if (ctx) {
            writeHeightfield(ctx, x, y, {
                terrain,
                isLand,
            });
        }
        else if (adapter) {
            adapter.setTerrainType(x, y, terrain);
        }
        else {
            TerrainBuilder.setTerrainType(x, y, terrain);
        }
        if (heightfield && !landMask) {
            heightfield.landMask[idx] = isLand ? 1 : 0;
        }
    };
    const carveOceanFromEast = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let removed = 0;
        let x = state.east[y];
        const limit = state.west[y];
        const rowOffset = y * width;
        while (removed < tiles && x >= limit) {
            const idx = rowOffset + x;
            if (!landMask || landMask[idx]) {
                setTerrain(x, y, globals.g_OceanTerrain, false);
                removed++;
            }
            x--;
        }
        state.east[y] = clampInt(state.east[y] - removed, limit, width - 1);
        return removed;
    };
    const carveOceanFromWest = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let removed = 0;
        let x = state.west[y];
        const limit = state.east[y];
        const rowOffset = y * width;
        while (removed < tiles && x <= limit) {
            const idx = rowOffset + x;
            if (!landMask || landMask[idx]) {
                setTerrain(x, y, globals.g_OceanTerrain, false);
                removed++;
            }
            x++;
        }
        state.west[y] = clampInt(state.west[y] + removed, 0, limit);
        return removed;
    };
    const fillLandFromWest = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let added = 0;
        let x = state.west[y] - 1;
        while (added < tiles && x >= 0) {
            setTerrain(x, y, globals.g_FlatTerrain, true);
            added++;
            x--;
        }
        state.west[y] = clampInt(state.west[y] - added, 0, width - 1);
        return added;
    };
    const fillLandFromEast = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let added = 0;
        let x = state.east[y] + 1;
        while (added < tiles && x < width) {
            setTerrain(x, y, globals.g_FlatTerrain, true);
            added++;
            x++;
        }
        state.east[y] = clampInt(state.east[y] + added, 0, width - 1);
        return added;
    };
    for (const pair of bandPairs) {
        const li = Array.isArray(pair) ? pair[0] | 0 : -1;
        const ri = Array.isArray(pair) ? pair[1] | 0 : -1;
        const left = rowStates[li];
        const right = rowStates[ri];
        if (!left || !right)
            continue;
        const rowStart = Math.max(0, Math.max(left.south, right.south));
        const rowEnd = Math.min(height - 1, Math.min(left.north, right.north));
        for (let y = rowStart; y <= rowEnd; y++) {
            const mid = clampInt(Math.floor((left.east[y] + right.west[y]) / 2), 0, width - 1);
            const clos = closeness[y * width + mid] | 0;
            let sep = baseSeparation;
            if (sep > 0) {
                const weight = clos / 255;
                sep += Math.round(weight * closenessMultiplier * baseSeparation);
            }
            if (sep > maxPerRow)
                sep = maxPerRow;
            if (sep <= 0)
                continue;
            carveOceanFromEast(left, y, sep);
            carveOceanFromWest(right, y, sep);
        }
    }
    const edgeWest = policy.edgeWest || {};
    if (rowStates.length && edgeWest.enabled) {
        const state = rowStates[0];
        const base = edgeWest.baseTiles | 0 || 0;
        const mult = Number.isFinite(edgeWest.boundaryClosenessMultiplier)
            ? edgeWest.boundaryClosenessMultiplier
            : 1.0;
        const cap = Math.max(0, edgeWest.maxPerRowDelta | 0 || 2);
        for (let y = state.south; y <= state.north; y++) {
            const clos = closeness[y * width + 0] | 0;
            let mag = Math.abs(base) + Math.round((clos / 255) * Math.abs(base) * mult);
            if (mag > cap)
                mag = cap;
            if (mag <= 0)
                continue;
            if (base >= 0) {
                carveOceanFromWest(state, y, mag);
            }
            else {
                fillLandFromWest(state, y, mag);
            }
        }
    }
    const edgeEast = policy.edgeEast || {};
    if (rowStates.length && edgeEast.enabled) {
        const state = rowStates[rowStates.length - 1];
        const base = edgeEast.baseTiles | 0 || 0;
        const mult = Number.isFinite(edgeEast.boundaryClosenessMultiplier)
            ? edgeEast.boundaryClosenessMultiplier
            : 1.0;
        const cap = Math.max(0, edgeEast.maxPerRowDelta | 0 || 2);
        for (let y = state.south; y <= state.north; y++) {
            const clos = closeness[y * width + (width - 1)] | 0;
            let mag = Math.abs(base) + Math.round((clos / 255) * Math.abs(base) * mult);
            if (mag > cap)
                mag = cap;
            if (mag <= 0)
                continue;
            if (base >= 0) {
                carveOceanFromEast(state, y, mag);
            }
            else {
                fillLandFromEast(state, y, mag);
            }
        }
    }
    const normalized = rowStates.map((state) => aggregateRowState(state, width, height));
    if (ctx && landMask && ctx.buffers?.heightfield?.landMask) {
        ctx.buffers.heightfield.landMask.set(landMask);
    }
    return {
        windows: normalized,
        landMask: landMask ?? undefined,
    };
}

function createRowState(win, index, width, height) {
    const normalized = normalizeWindow(win, index, width, height);
    const west = new Int16Array(height);
    const east = new Int16Array(height);
    for (let y = 0; y < height; y++) {
        west[y] = normalized.west;
        east[y] = normalized.east;
    }
    return {
        index,
        west,
        east,
        south: normalized.south,
        north: normalized.north,
        continent: normalized.continent,
    };
}

function aggregateRowState(state, width, height) {
    let minWest = width - 1;
    let maxEast = 0;
    const south = clampInt(state.south, 0, height - 1);
    const north = clampInt(state.north, 0, height - 1);
    for (let y = south; y <= north; y++) {
        if (state.west[y] < minWest)
            minWest = state.west[y];
        if (state.east[y] > maxEast)
            maxEast = state.east[y];
    }
    return {
        west: clampInt(minWest, 0, width - 1),
        east: clampInt(maxEast, 0, width - 1),
        south,
        north,
        continent: state.continent,
    };
}

function normalizeWindow(win, index, width, height) {
    if (!win)
        return {
            west: 0,
            east: Math.max(0, width - 1),
            south: 0,
            north: Math.max(0, height - 1),
            continent: index,
        };
    const west = clampInt(win.west | 0, 0, width - 1);
    const east = clampInt(win.east | 0, 0, width - 1);
    const south = clampInt(win.south | 0, 0, height - 1);
    const north = clampInt(win.north | 0, 0, height - 1);
    return {
        west: Math.min(west, east),
        east: Math.max(west, east),
        south: Math.min(south, north),
        north: Math.max(south, north),
        continent: win.continent ?? index,
    };
}
</file>

<file path="mod/maps/layers/mountains.js">
// @ts-nocheck
/**
 * Mountains Layer  Physics-Based Mountain and Rift Placement (Phase 2)
 *
 * Purpose:
 * - Replace random fractal mountain placement with plate-boundary-driven orogenesis
 * - Place mountain chains along convergent boundaries (collision zones)
 * - Create rift valleys and lowlands along divergent boundaries (spreading zones)
 * - Use WorldModel.upliftPotential and tile-precise boundary data for accurate placement
 *
 * Architecture:
 * - Reads WorldModel plate boundary data (Phase 1.5 output)
 * - Uses MapContext + Adapter pattern (Phase 1 foundation)
 * - Blends WorldModel-driven placement with optional fractal noise for variety
 * - Backward compatible: Falls back to base game fractals if WorldModel disabled
 *
 * Usage:
 *   import { layerAddMountainsPhysics } from "./layers/mountains.js";
 *   layerAddMountainsPhysics(ctx, {
 *     tectonicIntensity: 1.2,    // Higher = stronger tectonic effects = more mountains
 *     mountainThreshold: 0.45,   // Score threshold for mountains (lower = more permissive)
 *     hillThreshold: 0.25,       // Score threshold for hills
 *     upliftWeight: 0.75,        // 0..1, how much WorldModel drives placement
 *     fractalWeight: 0.25,       // 0..1, how much random fractal adds variety
 *   });
 */

import { WorldModel } from "../world/model.js";
import { ctxRandom, idx, writeHeightfield } from "../core/types.js";
import { devLogIf } from "../bootstrap/dev.js";
import * as globals from "/base-standard/maps/map-globals.js";

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

/**
 * Add mountains using WorldModel plate boundaries
 *
 * ARCHITECTURE: Physics-threshold based (not quota based)
 * - Mountains appear where physics score > mountainThreshold
 * - No forced quota - if tectonics don't create mountains, there are fewer mountains
 * - tectonicIntensity scales the physics parameters to control mountain prevalence
 * - This ensures mountains ONLY appear where plate tectonics justify them
 *
 * @param {import('../core/types.js').MapContext} ctx - Map context
 * @param {Object} options - Mountain generation options
 * @param {number} [options.tectonicIntensity=1.0] - Scales all tectonic effects (higher = more mountains)
 * @param {number} [options.mountainThreshold=0.45] - Score threshold for mountain placement (0..1)
 * @param {number} [options.hillThreshold=0.25] - Score threshold for hill placement (0..1)
 * @param {number} [options.upliftWeight=0.75] - Weight for WorldModel uplift (0..1)
 * @param {number} [options.fractalWeight=0.25] - Weight for fractal noise (0..1)
 * @param {number} [options.riftDepth=0.3] - Depression strength at rifts (0..1)
 * @param {number} [options.boundaryWeight=0.6] - Additional mountain weight contributed by boundary closeness
 * @param {number} [options.boundaryExponent=1.4] - Exponent applied to boundary closeness shaping belt width
 * @param {number} [options.interiorPenaltyWeight=0.2] - Penalty applied to interior tiles (push mountains toward margins)
 * @param {number} [options.convergenceBonus=0.9] - Added weight for convergent tiles (mountain belts)
 * @param {number} [options.transformPenalty=0.3] - Reduction applied to transform boundaries (flatter ridges)
 * @param {number} [options.riftPenalty=0.75] - Reduction applied to divergent tiles (discourage mountains in rifts)
 * @param {number} [options.hillBoundaryWeight=0.45] - Hill weight contributed by boundary closeness (foothills)
 * @param {number} [options.hillRiftBonus=0.5] - Hill bonus for divergent tiles (rift shoulders)
 * @param {number} [options.hillConvergentFoothill=0.25] - Hill bonus adjacent to convergent belts
 * @param {number} [options.hillInteriorFalloff=0.2] - Penalty for deep-interior tiles (keeps hills near action)
 * @param {number} [options.hillUpliftWeight=0.25] - Residual uplift contribution to hills
 */
export function layerAddMountainsPhysics(ctx, options = {}) {
    const {
        // Global relief scalar  higher values increase both tectonic forcing
        // and the fraction of land promoted to mountains/hills.
        tectonicIntensity = 1.0,
        mountainThreshold = 0.45,
        hillThreshold = 0.25,
        // Physics weights (scaled by tectonicIntensity)
        upliftWeight = 0.75,
        fractalWeight = 0.25,
        riftDepth = 0.3,
        boundaryWeight = 0.6,
        boundaryExponent = 1.4,
        interiorPenaltyWeight = 0.2,
        convergenceBonus = 0.9,
        transformPenalty = 0.3,
        riftPenalty = 0.75,
        hillBoundaryWeight = 0.45,
        hillRiftBonus = 0.5,
        hillConvergentFoothill = 0.25,
        hillInteriorFalloff = 0.2,
        hillUpliftWeight = 0.25,
    } = options;

    // Scale physics parameters by tectonic intensity
    // Higher intensity = stronger boundary effects = more tiles exceed threshold
    const scaledConvergenceBonus = convergenceBonus * tectonicIntensity;
    const scaledBoundaryWeight = boundaryWeight * tectonicIntensity;
    const scaledUpliftWeight = upliftWeight * tectonicIntensity;
    const scaledHillBoundaryWeight = hillBoundaryWeight * tectonicIntensity;
    const scaledHillConvergentFoothill = hillConvergentFoothill * tectonicIntensity;

    const dimensions = ctx?.dimensions || {};
    const width = Number.isFinite(dimensions.width)
        ? dimensions.width
        : GameplayMap?.getGridWidth?.() ?? 0;
    const height = Number.isFinite(dimensions.height)
        ? dimensions.height
        : GameplayMap?.getGridHeight?.() ?? 0;
    const adapter = ctx?.adapter;

    if (!width || !height || !adapter) {
        devLogIf &&
            devLogIf("LOG_MOUNTAINS", "[Mountains] Missing dimensions/adapter; skipping placement", {
                width,
                height,
                hasAdapter: !!adapter,
            });
        return;
    }
    const isWater = createIsWaterTile(ctx, adapter, width, height);
    const terrainWriter = (x, y, terrain) => {
        const isLand = terrain !== globals.g_CoastTerrain && terrain !== globals.g_OceanTerrain;
        if (ctx) {
            writeHeightfield(ctx, x, y, { terrain, isLand });
        }
        else {
            adapter.setTerrainType(x, y, terrain);
        }
    };
    const worldModelEnabled = WorldModel.isEnabled();

    devLogIf &&
        devLogIf("LOG_MOUNTAINS", "[Mountains] Starting physics-based placement", {
            worldModelEnabled,
            upliftWeight,
            fractalWeight,
        });

    // Create fractals for base noise and variety
    const g_MountainFractal = 0;
    const g_HillFractal = 1;
    const grainAmount = 5;
    const iFlags = 0;

    FractalBuilder.create(g_MountainFractal, width, height, grainAmount, iFlags);
    FractalBuilder.create(g_HillFractal, width, height, grainAmount, iFlags);

    // Calculate target tile counts
    let landTiles = 0;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!isWater(x, y)) {
                landTiles++;
            }
        }
    }

    devLogIf &&
        devLogIf("LOG_MOUNTAINS", "[Mountains] Physics-threshold mode", {
            landTiles,
            tectonicIntensity,
            mountainThreshold,
            hillThreshold,
        });

    // Compute placement scores for each tile
    const scores = new Float32Array(width * height);
    const hillScores = new Float32Array(width * height);

    if (worldModelEnabled) {
        // Physics-based placement using WorldModel
        // Pass SCALED parameters - tectonicIntensity affects mountain prevalence
        computePlateBasedScores(ctx, scores, hillScores, {
            upliftWeight: scaledUpliftWeight,
            fractalWeight,
            g_MountainFractal,
            g_HillFractal,
            boundaryWeight: scaledBoundaryWeight,
            boundaryExponent,
            interiorPenaltyWeight,
            convergenceBonus: scaledConvergenceBonus,
            transformPenalty,
            riftPenalty,
            hillBoundaryWeight: scaledHillBoundaryWeight,
            hillRiftBonus,
            hillConvergentFoothill: scaledHillConvergentFoothill,
            hillInteriorFalloff,
            hillUpliftWeight,
        }, isWater);
    } else {
        // Fallback: pure fractal (base game behavior)
        computeFractalOnlyScores(ctx, scores, hillScores, {
            g_MountainFractal,
            g_HillFractal,
        });
    }

    // Apply rift depressions (lower scores at divergent boundaries)
    if (worldModelEnabled && riftDepth > 0) {
        applyRiftDepressions(ctx, scores, hillScores, riftDepth);
    }

    const selectionAdapter = {
        isWater,
    };

    const mountainTiles = selectTilesAboveThreshold(
        scores,
        width,
        height,
        mountainThreshold,
        selectionAdapter
    );
    const hillTiles = selectTilesAboveThreshold(
        hillScores,
        width,
        height,
        hillThreshold,
        selectionAdapter,
        mountainTiles
    );

    const mountainsPlaced = mountainTiles.size;
    const hillsPlaced = hillTiles.size;
    // Place mountains
    for (const i of mountainTiles) {
        const x = i % width;
        const y = Math.floor(i / width);
        terrainWriter(x, y, globals.g_MountainTerrain);
    }

    // Place hills
    for (const i of hillTiles) {
        const x = i % width;
        const y = Math.floor(i / width);
        terrainWriter(x, y, globals.g_HillTerrain);
    }

    const summary = {
        mode: "physics-threshold",
        tectonicIntensity,
        mountainsPlaced,
        hillsPlaced,
        mountainPercent: landTiles > 0 ? ((mountainsPlaced / landTiles) * 100).toFixed(1) + "%" : "0%",
        hillPercent: landTiles > 0 ? ((hillsPlaced / landTiles) * 100).toFixed(1) + "%" : "0%",
        landTiles,
        worldModelEnabled,
    };
    devLogIf && devLogIf("LOG_MOUNTAINS", "[Mountains] placement", JSON.stringify(summary));
}

/**
 * Compute plate-based mountain scores using WorldModel boundaries
 */
function computePlateBasedScores(ctx, scores, hillScores, options, isWaterCheck) {
    // Get dimensions properly from ctx.dimensions (not ctx.width/height which don't exist!)
    const dims = ctx?.dimensions || {};
    const width = Number.isFinite(dims.width) ? dims.width : (GameplayMap?.getGridWidth?.() ?? 0);
    const height = Number.isFinite(dims.height) ? dims.height : (GameplayMap?.getGridHeight?.() ?? 0);
    const {
        upliftWeight,
        fractalWeight,
        g_MountainFractal,
        g_HillFractal,
        boundaryWeight,
        boundaryExponent,
        interiorPenaltyWeight,
        convergenceBonus,
        transformPenalty,
        riftPenalty,
        hillBoundaryWeight,
        hillRiftBonus,
        hillConvergentFoothill,
        hillInteriorFalloff,
        hillUpliftWeight,
    } = options;

    const upliftPotential = WorldModel.upliftPotential;
    const boundaryType = WorldModel.boundaryType;
    const boundaryCloseness = WorldModel.boundaryCloseness;
    const riftPotential = WorldModel.riftPotential;

    if (!upliftPotential || !boundaryType) {
        // Fallback if WorldModel data missing
        devLogIf &&
            devLogIf("LOG_MOUNTAINS", "[Mountains] Falling back to fractal-only scores (missing WorldModel arrays)");
        computeFractalOnlyScores(ctx, scores, hillScores, options);
        return;
    }

    // ========== DEBUG #1: Diagnose Land/Uplift Disconnect ==========
    // (Reuses width/height declared at function start)
    const isWater = typeof isWaterCheck === "function" ? isWaterCheck : (x, y) => GameplayMap?.isWater?.(x, y) ?? false;

    // Collect diagnostic data
    let totalLandTiles = 0;
    let landUpliftSum = 0;
    let landClosenessSum = 0;
    const landByBoundaryType = [0, 0, 0, 0]; // none, convergent, divergent, transform
    const landUpliftBuckets = { under25: 0, under50: 0, under100: 0, over100: 0 };
    const landClosenessBuckets = { under64: 0, under128: 0, under192: 0, over192: 0 };

    // Row-by-row analysis for south bias detection
    const rowStats = [];
    const rowStep = Math.max(1, Math.floor(height / 10));

    for (let y = 0; y < height; y++) {
        let rowLandCount = 0;
        let rowLandUpliftSum = 0;
        let rowLandClosenessSum = 0;

        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const isLand = !isWater(x, y);

            if (isLand) {
                totalLandTiles++;
                const upliftVal = upliftPotential[i] | 0;
                const closenessVal = boundaryCloseness[i] | 0;
                const bType = boundaryType[i] | 0;

                landUpliftSum += upliftVal;
                landClosenessSum += closenessVal;

                if (bType >= 0 && bType < 4) landByBoundaryType[bType]++;

                if (upliftVal < 25) landUpliftBuckets.under25++;
                else if (upliftVal < 50) landUpliftBuckets.under50++;
                else if (upliftVal < 100) landUpliftBuckets.under100++;
                else landUpliftBuckets.over100++;

                if (closenessVal < 64) landClosenessBuckets.under64++;
                else if (closenessVal < 128) landClosenessBuckets.under128++;
                else if (closenessVal < 192) landClosenessBuckets.under192++;
                else landClosenessBuckets.over192++;

                rowLandCount++;
                rowLandUpliftSum += upliftVal;
                rowLandClosenessSum += closenessVal;
            }
        }

        if (y % rowStep === 0 || y === height - 1) {
            rowStats.push({
                row: y,
                landCount: rowLandCount,
                avgUplift: rowLandCount > 0 ? Math.round(rowLandUpliftSum / rowLandCount) : 0,
                avgCloseness: rowLandCount > 0 ? Math.round(rowLandClosenessSum / rowLandCount) : 0,
            });
        }
    }

    devLogIf && devLogIf("LOG_MOUNTAINS", "[DEBUG #1] ========== LAND/UPLIFT DIAGNOSTIC ==========");
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Total land tiles: ${totalLandTiles}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Avg uplift on land: ${totalLandTiles > 0 ? (landUpliftSum / totalLandTiles).toFixed(1) : 0} / 255`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Avg closeness on land: ${totalLandTiles > 0 ? (landClosenessSum / totalLandTiles).toFixed(1) : 0} / 255`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Land by boundary type: none=${landByBoundaryType[0]}, convergent=${landByBoundaryType[1]}, divergent=${landByBoundaryType[2]}, transform=${landByBoundaryType[3]}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Land uplift buckets: <25=${landUpliftBuckets.under25}, 25-50=${landUpliftBuckets.under50}, 50-100=${landUpliftBuckets.under100}, >100=${landUpliftBuckets.over100}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Land closeness buckets: <64=${landClosenessBuckets.under64}, 64-128=${landClosenessBuckets.under128}, 128-192=${landClosenessBuckets.under192}, >192=${landClosenessBuckets.over192}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Row-by-row (south=0, north=${height-1}):`);
    rowStats.forEach(rs => {
        devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1]   row ${rs.row}: land=${rs.landCount}, avgUplift=${rs.avgUplift}, avgCloseness=${rs.avgCloseness}`);
    });
    devLogIf && devLogIf("LOG_MOUNTAINS", "[DEBUG #1] ================================================");
    // ========== END DEBUG #1 ==========

    const boundaryGate = 0.20;  // Minimum closeness (0-1) to consider boundary effects
    const falloffExponent = boundaryExponent || 2.5;  // Exponential falloff for concentrated mountain belts

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);

            const uplift = upliftPotential ? upliftPotential[i] / 255 : 0;
            const bType = boundaryType[i];
            const closenessRaw = boundaryCloseness ? boundaryCloseness[i] / 255 : 0;
            const rift = riftPotential ? riftPotential[i] / 255 : 0;

            const fractalMtn = FractalBuilder.getHeight(g_MountainFractal, x, y) / 65535;
            const fractalHill = FractalBuilder.getHeight(g_HillFractal, x, y) / 65535;

            // Base score: uplift potential + fractal variety
            let mountainScore = uplift * upliftWeight + fractalMtn * fractalWeight;

            // Physics-based boundary effects with exponential falloff
            // Mountain building is most intense RIGHT AT the collision zone
            // BUT we modulate by fractal noise to create natural variation:
            // - Peaks where fractal is high
            // - Saddles/valleys where fractal is low
            // - Interruptions in the mountain chain
            if (closenessRaw > boundaryGate) {
                // Normalize to 0-1 above threshold, then apply exponential falloff
                const normalized = (closenessRaw - boundaryGate) / (1 - boundaryGate);
                const intensity = Math.pow(normalized, falloffExponent);

                // General boundary weight (foothills near any boundary)
                // Modulated by fractal to create variable foothill bands
                if (boundaryWeight > 0) {
                    const foothillNoise = 0.5 + fractalMtn * 0.5; // 0.5-1.0 range
                    mountainScore += intensity * boundaryWeight * foothillNoise;
                }

                // Boundary-type-specific modifiers
                if (bType === ENUM_BOUNDARY.convergent) {
                    // CONVERGENT: Strong mountain bonus concentrated at collision zone
                    // Modulated by fractal: creates peaks where noise is high, saddles where low
                    // fractalMtn ranges 0-1, so bonus ranges from 0.3x to 1.0x of full bonus
                    const peakNoise = 0.3 + fractalMtn * 0.7; // Minimum 30% ensures some mountains
                    mountainScore += intensity * convergenceBonus * peakNoise;
                }
                else if (bType === ENUM_BOUNDARY.divergent) {
                    // DIVERGENT: Suppress mountains (rift valleys, not peaks)
                    mountainScore *= Math.max(0, 1 - intensity * riftPenalty);
                }
                else if (bType === ENUM_BOUNDARY.transform) {
                    // TRANSFORM: Moderate suppression (strike-slip faults, linear valleys)
                    mountainScore *= Math.max(0, 1 - intensity * transformPenalty);
                }
            }

            // Interior penalty - push mountains toward plate margins
            if (interiorPenaltyWeight > 0) {
                const interiorPenalty = (1 - closenessRaw) * interiorPenaltyWeight;
                mountainScore = Math.max(0, mountainScore - interiorPenalty);
            }

            scores[i] = Math.max(0, mountainScore);

            // Hill scoring - foothills form around mountain belts with softer falloff
            // Hills use fractalHill for natural variation in foothill extent
            let hillScore = fractalHill * fractalWeight + uplift * hillUpliftWeight;

            if (closenessRaw > boundaryGate) {
                // Normalize and apply softer falloff for hills (sqrt instead of pow 2.5)
                // Hills spread wider than peaks, forming foothill bands
                const normalized = (closenessRaw - boundaryGate) / (1 - boundaryGate);
                const hillIntensity = Math.sqrt(normalized);  // Softer falloff for wider foothill bands

                // Variable foothill width based on fractal noise
                // Some areas have extensive foothills, others transition sharply
                const foothillExtent = 0.4 + fractalHill * 0.6; // 0.4-1.0 range

                if (hillBoundaryWeight > 0) {
                    hillScore += hillIntensity * hillBoundaryWeight * foothillExtent;
                }

                if (bType === ENUM_BOUNDARY.divergent) {
                    // Rift shoulders - hills along divergent boundaries (like East African Rift)
                    // Modulated by fractal for irregular rift shoulder terrain
                    hillScore += hillIntensity * rift * hillRiftBonus * foothillExtent;
                }
                else if (bType === ENUM_BOUNDARY.convergent) {
                    // Foothill bands adjacent to mountain belts
                    // Variable extent creates natural-looking piedmont zones
                    hillScore += hillIntensity * hillConvergentFoothill * foothillExtent;
                }
            }

            // Interior falloff - fewer hills deep in plate interiors
            if (hillInteriorFalloff > 0) {
                hillScore -= (1 - closenessRaw) * hillInteriorFalloff;
            }

            hillScores[i] = Math.max(0, hillScore);
        }
    }
}

/**
 * Fallback: pure fractal-based scores (base game approach)
 */
function computeFractalOnlyScores(ctx, scores, hillScores, options) {
    // Get dimensions properly from ctx.dimensions
    const dims = ctx?.dimensions || {};
    const width = Number.isFinite(dims.width) ? dims.width : (GameplayMap?.getGridWidth?.() ?? 0);
    const height = Number.isFinite(dims.height) ? dims.height : (GameplayMap?.getGridHeight?.() ?? 0);
    const { g_MountainFractal, g_HillFractal } = options;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);

            scores[i] = FractalBuilder.getHeight(g_MountainFractal, x, y) / 65535;
            hillScores[i] = FractalBuilder.getHeight(g_HillFractal, x, y) / 65535;
        }
    }
}

/**
 * Apply rift depressions (lower mountains/hills at divergent boundaries)
 */
function applyRiftDepressions(ctx, scores, hillScores, riftDepth) {
    // Get dimensions properly from ctx.dimensions
    const dims = ctx?.dimensions || {};
    const width = Number.isFinite(dims.width) ? dims.width : (GameplayMap?.getGridWidth?.() ?? 0);
    const height = Number.isFinite(dims.height) ? dims.height : (GameplayMap?.getGridHeight?.() ?? 0);
    const riftPotential = WorldModel.riftPotential;
    const boundaryType = WorldModel.boundaryType;

    if (!riftPotential || !boundaryType) return;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);
            const rift = riftPotential[i] / 255; // 0..1
            const bType = boundaryType[i];

            // Depress scores at divergent boundaries (rift valleys)
            if (bType === ENUM_BOUNDARY.divergent) {
                const depression = rift * riftDepth;
                scores[i] = Math.max(0, scores[i] - depression);
                hillScores[i] = Math.max(0, hillScores[i] - depression * 0.5);
            }
        }
    }
}

/**
 * Build a water check that prefers the landMask buffer written by landmass generation.
 */
function createIsWaterTile(ctx, adapter, width, height) {
    const landMask = ctx?.buffers?.heightfield?.landMask || null;
    return (x, y) => {
        if (landMask) {
            const idx = y * width + x;
            if (idx >= 0 && idx < landMask.length) {
                return landMask[idx] === 0;
            }
        }
        if (adapter?.isWater) {
            return adapter.isWater(x, y);
        }
        return GameplayMap?.isWater?.(x, y) ?? false;
    };
}

/**
 * Select tiles where score exceeds threshold (physics-driven, no quota)
 *
 * This is the core of the physics-threshold architecture:
 * - Only tiles that genuinely qualify based on tectonic physics get selected
 * - No forcing tiles to meet a quota
 * - Mountain count is determined by geology, not arbitrary percentage
 *
 * @param {Float32Array} scores - Score array for all tiles
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} threshold - Minimum score for selection (0..1)
 * @param {Object} adapter - Adapter with isWater(x,y) method
 * @param {Set} [excludeSet] - Optional set of tile indices to exclude
 * @returns {Set} Set of selected tile indices
 */
function selectTilesAboveThreshold(scores, width, height, threshold, adapter, excludeSet = null) {
    const selected = new Set();

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;

            // Skip water
            if (adapter.isWater(x, y)) continue;

            // Skip excluded tiles
            if (excludeSet && excludeSet.has(i)) continue;

            // Only select if score exceeds threshold
            if (scores[i] > threshold) {
                selected.add(i);
            }
        }
    }

    return selected;
}

/**
 * Backward-compatible wrapper that can be called without ctx
 * Falls back to base game fractal approach
 */
export function addMountainsCompat(width, height) {
    // Create minimal adapter if ctx not available
    const adapter = {
        isWater: (x, y) => GameplayMap.isWater(x, y),
        setTerrainType: (x, y, type) => TerrainBuilder.setTerrainType(x, y, type),
    };

    const ctx = {
        dimensions: { width, height },
        adapter,
        rng: {
            calls: 0,
            sequence: [],
        },
    };

    layerAddMountainsPhysics(ctx, {
        tectonicIntensity: 1.0,  // Standard intensity
        mountainThreshold: 0.45,
        hillThreshold: 0.25,
        upliftWeight: WorldModel.isEnabled() ? 0.75 : 0,
        fractalWeight: WorldModel.isEnabled() ? 0.25 : 1.0,
    });
}

export default layerAddMountainsPhysics;
</file>

<file path="mod/maps/layers/placement.js">
// @ts-nocheck
console.log("[SWOOPER_MOD] Placement layer loading...");
/**
 * Placement Layer  Wonders, Floodplains, Snow, Resources, Starts, Discoveries, Fertility, Advanced Start
 *
 * Purpose
 * - Encapsulate all late-stage placement and finalization passes into a single, reusable function.
 * - Keep behavior compatible with the existing pipeline while enabling clean orchestration.
 *
 * Responsibilities
 * - Natural wonders (+1 vs. map defaults unless overridden)
 * - Floodplains
 * - Snow generation
 * - Resources
 * - Start position assignment (vanilla-compatible)
 * - Discoveries (post-starts to seed exploration)
 * - Fertility recalculation
 * - Advanced start region assignment
 *
 * Usage
 *   import { runPlacement } from "./layers/placement.js";
 *   const startPositions = runPlacement(iWidth, iHeight, {
 *     mapInfo,
 *     wondersPlusOne: true, // default true
 *     floodplains: { minLength: 4, maxLength: 10 },
 *     starts: {
 *       playersLandmass1, playersLandmass2,
 *       westContinent, eastContinent,
 *       startSectorRows, startSectorCols,
 *       startSectors
 *     }
 *   });
 *
 * Notes
 * - All external engine/module calls are wrapped in light defensive try/catch where sensible.
 * - Returns the computed startPositions array for downstream consumers (e.g., discoveries).
 */
import { addNaturalWonders } from "/base-standard/maps/natural-wonder-generator.js";
import { generateResources } from "/base-standard/maps/resource-generator.js";
import { assignAdvancedStartRegions } from "/base-standard/maps/assign-advanced-start-region.js";
import { generateDiscoveries } from "/base-standard/maps/discovery-generator.js";
import { generateSnow } from "/base-standard/maps/snow-generator.js";
import { assignStartPositions } from "/base-standard/maps/assign-starting-plots.js";
import { PLACEMENT_CFG } from "../bootstrap/tunables.js";
/**
 * Compute the number of natural wonders to place.
 * Default behavior mirrors the main script: +1 vs map defaults (but never below default).
 * @param {any} mapInfo
 * @param {boolean} wondersPlusOne
 * @returns {number}
 */
function resolveNaturalWonderCount(mapInfo, wondersPlusOne = true) {
    if (!mapInfo || typeof mapInfo.NumNaturalWonders !== "number") {
        return 1;
    }
    if (wondersPlusOne) {
        return Math.max(mapInfo.NumNaturalWonders + 1, mapInfo.NumNaturalWonders);
    }
    return mapInfo.NumNaturalWonders;
}
/**
 * Run late-stage placement and finalization passes.
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {object} params
 * @param {any} params.mapInfo - GameInfo.Maps row (used to derive defaults).
 * @param {boolean} [params.wondersPlusOne=true] - Whether to add +1 to map default wonders.
 * @param {{minLength:number,maxLength:number}} [params.floodplains] - Floodplains config (defaults: {4, 10}).
 * @param {object} params.starts - Start placement inputs.
 * @param {number} params.starts.playersLandmass1
 * @param {number} params.starts.playersLandmass2
 * @param {{west:number,east:number,south:number,north:number,continent:number}} params.starts.westContinent
 * @param {{west:number,east:number,south:number,north:number,continent:number}} params.starts.eastContinent
 * @param {number} params.starts.startSectorRows
 * @param {number} params.starts.startSectorCols
 * @param {Array<any>} params.starts.startSectors
 * @returns {Array<any>} startPositions
 */
export function runPlacement(iWidth, iHeight, { mapInfo, wondersPlusOne = true, floodplains = { minLength: 4, maxLength: 10 }, starts, } = {}) {
    console.log("[SWOOPER_MOD] === runPlacement() CALLED ===");
    console.log(`[SWOOPER_MOD] Map size: ${iWidth}x${iHeight}`);
    const startPositions = [];
    // 1) Natural Wonders
    try {
        const wonders = resolveNaturalWonderCount(mapInfo, typeof wondersPlusOne === "boolean"
            ? wondersPlusOne
            : PLACEMENT_CFG &&
                typeof PLACEMENT_CFG.wondersPlusOne === "boolean"
                ? PLACEMENT_CFG.wondersPlusOne
                : true);
        addNaturalWonders(iWidth, iHeight, wonders);
    }
    catch (err) {
        console.log("[Placement] addNaturalWonders failed:", err);
    }
    // 2) Floodplains
    try {
        const minLen = floodplains && typeof floodplains.minLength === "number"
            ? floodplains.minLength
            : PLACEMENT_CFG &&
                PLACEMENT_CFG.floodplains &&
                typeof PLACEMENT_CFG.floodplains.minLength === "number"
                ? PLACEMENT_CFG.floodplains.minLength
                : 4;
        const maxLen = floodplains && typeof floodplains.maxLength === "number"
            ? floodplains.maxLength
            : PLACEMENT_CFG &&
                PLACEMENT_CFG.floodplains &&
                typeof PLACEMENT_CFG.floodplains.maxLength === "number"
                ? PLACEMENT_CFG.floodplains.maxLength
                : 10;
        TerrainBuilder.addFloodplains(minLen, maxLen);
    }
    catch (err) {
        console.log("[Placement] addFloodplains failed:", err);
    }
    // 3) Snow (post-water/terrain stabilization)
    try {
        generateSnow(iWidth, iHeight);
    }
    catch (err) {
        console.log("[Placement] generateSnow failed:", err);
    }
    // 4) Resources (after snow)
    try {
        generateResources(iWidth, iHeight);
    }
    catch (err) {
        console.log("[Placement] generateResources failed:", err);
    }
    // 5) Start positions (vanilla-compatible)
    try {
        if (!starts) {
            console.log("[Placement] Start placement skipped (no starts config provided).");
        }
        else {
            const { playersLandmass1, playersLandmass2, westContinent, eastContinent, startSectorRows, startSectorCols, startSectors, } = starts;

            // DIAGNOSTIC LOGGING - Start placement parameters
            const totalPlayers = playersLandmass1 + playersLandmass2;
            console.log(`[START_DEBUG] === Beginning Start Placement ===`);
            console.log(`[START_DEBUG] Players: ${totalPlayers} total (${playersLandmass1} landmass1, ${playersLandmass2} landmass2)`);
            console.log(`[START_DEBUG] Continents: west=${westContinent}, east=${eastContinent}`);
            console.log(`[START_DEBUG] Sectors: ${startSectorRows}x${startSectorCols} grid, ${startSectors.length} sectors chosen`);

            const pos = assignStartPositions(playersLandmass1, playersLandmass2, westContinent, eastContinent, startSectorRows, startSectorCols, startSectors);

            // DIAGNOSTIC LOGGING - Placement results
            const successCount = pos ? pos.filter(p => p !== undefined && p >= 0).length : 0;
            console.log(`[START_DEBUG] Result: ${successCount}/${totalPlayers} civilizations placed successfully`);
            if (successCount < totalPlayers) {
                console.log(`[START_DEBUG] WARNING: ${totalPlayers - successCount} civilizations failed to find valid start locations!`);
            }
            console.log(`[START_DEBUG] === End Start Placement ===`);

            if (Array.isArray(pos)) {
                startPositions.push(...pos);
            }
            if (successCount === totalPlayers) {
                console.log("[Placement] Start positions assigned successfully");
            }
            else {
                console.log(`[Placement] Start positions assignment incomplete: ${totalPlayers - successCount} failures`);
            }
        }
    }
    catch (err) {
        console.log("[Placement] assignStartPositions failed:", err);
    }
    // 6) Discoveries (post-starts to seed exploration)
    try {
        generateDiscoveries(iWidth, iHeight, startPositions);
        console.log("[Placement] Discoveries generated successfully");
    }
    catch (err) {
        console.log("[Placement] generateDiscoveries failed:", err);
    }
    // 7) Fertility + Advanced Start
    try {
        FertilityBuilder.recalculate();
    }
    catch (err) {
        console.log("[Placement] FertilityBuilder.recalculate failed:", err);
    }
    try {
        assignAdvancedStartRegions();
    }
    catch (err) {
        console.log("[Placement] assignAdvancedStartRegions failed:", err);
    }
    return startPositions;
}
export default runPlacement;
</file>

<file path="mod/maps/layers/volcanoes.js">
// @ts-nocheck
/**
 * Volcano Placement  Plate-Aware Wrapper
 *
 * Purpose
 * - Replace the base game's continent-edge heuristic with a WorldModel-driven
 *   placement strategy that favors convergent arcs while still allowing inland
 *   hotspot-style volcanoes when configured.
 * - Exposes tunables through the `volcanoes` config block so presets can adjust
 *   density, spacing, and boundary weighting without touching this layer.
 *
 * Fallback
 * - If the WorldModel is disabled or required fields are unavailable, defer to
 *   the base game's `addVolcanoes()` implementation to preserve vanilla behavior.
 */

import { WorldModel } from "../world/model.js";
import { idx, writeHeightfield } from "../core/types.js";
import { devLogIf } from "../bootstrap/dev.js";
import * as globals from "/base-standard/maps/map-globals.js";
import { addVolcanoes as baseAddVolcanoes, isTooCloseToExistingVolcanoes } from "/base-standard/maps/volcano-generator.js";

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

/**
 * @typedef {import("../core/types.js").MapContext} MapContext
 * @typedef {import("../core/types.js").MapMetrics} MapMetrics
 */

/**
 * Plate-aware volcano placement. Falls back to base game implementation when
 * WorldModel data is unavailable.
 *
 * @param {MapContext} ctx
 * @param {Object} [options]
 */
export function layerAddVolcanoesPlateAware(ctx, options = {}) {
    const {
        enabled = true,
        baseDensity = 1 / 170, // ~1 volcano per 170 land tiles (close to vanilla)
        minSpacing = 3,
        boundaryThreshold = 0.35,
        boundaryWeight = 1.2,
        convergentMultiplier = 2.4,
        transformMultiplier = 1.1,
        divergentMultiplier = 0.35,
        hotspotWeight = 0.12,
        shieldPenalty = 0.6,
        randomJitter = 0.08,
        minVolcanoes = 5,
        maxVolcanoes = 40,
    } = options;

    const dimensions = ctx?.dimensions || {};
    const width = Number.isFinite(dimensions.width)
        ? dimensions.width
        : GameplayMap?.getGridWidth?.() ?? 0;
    const height = Number.isFinite(dimensions.height)
        ? dimensions.height
        : GameplayMap?.getGridHeight?.() ?? 0;
    const adapter = ctx?.adapter;

    if (!width || !height || !adapter) {
        devLogIf &&
            devLogIf("LOG_VOLCANOES", "[Volcanoes] Missing dimensions/adapter; skipping placement", {
                width,
                height,
                hasAdapter: !!adapter,
            });
        return;
    }

    if (!enabled) {
        devLogIf && devLogIf("LOG_VOLCANOES", "[Volcanoes] Disabled via config; skipping placement.");
        return;
    }

    const worldEnabled = WorldModel.isEnabled();
    const boundaryCloseness = WorldModel.boundaryCloseness;
    const boundaryType = WorldModel.boundaryType;
    const shieldStability = WorldModel.shieldStability;

    if (!worldEnabled || !boundaryCloseness || !boundaryType) {
        devLogIf &&
            devLogIf("LOG_VOLCANOES", "[Volcanoes] WorldModel unavailable; falling back to base generator.");
        baseAddVolcanoes(width, height, minSpacing);
        return;
    }

    // Count land tiles for density target
    let landTiles = 0;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!GameplayMap.isWater(x, y)) landTiles++;
        }
    }

    const rawDesired = Math.round(landTiles * Math.max(0, baseDensity));
    const targetVolcanoes = clamp(Math.max(minVolcanoes | 0, rawDesired), minVolcanoes | 0, maxVolcanoes > 0 ? maxVolcanoes | 0 : rawDesired);

    if (targetVolcanoes <= 0) {
        devLogIf && devLogIf("LOG_STORY_TAGS", "[Volcanoes] Target count <= 0; skipping placement.");
        return;
    }

    const candidates = [];
    const hotspotBase = Math.max(0, hotspotWeight);
    const threshold = Math.max(0, Math.min(1, boundaryThreshold));
    const shieldWeight = Math.max(0, Math.min(1, shieldPenalty));
    const jitter = Math.max(0, randomJitter);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (GameplayMap.isWater(x, y)) continue;
            if (GameplayMap.getFeatureType(x, y) === globals.g_VolcanoFeature) continue;

            const i = idx(x, y, width);
            const closeness = boundaryCloseness[i] / 255;
            const shield = shieldStability ? shieldStability[i] / 255 : 0;
            const bType = boundaryType[i] | 0;

            let weight = 0;
            let boundaryBand = 0;
            if (closeness >= threshold) {
                boundaryBand = (closeness - threshold) / Math.max(1e-3, 1 - threshold);
                const base = boundaryBand * Math.max(0, boundaryWeight);
                let multiplier = 1;
                if (bType === ENUM_BOUNDARY.convergent) multiplier = Math.max(0, convergentMultiplier);
                else if (bType === ENUM_BOUNDARY.transform) multiplier = Math.max(0, transformMultiplier);
                else if (bType === ENUM_BOUNDARY.divergent) multiplier = Math.max(0, divergentMultiplier);
                weight += base * multiplier;
            } else {
                // Interior hotspot chance scales with how far we are from boundaries
                const interiorBand = 1 - closeness;
                weight += hotspotBase * interiorBand;
            }

            if (weight <= 0) continue;

            if (shieldWeight > 0) {
                const penalty = shield * shieldWeight;
                weight *= Math.max(0, 1 - penalty);
            }

            if (jitter > 0) {
                const randomScale = (TerrainBuilder.getRandomNumber(1000, "VolcanoJitter") || 0) / 1000;
                weight += randomScale * jitter;
            }

            if (weight > 0) {
                candidates.push({ x, y, weight, closeness, boundaryType: bType });
            }
        }
    }

    if (candidates.length === 0) {
        devLogIf &&
            devLogIf("LOG_VOLCANOES", "[Volcanoes] No candidates with positive weight; falling back to base generator.");
        baseAddVolcanoes(width, height, minSpacing);
        return;
    }

    candidates.sort((a, b) => b.weight - a.weight);

    const placed = [];
    const minSpacingClamped = Math.max(1, minSpacing | 0);
    for (const candidate of candidates) {
        if (placed.length >= targetVolcanoes) break;
        if (GameplayMap.getFeatureType(candidate.x, candidate.y) === globals.g_VolcanoFeature) continue;
        if (isTooCloseToExistingVolcanoes(candidate.x, candidate.y, placed, minSpacingClamped)) continue;

        if (ctx) {
            writeHeightfield(ctx, candidate.x, candidate.y, {
                terrain: globals.g_MountainTerrain,
                isLand: true,
            });
        }
        else {
            adapter.setTerrainType(candidate.x, candidate.y, globals.g_MountainTerrain);
        }
        adapter.setFeatureType(candidate.x, candidate.y, {
            Feature: globals.g_VolcanoFeature,
            Direction: -1,
            Elevation: 0,
        });
        placed.push({ x: candidate.x, y: candidate.y });
    }

    devLogIf &&
        devLogIf("LOG_VOLCANOES", "[Volcanoes] placement", {
            candidates: candidates.length,
            placed: placed.length,
            targetVolcanoes,
            minSpacing: minSpacingClamped,
        });
}

function clamp(value, min, max) {
    if (typeof max === "number" && max >= min) {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    }
    return Math.max(value, min);
}

export default layerAddVolcanoesPlateAware;
</file>

<file path="mod/maps/story/corridors.js">
// @ts-nocheck
/**
 * Strategic Corridors  lightweight, gameplayfocused path tagging
 *
 * Tags sparse corridors that other layers respect to preserve or emphasize
 * traversal routes:
 *  - Sea lanes: long open water lanes across the map (dont obstruct with coasts/islands)
 *  - Islandhop lanes: promote hotspot trails as navigable arcs (avoid clutter)
 *  - Land open corridors: long riftshoulder runs get gentle grassland bias
 *  - River chains: postrivers, lowland riveradjacent crosscontinent paths
 *
 * Invariants and constraints:
 *  - Pure tagging; no heavy flood fills. All passes are O(width  height) with small constants.
 *  - Consumers must remain lanesafe: do not create chokepoints or dense clutter.
 *  - Does not modify rainfall or terrain here; those effects belong to other layers.
 */
import { StoryTags } from "./tags.js";
import { inBounds, storyKey, isAdjacentToLand } from "../core/utils.js";
import { STORY_ENABLE_CORRIDORS, CORRIDORS_CFG, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { devLogIf } from "../bootstrap/dev.js";

const STYLE_PRIMITIVE_CACHE = new Map();

function freezeClone(obj) {
    if (!obj || typeof obj !== "object")
        return undefined;
    const out = {};
    for (const key of Object.keys(obj))
        out[key] = obj[key];
    return Object.freeze(out);
}

function fetchCorridorStylePrimitive(kind, style) {
    if (typeof kind !== "string" || typeof style !== "string")
        return null;
    const cacheKey = `${kind}:${style}`;
    if (STYLE_PRIMITIVE_CACHE.has(cacheKey))
        return STYLE_PRIMITIVE_CACHE.get(cacheKey);
    const kindCfg = CORRIDORS_CFG?.kinds?.[kind];
    const styleCfg = kindCfg && kindCfg.styles ? kindCfg.styles[style] : null;
    if (!styleCfg)
        return null;
    const primitive = Object.freeze({
        kind,
        style,
        biomes: styleCfg.biomes ? freezeClone(styleCfg.biomes) : undefined,
        features: styleCfg.features ? freezeClone(styleCfg.features) : undefined,
        edge: styleCfg.edge ? freezeClone(styleCfg.edge) : undefined,
    });
    STYLE_PRIMITIVE_CACHE.set(cacheKey, primitive);
    return primitive;
}

function assignCorridorMetadata(key, kind, style) {
    if (typeof key !== "string" || typeof kind !== "string" || typeof style !== "string")
        return;
    StoryTags.corridorKind.set(key, kind);
    StoryTags.corridorStyle.set(key, style);
    const primitive = fetchCorridorStylePrimitive(kind, style);
    if (primitive)
        StoryTags.corridorAttributes.set(key, primitive);
    else
        StoryTags.corridorAttributes.delete(key);
}

function clearCorridorStyleCache() {
    STYLE_PRIMITIVE_CACHE.clear();
}
/**
 * Safe random helper (engine provided).
 * @param {number} n
 * @param {string} label
 * @returns {number}
 */
function rand(n, label) {
    return TerrainBuilder.getRandomNumber(Math.max(1, n | 0), label || "Corr");
}
/**
 * Compute the longest contiguous run of water along a fixed column x.
 * @param {number} x
 * @param {number} height
 * @returns {{start:number,end:number,len:number}}
 */
function longestWaterRunColumn(x, height) {
    let bestStart = -1, bestEnd = -1, bestLen = 0;
    let curStart = -1, curLen = 0;
    for (let y = 0; y < height; y++) {
        if (GameplayMap.isWater(x, y)) {
            if (curLen === 0)
                curStart = y;
            curLen++;
            if (curLen > bestLen) {
                bestLen = curLen;
                bestStart = curStart;
                bestEnd = y;
            }
        }
        else {
            curLen = 0;
        }
    }
    return { start: bestStart, end: bestEnd, len: bestLen };
}
/**
 * Compute the longest contiguous run of water along a fixed row y.
 * @param {number} y
 * @param {number} width
 * @returns {{start:number,end:number,len:number}}
 */
function longestWaterRunRow(y, width) {
    let bestStart = -1, bestEnd = -1, bestLen = 0;
    let curStart = -1, curLen = 0;
    for (let x = 0; x < width; x++) {
        if (GameplayMap.isWater(x, y)) {
            if (curLen === 0)
                curStart = x;
            curLen++;
            if (curLen > bestLen) {
                bestLen = curLen;
                bestStart = curStart;
                bestEnd = x;
            }
        }
        else {
            curLen = 0;
        }
    }
    return { start: bestStart, end: bestEnd, len: bestLen };
}
/**
 * Tag long open water sea lanes across the map.
 * We prefer a handful of long, straight segments (columns/rows) that clear a large span.
 */
function tagSeaLanes() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.sea) || {};
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const maxLanes = Math.max(0, (cfg.maxLanes ?? 3) | 0);
    const stride = Math.max(2, (cfg.scanStride ?? 6) | 0);
    const minLenFrac = Math.min(1, Math.max(0.4, cfg.minLengthFrac ?? 0.7));
    const preferDiagonals = !!cfg.preferDiagonals;
    const laneSpacing = Math.max(0, (cfg.laneSpacing ?? 6) | 0);
    const requiredMinWidth = Math.max(1, (cfg.minChannelWidth ?? 3) | 0);
    // Helper: check perpendicular water width around (x,y) for given orientation
    // Orient: 'col' (vertical), 'row' (horizontal), 'diagNE' (x+y const), 'diagNW' (x-y const)
    function hasPerpWidth(x, y, orient, minWidth) {
        const r = Math.floor((minWidth - 1) / 2);
        if (r <= 0)
            return GameplayMap.isWater(x, y);
        if (!GameplayMap.isWater(x, y))
            return false;
        // Check along perpendicular line
        if (orient === "col") {
            // Perpendicular to vertical is horizontal  vary dx, fixed y
            for (let dx = -r; dx <= r; dx++) {
                const nx = x + dx;
                if (nx < 0 || nx >= width)
                    return false;
                if (!GameplayMap.isWater(nx, y))
                    return false;
            }
            return true;
        }
        else if (orient === "row") {
            // Perpendicular to horizontal is vertical  vary dy, fixed x
            for (let dy = -r; dy <= r; dy++) {
                const ny = y + dy;
                if (ny < 0 || ny >= height)
                    return false;
                if (!GameplayMap.isWater(x, ny))
                    return false;
            }
            return true;
        }
        else if (orient === "diagNE") {
            // Lane along NE-SW (x+y = const); perpendicular is NW-SE (x+=t, y+=t)
            for (let t = -r; t <= r; t++) {
                const nx = x + t, ny = y + t;
                if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                    return false;
                if (!GameplayMap.isWater(nx, ny))
                    return false;
            }
            return true;
        }
        else if (orient === "diagNW") {
            // Lane along NW-SE (x-y = const); perpendicular is NE-SW (x+=t, y-=t)
            for (let t = -r; t <= r; t++) {
                const nx = x + t, ny = y - t;
                if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                    return false;
                if (!GameplayMap.isWater(nx, ny))
                    return false;
            }
            return true;
        }
        return false;
    }
    // Helpers for diagonals
    function longestWaterRunDiagSum(k) {
        // NE-SW family: x+y = k
        const xs = Math.max(0, k - (height - 1));
        const xe = Math.min(width - 1, k);
        let bestStartX = -1, bestEndX = -1, bestLen = 0;
        let curStartX = -1, curLen = 0;
        for (let x = xs; x <= xe; x++) {
            const y = k - x;
            if (GameplayMap.isWater(x, y)) {
                if (curLen === 0)
                    curStartX = x;
                curLen++;
                if (curLen > bestLen) {
                    bestLen = curLen;
                    bestStartX = curStartX;
                    bestEndX = x;
                }
            }
            else {
                curLen = 0;
            }
        }
        return {
            xs,
            xe,
            startX: bestStartX,
            endX: bestEndX,
            len: bestLen,
            axisLen: xe - xs + 1,
        };
    }
    function longestWaterRunDiagDiff(d) {
        // NW-SE family: x - y = d
        const ys = Math.max(0, -d);
        const ye = Math.min(height - 1, width - 1 - d);
        let bestStartY = -1, bestEndY = -1, bestLen = 0;
        let curStartY = -1, curLen = 0;
        for (let y = ys; y <= ye; y++) {
            const x = d + y;
            if (GameplayMap.isWater(x, y)) {
                if (curLen === 0)
                    curStartY = y;
                curLen++;
                if (curLen > bestLen) {
                    bestLen = curLen;
                    bestStartY = curStartY;
                    bestEndY = y;
                }
            }
            else {
                curLen = 0;
            }
        }
        return {
            ys,
            ye,
            startY: bestStartY,
            endY: bestEndY,
            len: bestLen,
            axisLen: ye - ys + 1,
        };
    }
    // Build candidates with simple scores and spacing metadata
    // Directionality bias setup (uses foundation directionality config; safe fallbacks)
    const DIR = FOUNDATION_DIRECTIONALITY || {};
    const COH = Math.max(0, Math.min(1, DIR.cohesion ?? 0));
    const plateAxisDeg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
    let windAxisDeg = (DIR?.primaryAxes?.windBiasDeg ?? 0) | 0;
    let currentAxisDeg = (DIR?.primaryAxes?.currentBiasDeg ?? 0) | 0;
    const windsFollowPlates = Math.max(0, Math.min(1, DIR?.interplay?.windsFollowPlates ?? 0)) * COH;
    const currentsFollowWinds = Math.max(0, Math.min(1, DIR?.interplay?.currentsFollowWinds ?? 0)) *
        COH;
    windAxisDeg += Math.round(plateAxisDeg * windsFollowPlates);
    currentAxisDeg += Math.round(plateAxisDeg * windsFollowPlates * 0.5);
    // Vector helpers
    function axisVec(deg) {
        const r = (deg * Math.PI) / 180;
        return { x: Math.cos(r), y: Math.sin(r) };
    }
    function laneVec(orient) {
        if (orient === "col")
            return { x: 0, y: 1 };
        if (orient === "row")
            return { x: 1, y: 0 };
        if (orient === "diagNE")
            return { x: 1 / Math.SQRT2, y: -1 / Math.SQRT2 }; // NE-SW
        if (orient === "diagNW")
            return { x: 1 / Math.SQRT2, y: 1 / Math.SQRT2 }; // NW-SE
        return { x: 1, y: 0 };
    }
    const WV = axisVec(windAxisDeg);
    const CV = axisVec(currentAxisDeg);
    function directionalityBias(orient) {
        if (COH <= 0)
            return 0;
        const L = laneVec(orient);
        const dotWind = Math.abs(WV.x * L.x + WV.y * L.y); // 0..1
        const dotCurr = Math.abs(CV.x * L.x + CV.y * L.y); // 0..1
        // Weight wind higher; currents gain from interplay with winds
        const wW = 1.0;
        const wC = 0.8 + 0.6 * currentsFollowWinds;
        const align = (dotWind * wW + dotCurr * wC) / (wW + wC);
        // Scale modestly to keep lane selection conservative
        return Math.round(align * 25 * COH);
    }
    /** @type {Array<{orient:'col'|'row'|'diagNE'|'diagNW', index:number, start:number, end:number, len:number, minWidth:number, score:number}>} */
    const candidates = [];
    // Columns
    const minCol = Math.floor(height * minLenFrac);
    for (let x = 1; x < width - 1; x += stride) {
        const run = longestWaterRunColumn(x, height);
        if (run.len >= minCol) {
            // Sample perpendicular width at a few points
            const step = Math.max(1, Math.floor(run.len / 10));
            let ok = true;
            for (let y = run.start; y <= run.end; y += step) {
                if (!hasPerpWidth(x, y, "col", requiredMinWidth)) {
                    ok = false;
                    break;
                }
            }
            const minW = ok ? requiredMinWidth : 1;
            const coverage = run.len / height;
            let score = run.len + 3 * minW + Math.round(coverage * 10);
            score += directionalityBias("col");
            candidates.push({
                orient: "col",
                index: x,
                start: run.start,
                end: run.end,
                len: run.len,
                minWidth: minW,
                score,
            });
        }
    }
    // Rows
    const minRow = Math.floor(width * minLenFrac);
    for (let y = 1; y < height - 1; y += stride) {
        const run = longestWaterRunRow(y, width);
        if (run.len >= minRow) {
            const step = Math.max(1, Math.floor(run.len / 10));
            let ok = true;
            for (let x = run.start; x <= run.end; x += step) {
                if (!hasPerpWidth(x, y, "row", requiredMinWidth)) {
                    ok = false;
                    break;
                }
            }
            const minW = ok ? requiredMinWidth : 1;
            const coverage = run.len / width;
            let score = run.len + 3 * minW + Math.round(coverage * 10);
            score += directionalityBias("row");
            candidates.push({
                orient: "row",
                index: y,
                start: run.start,
                end: run.end,
                len: run.len,
                minWidth: minW,
                score,
            });
        }
    }
    // Diagonals (optional)
    if (preferDiagonals) {
        // NE-SW: k = x+y in [0, width-1+height-1]
        const kMax = width - 1 + (height - 1);
        for (let k = 0; k <= kMax; k += Math.max(2, stride)) {
            const run = longestWaterRunDiagSum(k);
            const minDiag = Math.floor(run.axisLen * minLenFrac);
            if (run.len >= minDiag && run.startX !== -1) {
                const step = Math.max(1, Math.floor(run.len / 10));
                let ok = true;
                for (let x = run.startX; x <= run.endX; x += step) {
                    const y = k - x;
                    if (!hasPerpWidth(x, y, "diagNE", requiredMinWidth)) {
                        ok = false;
                        break;
                    }
                }
                const minW = ok ? requiredMinWidth : 1;
                const coverage = run.len / run.axisLen;
                let score = run.len + 2 * minW + Math.round(coverage * 10);
                score += directionalityBias("diagNE");
                candidates.push({
                    orient: "diagNE",
                    index: k,
                    start: run.startX,
                    end: run.endX,
                    len: run.len,
                    minWidth: minW,
                    score,
                });
            }
        }
        // NW-SE: d = x - y in [-(height-1)..(width-1)]
        const dMin = -(height - 1);
        const dMax = width - 1;
        for (let d = dMin; d <= dMax; d += Math.max(2, stride)) {
            const run = longestWaterRunDiagDiff(d);
            const minDiag = Math.floor(run.axisLen * minLenFrac);
            if (run.len >= minDiag && run.startY !== -1) {
                const step = Math.max(1, Math.floor(run.len / 10));
                let ok = true;
                for (let y = run.startY; y <= run.endY; y += step) {
                    const x = d + y;
                    if (!hasPerpWidth(x, y, "diagNW", requiredMinWidth)) {
                        ok = false;
                        break;
                    }
                }
                const minW = ok ? requiredMinWidth : 1;
                const coverage = run.len / run.axisLen;
                let score = run.len + 2 * minW + Math.round(coverage * 10);
                score += directionalityBias("diagNW");
                candidates.push({
                    orient: "diagNW",
                    index: d,
                    start: run.startY,
                    end: run.endY,
                    len: run.len,
                    minWidth: minW,
                    score,
                });
            }
        }
    }
    // Select top-K by score while enforcing spacing within the same orientation family
    candidates.sort((a, b) => b.score - a.score);
    /** @type {{col:number[],row:number[],diagNE:number[],diagNW:number[]}} */
    const chosenIdx = { col: [], row: [], diagNE: [], diagNW: [] };
    let lanes = 0;
    function spaced(orient, index) {
        const arr = chosenIdx[orient];
        for (let i = 0; i < arr.length; i++) {
            if (Math.abs(arr[i] - index) < laneSpacing)
                return false;
        }
        return true;
    }
    for (const c of candidates) {
        if (lanes >= maxLanes)
            break;
        if (!spaced(c.orient, c.index))
            continue;
        chosenIdx[c.orient].push(c.index);
        // Tag tiles for this lane
        if (c.orient === "col") {
            const x = c.index;
            for (let y = c.start; y <= c.end; y++) {
                if (GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        else if (c.orient === "row") {
            const y = c.index;
            for (let x = c.start; x <= c.end; x++) {
                if (GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        else if (c.orient === "diagNE") {
            const k = c.index;
            for (let x = c.start; x <= c.end; x++) {
                const y = k - x;
                if (x >= 0 &&
                    x < width &&
                    y >= 0 &&
                    y < height &&
                    GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        else if (c.orient === "diagNW") {
            const d = c.index;
            for (let y = c.start; y <= c.end; y++) {
                const x = d + y;
                if (x >= 0 &&
                    x < width &&
                    y >= 0 &&
                    y < height &&
                    GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        lanes++;
    }
    // Log a compact summary of selected sea lanes
    devLogIf &&
        devLogIf("LOG_STORY_TAGS", `[Corridors] Sea lanes selected: ${lanes} (col:${chosenIdx.col.length}, row:${chosenIdx.row.length}, diagNE:${chosenIdx.diagNE.length}, diagNW:${chosenIdx.diagNW.length}); tiles=${StoryTags.corridorSeaLane.size}`);
}
/**
 * Promote hotspot trail points to islandhop lanes (avoid clutter, just tag proximity).
 * We select up to N arcs from existing StoryTags.hotspot points.
 */
function tagIslandHopFromHotspots() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.islandHop) || {};
    if (!cfg.useHotspots)
        return;
    const maxArcs = Math.max(0, (cfg.maxArcs ?? 2) | 0);
    if (maxArcs === 0)
        return;
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    // Gather hotspot keys for indexed access
    const keys = Array.from(StoryTags.hotspot);
    if (!keys.length)
        return;
    // Randomly sample up to maxArcs seeds from the hotspot set
    const picked = new Set();
    let arcs = 0, attempts = 0;
    while (arcs < maxArcs && attempts < 100 && attempts < keys.length * 2) {
        attempts++;
        const idx = rand(keys.length, "IslandHopPick");
        const key = keys[idx % keys.length];
        if (picked.has(key))
            continue;
        picked.add(key);
        arcs++;
        // Tag the seed and a tight neighborhood to promote the trail locally
        const [sx, sy] = key.split(",").map(Number);
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const nx = sx + dx, ny = sy + dy;
                if (!inBounds(nx, ny))
                    continue;
                if (!GameplayMap.isWater(nx, ny))
                    continue;
                {
                    const kk = storyKey(nx, ny);
                    StoryTags.corridorIslandHop.add(kk);
                    assignCorridorMetadata(kk, "islandHop", "archipelago");
                }
            }
        }
    }
}
/**
 * Promote long riftshoulder runs as landopen corridors (plains/grass bias consumers).
 * MVP: tag shoulder tiles that form sufficiently long contiguous row segments.
 */
function tagLandCorridorsFromRifts() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.land) || {};
    if (!cfg.useRiftShoulders)
        return;
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const maxCorridors = Math.max(0, (cfg.maxCorridors ?? 2) | 0);
    const minRun = Math.max(12, (cfg.minRunLength ?? 24) | 0);
    if (maxCorridors === 0 || StoryTags.riftShoulder.size === 0)
        return;
    let corridors = 0;
    const spacing = Math.max(0, (cfg.spacing ?? 0) | 0);
    const usedRows = [];
    // Sweep rows; find shoulder segments of sufficient length, tag them until budget exhausted
    for (let y = 1; y < height - 1 && corridors < maxCorridors; y++) {
        let x = 1;
        while (x < width - 1 && corridors < maxCorridors) {
            // Skip nonshoulder
            while (x < width - 1 && !StoryTags.riftShoulder.has(storyKey(x, y)))
                x++;
            if (x >= width - 1)
                break;
            const start = x;
            while (x < width - 1 && StoryTags.riftShoulder.has(storyKey(x, y)))
                x++;
            const end = x - 1;
            const len = end - start + 1;
            if (len >= minRun) {
                // Enforce row spacing between chosen corridors
                let tooClose = false;
                for (let i = 0; i < usedRows.length; i++) {
                    if (Math.abs(usedRows[i] - y) < spacing) {
                        tooClose = true;
                        break;
                    }
                }
                if (!tooClose) {
                    // Determine corridor style for this segment using simple context heuristics
                    let totalElev = 0, totalRain = 0, samples = 0, reliefHits = 0;
                    for (let cx = start; cx <= end; cx++) {
                        if (GameplayMap.isWater(cx, y))
                            continue;
                        const e = GameplayMap.getElevation(cx, y);
                        const r = GameplayMap.getRainfall(cx, y);
                        totalElev += e;
                        totalRain += r;
                        samples++;
                        // simple local relief check (4-neighborhood)
                        const eN = GameplayMap.getElevation(cx, Math.max(0, y - 1));
                        const eS = GameplayMap.getElevation(cx, Math.min(GameplayMap.getGridHeight() - 1, y + 1));
                        const eW = GameplayMap.getElevation(Math.max(0, cx - 1), y);
                        const eE = GameplayMap.getElevation(Math.min(GameplayMap.getGridWidth() - 1, cx + 1), y);
                        const dMax = Math.max(Math.abs(e - eN), Math.abs(e - eS), Math.abs(e - eW), Math.abs(e - eE));
                        if (dMax >= 60)
                            reliefHits++;
                    }
                    const avgElev = samples > 0 ? Math.round(totalElev / samples) : 0;
                    const avgRain = samples > 0 ? Math.round(totalRain / samples) : 0;
                    const reliefFrac = samples > 0 ? reliefHits / samples : 0;
                    const latDeg = Math.abs(GameplayMap.getPlotLatitude(0, y));
                    // Baseline style from local context
                    let style = "plainsBelt";
                    if (reliefFrac > 0.35 && avgRain < 95) {
                        style = "canyon";
                    }
                    else if (avgElev > 650 && reliefFrac < 0.2) {
                        style = "plateau";
                    }
                    else if (avgElev > 550 && reliefFrac < 0.35) {
                        style = "flatMtn";
                    }
                    else if (avgRain < 85 && latDeg < 35) {
                        style = "desertBelt";
                    }
                    else if (avgRain > 115) {
                        style = "grasslandBelt";
                    }
                    // Directionality-influenced steering (cohesive macro alignment)
                    // Lanes here are row-oriented (east-west). Use global axes to nudge style.
                    try {
                        const DIR = FOUNDATION_DIRECTIONALITY || {};
                        const cohesion = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                        if (cohesion > 0) {
                            const plateDeg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
                            const windDeg = (DIR?.primaryAxes?.windBiasDeg ?? 0) | 0;
                            // Unit vectors for axes and this corridor orientation (row  east-west)
                            const radP = (plateDeg * Math.PI) / 180;
                            const radW = (windDeg * Math.PI) / 180;
                            const PV = { x: Math.cos(radP), y: Math.sin(radP) };
                            const WV = { x: Math.cos(radW), y: Math.sin(radW) };
                            const L = { x: 1, y: 0 }; // row-aligned
                            // Alignment 0..1 (absolute dot; we care about parallelism)
                            const alignPlate = Math.abs(PV.x * L.x + PV.y * L.y);
                            const alignWind = Math.abs(WV.x * L.x + WV.y * L.y);
                            // Heuristic thresholds scaled by cohesion
                            const hiAlign = 0.75 * cohesion + 0.1; // ~0.85 at cohesion 1.0
                            const midAlign = 0.5 * cohesion + 0.1;
                            // Plate-aligned corridors: bias toward structural styles
                            if (alignPlate >= hiAlign) {
                                if (avgElev > 650 && reliefFrac < 0.28) {
                                    style = "plateau";
                                }
                                else if (reliefFrac > 0.3 && avgRain < 100) {
                                    style = "canyon";
                                }
                                else if (avgElev > 560 && reliefFrac < 0.35) {
                                    style = "flatMtn";
                                }
                            }
                            else if (alignPlate >= midAlign) {
                                if (avgElev > 600 && reliefFrac < 0.25) {
                                    style = "plateau";
                                }
                            }
                            // Wind-aligned corridors: bias toward open belts (desert/grassland)
                            if (alignWind >= hiAlign) {
                                if (avgRain > 110 ||
                                    (latDeg < 25 && avgRain > 100)) {
                                    style = "grasslandBelt";
                                }
                                else if (avgRain < 90 && latDeg < 35) {
                                    style = "desertBelt";
                                }
                            }
                            else if (alignWind >= midAlign) {
                                if (avgRain > 120) {
                                    style = "grasslandBelt";
                                }
                            }
                        }
                    }
                    catch (_) {
                        // Keep baseline style on any error
                    }
                    for (let cx = start; cx <= end; cx++) {
                        if (!GameplayMap.isWater(cx, y)) {
                            const kk = storyKey(cx, y);
                            StoryTags.corridorLandOpen.add(kk);
                            assignCorridorMetadata(kk, "land", style);
                        }
                    }
                    usedRows.push(y);
                    corridors++;
                }
            }
        }
    }
}
/**
 * After rivers are modeled, tag riverchain corridors:
 * - Start near a coast and near rivers
 * - Greedily step to adjacent tiles that remain riveradjacent and prefer lowlands/downhill
 */
function tagRiverChainsPostRivers() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.river) || {};
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const maxChains = Math.max(0, (cfg.maxChains ?? 2) | 0);
    const maxSteps = Math.max(20, (cfg.maxSteps ?? 80) | 0);
    const lowlandThresh = Math.max(0, (cfg.preferLowlandBelow ?? 300) | 0);
    const coastSeedR = Math.max(1, (cfg.coastSeedRadius ?? 2) | 0);
    if (maxChains === 0)
        return;
    let chains = 0, tries = 0;
    while (chains < maxChains && tries < 300) {
        tries++;
        const sx = rand(width, "RiverChainSX");
        const sy = rand(height, "RiverChainSY");
        if (!inBounds(sx, sy))
            continue;
        if (!GameplayMap.isCoastalLand(sx, sy))
            continue;
        if (!GameplayMap.isAdjacentToRivers(sx, sy, coastSeedR))
            continue;
        let x = sx, y = sy, steps = 0;
        const pathKeys = [];
        while (steps < maxSteps) {
            if (!GameplayMap.isWater(x, y) &&
                GameplayMap.isAdjacentToRivers(x, y, 1)) {
                pathKeys.push(storyKey(x, y));
            }
            // Greedy move: prefer neighbor thats riveradjacent and lower/similar elevation,
            // with a mild preference for lowlands
            let bx = x, by = y, be = GameplayMap.getElevation(x, y);
            let improved = false;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0)
                        continue;
                    const nx = x + dx, ny = y + dy;
                    if (!inBounds(nx, ny) || GameplayMap.isWater(nx, ny))
                        continue;
                    if (!GameplayMap.isAdjacentToRivers(nx, ny, 1))
                        continue;
                    const e = GameplayMap.getElevation(nx, ny);
                    const prefer = e <= be || // downhill or level near river
                        (e < lowlandThresh && be >= lowlandThresh); // moving toward lowland
                    if (prefer) {
                        // Soft tiebreak with slight randomness to avoid loops
                        if (!improved || rand(3, "RiverChainTie") === 0) {
                            bx = nx;
                            by = ny;
                            be = e;
                            improved = true;
                        }
                    }
                }
            }
            if (!improved)
                break;
            x = bx;
            y = by;
            steps++;
        }
        const minTiles = Math.max(0, (cfg.minTiles ?? 0) | 0);
        const mustEndNearCoast = !!cfg.mustEndNearCoast;
        let endOK = true;
        if (mustEndNearCoast) {
            endOK =
                GameplayMap.isCoastalLand(x, y) ||
                    GameplayMap.isAdjacentToShallowWater(x, y);
        }
        if (pathKeys.length >= minTiles && endOK) {
            for (let i = 0; i < pathKeys.length; i++) {
                const kk = pathKeys[i];
                StoryTags.corridorRiverChain.add(kk);
                assignCorridorMetadata(kk, "river", "riverChain");
            }
            chains++;
        }
    }
}
/**
 * Entrypoint for corridor tagging.
 * Call with:
 *  - stage="preIslands": After coast/margin shaping, before island seeding
 *  - stage="postRivers": After modelRivers/defineNamedRivers
 * @param {"preIslands"|"postRivers"} stage
 */
export function storyTagStrategicCorridors(stage) {
    if (!STORY_ENABLE_CORRIDORS)
        return;
    clearCorridorStyleCache();
    if (stage === "preIslands") {
        tagSeaLanes();
        tagIslandHopFromHotspots();
        tagLandCorridorsFromRifts();
        backfillCorridorKinds();
    }
    else if (stage === "postRivers") {
        tagRiverChainsPostRivers();
        backfillCorridorKinds();
    }
}
function backfillCorridorKinds() {
    // Sea lanes: classify as coastal when adjacent to shallow water; else ocean
    for (const key of StoryTags.corridorSeaLane) {
        let kind = StoryTags.corridorKind.get(key) || "sea";
        let style = StoryTags.corridorStyle.get(key);
        if (!style) {
            const [sx, sy] = key.split(",").map(Number);
            style = GameplayMap.isAdjacentToShallowWater(sx, sy)
                ? "coastal"
                : "ocean";
        }
        assignCorridorMetadata(key, kind, style);
    }
    // Island-hop lanes: archipelago style
    for (const key of StoryTags.corridorIslandHop) {
        const kind = StoryTags.corridorKind.get(key) || "islandHop";
        const style = StoryTags.corridorStyle.get(key) || "archipelago";
        assignCorridorMetadata(key, kind, style);
    }
    // Land-open corridors: default to plainsBelt style (playable open land)
    for (const key of StoryTags.corridorLandOpen) {
        const kind = StoryTags.corridorKind.get(key) || "land";
        const style = StoryTags.corridorStyle.get(key) || "plainsBelt";
        assignCorridorMetadata(key, kind, style);
    }
    // River-chain corridors: riverChain style
    for (const key of StoryTags.corridorRiverChain) {
        const kind = StoryTags.corridorKind.get(key) || "river";
        const style = StoryTags.corridorStyle.get(key) || "riverChain";
        assignCorridorMetadata(key, kind, style);
    }
    // Dev: style distribution summary (counts by kind:style)
    try {
        const styleCounts = {};
        for (const [k, kind] of StoryTags.corridorKind) {
            const st = StoryTags.corridorStyle.get(k) || "unknown";
            const bucket = `${kind}:${st}`;
            styleCounts[bucket] = (styleCounts[bucket] || 0) + 1;
        }
        devLogIf &&
            devLogIf("LOG_STORY_TAGS", `[Corridors] Style distribution: ${JSON.stringify(styleCounts)}`);
    }
    catch (_) {
        /* safe log */
    }
}
export default {
    storyTagStrategicCorridors,
};
</file>

<file path="mod/maps/story/overlays.js">
// @ts-nocheck
/**
 * Story Overlay Registry  immutable narrative data products.
 *
 * Overlays capture sparse storytelling metadata (margins, corridors, etc.) so
 * downstream stages can consume consistent snapshots without rerunning the
 * tagging passes that produced them.
 */

const overlayRegistry = new Map();

/** @typedef {import("../core/types.js").StoryOverlaySnapshot} StoryOverlaySnapshot */
/** @typedef {import("../core/types.js").StoryOverlayRegistry} StoryOverlayRegistry */

/**
 * Known overlay keys.
 */
export const StoryOverlayKeys = Object.freeze({
  MARGINS: "margins",
});

/**
 * Clear the global overlay registry. Primarily used by tests.
 */
export function resetStoryOverlays() {
  overlayRegistry.clear();
}

/**
 * Publish an overlay snapshot into the registry and attach it to the provided
 * MapContext when available.
 *
 * @param {import("../core/types.js").MapContext|null} ctx
 * @param {string} key
 * @param {Partial<StoryOverlaySnapshot>} overlay
 * @returns {StoryOverlaySnapshot}
 */
export function publishStoryOverlay(ctx, key, overlay) {
  const snapshot = normalizeOverlay(key, overlay);
  overlayRegistry.set(key, snapshot);
  if (ctx && typeof ctx === "object") {
    if (!ctx.overlays || typeof ctx.overlays.set !== "function") {
      ctx.overlays = new Map();
    }
    ctx.overlays.set(key, snapshot);
  }
  return snapshot;
}

/**
 * Finalize an overlay snapshot without publishing it to the registry.
 *
 * @param {string} key
 * @param {Partial<StoryOverlaySnapshot>} overlay
 * @returns {StoryOverlaySnapshot}
 */
export function finalizeStoryOverlay(key, overlay) {
  return normalizeOverlay(key, overlay);
}

/**
 * Retrieve an overlay snapshot. Prefers the MapContext registry when available
 * and falls back to the global module registry.
 *
 * @param {import("../core/types.js").MapContext|null} ctx
 * @param {string} key
 * @returns {StoryOverlaySnapshot|null}
 */
export function getStoryOverlay(ctx, key) {
  if (ctx && ctx.overlays && typeof ctx.overlays.get === "function") {
    const local = ctx.overlays.get(key);
    if (local)
      return local;
  }
  return overlayRegistry.get(key) || null;
}

/**
 * Populate StoryTags margin sets from a margin overlay snapshot.
 *
 * @param {StoryOverlaySnapshot|null|undefined} overlay
 * @param {{ activeMargin?: Set<string>, passiveShelf?: Set<string> }} storyTags
 * @param {{ clear?: boolean }} [options]
 * @returns {typeof storyTags}
 */
export function hydrateMarginsStoryTags(overlay, storyTags, options = {}) {
  if (!overlay || !storyTags || typeof storyTags !== "object")
    return storyTags;
  const active = Array.isArray(overlay.active) ? overlay.active : [];
  const passive = Array.isArray(overlay.passive) ? overlay.passive : [];
  const clear = options.clear !== false;
  const activeSet = storyTags.activeMargin;
  const passiveSet = storyTags.passiveShelf;
  if (clear) {
    activeSet?.clear?.();
    passiveSet?.clear?.();
  }
  if (activeSet && typeof activeSet.add === "function") {
    for (const key of active)
      activeSet.add(key);
  }
  if (passiveSet && typeof passiveSet.add === "function") {
    for (const key of passive)
      passiveSet.add(key);
  }
  return storyTags;
}

/**
 * Internal: normalize and freeze an overlay snapshot to guarantee immutability.
 *
 * @param {string} key
 * @param {Partial<StoryOverlaySnapshot>} overlay
 * @returns {StoryOverlaySnapshot}
 */
function normalizeOverlay(key, overlay) {
  const base = overlay && typeof overlay === "object" ? overlay : {};
  const width = Number.isFinite(base.width) ? base.width : 0;
  const height = Number.isFinite(base.height) ? base.height : 0;
  const version = Number.isFinite(base.version) ? base.version : 1;
  const kind = typeof base.kind === "string" && base.kind.length > 0 ? base.kind : key;
  const active = freezeKeyArray(base.active);
  const passive = freezeKeyArray(base.passive);
  const summary = freezeSummary(base.summary);
  return Object.freeze({
    key,
    kind,
    version,
    width,
    height,
    active,
    passive,
    summary,
  });
}

function freezeKeyArray(values) {
  if (!Array.isArray(values))
    return Object.freeze([]);
  const deduped = [];
  const seen = new Set();
  for (const value of values) {
    if (typeof value !== "string")
      continue;
    if (seen.has(value))
      continue;
    seen.add(value);
    deduped.push(value);
  }
  return Object.freeze(deduped);
}

function freezeSummary(summary) {
  if (!summary || typeof summary !== "object")
    return Object.freeze({});
  return Object.freeze({ ...summary });
}

/**
 * Expose the registry for diagnostics without allowing mutation.
 */
export const StoryOverlays = Object.freeze({
  get registry() {
    return overlayRegistry;
  },
});
</file>

<file path="mod/maps/story/tagging.js">
// @ts-nocheck
/**
 * Climate Story  Tagging functions
 *
 * This module generates lightweight, sparse tags (StoryTags) that imprint
 * narrative motifs onto the map without heavy simulation. Tags are consumed by
 * other layers (coast/island shaping, rainfall refinement, biome/feature nudges).
 *
 * Exports:
 *  - storyTagHotspotTrails(ctx?): Tag deepocean hotspot polylines.
 *  - storyTagRiftValleys(ctx?): Tag inland rift centerlines and shoulder tiles.
 *
 * Notes:
 *  - Tags are stored in StoryTags as "x,y" string keys for simplicity.
 *  - ctx is optional; functions will query GameplayMap directly if omitted.
 *  - All tunables are conservative; guardrails are preserved by consumers.
 *  - Climate tuning (baseline and refinement) is configured via map_config and consumed in the climate layers; this module only tags, while consumers preserve clamps.
 */
import { StoryTags } from "./tags.js";
import { publishStoryOverlay, finalizeStoryOverlay, StoryOverlayKeys, hydrateMarginsStoryTags } from "./overlays.js";
import { STORY_TUNABLES, STORY_ENABLE_SWATCHES, STORY_ENABLE_PALEO, MARGINS_CFG, MOISTURE_ADJUSTMENTS, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { inBounds, storyKey, isAdjacentToLand } from "../core/utils.js";
import { writeClimateField, syncClimateField, ctxRandom } from "../core/types.js";
import { WorldModel } from "../world/model.js";
import { applyClimateSwatches } from "../layers/climate-engine.js";
/**
 * Tag deepocean hotspot trails as sparse polylines.
 * Trails are later used to bias offshore island placement and microclimates.
 *
 * Rules:
 *  - Keep trails far from land (minDistFromLand).
 *  - Enforce minimum separation between different trails.
 *  - March a fixed number of steps with occasional gentle bends.
 *
 * @param {object} [ctx] - Optional context (unused; present for future parity).
 * @returns {{ trails:number, points:number }} summary counts
 */
export function storyTagHotspotTrails(ctx) {
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const baseHot = STORY_TUNABLES.hotspot;
    const areaHot = Math.max(1, width * height);
    const sqrtHot = Math.min(2.0, Math.max(0.6, Math.sqrt(areaHot / 10000)));
    const maxTrails = Math.max(1, Math.round(baseHot.maxTrails * (0.9 + 0.6 * sqrtHot)));
    const steps = Math.round(baseHot.steps * (0.9 + 0.4 * sqrtHot));
    const stepLen = baseHot.stepLen;
    const minDistFromLand = baseHot.minDistFromLand;
    const minTrailSeparation = baseHot.minTrailSeparation;
    // Helper: ensure a candidate is far enough from any previously tagged hotspot point
    function farFromExisting(x, y) {
        for (const key of StoryTags.hotspot) {
            const [sx, sy] = key.split(",").map(Number);
            const d = Math.abs(sx - x) + Math.abs(sy - y); // Manhattan is cheap/sufficient
            if (d < minTrailSeparation)
                return false;
        }
        return true;
    }
    let trailsMade = 0;
    let totalPoints = 0;
    let attempts = 0;
    while (trailsMade < maxTrails && attempts < 200) {
        attempts++;
        const sx = TerrainBuilder.getRandomNumber(width, "HotspotSeedX");
        const sy = TerrainBuilder.getRandomNumber(height, "HotspotSeedY");
        if (!inBounds(sx, sy))
            continue;
        if (!GameplayMap.isWater(sx, sy))
            continue;
        if (isAdjacentToLand(sx, sy, minDistFromLand))
            continue;
        if (!farFromExisting(sx, sy))
            continue;
        // Choose one of 8 compass directions; well allow small bends as we march.
        const dirs = [
            [1, 0],
            [1, 1],
            [0, 1],
            [-1, 1],
            [-1, 0],
            [-1, -1],
            [0, -1],
            [1, -1],
        ];
        let dIndex = TerrainBuilder.getRandomNumber(dirs.length, "HotspotDir");
        let [dx, dy] = dirs[dIndex];
        let x = sx;
        let y = sy;
        let taggedThisTrail = 0;
        for (let s = 0; s < steps; s++) {
            x += dx * stepLen;
            y += dy * stepLen;
            if (!inBounds(x, y))
                break;
            if (!GameplayMap.isWater(x, y))
                continue;
            if (isAdjacentToLand(x, y, minDistFromLand))
                continue;
            StoryTags.hotspot.add(storyKey(x, y));
            taggedThisTrail++;
            totalPoints++;
            // Gentle bend with small probability (creates subtle arcs)
            if (TerrainBuilder.getRandomNumber(5, "HotspotBend") === 0) {
                dIndex =
                    (dIndex +
                        (TerrainBuilder.getRandomNumber(3, "HotspotTurn") - 1) +
                        dirs.length) %
                        dirs.length;
                [dx, dy] = dirs[dIndex];
            }
        }
        if (taggedThisTrail > 0) {
            trailsMade++;
        }
    }
    return { trails: trailsMade, points: totalPoints };
}
/**
 * Tag inland rift valleys using WorldModel.riftPotential where available.
 * Fallback: legacy random-marching rifts when WorldModel is disabled.
 *
 * @param {object} [ctx]
 * @returns {{ rifts:number, lineTiles:number, shoulderTiles:number }}
 */
export function storyTagRiftValleys(ctx) {
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const baseRift = STORY_TUNABLES.rift;
    const areaRift = Math.max(1, width * height);
    const sqrtRift = Math.min(2.0, Math.max(0.6, Math.sqrt(areaRift / 10000)));
    const maxRiftsPerMap = Math.max(1, Math.round(baseRift.maxRiftsPerMap * (0.8 + 0.6 * sqrtRift)));
    const lineSteps = Math.round(baseRift.lineSteps * (0.9 + 0.4 * sqrtRift));
    const stepLen = Math.max(1, baseRift.stepLen | 0);
    const shoulderWidth = baseRift.shoulderWidth + (sqrtRift > 1.5 ? 1 : 0);
    const useWM = !!(WorldModel?.isEnabled?.() &&
        WorldModel.riftPotential &&
        WorldModel.boundaryType &&
        WorldModel.boundaryCloseness);
    const idx = (x, y) => y * width + x;
    const inb = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
    const latDegAt = (y) => Math.abs(GameplayMap.getPlotLatitude(0, y));
    if (useWM) {
        const RP = WorldModel.riftPotential;
        const BT = WorldModel.boundaryType; // 1=convergent, 2=divergent
        const BC = WorldModel.boundaryCloseness;
        // 1) Find sparse seeds: local maxima on divergent boundaries over land
        const seeds = [];
        let thr = 192;
        let attempts = 0;
        while (attempts++ < 6) {
            seeds.length = 0;
            for (let y = 1; y < height - 1; y++) {
                if (latDegAt(y) > 70)
                    continue;
                for (let x = 1; x < width - 1; x++) {
                    if (GameplayMap.isWater(x, y))
                        continue;
                    const i = idx(x, y);
                    if (BT[i] !== 2 || BC[i] <= 32 || RP[i] < thr)
                        continue;
                    // Local-maximum test
                    const v = RP[i];
                    let isPeak = true;
                    for (let dy = -1; dy <= 1 && isPeak; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            if (RP[idx(x + dx, y + dy)] > v) {
                                isPeak = false;
                                break;
                            }
                        }
                    }
                    if (isPeak)
                        seeds.push({ x, y, v });
                }
            }
            if (seeds.length >= maxRiftsPerMap * 2 || thr <= 112)
                break;
            thr -= 16;
        }
        seeds.sort((a, b) => b.v - a.v);
        // Space seeds out by Manhattan distance
        const chosen = [];
        const minSeedSep = Math.round(sqrtRift > 1.5 ? 18 : 14);
        for (const s of seeds) {
            if (chosen.length >= maxRiftsPerMap)
                break;
            const farEnough = chosen.every((c) => Math.abs(c.x - s.x) + Math.abs(c.y - s.y) >= minSeedSep);
            if (farEnough)
                chosen.push(s);
        }
        let riftsMade = 0;
        let lineCount = 0;
        let shoulderCount = 0;
        function tagShoulders(x, y, sdx, sdy) {
            for (let off = 1; off <= shoulderWidth; off++) {
                const px = x + -sdy * off;
                const py = y + sdx * off;
                const qx = x + sdy * off;
                const qy = y + -sdx * off;
                if (inb(px, py) && !GameplayMap.isWater(px, py)) {
                    const pk = storyKey(px, py);
                    if (!StoryTags.riftShoulder.has(pk)) {
                        StoryTags.riftShoulder.add(pk);
                        shoulderCount++;
                    }
                }
                if (inb(qx, qy) && !GameplayMap.isWater(qx, qy)) {
                    const qk = storyKey(qx, qy);
                    if (!StoryTags.riftShoulder.has(qk)) {
                        StoryTags.riftShoulder.add(qk);
                        shoulderCount++;
                    }
                }
            }
        }
        for (const seed of chosen) {
            let x = seed.x, y = seed.y;
            if (latDegAt(y) > 70)
                continue;
            // Initialize step direction toward highest neighboring RP
            let sdx = 1, sdy = 0;
            {
                let best = -1, bdx = 1, bdy = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        const nx = x + dx, ny = y + dy;
                        if (!inb(nx, ny) || GameplayMap.isWater(nx, ny))
                            continue;
                        const p = RP[idx(nx, ny)];
                        if (p > best) {
                            best = p;
                            bdx = dx;
                            bdy = dy;
                        }
                    }
                }
                sdx = bdx;
                sdy = bdy;
            }
            let placedAny = false;
            for (let s = 0; s < lineSteps; s++) {
                if (!inb(x, y) || GameplayMap.isWater(x, y) || latDegAt(y) > 70)
                    break;
                const k = storyKey(x, y);
                if (!StoryTags.riftLine.has(k)) {
                    StoryTags.riftLine.add(k);
                    lineCount++;
                }
                placedAny = true;
                tagShoulders(x, y, sdx, sdy);
                // Helper: directionality bias toward plateAxisDeg (cohesion  riftsFollowPlates)
                function stepDirBias(tx, ty) {
                    try {
                        const DIR = FOUNDATION_DIRECTIONALITY || {};
                        const coh = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                        const follow = Math.max(0, Math.min(1, DIR?.interplay?.riftsFollowPlates ?? 0)) * coh;
                        if (follow <= 0)
                            return 0;
                        const deg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
                        const rad = (deg * Math.PI) / 180;
                        const ax = Math.cos(rad);
                        const ay = Math.sin(rad);
                        const vlen = Math.max(1, Math.hypot(tx, ty));
                        const vx = tx / vlen;
                        const vy = ty / vlen;
                        const dot = ax * vx + ay * vy; // -1..1
                        // Scale to a small, safe bonus
                        return Math.round(10 * follow * dot);
                    }
                    catch {
                        return 0;
                    }
                }
                // Choose next step by RP gradient with straightness + directionality preference
                let bestScore = -1, ndx = sdx, ndy = sdy, nx = x, ny = y;
                for (let ty = -1; ty <= 1; ty++) {
                    for (let tx = -1; tx <= 1; tx++) {
                        if (tx === 0 && ty === 0)
                            continue;
                        const cx = x + tx * stepLen, cy = y + ty * stepLen;
                        if (!inb(cx, cy) || GameplayMap.isWater(cx, cy))
                            continue;
                        const p = RP[idx(cx, cy)];
                        const align = tx === sdx && ty === sdy
                            ? 16
                            : tx === -sdx && ty === -sdy
                                ? -12
                                : 0;
                        const score = p + align + stepDirBias(tx, ty);
                        if (score > bestScore) {
                            bestScore = score;
                            ndx = tx;
                            ndy = ty;
                            nx = cx;
                            ny = cy;
                        }
                    }
                }
                // Stop if leaving divergent boundary band or very weak RP
                const ii = inb(nx, ny) ? idx(nx, ny) : -1;
                if (ii < 0 || BT[ii] !== 2 || BC[ii] <= 16 || RP[ii] < 64)
                    break;
                x = nx;
                y = ny;
                sdx = ndx;
                sdy = ndy;
            }
            if (placedAny)
                riftsMade++;
            if (riftsMade >= maxRiftsPerMap)
                break;
        }
        return {
            rifts: riftsMade,
            lineTiles: lineCount,
            shoulderTiles: shoulderCount,
        };
    }
    // Legacy fallback: original random marching implementation
    {
        // Two families of headings to get continental-scale lines without zig-zag
        const dirsNS = [
            [0, 1],
            [0, -1],
            [1, 1],
            [-1, -1],
        ];
        const dirsEW = [
            [1, 0],
            [-1, 0],
            [1, 1],
            [-1, -1],
        ];
        let riftsMade = 0;
        let lineCount = 0;
        let shoulderCount = 0;
        let tries = 0;
        while (riftsMade < maxRiftsPerMap && tries < 300) {
            tries++;
            const sx = TerrainBuilder.getRandomNumber(width, "RiftSeedX");
            const sy = TerrainBuilder.getRandomNumber(height, "RiftSeedY");
            if (!inBounds(sx, sy))
                continue;
            if (GameplayMap.isWater(sx, sy))
                continue;
            const plat = Math.abs(GameplayMap.getPlotLatitude(sx, sy));
            if (plat > 70)
                continue; // avoid extreme polar artifacts
            const elev = GameplayMap.getElevation(sx, sy);
            if (elev > 500)
                continue; // seed away from high mountains
            // Pick axis family and a particular direction
            const useNS = TerrainBuilder.getRandomNumber(2, "RiftAxis") === 0;
            let dir = useNS
                ? dirsNS[TerrainBuilder.getRandomNumber(dirsNS.length, "RiftDirNS")]
                : dirsEW[TerrainBuilder.getRandomNumber(dirsEW.length, "RiftDirEW")];
            let [dx, dy] = dir;
            let x = sx;
            let y = sy;
            let placedAny = false;
            for (let s = 0; s < lineSteps; s++) {
                x += dx * stepLen;
                y += dy * stepLen;
                if (!inBounds(x, y))
                    break;
                if (GameplayMap.isWater(x, y))
                    continue;
                const k = storyKey(x, y);
                if (!StoryTags.riftLine.has(k)) {
                    StoryTags.riftLine.add(k);
                    lineCount++;
                }
                placedAny = true;
                // Tag shoulder tiles on both sides (perpendicular offset)
                for (let off = 1; off <= shoulderWidth; off++) {
                    const px = x + -dy * off;
                    const py = y + dx * off;
                    const qx = x + dy * off;
                    const qy = y + -dx * off;
                    if (inBounds(px, py) && !GameplayMap.isWater(px, py)) {
                        const pk = storyKey(px, py);
                        if (!StoryTags.riftShoulder.has(pk)) {
                            StoryTags.riftShoulder.add(pk);
                            shoulderCount++;
                        }
                    }
                    if (inBounds(qx, qy) && !GameplayMap.isWater(qx, qy)) {
                        const qk = storyKey(qx, qy);
                        if (!StoryTags.riftShoulder.has(qk)) {
                            StoryTags.riftShoulder.add(qk);
                            shoulderCount++;
                        }
                    }
                }
                // Occasional, small bend to avoid ruler-straight lines
                if (TerrainBuilder.getRandomNumber(6, "RiftBend") === 0) {
                    if (useNS) {
                        dir =
                            dirsNS[TerrainBuilder.getRandomNumber(dirsNS.length, "RiftDirNS2")];
                    }
                    else {
                        dir =
                            dirsEW[TerrainBuilder.getRandomNumber(dirsEW.length, "RiftDirEW2")];
                    }
                    [dx, dy] = dir;
                }
            }
            if (placedAny) {
                riftsMade++;
            }
        }
        return {
            rifts: riftsMade,
            lineTiles: lineCount,
            shoulderTiles: shoulderCount,
        };
    }
}
export const OrogenyCache = {
    belts: new Set(),
    windward: new Set(),
    lee: new Set(),
};
/**
 * Tag Orogeny belts using WorldModel uplift/tectonic stress near convergent boundaries.
 * Fallback: legacy elevation-density heuristic when WorldModel is disabled.
 *
 * Returns simple counts; results stored in OrogenyCache for consumers.
 */
export function storyTagOrogenyBelts(ctx) {
    // Clear previous cache
    OrogenyCache.belts.clear();
    OrogenyCache.windward.clear();
    OrogenyCache.lee.clear();
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const area = Math.max(1, width * height);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    const cfg = STORY_TUNABLES?.orogeny || {};
    const baseRadius = (cfg.radius ?? 2) | 0;
    const radius = baseRadius + (sqrtScale > 1.5 ? 1 : 0);
    const minLenSoft = Math.max(10, Math.round((cfg.beltMinLength ?? 30) * (0.9 + 0.4 * sqrtScale)));
    const useWM = !!(WorldModel?.isEnabled?.() &&
        WorldModel.upliftPotential &&
        WorldModel.tectonicStress &&
        WorldModel.boundaryType &&
        WorldModel.boundaryCloseness);
    if (useWM) {
        const U = WorldModel.upliftPotential;
        const S = WorldModel.tectonicStress;
        const BT = WorldModel.boundaryType; // 1=convergent
        const BC = WorldModel.boundaryCloseness;
        // Pass 1: seed belts from convergent boundaries with high uplift/stress combo
        // Combined metric: 0.7*U + 0.3*S; threshold search to keep belts sparse
        let thr = 180;
        let attempts = 0;
        while (attempts++ < 5) {
            OrogenyCache.belts.clear();
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    if (GameplayMap.isWater(x, y))
                        continue;
                    const i = y * width + x;
                    if (BT[i] !== 1 || BC[i] < 48)
                        continue;
                    const metric = Math.round(0.7 * U[i] + 0.3 * S[i]);
                    if (metric >= thr) {
                        // Light neighborhood density check to avoid salt-and-pepper
                        let dense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0)
                                    continue;
                                const j = (y + dy) * width + (x + dx);
                                if (j >= 0 && j < width * height) {
                                    const m2 = Math.round(0.7 * U[j] + 0.3 * S[j]);
                                    if (m2 >= thr)
                                        dense++;
                                }
                            }
                        }
                        if (dense >= 2) {
                            OrogenyCache.belts.add(`${x},${y}`);
                        }
                    }
                }
            }
            if (OrogenyCache.belts.size >= minLenSoft || thr <= 128)
                break;
            thr -= 12;
        }
        // Soft reject trivial belts
        if (OrogenyCache.belts.size < minLenSoft) {
            return { belts: 0, windward: 0, lee: 0 };
        }
        // Prevailing wind step using WorldModel winds (fallback to zonal if unavailable)
        function windStepXY(x, y) {
            try {
                if (WorldModel?.windU && WorldModel?.windV) {
                    const width = GameplayMap.getGridWidth();
                    const i = y * width + x;
                    const u = WorldModel.windU[i] | 0;
                    const v = WorldModel.windV[i] | 0;
                    if (Math.abs(u) >= Math.abs(v)) {
                        return { dx: u === 0 ? 0 : u > 0 ? 1 : -1, dy: 0 };
                    }
                    else {
                        return { dx: 0, dy: v === 0 ? 0 : v > 0 ? 1 : -1 };
                    }
                }
            }
            catch {
                /* fall back to zonal below */
            }
            const lat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            return { dx: lat < 30 || lat >= 60 ? -1 : 1, dy: 0 };
        }
        // Pass 2: expand flanks on both sides of each belt tile
        for (const key of OrogenyCache.belts) {
            const [sx, sy] = key.split(",").map(Number);
            const { dx, dy } = windStepXY(sx, sy);
            const upwindX = -dx, upwindY = -dy;
            const downX = dx, downY = dy;
            for (let r = 1; r <= radius; r++) {
                const wx = sx + upwindX * r, wy = sy + upwindY * r;
                const lx = sx + downX * r, ly = sy + downY * r;
                if (inBounds(wx, wy) && !GameplayMap.isWater(wx, wy)) {
                    OrogenyCache.windward.add(storyKey(wx, wy));
                }
                if (inBounds(lx, ly) && !GameplayMap.isWater(lx, ly)) {
                    OrogenyCache.lee.add(storyKey(lx, ly));
                }
            }
        }
        return {
            belts: OrogenyCache.belts.size,
            windward: OrogenyCache.windward.size,
            lee: OrogenyCache.lee.size,
        };
    }
    // Legacy fallback: elevation-density heuristic
    {
        // Helper: elevation predicate (prefer GameplayMap.isMountain when exposed)
        function isHighElev(x, y) {
            if (!inBounds(x, y))
                return false;
            if (GameplayMap.isMountain && GameplayMap.isMountain(x, y))
                return true;
            return GameplayMap.getElevation(x, y) >= 500;
        }
        // Pass 1: collect belt candidates by local mountain density
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (!isHighElev(x, y))
                    continue;
                // Count high-elevation neighbors (8-neighborhood)
                let hi = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        const nx = x + dx, ny = y + dy;
                        if (isHighElev(nx, ny))
                            hi++;
                    }
                }
                if (hi >= 2) {
                    OrogenyCache.belts.add(storyKey(x, y));
                }
            }
        }
        // Soft reject trivial belts (very small mountain presence)
        if (OrogenyCache.belts.size < minLenSoft) {
            return { belts: 0, windward: 0, lee: 0 };
        }
        // Prevailing wind vector by latitude (zonal)
        function windDX(x, y) {
            const lat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            return lat < 30 || lat >= 60 ? -1 : 1; // EW else WE
        }
        // Pass 2: expand flanks on both sides of each belt tile
        for (const key of OrogenyCache.belts) {
            const [x, y] = key.split(",").map(Number);
            const dx = windDX(x, y);
            const dy = 0;
            const upwindX = -dx, upwindY = -dy;
            const downX = dx, downY = dy;
            for (let r = 1; r <= radius; r++) {
                const wx = x + upwindX * r, wy = y + upwindY * r;
                const lx = x + downX * r, ly = y + downY * r;
                if (inBounds(wx, wy) && !GameplayMap.isWater(wx, wy)) {
                    OrogenyCache.windward.add(storyKey(wx, wy));
                }
                if (inBounds(lx, ly) && !GameplayMap.isWater(lx, ly)) {
                    OrogenyCache.lee.add(storyKey(lx, ly));
                }
            }
        }
        return {
            belts: OrogenyCache.belts.size,
            windward: OrogenyCache.windward.size,
            lee: OrogenyCache.lee.size,
        };
    }
}
/**
 * Tag ACTIVE_MARGIN and PASSIVE_SHELF coast segments.
 * Heuristic (lane-safe, size-aware):
 * - Scan rows to collect contiguous coastal-land segments (cheap linear pass).
 * - Choose sparse, long segments for margins using target fractions and a minimum segment length.
 * - Targets scale gently with map size (sqrt(area/base)).
 * Notes
 * - Works without continent IDs; segments stay local and sparse to avoid noisy toggling.
 * - Consumers (coastlines/islands/features) must preserve minimum sea-lane width.
 */
export function storyTagContinentalMargins(ctxOrOptions = null, maybeOptions = null) {
    let ctx = null;
    let options = maybeOptions || {};
    if (ctxOrOptions && typeof ctxOrOptions === "object") {
        if (ctxOrOptions.adapter && ctxOrOptions.dimensions) {
            ctx = ctxOrOptions;
        }
        else if (!maybeOptions) {
            options = ctxOrOptions;
        }
    }
    const width = ctx?.dimensions?.width ?? GameplayMap.getGridWidth();
    const height = ctx?.dimensions?.height ?? GameplayMap.getGridHeight();
    // Size-aware fractions (configurable with safe defaults)
    const area = Math.max(1, width * height);
    const sqrt = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    const mcfg = MARGINS_CFG || {};
    const baseActiveFrac = Number.isFinite(mcfg.activeFraction)
        ? mcfg.activeFraction
        : 0.25;
    const basePassiveFrac = Number.isFinite(mcfg.passiveFraction)
        ? mcfg.passiveFraction
        : 0.25;
    const activeFrac = Math.min(0.35, baseActiveFrac + 0.05 * (sqrt - 1));
    const passiveFrac = Math.min(0.35, basePassiveFrac + 0.05 * (sqrt - 1));
    const baseMinSeg = Number.isFinite(mcfg.minSegmentLength)
        ? mcfg.minSegmentLength
        : 12;
    const minSegLen = Math.max(10, Math.round(baseMinSeg * (0.9 + 0.4 * sqrt))); // size-aware minimum
    // First pass: count total coastal land to derive quotas
    let totalCoast = 0;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (GameplayMap.isCoastalLand(x, y))
                totalCoast++;
        }
    }
    const targetActive = Math.floor(totalCoast * activeFrac);
    const targetPassive = Math.floor(totalCoast * passiveFrac);
    let markedActive = 0;
    let markedPassive = 0;
    const activeSet = new Set();
    const passiveSet = new Set();
    // Helper to mark a segment safely
    function markSegment(y, x0, x1, active) {
        for (let x = x0; x <= x1; x++) {
            const k = `${x},${y}`;
            if (!GameplayMap.isCoastalLand(x, y))
                continue;
            if (active) {
                if (markedActive >= targetActive)
                    break;
                if (!activeSet.has(k)) {
                    activeSet.add(k);
                    markedActive++;
                }
            }
            else {
                if (markedPassive >= targetPassive)
                    break;
                if (!passiveSet.has(k)) {
                    passiveSet.add(k);
                    markedPassive++;
                }
            }
        }
    }
    // Row sweep: build contiguous coastal-land segments and select some
    // Alternate selections to avoid clustering too many active or passive in a row.
    let preferActive = true;
    for (let y = 1; y < height - 1; y++) {
        let x = 1;
        while (x < width - 1) {
            // Find start of a coastal segment
            while (x < width - 1 && !GameplayMap.isCoastalLand(x, y))
                x++;
            if (x >= width - 1)
                break;
            const start = x;
            while (x < width - 1 && GameplayMap.isCoastalLand(x, y))
                x++;
            const end = x - 1;
            const segLen = end - start + 1;
            if (segLen >= minSegLen) {
                // Coin flip with bias toward the currently preferred type
                const roll = TerrainBuilder.getRandomNumber(100, "MarginSelect");
                const pickActive = (preferActive && roll < 60) || (!preferActive && roll < 40);
                if (pickActive && markedActive < targetActive) {
                    markSegment(y, start, end, true);
                }
                else if (markedPassive < targetPassive) {
                    markSegment(y, start, end, false);
                }
                // Alternate preference to reduce long runs of the same type
                preferActive = !preferActive;
            }
        }
        // Reset scanning x for next row
        x = 1;
    }
    const overlay = {
        kind: StoryOverlayKeys.MARGINS,
        version: 1,
        width,
        height,
        active: Array.from(activeSet),
        passive: Array.from(passiveSet),
        summary: {
            active: markedActive,
            passive: markedPassive,
            targetActive,
            targetPassive,
            minSegmentLength: minSegLen,
        },
    };
    const shouldPublish = options.publish !== false;
    const snapshot = shouldPublish
        ? publishStoryOverlay(ctx, StoryOverlayKeys.MARGINS, overlay)
        : finalizeStoryOverlay(StoryOverlayKeys.MARGINS, overlay);
    if (options.hydrateStoryTags !== false) {
        hydrateMarginsStoryTags(snapshot, StoryTags);
    }
    return snapshot;
}
// -------------------------------- Climate Swatches --------------------------------
/**
 * storyTagClimateSwatches  Paint one guaranteed macro swatch with soft edges.
 * - Selects one swatch type (weighted) and applies rainfall deltas with gentle falloff.
 * - Uses sqrt(area/base) to scale width/length modestly on large maps.
 * - Keeps all adjustments clamped to [0, 200] and local (single O(WH) pass).
 *
 * Swatch types (see STORY_TUNABLES.swatches.types):
 *  - macroDesertBelt: subtract rainfall around ~20 lat with soft bleed.
 *  - equatorialRainbelt: add rainfall around 0 lat with generous bleed.
 *  - rainforestArchipelago: add rainfall near warm coasts/islands (tropics).
 *  - mountainForests: add on orogeny windward, subtract a touch on lee.
 *  - greatPlains: lowland mid-lat dry bias (broad plains feel).
 */
export function storyTagClimateSwatches(ctx = null) {
    if (!STORY_ENABLE_SWATCHES)
        return { applied: false, kind: "disabled" };
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    if (!storyMoisture?.swatches)
        return { applied: false, kind: "missing-config" };
    const width = ctx?.dimensions?.width ?? GameplayMap.getGridWidth();
    const height = ctx?.dimensions?.height ?? GameplayMap.getGridHeight();
    const result = applyClimateSwatches(width, height, ctx, { orogenyCache: OrogenyCache });
    const summary = { ...result };
    if (STORY_ENABLE_PALEO) {
        try {
            const paleoResult = storyTagPaleoHydrology(ctx || undefined);
            summary.paleo = paleoResult;
        }
        catch (_) {
            /* keep generation resilient */
        }
    }
    return summary;
}
// -------------------------------- PaleoHydrology --------------------------------
/**
 * storyTagPaleoHydrology  elevationaware paleo motifs:
 *  - Deltas: slight humidity fans near river mouths (lowland, coastal).
 *  - Oxbows: a handful of lowland riveradjacent wet pockets (no rivers added).
 *  - Fossil channels: short polylines across dry lowlands toward local basins.
 * Elevation cues:
 *  - Canyon/bed dryness on the fossil centerline (small).
 *  - Optional bluff/rim hint via minor adjustments on immediate flanks.
 * Invariants:
 *  - All rainfall ops clamped [0, 200]. No broad floodfills. Strict caps.
 */
export function storyTagPaleoHydrology(ctx = null) {
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    const cfg = storyMoisture.paleo;
    if (!cfg)
        return { deltas: 0, oxbows: 0, fossils: 0 };
    const width = ctx?.dimensions?.width ?? GameplayMap.getGridWidth();
    const height = ctx?.dimensions?.height ?? GameplayMap.getGridHeight();
    const area = Math.max(1, width * height);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    if (ctx) {
        syncClimateField(ctx);
    }
    const clamp = (v, lo, hi) => (v < lo ? lo : v > hi ? hi : v);
    const nearStartGuard = ( /*x,y*/) => true;
    const rand = (n, lbl) => (ctx ? ctxRandom(ctx, lbl || 'Paleo', n) : TerrainBuilder.getRandomNumber(n, lbl || 'Paleo'));
    const adapter = ctx?.adapter ?? null;
    const rainfallBuf = ctx?.buffers?.climate?.rainfall || null;
    const idx = (x, y) => y * width + x;
    const readRainfall = (x, y) => {
        if (ctx && rainfallBuf) {
            return rainfallBuf[idx(x, y)] | 0;
        }
        return GameplayMap.getRainfall(x, y);
    };
    const writeRainfall = (x, y, rf) => {
        const clamped = clamp(rf, 0, 200);
        if (ctx) {
            writeClimateField(ctx, x, y, { rainfall: clamped });
        }
        else {
            TerrainBuilder.setRainfall(x, y, clamped);
        }
    };
    let deltas = 0, oxbows = 0, fossils = 0;
    if (cfg.maxDeltas > 0) {
        for (let y = 1; y < height - 1 && deltas < cfg.maxDeltas; y++) {
            for (let x = 1; x < width - 1 && deltas < cfg.maxDeltas; x++) {
                if (!(adapter?.isCoastalLand ? adapter.isCoastalLand(x, y) : GameplayMap.isCoastalLand(x, y)))
                    continue;
                if (!(adapter?.isAdjacentToRivers ? adapter.isAdjacentToRivers(x, y, 1) : GameplayMap.isAdjacentToRivers(x, y, 1)))
                    continue;
                if ((adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y)) > 300)
                    continue;
                const fanR = Math.max(0, cfg.deltaFanRadius | 0);
                for (let dy = -fanR; dy <= fanR; dy++) {
                    for (let dx = -fanR; dx <= fanR; dx++) {
                        const nx = x + dx, ny = y + dy;
                        if (!inBounds(nx, ny))
                            continue;
                        if (adapter?.isWater ? adapter.isWater(nx, ny) : GameplayMap.isWater(nx, ny))
                            continue;
                        let rf = readRainfall(nx, ny);
                        if (rand(100, 'DeltaMarsh') < Math.round((cfg.deltaMarshChance || 0.35) * 100)) {
                            rf = clamp(rf + 6, 0, 200);
                        }
                        else {
                            rf = clamp(rf + 3, 0, 200);
                        }
                        writeRainfall(nx, ny, rf);
                    }
                }
                deltas++;
            }
        }
    }
    if (cfg.maxOxbows > 0) {
        let attempts = 0;
        while (oxbows < cfg.maxOxbows && attempts < 300) {
            attempts++;
            const x = rand(width, 'OxbowX');
            const y = rand(height, 'OxbowY');
            if (!inBounds(x, y))
                continue;
            if (adapter?.isWater ? adapter.isWater(x, y) : GameplayMap.isWater(x, y))
                continue;
            const elev = adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y);
            if (elev > (cfg.oxbowElevationMax ?? 280))
                continue;
            if (!(adapter?.isAdjacentToRivers ? adapter.isAdjacentToRivers(x, y, 1) : GameplayMap.isAdjacentToRivers(x, y, 1)))
                continue;
            if (!nearStartGuard(x, y))
                continue;
            let rf = readRainfall(x, y);
            writeRainfall(x, y, rf + 8);
            oxbows++;
        }
    }
    if (cfg.maxFossilChannels > 0) {
        const baseLen = Math.max(6, cfg.fossilChannelLengthTiles | 0);
        const step = Math.max(1, cfg.fossilChannelStep | 0);
        const len = Math.round(baseLen * (1 + (cfg.sizeScaling?.lengthMulSqrt || 0) * (sqrtScale - 1)));
        const hum = cfg.fossilChannelHumidity | 0;
        const minDistFromRivers = Math.max(0, cfg.fossilChannelMinDistanceFromCurrentRivers | 0);
        const canyonCfg = cfg.elevationCarving || {};
        const rimW = Math.max(0, canyonCfg.rimWidth | 0);
        const canyonDryBonus = Math.max(0, canyonCfg.canyonDryBonus | 0);
        let tries = 0;
        while (fossils < cfg.maxFossilChannels && tries < 120) {
            tries++;
            let sx = rand(width, 'FossilX');
            let sy = rand(height, 'FossilY');
            if (!inBounds(sx, sy))
                continue;
            if (adapter?.isWater ? adapter.isWater(sx, sy) : GameplayMap.isWater(sx, sy))
                continue;
            const startElev = adapter?.getElevation ? adapter.getElevation(sx, sy) : GameplayMap.getElevation(sx, sy);
            if (startElev > 320)
                continue;
            if ((adapter?.isAdjacentToRivers ? adapter.isAdjacentToRivers(sx, sy, minDistFromRivers) : GameplayMap.isAdjacentToRivers(sx, sy, minDistFromRivers)))
                continue;
            let x = sx, y = sy;
            let used = 0;
            while (used < len) {
                if (inBounds(x, y) && !(adapter?.isWater ? adapter.isWater(x, y) : GameplayMap.isWater(x, y))) {
                    let rf = readRainfall(x, y);
                    rf = clamp(rf + hum, 0, 200);
                    if ((canyonCfg.enableCanyonRim ?? true) && canyonDryBonus > 0) {
                        rf = clamp(rf - canyonDryBonus, 0, 200);
                    }
                    writeRainfall(x, y, rf);
                    if ((canyonCfg.enableCanyonRim ?? true) && rimW > 0) {
                        for (let ry = -rimW; ry <= rimW; ry++) {
                            for (let rx = -rimW; rx <= rimW; rx++) {
                                if (rx === 0 && ry === 0)
                                    continue;
                                const nx = x + rx, ny = y + ry;
                                if (!inBounds(nx, ny) || (adapter?.isWater ? adapter.isWater(nx, ny) : GameplayMap.isWater(nx, ny)))
                                    continue;
                                const e0 = adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y);
                                const e1 = adapter?.getElevation ? adapter.getElevation(nx, ny) : GameplayMap.getElevation(nx, ny);
                                if (e1 > e0 + 15) {
                                    const rfn = clamp(readRainfall(nx, ny) - (cfg.bluffWetReduction ?? 0), 0, 200);
                                    writeRainfall(nx, ny, rfn);
                                }
                            }
                        }
                    }
                }
                let bestNX = x, bestNY = y, bestElev = adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y);
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        if ((dx !== 0 || dy !== 0) && (Math.abs(dx) + Math.abs(dy)) * step > 2)
                            continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (!inBounds(nx, ny))
                            continue;
                        const elev = adapter?.getElevation ? adapter.getElevation(nx, ny) : GameplayMap.getElevation(nx, ny);
                        if (elev < bestElev) {
                            bestElev = elev;
                            bestNX = nx;
                            bestNY = ny;
                        }
                    }
                }
                if (bestNX === x && bestNY === y)
                    break;
                x = bestNX;
                y = bestNY;
                used += step;
            }
            if (used >= len)
                fossils++;
        }
    }
    return { deltas, oxbows, fossils };
}

export default {
    storyTagHotspotTrails,
    storyTagRiftValleys,
    storyTagOrogenyBelts,
    storyTagContinentalMargins,
    storyTagClimateSwatches,
    storyTagPaleoHydrology,
    OrogenyCache,
};
</file>

<file path="mod/maps/story/tags.js">
// @ts-nocheck
/**
 * Climate Story  StoryTags
 *
 * A tiny singleton that holds sparse tag sets used to imprint narrative motifs
 * onto the map (e.g., hotspot trails, rift lines, shoulders, etc.). The object
 * itself is frozen to prevent reassignment, but the contained Sets are mutable.
 *
 * Usage:
 *   import { StoryTags, resetStoryTags } from './story/tags.js';
 *   StoryTags.hotspot.add(`${x},${y}`);
 *   resetStoryTags(); // clears all tag sets between generations
 */
/** @typedef {Set<string>} TagSet */
/**
 * StoryTags  singleton container for sparse tag sets.
 * Keys are tile-coordinate strings in the form "x,y".
 */
export const StoryTags = Object.freeze({
    /** @type {TagSet} Deep-ocean hotspot trail points */
    hotspot: new Set(),
    /** @type {TagSet} Centers of hotspot islands classified as "paradise" */
    hotspotParadise: new Set(),
    /** @type {TagSet} Centers of hotspot islands classified as "volcanic" */
    hotspotVolcanic: new Set(),
    /** @type {TagSet} Linear rift centerline tiles (inland) */
    riftLine: new Set(),
    /** @type {TagSet} Lateral shoulder tiles adjacent to rift lines */
    riftShoulder: new Set(),
    /** @type {TagSet} Active continental margin segments (trenchy/fjordy coast) */
    activeMargin: new Set(),
    /** @type {TagSet} Passive shelf segments (broad shallow shelf) */
    passiveShelf: new Set(),
    /** @type {TagSet} Naval open-water lanes (protected sea lanes) */
    corridorSeaLane: new Set(),
    /** @type {TagSet} Hotspot-based island-hop arcs (promoted trails) */
    corridorIslandHop: new Set(),
    /** @type {TagSet} Land open corridors (plains/grass bias zones) */
    corridorLandOpen: new Set(),
    /** @type {TagSet} River chain corridors (river-adjacent lowland paths) */
    corridorRiverChain: new Set(),
    /**
     * Corridor metadata  kind and style
     * - kind: high-level corridor family (e.g., "sea", "islandHop", "land", "river")
     * - style: sub-variant or motif (e.g., "ocean", "coastal", "canyon", "plateau", "flatMtn")
     * Keys match StoryTags tile keys ("x,y"). These maps are sparse like the tag sets.
     */
    /** @type {Map<string, string>} */
    corridorKind: new Map(),
    /** @type {Map<string, string>} */
    corridorStyle: new Map(),
    /** @type {Map<string, Readonly<Record<string, any>>>} */
    corridorAttributes: new Map(),
});
/**
 * Clears all StoryTags sets. Call once per generation (or when rebuilding tags)
 * to ensure callers never operate on stale data.
 */
export function resetStoryTags() {
    StoryTags.hotspot.clear();
    StoryTags.hotspotParadise.clear();
    StoryTags.hotspotVolcanic.clear();
    StoryTags.riftLine.clear();
    StoryTags.riftShoulder.clear();
    StoryTags.activeMargin.clear();
    StoryTags.passiveShelf.clear();
    StoryTags.corridorSeaLane.clear();
    StoryTags.corridorIslandHop.clear();
    StoryTags.corridorLandOpen.clear();
    StoryTags.corridorRiverChain.clear();
    // Corridor metadata maps
    StoryTags.corridorKind.clear();
    StoryTags.corridorStyle.clear();
    StoryTags.corridorAttributes.clear();
}
export default StoryTags;
</file>

<file path="mod/maps/world/model.js">
// @ts-nocheck
/**
 * WorldModel  Earth Forces Simulation (Physics-Based Plate Tectonics)
 *
 * Purpose
 * - Precompute global "world fields" (plates, plate boundaries, uplift/rift potentials,
 *   winds, ocean currents, mantle pressure) using proper Voronoi diagrams and physics.
 * - These fields are read-only for other layers (tagging, climate, coasts, corridors) to use later.
 * - Keep conservative defaults; remain fully optional via config toggle.
 *
 * Invariants
 * - Never mutate engine surfaces from here; this module only computes arrays/fields.
 * - Keep complexity O(width  height) with small constants; no flood fills.
 *
 * Dependencies (Base Game Scripts)
 * - Imports from /base-standard/scripts/voronoi-utils.js - Voronoi diagram generation
 * - Imports from /base-standard/scripts/voronoi-region.js - PlateRegion with movement vectors
 * - Imports from /base-standard/scripts/kd-tree.js - Spatial indexing for boundaries
 *
 * Status
 * - Phase 1.5 Complete: Proper Voronoi-based plates with physics-driven boundaries
 * - Phase 2 Pending: Wire WorldModel to consumers (mountains, climate, coasts)
 */
import { FOUNDATION_PLATES, FOUNDATION_DYNAMICS, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { computePlatesVoronoi } from "./plates.js";
import { PlateSeedManager } from "./plate_seed.js";
import { devLogIf } from "../bootstrap/dev.js";
/** @typedef {"none" | "convergent" | "divergent" | "transform"} BoundaryType */
const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});
/** Internal state holder (module singletons) */
const _state = {
    initialized: false,
    width: 0,
    height: 0,
    // Plates
    plateId: /** @type {Int16Array|null} */ (null),
    boundaryCloseness: /** @type {Uint8Array|null} */ (null), // 0..255 (higher = closer to boundary)
    boundaryType: /** @type {Uint8Array|null} */ (null), // ENUM_BOUNDARY
    tectonicStress: /** @type {Uint8Array|null} */ (null), // 0..255
    upliftPotential: /** @type {Uint8Array|null} */ (null), // 0..255
    riftPotential: /** @type {Uint8Array|null} */ (null), // 0..255
    shieldStability: /** @type {Uint8Array|null} */ (null), // 0..255 (higher = more interior/stable)
    // Plate movement vectors (new in Phase 1.5)
    plateMovementU: /** @type {Int8Array|null} */ (null), // -127..127 (horizontal plate movement)
    plateMovementV: /** @type {Int8Array|null} */ (null), // -127..127 (vertical plate movement)
    plateRotation: /** @type {Int8Array|null} */ (null), // -127..127 (plate rotation value)
    // Winds (per tile, basic vector)
    windU: /** @type {Int8Array|null} */ (null), // -127..127
    windV: /** @type {Int8Array|null} */ (null),
    // Ocean currents (only meaningful on water tiles)
    currentU: /** @type {Int8Array|null} */ (null),
    currentV: /** @type {Int8Array|null} */ (null),
    // Mantle pressure/bumps (0..255)
    pressure: /** @type {Uint8Array|null} */ (null),
    // Plate boundary spatial index (new in Phase 1.5)
    boundaryTree: /** @type {any|null} */ (null), // kdTree for fast boundary queries
    plateSeed: /** @type {Readonly<any>|null} */ (null),
};
/**
 * Public singleton API
 */
export const WorldModel = {
    /**
     * Returns true if WorldModel is toggled on and successfully initialized for this map.
     */
    isEnabled() {
        return !!_state.initialized;
    },
    /**
     * Initialize world fields. Safe to call multiple times; subsequent calls are no-ops.
     * Does nothing if the toggle is disabled or engine APIs are unavailable.
     */
    init() {
        if (_state.initialized)
            return true;
        // Guard: engine-provided API
        const ok = typeof GameplayMap?.getGridWidth === "function" &&
            typeof GameplayMap?.getGridHeight === "function" &&
            typeof GameplayMap?.isWater === "function" &&
            typeof GameplayMap?.getPlotLatitude === "function";
        if (!ok) {
            devLogIf &&
                devLogIf("LOG_STORY_TAGS", "[WorldModel] Engine APIs unavailable; skipping initialization.");
            return false;
        }
        const width = GameplayMap.getGridWidth();
        const height = GameplayMap.getGridHeight();
        _state.width = width | 0;
        _state.height = height | 0;
        const size = Math.max(0, width * height) | 0;
        // Allocate arrays
        _state.plateId = new Int16Array(size);
        _state.boundaryCloseness = new Uint8Array(size);
        _state.boundaryType = new Uint8Array(size);
        _state.tectonicStress = new Uint8Array(size);
        _state.upliftPotential = new Uint8Array(size);
        _state.riftPotential = new Uint8Array(size);
        _state.shieldStability = new Uint8Array(size);
        _state.plateMovementU = new Int8Array(size);
        _state.plateMovementV = new Int8Array(size);
        _state.plateRotation = new Int8Array(size);
        _state.windU = new Int8Array(size);
        _state.windV = new Int8Array(size);
        _state.currentU = new Int8Array(size);
        _state.currentV = new Int8Array(size);
        _state.pressure = new Uint8Array(size);
        // Compute placeholder fields (fast, coherent)
        computePlates(width, height);
        computePressure(width, height);
        computeWinds(width, height);
        computeCurrents(width, height);
        _state.initialized = true;
        devLogIf &&
            devLogIf("LOG_STORY_TAGS", "[WorldModel] Initialized fields for this map.", {
                width,
                height,
                plates: FOUNDATION_PLATES?.count ?? 0,
            });
        return true;
    },
    /**
     * Utility to fetch typed arrays (read-only by convention).
     * Returns null if not initialized or disabled.
     */
    get plateId() {
        return _state.plateId;
    },
    get boundaryCloseness() {
        return _state.boundaryCloseness;
    },
    get boundaryType() {
        return _state.boundaryType;
    },
    get tectonicStress() {
        return _state.tectonicStress;
    },
    get upliftPotential() {
        return _state.upliftPotential;
    },
    get riftPotential() {
        return _state.riftPotential;
    },
    get shieldStability() {
        return _state.shieldStability;
    },
    get windU() {
        return _state.windU;
    },
    get windV() {
        return _state.windV;
    },
    get currentU() {
        return _state.currentU;
    },
    get currentV() {
        return _state.currentV;
    },
    get pressure() {
        return _state.pressure;
    },
    get plateMovementU() {
        return _state.plateMovementU;
    },
    get plateMovementV() {
        return _state.plateMovementV;
    },
    get plateRotation() {
        return _state.plateRotation;
    },
    get boundaryTree() {
        return _state.boundaryTree;
    },
    get plateSeed() {
        return _state.plateSeed;
    },
};
/* ---------------------------------- helpers ---------------------------------- */
function idx(x, y, width) {
    return y * width + x;
}
/**
 * Compute plate assignment using proper Voronoi diagrams with physics-based boundaries
 * - Uses base game's VoronoiUtils for accurate boundary detection
 * - Calculates subduction/sliding from plate movement vectors
 * - Stores boundaries in kdTree for fast Phase 2 queries
 *
 * Phase 1.5 Upgrade: Replaced simple distance-based Voronoi with proper edge-based system
 */
function computePlates(width, height) {
    const platesCfg = FOUNDATION_PLATES || {};
    const count = Math.max(2, platesCfg?.count | 0 || 8);
    const convergenceMix = Math.max(0, Math.min(1, platesCfg?.convergenceMix ?? 0.5));
    const relaxationSteps = Math.max(0, platesCfg?.relaxationSteps | 0 || 5);
    const plateRotationMultiple = platesCfg?.plateRotationMultiple ?? 1.0;
    const seedMode = platesCfg?.seedMode === "fixed" ? "fixed" : "engine";
    const seedOffset = Number.isFinite(platesCfg?.seedOffset)
        ? Math.trunc(platesCfg.seedOffset)
        : 0;
    const fixedSeed = Number.isFinite(platesCfg?.fixedSeed)
        ? Math.trunc(platesCfg.fixedSeed)
        : undefined;

    const configSnapshot = {
        count,
        relaxationSteps,
        convergenceMix,
        plateRotationMultiple,
        seedMode,
        fixedSeed,
        seedOffset,
    };
    const generationConfig = {
        ...configSnapshot,
        directionality: FOUNDATION_DIRECTIONALITY,
    };
    const { snapshot: seedBase, restore: restoreSeed } = PlateSeedManager.capture(width, height, generationConfig);
    let plateData = null;
    try {
        // Call new Voronoi-based plate generation
        plateData = computePlatesVoronoi(width, height, generationConfig);
    }
    finally {
        if (typeof restoreSeed === "function") {
            try {
                restoreSeed();
            }
            catch (_err) {
                /* no-op */
            }
        }
    }
    if (!plateData) {
        const fallbackConfig = Object.freeze({ ...configSnapshot });
        const fallbackSeed = seedBase
            ? Object.freeze({
                ...seedBase,
                config: fallbackConfig,
            })
            : Object.freeze({
                width,
                height,
                config: fallbackConfig,
            });
        _state.plateSeed =
            PlateSeedManager.finalize(seedBase, {
                config: configSnapshot,
            }) || fallbackSeed;
        return;
    }

    // Copy results into WorldModel state arrays
    _state.plateId.set(plateData.plateId);
    _state.boundaryCloseness.set(plateData.boundaryCloseness);
    _state.boundaryType.set(plateData.boundaryType);
    _state.tectonicStress.set(plateData.tectonicStress);
    _state.upliftPotential.set(plateData.upliftPotential);
    _state.riftPotential.set(plateData.riftPotential);
    _state.shieldStability.set(plateData.shieldStability);
    _state.plateMovementU.set(plateData.plateMovementU);
    _state.plateMovementV.set(plateData.plateMovementV);
    _state.plateRotation.set(plateData.plateRotation);

    // Store boundary tree for Phase 2 mountain placement
    _state.boundaryTree = plateData.boundaryTree;
    const meta = plateData.meta || {};
    const fallbackConfig = Object.freeze({ ...configSnapshot });
    const fallbackSeed = seedBase
        ? Object.freeze({
            ...seedBase,
            config: fallbackConfig,
        })
        : Object.freeze({
            width,
            height,
            config: fallbackConfig,
        });
    _state.plateSeed =
        PlateSeedManager.finalize(seedBase, {
            config: configSnapshot,
            meta,
        }) || fallbackSeed;

    devLogIf &&
        devLogIf("LOG_STORY_TAGS", "[WorldModel] Plate generation complete", {
            plateCount: count,
            boundaryCount: plateData.boundaryTree ? "available" : "none",
        });
}
/**
 * Mantle pressure: small number of Gaussian bumps (very low frequency) + normalization.
 * Output: pressure 0..255
 */
function computePressure(width, height) {
    const size = width * height;
    const pressure = _state.pressure;
    if (!pressure)
        return;
    // Params
    const mantleCfg = FOUNDATION_DYNAMICS?.mantle || {};
    const bumps = Math.max(1, mantleCfg?.bumps | 0 || 4);
    const amp = Math.max(0.1, mantleCfg?.amplitude ?? 0.6);
    const scl = Math.max(0.1, mantleCfg?.scale ?? 0.4);
    const sigma = Math.max(4, Math.floor(Math.min(width, height) * scl));
    // Random bump centers
    const centers = [];
    for (let i = 0; i < bumps; i++) {
        const cx = TerrainBuilder?.getRandomNumber?.(width, "PressCX") ??
            (i * width) / bumps;
        const cy = TerrainBuilder?.getRandomNumber?.(height, "PressCY") ??
            (i * height) / bumps;
        const a = amp *
            (0.75 +
                (TerrainBuilder?.getRandomNumber?.(50, "PressA") ?? 0) / 100);
        centers.push({ x: Math.floor(cx), y: Math.floor(cy), a });
    }
    // Accumulate Gaussian bumps
    const acc = new Float32Array(size);
    const inv2s2 = 1.0 / (2 * sigma * sigma);
    let maxVal = 1e-6;
    for (let k = 0; k < centers.length; k++) {
        const { x: cx, y: cy, a } = centers[k];
        const yMin = Math.max(0, cy - sigma * 2);
        const yMax = Math.min(height - 1, cy + sigma * 2);
        const xMin = Math.max(0, cx - sigma * 2);
        const xMax = Math.min(width - 1, cx + sigma * 2);
        for (let y = yMin; y <= yMax; y++) {
            const dy = y - cy;
            for (let x = xMin; x <= xMax; x++) {
                const dx = x - cx;
                const e = Math.exp(-(dx * dx + dy * dy) * inv2s2);
                const v = a * e;
                const i = idx(x, y, width);
                acc[i] += v;
                if (acc[i] > maxVal)
                    maxVal = acc[i];
            }
        }
    }
    // Normalize 0..255
    for (let i = 0; i < size; i++) {
        pressure[i] = toByte(acc[i] / maxVal);
    }
}
/**
 * Winds: zonal baseline by latitude band + a few jet streaks; tiny V component.
 * Output: windU, windV in approximate tile-units (-127..127)
 */
function computeWinds(width, height) {
    const U = _state.windU;
    const V = _state.windV;
    if (!U || !V)
        return;
    const windCfg = FOUNDATION_DYNAMICS?.wind || {};
    const streaks = Math.max(0, windCfg?.jetStreaks | 0 || 3);
    const jetStrength = Math.max(0, windCfg?.jetStrength ?? 1.0);
    const variance = Math.max(0, windCfg?.variance ?? 0.6);
    // Build jet streak latitude centers (absolute degrees)
    const streakLats = [];
    for (let s = 0; s < streaks; s++) {
        const base = 30 + s * (30 / Math.max(1, streaks - 1)); // between 30 and ~60
        const jitter = (TerrainBuilder?.getRandomNumber?.(12, "JetJit") ?? 0) - 6;
        streakLats.push(Math.max(15, Math.min(75, base + jitter)));
    }
    for (let y = 0; y < height; y++) {
        const latDeg = Math.abs(GameplayMap.getPlotLatitude(0, y));
        // Zonal baseline (Coriolis): 030 and 6090 EW (-), 3060 WE (+)
        let u = latDeg < 30 || latDeg >= 60 ? -80 : 80;
        let v = 0;
        // Jet amplification near streak latitudes
        for (let k = 0; k < streakLats.length; k++) {
            const d = Math.abs(latDeg - streakLats[k]);
            const f = Math.max(0, 1 - d / 12); // within ~12 band
            if (f > 0) {
                const boost = Math.round(32 * jetStrength * f);
                u += latDeg < streakLats[k] ? boost : -boost; // simple shear orientation
            }
        }
        // Per-row variance
        const varU = Math.round(((TerrainBuilder?.getRandomNumber?.(21, "WindUVar") ?? 0) -
            10) *
            variance) | 0;
        const varV = Math.round(((TerrainBuilder?.getRandomNumber?.(11, "WindVVar") ?? 0) - 5) *
            variance) | 0;
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);
            // Directionality bias for winds (cohesive global control)
            (function applyWindBias() {
                try {
                    const DIR = FOUNDATION_DIRECTIONALITY || {};
                    const cohesion = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                    const followPlates = Math.max(0, Math.min(1, DIR?.interplay?.windsFollowPlates ?? 0));
                    let biasDeg = DIR?.primaryAxes?.windBiasDeg ?? 0;
                    biasDeg +=
                        (DIR?.primaryAxes?.plateAxisDeg ?? 0) *
                            followPlates *
                            cohesion;
                    // Optional hemisphere flip around equator
                    const rawLat = GameplayMap.getPlotLatitude(0, y);
                    if ((DIR?.hemispheres?.southernFlip ?? false) &&
                        rawLat < 0) {
                        biasDeg = -biasDeg;
                    }
                    const angleJitter = (DIR?.variability?.angleJitterDeg ?? 0) | 0;
                    const jitter = (TerrainBuilder?.getRandomNumber?.(angleJitter * 2 + 1, "WindDirJit") ?? 0) - angleJitter;
                    const rad = ((biasDeg + jitter) * Math.PI) / 180;
                    const biasMag = Math.round(30 * cohesion);
                    const bu = Math.round(biasMag * Math.cos(rad));
                    const bv = Math.round(biasMag * Math.sin(rad));
                    U[i] = clampInt(u + varU + bu, -127, 127);
                    V[i] = clampInt(v + varV + bv, -127, 127);
                    return;
                }
                catch (_) {
                    /* fall back to baseline below */
                }
                U[i] = clampInt(u + varU, -127, 127);
                V[i] = clampInt(v + varV, -127, 127);
            })();
        }
    }
}
/**
 * Ocean currents: placeholder banded flows.
 * - Equatorial westward current near 012
 * - Weak subpolar east/west hints at high latitudes
 */
function computeCurrents(width, height) {
    const U = _state.currentU;
    const V = _state.currentV;
    if (!U || !V)
        return;
    for (let y = 0; y < height; y++) {
        const latDeg = Math.abs(GameplayMap.getPlotLatitude(0, y));
        let baseU = 0;
        let baseV = 0;
        if (latDeg < 12) {
            baseU = -50; // westward
        }
        else if (latDeg >= 45 && latDeg < 60) {
            baseU = 20; // modest eastward mid-lat
        }
        else if (latDeg >= 60) {
            baseU = -15; // weak westward near polar
        }
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);
            if (GameplayMap.isWater(x, y)) {
                // Directionality bias for currents + interplay with winds
                let cu = baseU;
                let cv = baseV;
                (function applyCurrentBias() {
                    try {
                        const DIR = FOUNDATION_DIRECTIONALITY || {};
                        const cohesion = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                        const windsFactor = Math.max(0, Math.min(1, DIR?.interplay?.currentsFollowWinds ?? 0)) * cohesion;
                        // Sample prevailing wind vector at the row center (cheap proxy)
                        let wu = 0, wv = 0;
                        if (_state.windU && _state.windV) {
                            const wi = idx(Math.floor(width / 2), y, width);
                            wu = _state.windU[wi] | 0;
                            wv = _state.windV[wi] | 0;
                        }
                        cu += Math.round(wu * windsFactor);
                        cv += Math.round(wv * windsFactor);
                        // Add global current bias (optionally nudged toward plate axis via winds-follow-plates)
                        let biasDeg = DIR?.primaryAxes?.currentBiasDeg ?? 0;
                        biasDeg +=
                            (DIR?.interplay?.windsFollowPlates ?? 0) *
                                (DIR?.primaryAxes?.plateAxisDeg ?? 0) *
                                cohesion *
                                0.5;
                        const angleJitter = (DIR?.variability?.angleJitterDeg ?? 0) | 0;
                        const jitter = (TerrainBuilder?.getRandomNumber?.(angleJitter * 2 + 1, "CurrentDirJit") ?? 0) - angleJitter;
                        // Optional hemisphere flip around equator
                        const rawLat = GameplayMap.getPlotLatitude(0, y);
                        if ((DIR?.hemispheres?.southernFlip ?? false) &&
                            rawLat < 0) {
                            biasDeg = -biasDeg;
                        }
                        const rad = ((biasDeg + jitter) * Math.PI) / 180;
                        const biasMag = Math.round(25 * cohesion);
                        cu += Math.round(biasMag * Math.cos(rad));
                        cv += Math.round(biasMag * Math.sin(rad));
                    }
                    catch (_) {
                        /* keep baseline cu/cv */
                    }
                })();
                U[i] = clampInt(cu, -127, 127);
                V[i] = clampInt(cv, -127, 127);
            }
            else {
                U[i] = 0;
                V[i] = 0;
            }
        }
    }
}
/* --------------------------------- utilities -------------------------------- */
function clampInt(v, lo, hi) {
    return v < lo ? lo : v > hi ? hi : v | 0;
}
function toByte01(f) {
    const v = Math.max(0, Math.min(1, f));
    return Math.round(v * 255) | 0;
}
function toByte(v) {
    // Accept 0..1 or raw float values; clamp to [0..255]
    if (v <= 1 && v >= 0)
        return toByte01(v);
    return clampInt(Math.round(v), 0, 255);
}
export default WorldModel;
</file>

<file path="mod/maps/world/plate_seed.js">
// @ts-nocheck
/**
 * PlateSeedManager  deterministic Voronoi physics seeding
 *
 * Responsibilities
 * - Normalize plate seed config (mode, fixed seed, offsets).
 * - Capture the Civ VII RandomImpl state before plate generation, apply overrides,
 *   and provide a restoration callback so downstream systems share a single seed.
 * - Emit frozen snapshots for diagnostics (timestamp, RNG state, seed locations).
 */
import { RandomImpl } from "/base-standard/scripts/random-pcg-32.js";

function safeTimestamp() {
    try {
        return typeof Date?.now === "function" ? Date.now() : null;
    }
    catch (_err) {
        return null;
    }
}

function freezeRngState(state) {
    if (!state || typeof state !== "object")
        return null;
    const clone = {};
    for (const key of Object.keys(state)) {
        clone[key] = state[key];
    }
    return Object.freeze(clone);
}

function normalizeSeedConfig(config) {
    const cfg = config || {};
    const wantsFixed = cfg?.seedMode === "fixed";
    const hasFixed = wantsFixed && Number.isFinite(cfg?.fixedSeed);
    const seedMode = hasFixed ? "fixed" : "engine";
    const fixedSeed = hasFixed ? Math.trunc(cfg.fixedSeed) : null;
    const seedOffset = Number.isFinite(cfg?.seedOffset) ? Math.trunc(cfg.seedOffset) : 0;
    return { seedMode, fixedSeed, seedOffset };
}

function applySeedControl(seedMode, fixedSeed, seedOffset) {
    if (!RandomImpl || typeof RandomImpl.getState !== "function" || typeof RandomImpl.setState !== "function") {
        return { restore: null, seed: null, rngState: null };
    }
    let originalState = null;
    try {
        originalState = RandomImpl.getState();
    }
    catch (_err) {
        originalState = null;
    }
    if (!originalState || typeof originalState !== "object") {
        return { restore: null, seed: null, rngState: null };
    }
    const hasFixed = seedMode === "fixed" && Number.isFinite(fixedSeed);
    const offsetValue = Number.isFinite(seedOffset) ? Math.trunc(seedOffset) : 0;
    let seedValue = null;
    if (hasFixed) {
        seedValue = Math.trunc(fixedSeed);
    }
    else {
        const base = originalState.state;
        if (typeof base === "bigint") {
            seedValue = Number(base & 0xffffffffn);
        }
    }
    if (seedValue == null) {
        const restore = () => {
            try {
                RandomImpl.setState(originalState);
            }
            catch (_err) {
                /* no-op */
            }
        };
        return { restore, seed: null, rngState: freezeRngState(originalState) };
    }
    seedValue = offsetValue ? (seedValue + offsetValue) >>> 0 : seedValue >>> 0;
    let appliedState = null;
    try {
        if (typeof RandomImpl.seed === "function") {
            RandomImpl.seed(seedValue >>> 0);
            appliedState = RandomImpl.getState?.() ?? null;
        }
        else {
            const nextState = { ...originalState };
            if (typeof nextState.state === "bigint") {
                nextState.state = BigInt(seedValue >>> 0);
            }
            RandomImpl.setState(nextState);
            appliedState = nextState;
        }
    }
    catch (_err) {
        appliedState = null;
    }
    const restore = () => {
        try {
            RandomImpl.setState(originalState);
        }
        catch (_err) {
            /* no-op */
        }
    };
    return { restore, seed: seedValue >>> 0, rngState: freezeRngState(appliedState) };
}

function normalizeSites(sites) {
    if (!Array.isArray(sites) || sites.length === 0)
        return null;
    const frozen = sites.map((site, index) => {
        if (site && typeof site === "object") {
            const id = site.id ?? index;
            const x = site.x ?? (Array.isArray(site) ? site[0] ?? 0 : 0);
            const y = site.y ?? (Array.isArray(site) ? site[1] ?? 0 : 0);
            return Object.freeze({ id, x, y });
        }
        if (Array.isArray(site)) {
            const [x = 0, y = 0] = site;
            return Object.freeze({ id: index, x, y });
        }
        return Object.freeze({ id: index, x: 0, y: 0 });
    });
    return Object.freeze(frozen);
}

export const PlateSeedManager = {
    capture(width, height, config) {
        const seedCfg = normalizeSeedConfig(config);
        const timestamp = safeTimestamp();
        const control = applySeedControl(seedCfg.seedMode, seedCfg.fixedSeed, seedCfg.seedOffset);
        const snapshot = {
            width,
            height,
            seedMode: seedCfg.seedMode,
            seedOffset: seedCfg.seedOffset,
        };
        if (seedCfg.fixedSeed != null)
            snapshot.fixedSeed = seedCfg.fixedSeed;
        if (timestamp != null)
            snapshot.timestamp = timestamp;
        if (control.seed != null)
            snapshot.seed = control.seed;
        if (control.rngState)
            snapshot.rngState = control.rngState;
        return {
            snapshot: Object.freeze(snapshot),
            restore: typeof control.restore === "function" ? control.restore : null,
        };
    },
    finalize(baseSnapshot, extras = {}) {
        if (!baseSnapshot || typeof baseSnapshot !== "object")
            return null;
        const { config = null, meta = null } = extras || {};
        const result = {
            width: baseSnapshot.width,
            height: baseSnapshot.height,
            seedMode: baseSnapshot.seedMode,
        };
        if (baseSnapshot.timestamp != null)
            result.timestamp = baseSnapshot.timestamp;
        if (baseSnapshot.seedOffset != null)
            result.seedOffset = baseSnapshot.seedOffset;
        if (baseSnapshot.seed != null)
            result.seed = baseSnapshot.seed;
        if (baseSnapshot.fixedSeed != null)
            result.fixedSeed = baseSnapshot.fixedSeed;
        if (baseSnapshot.rngState)
            result.rngState = baseSnapshot.rngState;
        if (config && typeof config === "object") {
            result.config = Object.freeze({ ...config });
        }
        const seeds = Array.isArray(meta?.seedLocations)
            ? meta.seedLocations
            : Array.isArray(meta?.sites)
                ? meta.sites
                : null;
        const normalizedSites = normalizeSites(seeds);
        if (normalizedSites) {
            result.seedLocations = normalizedSites;
            result.sites = normalizedSites;
        }
        return Object.freeze(result);
    },
};
</file>

<file path="mod/maps/world/plates.js">
// @ts-nocheck
/**
 * Plate Tectonics Generation - Advanced Voronoi-based plate system
 *
 * Purpose:
 * - Generate tectonic plates using proper Voronoi diagrams (not simple distance)
 * - Calculate physics-based plate boundaries with subduction and sliding
 * - Provide structured data for WorldModel to consume
 *
 * Dependencies (from base-standard module):
 * - /base-standard/scripts/kd-tree.js - VoronoiUtils + spatial queries + region/boundary helpers
 * - /base-standard/scripts/voronoi-region.js - PlateRegion with movement vectors
 *
 * Architecture:
 * - Imports base game's proven plate generation algorithms
 * - Wraps them for WorldModel integration
 * - Returns typed arrays and boundary data structures
 */

import { VoronoiUtils, RegionCell, RegionCellPosGetter, kdTree } from '/base-standard/scripts/kd-tree.js';
import { PlateRegion } from '/base-standard/scripts/voronoi-region.js';

/**
 * @typedef {Object} PlateGenerationResult
 * @property {Int16Array} plateId - Plate assignment per tile
 * @property {Uint8Array} boundaryCloseness - 0..255, higher near boundaries
 * @property {Uint8Array} boundaryType - ENUM_BOUNDARY values
 * @property {Uint8Array} tectonicStress - 0..255, tracks boundary closeness
 * @property {Uint8Array} upliftPotential - 0..255, high at convergent boundaries
 * @property {Uint8Array} riftPotential - 0..255, high at divergent boundaries
 * @property {Uint8Array} shieldStability - 0..255, inverse of stress (plate interiors)
 * @property {Int8Array} plateMovementU - -127..127, horizontal plate movement
 * @property {Int8Array} plateMovementV - -127..127, vertical plate movement
 * @property {Int8Array} plateRotation - -127..127, plate rotation value
 * @property {null} boundaryTree - Deprecated: tile-precise boundaries used instead
 * @property {Array<PlateRegion>} plateRegions - Array of PlateRegion instances
 */

/**
 * @typedef {Object} PlateConfig
 * @property {number} count - Number of plates to generate
 * @property {number} relaxationSteps - Lloyd relaxation iterations (default 5)
 * @property {number} convergenceMix - 0..1, ratio of convergent vs divergent boundaries
 * @property {number} plateRotationMultiple - Multiplier for plate rotation influence
 * @property {Object} directionality - Optional directionality config
 * @property {"engine"|"fixed"} [seedMode] - Use Civ's seed (engine) or a fixed seed value (fixed)
 * @property {number} [fixedSeed] - Seed value when seedMode is "fixed"
 * @property {number} [seedOffset] - Integer offset applied to the chosen base seed
 */

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

/**
 * Generate tectonic plates using proper Voronoi diagrams
 *
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {PlateConfig} config - Plate generation configuration
 * @returns {PlateGenerationResult} Complete plate data for WorldModel
 */
export function computePlatesVoronoi(width, height, config) {
    const {
        count = 8,
        relaxationSteps = 5,
        convergenceMix = 0.5,
        plateRotationMultiple = 1.0,
        directionality = null,
        seedMode = "engine",
        fixedSeed = undefined,
        seedOffset = 0,
    } = config;

    const size = width * height;
    const meta = {
        width,
        height,
        config: {
            count,
            relaxationSteps,
            convergenceMix,
            plateRotationMultiple,
            seedMode,
            fixedSeed,
            seedOffset,
        },
        seedLocations: [],
    };

    const runGeneration = (attempt = {}) => {
        const {
            // Density of intermediate Voronoi cells that approximate plate areas.
            // Lower density  larger cells  thicker interiors and fewer boundary seams.
            cellDensity = 0.003,
            // How far boundary influence propagates into interiors (in hex tiles).
            boundaryInfluenceDistance = 3,
            // Exponential falloff for boundary closeness; higher = faster decay.
            boundaryDecay = 0.8,
            // Optionally override plate count for retries.
            plateCountOverride = null,
        } = attempt;
        const plateCount = Math.max(2, plateCountOverride ?? count);
        // Create Voronoi diagram using base game utilities
        const bbox = { xl: 0, xr: width, yt: 0, yb: height };
        const sites = VoronoiUtils.createRandomSites(plateCount, bbox.xr, bbox.yb);
        const diagram = VoronoiUtils.computeVoronoi(sites, bbox, relaxationSteps);

        // Create PlateRegion instances with movement vectors
        const plateRegions = diagram.cells.map((cell, index) => {
            const region = new PlateRegion(
                `Plate${index}`,
                index,
                0, // type
                bbox.xr * bbox.yb, // maxArea
                { x: Math.random(), y: Math.random(), z: Math.random() } // color (not used in WorldModel)
            );
            region.seedLocation = { x: cell.site.x, y: cell.site.y };

            // Apply directionality bias if provided
            if (directionality) {
                applyDirectionalityBias(region, directionality);
            }

            return region;
        });
        if (!plateRegions.length) {
            throw new Error(
                `[WorldModel] Plate generation returned zero plates (sites=${sites.length}, cells=${diagram.cells?.length ?? 0}).`
            );
        }
        const invalidPlateIndex = plateRegions.findIndex(
            (p) => !p || !p.seedLocation || !isFinite(p.seedLocation.x) || !isFinite(p.seedLocation.y)
        );
        if (invalidPlateIndex >= 0) {
            throw new Error(
                `[WorldModel] Plate generation produced invalid plate ${invalidPlateIndex}; seed missing or NaN (cells=${diagram.cells?.length ?? 0}).`
            );
        }
        meta.seedLocations = plateRegions.map((region, id) => ({
            id,
            x: region.seedLocation?.x ?? 0,
            y: region.seedLocation?.y ?? 0,
        }));

        // Create RegionCells for the map grid
        // Note: For performance, we create a coarser Voronoi grid for plate assignment
        // This matches the base game's approach in ContinentGenerator.growPlates()
        const cellCount = Math.max(
            plateCount * 2, // keep cells per plate low to thicken interiors
            Math.floor(width * height * cellDensity),
            plateCount
        );
        const cellSites = VoronoiUtils.createRandomSites(cellCount, bbox.xr, bbox.yb);
        const cellDiagram = VoronoiUtils.computeVoronoi(cellSites, bbox, 2);

        const regionCells = cellDiagram.cells.map((cell, index) => {
            const area = VoronoiUtils.calculateCellArea(cell);
            return new RegionCell(cell, index, area);
        });

        // Build kdTree for fast spatial queries
        const cellKdTree = new kdTree(RegionCellPosGetter);
        cellKdTree.build(regionCells);

        // Assign each region cell to nearest plate
        for (const regionCell of regionCells) {
            const pos = { x: regionCell.cell.site.x, y: regionCell.cell.site.y };
            let bestDist = Infinity;
            let bestPlateId = -1;

            for (let i = 0; i < plateRegions.length; i++) {
                const dx = pos.x - plateRegions[i].seedLocation.x;
                const dy = pos.y - plateRegions[i].seedLocation.y;
                const dist = dx * dx + dy * dy;

                if (dist < bestDist) {
                    bestDist = dist;
                    bestPlateId = i;
                }
            }

            regionCell.plateId = bestPlateId;
        }
        const invalidCell = regionCells.find((c) => c.plateId < 0 || c.plateId >= plateRegions.length);
        if (invalidCell) {
            throw new Error(
                `[WorldModel] Plate assignment failed: invalid plateId ${invalidCell.plateId} for regionCell ${invalidCell.id} (plates=${plateRegions.length}, sites=${sites.length}).`
            );
        }

        // Allocate output arrays
        const plateId = new Int16Array(size);
        const boundaryCloseness = new Uint8Array(size);
        const boundaryType = new Uint8Array(size);
        const tectonicStress = new Uint8Array(size);
        const upliftPotential = new Uint8Array(size);
        const riftPotential = new Uint8Array(size);
        const shieldStability = new Uint8Array(size);
        const plateMovementU = new Int8Array(size);
        const plateMovementV = new Int8Array(size);
        const plateRotation = new Int8Array(size);

        // Step 1: Assign each map tile to nearest Voronoi cell for plateId and movement
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const pos = { x, y };

                const nearestCellResult = cellKdTree.search(pos);
                const nearestCell = nearestCellResult?.data ?? nearestCellResult;
                if (!nearestCell) {
                    throw new Error(`[WorldModel] Nearest Voronoi cell not found at pos (${x},${y}).`);
                }
                const pId = nearestCell.plateId;
                plateId[i] = pId;

                const plate = plateRegions[pId];
                if (!plate || !plate.seedLocation) {
                    throw new Error(`[WorldModel] Missing plate data for plateId=${pId} at pos (${x},${y}).`);
                }
                const movement = calculatePlateMovement(plate, pos, plateRotationMultiple);
                plateMovementU[i] = clampInt8(Math.round(movement.x * 100));
                plateMovementV[i] = clampInt8(Math.round(movement.y * 100));
                plateRotation[i] = clampInt8(Math.round(plate.m_rotation * 100));
            }
        }

        // Step 2: Tile-precise boundary detection (replaces kdTree approach)
        // Detects boundaries by checking if any hex neighbor has a different plateId
        const { isBoundary, neighborPlates } = detectBoundaryTiles(plateId, width, height);

        // Step 3: Compute distance field from boundary tiles using BFS
        // This gives us precise tile distances instead of approximate kdTree distances
        const distanceField = computeDistanceField(
            isBoundary,
            width,
            height,
            boundaryInfluenceDistance + 1 // compute just past the influence band
        );

        // Step 4: Compute boundary physics (subduction/sliding) for boundary tiles
        const physics = computeBoundaryPhysicsForTiles(
            isBoundary, neighborPlates, plateId, plateRegions,
            width, height, plateRotationMultiple
        );

        // Step 5: Assign boundary types with inheritance for near-boundary tiles
        assignBoundaryTypesWithInheritance(
            distanceField, isBoundary, neighborPlates, physics,
            boundaryType, boundaryCloseness, upliftPotential, riftPotential,
            shieldStability, tectonicStress, width, height,
            boundaryInfluenceDistance, boundaryDecay
        );

        const boundaryStats = summarizeBoundaryCoverage(isBoundary, boundaryCloseness);
        meta.generationAttempts = meta.generationAttempts || [];
        meta.generationAttempts.push({
            params: { cellDensity, boundaryInfluenceDistance, boundaryDecay, cellCount },
            boundaryStats,
        });
        meta.boundaryStats = boundaryStats;

        return {
            plateId,
            boundaryCloseness,
            boundaryType,
            tectonicStress,
            upliftPotential,
            riftPotential,
            shieldStability,
            plateMovementU,
            plateMovementV,
            plateRotation,
            boundaryTree: null, // No longer using kdTree for boundaries
            plateRegions,
            meta,
        };
    };

    const attempts = [
        // Default: very coarse grid so plates span hundreds of tiles; fast decay keeps boundary belts thin.
        { cellDensity: 0.003, boundaryInfluenceDistance: 3, boundaryDecay: 0.8 },
        // Fallback: even coarser grid + shorter influence if boundaries still dominate.
        { cellDensity: 0.002, boundaryInfluenceDistance: 2, boundaryDecay: 0.9 },
        // Final fallback: reduce plate count modestly to grow interiors if saturation persists.
        { cellDensity: 0.002, boundaryInfluenceDistance: 2, boundaryDecay: 0.9, plateCountOverride: Math.max(6, Math.round(count * 0.6)) },
        // Extreme fallback: force low plate count and ultra-coarse cells to guarantee interiors.
        { cellDensity: 0.0015, boundaryInfluenceDistance: 2, boundaryDecay: 1.0, plateCountOverride: Math.max(4, Math.round(count * 0.4)) },
    ];
    const saturationLimit = 0.45; // if >45% of tiles are influenced by boundaries, reroll with coarser params
    const closenessLimit = 80;    // if average influenced closeness is too high, reroll

    let lastResult = null;
    for (const attempt of attempts) {
        const result = runGeneration(attempt);
        lastResult = result;
        const stats = result?.meta?.boundaryStats;
        const boundaryShare = stats?.boundaryInfluenceShare ?? 1;
        const boundaryTileShare = stats?.boundaryTileShare ?? 1;
        const avgInfluenceCloseness = stats?.avgInfluenceCloseness ?? 255;
        if (
            boundaryShare <= saturationLimit &&
            boundaryTileShare <= saturationLimit &&
            avgInfluenceCloseness <= closenessLimit
        ) {
            return result;
        }
    }

    return lastResult;
}

/**
 * Calculate plate movement at a specific position
 * Combines linear movement with rotational component
 * Based on ContinentGenerator.growPlates() lines 7908-7914
 *
 * @param {PlateRegion} plate - Plate region
 * @param {{x: number, y: number}} pos - Position to calculate movement at
 * @param {number} rotationMultiple - Rotation influence multiplier
 * @returns {{x: number, y: number}} Movement vector
 */
function calculatePlateMovement(plate, pos, rotationMultiple) {
    if (!plate || !plate.seedLocation) {
        return { x: 0, y: 0 };
    }
    // Relative position from plate center
    const relPos = {
        x: pos.x - plate.seedLocation.x,
        y: pos.y - plate.seedLocation.y,
    };

    // Rotation component: rotate relative position
    const angularMovement = plate.m_rotation * Math.PI / 180 * rotationMultiple;
    const rotatedPos = rotate2(relPos, angularMovement);

    // Rotation movement is difference between original and rotated position
    const rotationMovement = {
        x: relPos.x - rotatedPos.x,
        y: relPos.y - rotatedPos.y,
    };

    // Combine translation and rotation
    return {
        x: rotationMovement.x + plate.m_movement.x,
        y: rotationMovement.y + plate.m_movement.y,
    };
}

/**
 * Apply directionality bias to plate movement
 * Adjusts plate movement vectors to align with global directionality config
 *
 * @param {PlateRegion} plate - Plate region to modify
 * @param {Object} directionality - Directionality configuration
 */
function applyDirectionalityBias(plate, directionality) {
    const cohesion = Math.max(0, Math.min(1, directionality?.cohesion ?? 0));
    const plateAxisDeg = (directionality?.primaryAxes?.plateAxisDeg ?? 0) | 0;
    const angleJitterDeg = (directionality?.variability?.angleJitterDeg ?? 0) | 0;
    const magnitudeVariance = directionality?.variability?.magnitudeVariance ?? 0.35;

    // Current movement direction
    const currentAngle = Math.atan2(plate.m_movement.y, plate.m_movement.x) * 180 / Math.PI;
    const currentMag = Math.sqrt(plate.m_movement.x ** 2 + plate.m_movement.y ** 2);

    // Bias toward plate axis
    const jitter = (TerrainBuilder?.getRandomNumber?.(angleJitterDeg * 2 + 1, "PlateDirJit") ?? 0) - angleJitterDeg;
    const targetAngle = currentAngle * (1 - cohesion) + plateAxisDeg * cohesion + jitter * magnitudeVariance;

    // Apply biased angle
    const rad = targetAngle * Math.PI / 180;
    plate.m_movement.x = Math.cos(rad) * currentMag;
    plate.m_movement.y = Math.sin(rad) * currentMag;
}

// -------------------------------- Math Utilities --------------------------------

function toByte(f) {
    return Math.max(0, Math.min(255, Math.round(f * 255))) | 0;
}

function clampInt8(v) {
    return Math.max(-127, Math.min(127, v)) | 0;
}

function dot2(a, b) {
    return a.x * b.x + a.y * b.y;
}

function dot2_90(a, b) {
    // Dot product with 90-degree rotated vector: (x,y)  (-y,x)
    return -a.y * b.x + a.x * b.y;
}

function rotate2(v, angleRad) {
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);
    return {
        x: v.x * cos - v.y * sin,
        y: v.x * sin + v.y * cos,
    };
}

function sub2(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
}

function add2(a, b) {
    return { x: a.x + b.x, y: a.y + b.y };
}

function summarizeBoundaryCoverage(isBoundary, boundaryCloseness) {
    const size = isBoundary?.length || 1;
    let boundaryTiles = 0;
    let influencedTiles = 0;
    let closenessSum = 0;
    let closenessInfluencedSum = 0;
    let maxCloseness = 0;

    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) boundaryTiles++;
        const c = boundaryCloseness[i] | 0;
        if (c > 0) influencedTiles++;
        closenessSum += c;
        if (c > 0) closenessInfluencedSum += c;
        if (c > maxCloseness) maxCloseness = c;
    }

    return {
        boundaryTileShare: boundaryTiles / size,
        boundaryInfluenceShare: influencedTiles / size,
        avgCloseness: closenessSum / size,
        avgInfluenceCloseness: influencedTiles > 0 ? closenessInfluencedSum / influencedTiles : 0,
        maxCloseness,
        boundaryTiles,
        influencedTiles,
        totalTiles: size,
    };
}

// -------------------------------- Tile-Precise Boundary Detection --------------------------------

/**
 * Get hex neighbors for a tile (odd-q vertical layout as used by Civ7)
 * @param {number} x - Tile x coordinate
 * @param {number} y - Tile y coordinate
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @returns {Array<{x: number, y: number, i: number}>} Array of valid neighbor coordinates and indices
 */
function getHexNeighbors(x, y, width, height) {
    const neighbors = [];
    const isOddCol = (x & 1) === 1;

    // Hex offsets for odd-q vertical layout
    const offsets = isOddCol
        ? [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, 1], [1, 1]]   // Odd column
        : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, -1]]; // Even column

    for (const [dx, dy] of offsets) {
        const nx = x + dx;
        const ny = y + dy;
        // Handle cylindrical wrapping for x, but clamp y
        const wrappedX = ((nx % width) + width) % width;
        if (ny >= 0 && ny < height) {
            neighbors.push({ x: wrappedX, y: ny, i: ny * width + wrappedX });
        }
    }
    return neighbors;
}

/**
 * Detect boundary tiles by checking if any neighbor has a different plateId
 * @param {Int16Array} plateId - Plate assignment per tile
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @returns {{isBoundary: Uint8Array, neighborPlates: Int16Array}} Boundary detection results
 */
function detectBoundaryTiles(plateId, width, height) {
    const size = width * height;
    const isBoundary = new Uint8Array(size); // 1 if boundary, 0 otherwise
    const neighborPlates = new Int16Array(size); // Store the OTHER plate id for boundary tiles

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const myPlate = plateId[i];
            neighborPlates[i] = -1; // Default: no neighboring plate

            const neighbors = getHexNeighbors(x, y, width, height);
            for (const n of neighbors) {
                const otherPlate = plateId[n.i];
                if (otherPlate !== myPlate) {
                    isBoundary[i] = 1;
                    neighborPlates[i] = otherPlate; // Store first different neighbor plate
                    break;
                }
            }
        }
    }

    return { isBoundary, neighborPlates };
}

/**
 * Compute distance field from boundary tiles using BFS
 * @param {Uint8Array} isBoundary - Boundary mask
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} maxDistance - Maximum distance to compute (default 20)
 * @returns {Uint8Array} Distance to nearest boundary (0 for boundary tiles)
 */
function computeDistanceField(isBoundary, width, height, maxDistance = 20) {
    const size = width * height;
    const distance = new Uint8Array(size);
    distance.fill(255); // Initialize with max

    // BFS queue: start with all boundary tiles
    const queue = [];
    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) {
            distance[i] = 0;
            queue.push(i);
        }
    }

    // BFS to compute distances
    let head = 0;
    while (head < queue.length) {
        const i = queue[head++];
        const d = distance[i];
        if (d >= maxDistance) continue;

        const x = i % width;
        const y = Math.floor(i / width);
        const neighbors = getHexNeighbors(x, y, width, height);

        for (const n of neighbors) {
            if (distance[n.i] > d + 1) {
                distance[n.i] = d + 1;
                queue.push(n.i);
            }
        }
    }

    return distance;
}

/**
 * Compute boundary physics (subduction/sliding) for boundary tiles
 * @param {Uint8Array} isBoundary - Boundary mask
 * @param {Int16Array} neighborPlates - Neighboring plate IDs for boundary tiles
 * @param {Int16Array} plateId - Plate assignment per tile
 * @param {Array<PlateRegion>} plateRegions - Plate regions with movement data
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} plateRotationMultiple - Rotation influence multiplier
 * @returns {{subduction: Float32Array, sliding: Float32Array}} Physics values for each tile
 */
function computeBoundaryPhysicsForTiles(isBoundary, neighborPlates, plateId, plateRegions, width, height, plateRotationMultiple) {
    const size = width * height;
    const subduction = new Float32Array(size);
    const sliding = new Float32Array(size);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            if (!isBoundary[i]) continue;

            const plate1Id = plateId[i];
            const plate2Id = neighborPlates[i];
            if (plate2Id < 0 || plate2Id >= plateRegions.length) continue;

            const plate1 = plateRegions[plate1Id];
            const plate2 = plateRegions[plate2Id];
            if (!plate1 || !plate2) continue;

            const pos = { x, y };

            // Calculate movement vectors at this position
            const movement1 = calculatePlateMovement(plate1, pos, plateRotationMultiple);
            const movement2 = calculatePlateMovement(plate2, pos, plateRotationMultiple);

            // Normal: direction from plate1 toward plate2 center
            const normal = VoronoiUtils.normalize({
                x: plate2.seedLocation.x - plate1.seedLocation.x,
                y: plate2.seedLocation.y - plate1.seedLocation.y,
            });

            // Subduction: relative movement along normal (positive = converging)
            subduction[i] = dot2(normal, movement1) - dot2(normal, movement2);

            // Sliding: relative movement perpendicular to normal
            sliding[i] = Math.abs(dot2_90(normal, movement1) - dot2_90(normal, movement2));
        }
    }

    return { subduction, sliding };
}

/**
 * Assign boundary types based on physics, with inheritance for near-boundary tiles
 * @param {Uint8Array} distanceField - Distance to nearest boundary
 * @param {Uint8Array} isBoundary - Boundary mask
 * @param {Int16Array} neighborPlates - Neighboring plate IDs
 * @param {{subduction: Float32Array, sliding: Float32Array}} physics - Physics values
 * @param {Uint8Array} boundaryType - Output: boundary type per tile
 * @param {Uint8Array} boundaryCloseness - Output: closeness to boundary (255 at boundary)
 * @param {Uint8Array} upliftPotential - Output: uplift potential
 * @param {Uint8Array} riftPotential - Output: rift potential
 * @param {Uint8Array} shieldStability - Output: shield stability
 * @param {Uint8Array} tectonicStress - Output: tectonic stress
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} maxInfluenceDistance - Maximum distance for boundary influence (default 8)
 * @param {number} decay - Exponential decay applied to boundary influence
 */
function assignBoundaryTypesWithInheritance(
    distanceField, isBoundary, neighborPlates, physics,
    boundaryType, boundaryCloseness, upliftPotential, riftPotential, shieldStability, tectonicStress,
    width, height, maxInfluenceDistance = 5, decay = 0.55
) {
    const size = width * height;
    const convThreshold = 0.25;  // Slightly more permissive for convergent
    const divThreshold = -0.15;  // Slightly more permissive for divergent
    const transformThreshold = 0.4;

    // First pass: assign types to boundary tiles
    for (let i = 0; i < size; i++) {
        if (!isBoundary[i]) continue;

        const sub = physics.subduction[i];
        const slid = physics.sliding[i];

        if (sub > convThreshold) {
            boundaryType[i] = ENUM_BOUNDARY.convergent;
        } else if (sub < divThreshold) {
            boundaryType[i] = ENUM_BOUNDARY.divergent;
        } else if (slid > transformThreshold) {
            boundaryType[i] = ENUM_BOUNDARY.transform;
        } else {
            boundaryType[i] = ENUM_BOUNDARY.none;
        }
    }

    // Second pass: non-boundary tiles inherit from nearest boundary via BFS traversal
    // We need to track which boundary tile each interior tile inherits from
    const inheritedFrom = new Int32Array(size);
    inheritedFrom.fill(-1);

    // Mark boundary tiles as inheriting from themselves
    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) {
            inheritedFrom[i] = i;
        }
    }

    // BFS to propagate boundary type inheritance
    const queue = [];
    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) queue.push(i);
    }

    let head = 0;
    while (head < queue.length) {
        const i = queue[head++];
        const d = distanceField[i];
        if (d >= maxInfluenceDistance) continue;

        const x = i % width;
        const y = Math.floor(i / width);
        const neighbors = getHexNeighbors(x, y, width, height);

        for (const n of neighbors) {
            if (inheritedFrom[n.i] < 0 && distanceField[n.i] === d + 1) {
                inheritedFrom[n.i] = inheritedFrom[i];
                queue.push(n.i);
            }
        }
    }

    // Third pass: compute all derived values
    for (let i = 0; i < size; i++) {
        const dist = distanceField[i];

        // Compute closeness: 255 at boundary, falls off with distance
        // Use exponential falloff for sharp boundary influence
        if (dist >= maxInfluenceDistance) {
            boundaryCloseness[i] = 0;
            boundaryType[i] = ENUM_BOUNDARY.none;
            upliftPotential[i] = 0;
            riftPotential[i] = 0;
            shieldStability[i] = 255;
            tectonicStress[i] = 0;
            continue;
        }

        const closeness = Math.exp(-dist * decay);
        const closeness255 = toByte(closeness);
        boundaryCloseness[i] = closeness255;

        // Inherit boundary type from nearest boundary tile
        const sourceIdx = inheritedFrom[i];
        if (sourceIdx >= 0 && !isBoundary[i]) {
            boundaryType[i] = boundaryType[sourceIdx];
        }

        // Compute derived values
        const bType = boundaryType[i];
        tectonicStress[i] = closeness255;
        // Shield stability is a simple inverse of boundary closeness:
        // deep interiors  255, boundary core  0. Landmass selection then
        // treats shield as the primary interior signal, while boundary
        // closeness is a secondary bias; do NOT make these perfectly
        // complementary, or the combined score becomes constant.
        shieldStability[i] = 255 - closeness255;

        // Uplift/rift potential scaled by closeness and boundary type
        if (bType === ENUM_BOUNDARY.convergent) {
            upliftPotential[i] = closeness255;
            riftPotential[i] = closeness255 >> 2;
        } else if (bType === ENUM_BOUNDARY.divergent) {
            upliftPotential[i] = closeness255 >> 2;
            riftPotential[i] = closeness255;
        } else {
            upliftPotential[i] = closeness255 >> 2;
            riftPotential[i] = closeness255 >> 2;
        }
    }
}
</file>

<file path="mod/maps/map_orchestrator.js">
// Epic Diverse Huge Map Generator
/**
 * Custom map script - Produces diverse terrain with cliffs, inland lakes,
 * coastal regions, mountains, jungle, tundra, and all biome variety on huge maps.
 * @packageDocumentation
 */
console.log("Loading Epic Diverse Huge Map Generator");
console.log("[SWOOPER_MOD] ========================================");
console.log("[SWOOPER_MOD] Map orchestrator loaded - v1.0");
console.log("[SWOOPER_MOD] Plate-aware mountain tuning enabled");
console.log("[SWOOPER_MOD] Diagnostics enabled");
console.log("[SWOOPER_MOD] ========================================");
import { chooseStartSectors } from "/base-standard/maps/assign-starting-plots.js";
import { expandCoasts, generateLakes } from "/base-standard/maps/elevation-terrain-generator.js";
import { layerAddMountainsPhysics } from "./layers/mountains.js";
import * as globals from "/base-standard/maps/map-globals.js";
import * as utilities from "/base-standard/maps/map-utilities.js";
import {
    stageEnabled,
    LANDMASS_CFG,
    LANDMASS_GEOMETRY,
    MOUNTAINS_CFG,
    VOLCANOES_CFG,
    FOUNDATION_SEED,
    FOUNDATION_PLATES,
    FOUNDATION_DYNAMICS,
    FOUNDATION_SURFACE,
    FOUNDATION_POLICY,
    FOUNDATION_DIAGNOSTICS,
    rebind,
} from "./bootstrap/tunables.js";
import { StoryTags, resetStoryTags } from "./story/tags.js";
import { storyTagStrategicCorridors } from "./story/corridors.js";
import { storyTagHotspotTrails, storyTagRiftValleys, storyTagOrogenyBelts, storyTagContinentalMargins, storyTagClimateSwatches, OrogenyCache, } from "./story/tagging.js";
import { StoryOverlayKeys, getStoryOverlay, hydrateMarginsStoryTags } from "./story/overlays.js";
import { layerAddVolcanoesPlateAware } from "./layers/volcanoes.js";
import { createPlateDrivenLandmasses } from "./layers/landmass_plate.js";
import { applyLandmassPostAdjustments, applyPlateAwareOceanSeparation } from "./layers/landmass_utils.js";
import { addRuggedCoasts as layerAddRuggedCoasts } from "./layers/coastlines.js";
import { addIslandChains as layerAddIslandChains } from "./layers/islands.js";
import { applyClimateBaseline, refineClimateEarthlike } from "./layers/climate-engine.js";
import { designateEnhancedBiomes as layerDesignateEnhancedBiomes } from "./layers/biomes.js";
import { addDiverseFeatures as layerAddDiverseFeatures } from "./layers/features.js";
import { runPlacement as layerRunPlacement } from "./layers/placement.js";
import { devLogIf, timeStart, timeEnd, logStoryTagsSummary, logRainfallHistogram, logRainfallStats, logCorridorAsciiOverlay, logFoundationSummary, logFoundationHistograms, logFoundationAscii, logBoundaryMetrics, logLandmassAscii, logTerrainReliefAscii, logRainfallAscii, logBiomeAscii, logBiomeSummary, logFoundationSeed, logFoundationPlates, logFoundationDynamics, logFoundationSurface, } from "./bootstrap/dev.js";
import { WorldModel } from "./world/model.js";
// Phase 1 Refactoring: Context + Adapter layer
import {
    createMapContext,
    syncHeightfield,
    syncClimateField,
    createFoundationContext,
    assertFoundationContext,
} from "./core/types.js";
import { addPlotTags } from "./core/plot_tags.js";
import { CivEngineAdapter } from "./core/adapters.js";

// Maintain compatibility with dev helpers that expect StoryTags on the global scope.
try {
    globalThis.StoryTags = StoryTags;
}
catch (_err) {
    // Swallow silently; the game VM should always expose globalThis but guard just in case.
}
/**
 * Climate Story v0.1  StoryTags scaffolding and toggles
 * Tags are sparse: store as "x,y" strings in Sets.
 * Per-map config is read at runtime from getConfig().
 */
// StoryTags are now imported from ./story/tags.js
function requestMapData(initParams) {
    console.log("=== EPIC DIVERSE HUGE GENERATOR STARTING ===");
    console.log(`Map dimensions: ${initParams.width} x ${initParams.height}`);
    console.log(`Latitude range: ${initParams.bottomLatitude} to ${initParams.topLatitude}`);
    engine.call("SetMapInitData", initParams);
}

/**
 * Lightweight surface sanity check before calling engine area/continent builders.
 * Reports aggregate land/water counts so crashes inside AreaBuilder or
 * TerrainBuilder can be correlated with the last known terrain mix.
 *
 * @param {number} width
 * @param {number} height
 */
function logSurfaceSanity(label, width, height) {
    try {
        let water = 0;
        let land = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (GameplayMap.isWater(x, y)) {
                    water++;
                } else {
                    land++;
                }
            }
        }
        const total = width * height || 1;
        const waterPct = ((water / total) * 100).toFixed(1);
        const landPct = ((land / total) * 100).toFixed(1);
        console.log(
            `[SWOOPER_MOD][SurfaceCheck] ${label}: water=${water} (${waterPct}%), land=${land} (${landPct}%)`
        );
    } catch (err) {
        console.warn("[SWOOPER_MOD][SurfaceCheck] Failed during", label, ":", err);
    }
}

function generateMap() {
    console.log("[SWOOPER_MOD] === generateMap() CALLED ===");
    console.log("Generating Epic Diverse Map with maximum terrain variety!");
    // Ensure tunables reflect the active entry config for this run.
    rebind();
    const stageFoundation = stageEnabled("foundation");
    const stageLandmassPlates = stageEnabled("landmassPlates");
    const stageCoastlines = stageEnabled("coastlines");
    const stageStorySeed = stageEnabled("storySeed");
    const stageStoryHotspots = stageEnabled("storyHotspots");
    const stageStoryRifts = stageEnabled("storyRifts");
    const stageStoryOrogeny = stageEnabled("storyOrogeny");
    const stageStoryCorridorsPre = stageEnabled("storyCorridorsPre");
    const stageIslands = stageEnabled("islands");
    const stageMountains = stageEnabled("mountains");
    const stageVolcanoes = stageEnabled("volcanoes");
    const stageLakes = stageEnabled("lakes");
    const stageClimateBaseline = stageEnabled("climateBaseline");
    const stageStorySwatches = stageEnabled("storySwatches");
    const stageRivers = stageEnabled("rivers");
    const stageStoryCorridorsPost = stageEnabled("storyCorridorsPost");
    const stageClimateRefine = stageEnabled("climateRefine");
    const stageBiomes = stageEnabled("biomes");
    const stageFeatures = stageEnabled("features");
    const stagePlacement = stageEnabled("placement");
    logFoundationSeed(FOUNDATION_SEED, null);
    logFoundationPlates(FOUNDATION_PLATES);
    logFoundationDynamics(FOUNDATION_DYNAMICS);
    logFoundationSurface(FOUNDATION_SURFACE);
    const mountainsConfig = MOUNTAINS_CFG || {};
    const mountainOptions = {
        // Physics-threshold controls (no quota - mountains only where physics justifies)
        tectonicIntensity: mountainsConfig.tectonicIntensity ?? 1.0,
        mountainThreshold: mountainsConfig.mountainThreshold ?? 0.45,
        hillThreshold: mountainsConfig.hillThreshold ?? 0.25,
        // Physics weights
        upliftWeight: mountainsConfig.upliftWeight ?? 0.75,
        fractalWeight: mountainsConfig.fractalWeight ?? 0.25,
        riftDepth: mountainsConfig.riftDepth ?? 0.3,
        boundaryWeight: mountainsConfig.boundaryWeight ?? 0.6,
        boundaryExponent: mountainsConfig.boundaryExponent ?? 1.4,
        interiorPenaltyWeight: mountainsConfig.interiorPenaltyWeight ?? 0.2,
        convergenceBonus: mountainsConfig.convergenceBonus ?? 0.9,
        transformPenalty: mountainsConfig.transformPenalty ?? 0.3,
        riftPenalty: mountainsConfig.riftPenalty ?? 0.75,
        hillBoundaryWeight: mountainsConfig.hillBoundaryWeight ?? 0.45,
        hillRiftBonus: mountainsConfig.hillRiftBonus ?? 0.5,
        hillConvergentFoothill: mountainsConfig.hillConvergentFoothill ?? 0.25,
        hillInteriorFalloff: mountainsConfig.hillInteriorFalloff ?? 0.2,
        hillUpliftWeight: mountainsConfig.hillUpliftWeight ?? 0.25,
    };
    const volcanoConfig = VOLCANOES_CFG || {};
    const volcanoOptions = {
        enabled: volcanoConfig.enabled ?? true,
        baseDensity: volcanoConfig.baseDensity ?? (1 / 170),
        minSpacing: volcanoConfig.minSpacing ?? 3,
        boundaryThreshold: volcanoConfig.boundaryThreshold ?? 0.35,
        boundaryWeight: volcanoConfig.boundaryWeight ?? 1.2,
        convergentMultiplier: volcanoConfig.convergentMultiplier ?? 2.4,
        transformMultiplier: volcanoConfig.transformMultiplier ?? 1.1,
        divergentMultiplier: volcanoConfig.divergentMultiplier ?? 0.35,
        hotspotWeight: volcanoConfig.hotspotWeight ?? 0.12,
        shieldPenalty: volcanoConfig.shieldPenalty ?? 0.6,
        randomJitter: volcanoConfig.randomJitter ?? 0.08,
        minVolcanoes: volcanoConfig.minVolcanoes ?? 5,
        maxVolcanoes: volcanoConfig.maxVolcanoes ?? 40,
    };
    console.log("[SWOOPER_MOD] Tunables rebound successfully");
    console.log(
        `[SWOOPER_MOD] Mountains: intensity=${mountainOptions.tectonicIntensity}, threshold=${mountainOptions.mountainThreshold} | Hills: threshold=${mountainOptions.hillThreshold}`
    );
    console.log(
        `[SWOOPER_MOD] Volcano config  base density ${(volcanoOptions.baseDensity ?? 0).toFixed(4)}, spacing ${volcanoOptions.minSpacing}`
    );
    let iWidth = GameplayMap.getGridWidth();
    let iHeight = GameplayMap.getGridHeight();
    let uiMapSize = GameplayMap.getMapSize();
    let startPositions = [];
    let mapInfo = GameInfo.Maps.lookup(uiMapSize);
    if (mapInfo == null)
        return;

    // Phase 1 Refactoring: Create MapContext with adapter
    console.log("[Refactoring] Creating MapContext with CivEngineAdapter...");
    const adapter = new CivEngineAdapter(iWidth, iHeight);
    const ctx = createMapContext(
        { width: iWidth, height: iHeight },
        adapter,
        {
            STORY_ENABLE_HOTSPOTS: stageStoryHotspots,
            STORY_ENABLE_RIFTS: stageStoryRifts,
            STORY_ENABLE_OROGENY: stageStoryOrogeny,
            LANDMASS_GEOMETRY,
        }
    );

    // Initialize WorldModel (optional) and attach to context
    if (!stageFoundation) {
        console.warn("[StageManifest] Foundation stage disabled; physics pipeline requires it.");
    }
    let foundationContext = null;
    if (stageFoundation) {
        try {
            if (!WorldModel.init()) {
                throw new Error("[WorldModel] Initialization failed; physics data unavailable.");
            }
            ctx.worldModel = WorldModel;
            foundationContext = createFoundationContext(WorldModel, {
                dimensions: ctx.dimensions,
                config: {
                    seed: FOUNDATION_SEED,
                    plates: FOUNDATION_PLATES,
                    dynamics: FOUNDATION_DYNAMICS,
                    surface: FOUNDATION_SURFACE,
                    policy: FOUNDATION_POLICY,
                    diagnostics: FOUNDATION_DIAGNOSTICS,
                },
            });
            ctx.foundation = foundationContext;
            devLogIf("LOG_STORY_TAGS", "[WorldModel] Initialized and attached to context");
            logFoundationSummary(WorldModel);
            logFoundationAscii(WorldModel);
            logFoundationSeed(FOUNDATION_SEED, foundationContext.plateSeed || null, { skipConfig: true });
        }
        catch (err) {
            const message = err && typeof err.message === "string" ? err.message : String(err);
            console.error(`[FoundationContext] Failed to initialize: ${message}`);
            throw err;
        }
    }
    let iNumNaturalWonders = Math.max(mapInfo.NumNaturalWonders + 1, mapInfo.NumNaturalWonders);
    let iTilesPerLake = Math.max(10, mapInfo.LakeGenerationFrequency * 2); // fewer lakes than base script used
    let iNumPlayers1 = mapInfo.PlayersLandmass1;
    let iNumPlayers2 = mapInfo.PlayersLandmass2;
    let iStartSectorRows = mapInfo.StartSectorRows;
    let iStartSectorCols = mapInfo.StartSectorCols;
    // Set up start sectors first (before terrain generation)
    let bHumanNearEquator = utilities.needHumanNearEquator();
    let startSectors = chooseStartSectors(iNumPlayers1, iNumPlayers2, iStartSectorRows, iStartSectorCols, bHumanNearEquator);
    console.log("Start sectors chosen successfully");
    // Create continent boundaries for start position assignment (simplified for compatibility)
    let westContinent = {
        west: globals.g_AvoidSeamOffset,
        east: iWidth / 2 - globals.g_AvoidSeamOffset,
        south: globals.g_PolarWaterRows,
        north: iHeight - globals.g_PolarWaterRows,
        continent: 0,
    };
    let eastContinent = {
        west: iWidth / 2 + globals.g_AvoidSeamOffset,
        east: iWidth - globals.g_AvoidSeamOffset,
        south: globals.g_PolarWaterRows,
        north: iHeight - globals.g_PolarWaterRows,
        continent: 0,
    };
    const landmassSource = stageLandmassPlates ? "plate" : "disabled";
    let landmaskDebug = null;
    let landmassWindowsFinal = [];
    const ensureFoundation = (stageName) => assertFoundationContext(ctx, stageName);
    if (stageLandmassPlates) {
        ensureFoundation("landmassPlates");
        const t = timeStart("Landmass (Plate-Driven)");
        const plateResult = createPlateDrivenLandmasses(iWidth, iHeight, ctx, {
            landmassCfg: LANDMASS_CFG,
            geometry: LANDMASS_GEOMETRY,
        });
        if (!plateResult || !Array.isArray(plateResult.windows) || plateResult.windows.length === 0) {
            console.error("[SWOOPER_MOD] ERROR: Plate-driven landmass generation failed (no windows).");
            timeEnd(t);
            return;
        }
        landmaskDebug = plateResult.landMask || null;
        let landmassWindows = plateResult.windows.slice();
        const separationResult = applyPlateAwareOceanSeparation({
            width: iWidth,
            height: iHeight,
            windows: landmassWindows,
            landMask: plateResult.landMask,
            context: ctx,
            adapter: ctx?.adapter,
            worldModel: WorldModel,
        });
        landmassWindows = separationResult.windows;
        if (separationResult.landMask) {
            landmaskDebug = separationResult.landMask;
        }
        landmassWindows = applyLandmassPostAdjustments(landmassWindows, LANDMASS_GEOMETRY, iWidth, iHeight);
        if (Array.isArray(landmassWindows) && landmassWindows.length >= 2) {
            const first = landmassWindows[0];
            const last = landmassWindows[landmassWindows.length - 1];
            if (first && last) {
                westContinent = {
                    west: first.west,
                    east: first.east,
                    south: first.south,
                    north: first.north,
                    continent: first.continent ?? 0,
                };
                eastContinent = {
                    west: last.west,
                    east: last.east,
                    south: last.south,
                    north: last.north,
                    continent: last.continent ?? 1,
                };
            }
        }
        landmassWindowsFinal = landmassWindows;
        console.log("[SWOOPER_MOD] Applied plate-driven landmass mask");
        timeEnd(t);

        // === FOUNDATION SURFACE GATE: Landmass  Engine Continents ===
        // At this point, the macro land/ocean pattern is established (plates + separation).
        // Stamp engine continents once here so downstream systems can rely on them.
        // Later surface tweaks (coasts, islands, mountains) should not require re-stamping.
        TerrainBuilder.validateAndFixTerrain();
        logSurfaceSanity("post-landmass", iWidth, iHeight);
        console.log("[SWOOPER_MOD] Recalculating areas after plate-driven landmass...");
        AreaBuilder.recalculateAreas();
        console.log("[SWOOPER_MOD] Stamping continents from plate-driven landmass...");
        TerrainBuilder.stampContinents();

        // Derive west/east macro regions from windows for placement & plot tagging.
        if (landmassWindowsFinal.length) {
            const windowSummary = landmassWindowsFinal.map((win, idx) => {
                if (!win)
                    return { index: idx };
                const spanX = Number.isFinite(win.east) && Number.isFinite(win.west) ? win.east - win.west + 1 : null;
                const spanY = Number.isFinite(win.north) && Number.isFinite(win.south) ? win.north - win.south + 1 : null;
                return {
                    index: idx,
                    continent: win.continent ?? idx,
                    west: win.west,
                    east: win.east,
                    south: win.south,
                    north: win.north,
                    width: spanX,
                    height: spanY,
                    area: spanX && spanY ? spanX * spanY : null,
                };
            });
            devLogIf("LOG_LANDMASS_WINDOWS", "[Landmass] windows summary", JSON.stringify(windowSummary));
        }
        else {
            devLogIf("LOG_LANDMASS_WINDOWS", "[Landmass] windows summary", "no plate windows");
        }

        // Update start-continent hints from the stamped landmass windows.
        if (Array.isArray(landmassWindowsFinal) && landmassWindowsFinal.length >= 2) {
            const first = landmassWindowsFinal[0];
            const last = landmassWindowsFinal[landmassWindowsFinal.length - 1];
            if (first && last) {
                westContinent = {
                    west: first.west,
                    east: first.east,
                    south: first.south,
                    north: first.north,
                    continent: first.continent ?? 0,
                };
                eastContinent = {
                    west: last.west,
                    east: last.east,
                    south: last.south,
                    north: last.north,
                    continent: last.continent ?? 1,
                };
            }
        }

        // Apply plot tags based on the macro east/west split.
        addPlotTags(iHeight, iWidth, eastContinent.west);
    }
    else {
        console.warn("[StageManifest] Landmass stage disabled  skipping landmass generation.");
    }
    logLandmassAscii(landmassSource, {
        windows: Array.isArray(landmassWindowsFinal) ? landmassWindowsFinal : [],
        landMask: landmaskDebug || undefined,
    });
    if (stageCoastlines) {
        ensureFoundation("coastlines");
        const t = timeStart("ExpandCoasts");
        expandCoasts(iWidth, iHeight);
        timeEnd(t);
    }
    else {
        console.log("[StageManifest] Coastlines stage disabled  skipping expandCoasts()");
    }
    // Reset StoryTags and tag continental margins before coast shaping
    let marginsOverlay = null;
    if (stageStorySeed) {
        ensureFoundation("storySeed");
        resetStoryTags();
        console.log("Imprinting continental margins (active/passive)...");
        marginsOverlay = storyTagContinentalMargins(ctx);
        if (!marginsOverlay) {
            marginsOverlay = getStoryOverlay(ctx, StoryOverlayKeys.MARGINS);
        }
    }
    // Add post-processing to make coasts more rugged (margin-aware) and place a few islands
    if (stageCoastlines) {
        const t = timeStart("RuggedCoasts");
        layerAddRuggedCoasts(iWidth, iHeight, ctx);
        timeEnd(t);
    }
    // Climate Story v0.1: Tag narrative motifs after coasts exist
    if (stageStoryHotspots || stageStoryRifts) {
        resetStoryTags();
        if (!marginsOverlay) {
            marginsOverlay = getStoryOverlay(ctx, StoryOverlayKeys.MARGINS);
        }
        if (marginsOverlay) {
            hydrateMarginsStoryTags(marginsOverlay, StoryTags);
        }
    }
    if (stageStoryHotspots) {
        ensureFoundation("storyHotspots");
        console.log("Drawing hotspot trails...");
        storyTagHotspotTrails(iWidth, iHeight);
    }
    if (stageStoryRifts) {
        ensureFoundation("storyRifts");
        console.log("Marking rift lines and shoulders...");
        storyTagRiftValleys(iWidth, iHeight);
    }
    if (stageStoryOrogeny) {
        ensureFoundation("storyOrogeny");
        console.log("Tagging orogenic belts...");
        storyTagOrogenyBelts();
        logFoundationHistograms(WorldModel, {
            riftSet: StoryTags.riftLine,
            beltSet: OrogenyCache.belts,
            bins: 12,
        });
    }
    // Re-tag continental margins for downstream consumers (islands/features) after reset
    if (stageStorySeed && marginsOverlay) {
        hydrateMarginsStoryTags(marginsOverlay, StoryTags);
    }
    // Strategic Corridors: tag pre-islands lanes and land corridors
    if (stageStoryCorridorsPre) {
        ensureFoundation("storyCorridorsPre");
        storyTagStrategicCorridors("preIslands");
        logCorridorAsciiOverlay();
    }
    if (stageStorySeed || stageStoryHotspots || stageStoryRifts || stageStoryOrogeny) {
        devLogIf("LOG_STORY_TAGS", "StoryTags summary follows");
        logStoryTagsSummary(StoryTags, OrogenyCache);
    }
    if (stageIslands) {
        ensureFoundation("islands");
        const t = timeStart("IslandChains");
        layerAddIslandChains(iWidth, iHeight, ctx);
        timeEnd(t);
    }
    // Mountains & Hills  Phase 2: Physics-based placement using plate boundaries
    if (stageMountains) {
        ensureFoundation("mountains");
        const t = timeStart("Mountains & Hills (Physics)");
        layerAddMountainsPhysics(ctx, mountainOptions);
        timeEnd(t);
        if (stageFoundation) {
            logBoundaryMetrics(WorldModel, { stage: "post-mountains" });
        }
    }
    if (stageVolcanoes) {
        ensureFoundation("volcanoes");
        const t = timeStart("Volcanoes");
        layerAddVolcanoesPlateAware(ctx, volcanoOptions);
        timeEnd(t);
        if (stageFoundation) {
            logBoundaryMetrics(WorldModel, { stage: "post-volcanoes" });
        }
    }
    if (stageMountains || stageVolcanoes) {
        logTerrainReliefAscii("post-volcanoes");
    }
    // Lakes  fewer than before
    if (stageLakes) {
        ensureFoundation("lakes");
        const t = timeStart("Lakes");
        generateLakes(iWidth, iHeight, iTilesPerLake);
        timeEnd(t);
        syncHeightfield(ctx);
    }
    // MAP STATISTICS LOGGING - Diagnostic for start placement failures
    console.log("[SWOOPER_MOD] About to calculate MAP_STATS...");
    {
        let waterCount = 0, mountainCount = 0, hillCount = 0, flatCount = 0;
        const totalTiles = iWidth * iHeight;
        for (let y = 0; y < iHeight; y++) {
            for (let x = 0; x < iWidth; x++) {
                if (GameplayMap.isWater(x, y))
                    waterCount++;
                else if (GameplayMap.isMountain(x, y))
                    mountainCount++;
                else if (GameplayMap.getTerrainType(x, y) === globals.g_HillTerrain)
                    hillCount++;
                else
                    flatCount++;
            }
        }
        const landCount = totalTiles - waterCount;
        const waterPct = ((waterCount / totalTiles) * 100).toFixed(1);
        const landPct = ((landCount / totalTiles) * 100).toFixed(1);
        const mtnPct = landCount > 0 ? ((mountainCount / landCount) * 100).toFixed(1) : 0;
        const hillPct = landCount > 0 ? ((hillCount / landCount) * 100).toFixed(1) : 0;
        const flatPct = landCount > 0 ? ((flatCount / landCount) * 100).toFixed(1) : 0;
        console.log(`[MAP_STATS] Total tiles: ${totalTiles}, Water: ${waterCount} (${waterPct}%), Land: ${landCount} (${landPct}%)`);
        console.log(`[MAP_STATS] Land breakdown: Mountains: ${mountainCount} (${mtnPct}%), Hills: ${hillCount} (${hillPct}%), Flat: ${flatCount} (${flatPct}%)`);
    }
    AreaBuilder.recalculateAreas();
    // Commit the latest mountain/hill assignments before climate stages.
    // Base-standard scripts call TerrainBuilder.buildElevation() here so the
    // engine propagates terrain height for rainfall, biomes, and placement.
    TerrainBuilder.buildElevation();
    // Create moderated rainfall patterns (keep enhanced but gentle)
    if (stageClimateBaseline) {
        ensureFoundation("climateBaseline");
        const t = timeStart("Climate: Baseline");
        applyClimateBaseline(iWidth, iHeight, ctx);
        timeEnd(t);
        logRainfallAscii("baseline");
        logRainfallStats("baseline", iWidth, iHeight);
    }
    if (stageStorySwatches) {
        ensureFoundation("storySwatches");
        const t = timeStart("Climate: Swatches");
        const swatchResult = storyTagClimateSwatches(ctx);
        if (swatchResult && swatchResult.kind) {
            devLogIf("LOG_STORY_TAGS", `Climate Swatch: ${swatchResult.kind} (${swatchResult.tiles} tiles)`);
        }
        devLogIf("LOG_SWATCHES", "[Swatches] result", swatchResult || null);
        timeEnd(t);
    }
    // Rivers  closer to base values for balance
    if (stageRivers) {
        ensureFoundation("rivers");
        const t = timeStart("Rivers");
        TerrainBuilder.modelRivers(5, 15, globals.g_NavigableRiverTerrain);
        timeEnd(t);
        TerrainBuilder.validateAndFixTerrain();
        syncHeightfield(ctx);
        syncClimateField(ctx);
        TerrainBuilder.defineNamedRivers();
    }
    // Strategic Corridors: tag river-chain corridors post-rivers
    if (stageStoryCorridorsPost) {
        ensureFoundation("storyCorridorsPost");
        storyTagStrategicCorridors("postRivers");
        logCorridorAsciiOverlay();
    }
    // Refine rainfall with earthlike dynamics after rivers exist
    if (stageClimateRefine) {
        ensureFoundation("climateRefine");
        const t = timeStart("Climate: Earthlike Refinements");
        // Phase 1: Pass context to refactored layer
        refineClimateEarthlike(iWidth, iHeight, ctx);
        timeEnd(t);
        logRainfallAscii("refined");
        logRainfallStats("refined", iWidth, iHeight);
    }
    // Enhanced biome diversity
    if (stageBiomes) {
        ensureFoundation("biomes");
        const t = timeStart("Biomes");
        layerDesignateEnhancedBiomes(iWidth, iHeight);
        timeEnd(t);
        logBiomeAscii("final");
        logBiomeSummary("final", iWidth, iHeight);
    }
    // Add extensive feature variety
    if (stageFeatures) {
        ensureFoundation("features");
        const t = timeStart("Features");
        layerAddDiverseFeatures(iWidth, iHeight, ctx);
        timeEnd(t);
        TerrainBuilder.validateAndFixTerrain();
        syncHeightfield(ctx);
        AreaBuilder.recalculateAreas();
    }
    if (stageClimateBaseline || stageClimateRefine) {
        devLogIf("RAINFALL_HISTOGRAM", "Rainfall histogram (land tiles)");
        logRainfallHistogram(iWidth, iHeight, 12);
    }
    TerrainBuilder.storeWaterData();
    // Placement phase (wonders, floodplains, snow, resources, starts, discoveries, fertility, advanced starts)
    if (stagePlacement) {
        ensureFoundation("placement");
        const t = timeStart("Placement");
        startPositions = layerRunPlacement(iWidth, iHeight, {
            mapInfo,
            wondersPlusOne: true,
            floodplains: { minLength: 4, maxLength: 10 },
            starts: {
                playersLandmass1: iNumPlayers1,
                playersLandmass2: iNumPlayers2,
                westContinent,
                eastContinent,
                startSectorRows: iStartSectorRows,
                startSectorCols: iStartSectorCols,
                startSectors,
            },
        });
        timeEnd(t);
    }
    console.log("=== EPIC DIVERSE HUGE GENERATOR COMPLETED ===");
}
// Register listeners
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Epic Diverse Huge Map Generator loaded and ready!");
</file>

<file path="mod/maps/swooper-desert-mountains.js">
// @ts-check
/**
 * Swooper Desert Mountains  Hyperarid, plate-driven world
 *
 * Purpose
 * - Deliver a mostly dry planet punctuated by brutal orographic walls.
 * - Lean on plate-aware uplift so convergent margins become mega ranges.
 * - Reserve humidity for narrow rainfall belts hugging those ranges and a
 *   few equatorial/monsoonal refuges.
 *
 * Notes
 * - Mountains: the config intentionally dampens shoreline stacking by
 *   reducing boundary bonuses, raising interior penalties, and enabling a
 *   light ocean-separation pass. If convergent belts begin clumping again,
 *   revisit `mountains.*` weights or tweak the plate seed/rotation knobs
 *   under the `foundation` config.
 */
import { bootstrap } from "./bootstrap/entry.js";

/** @typedef {import("./bootstrap/map_config.types.js").MapConfig} MapConfig */
/** @typedef {import("./bootstrap/map_config.types.js").ClimateRefine} ClimateRefine */
/** @typedef {import("./bootstrap/map_config.types.js").FoundationConfig} FoundationCfg */
/** @typedef {import("./bootstrap/map_config.types.js").StageConfigProviders} StageConfigProviders */

bootstrap({
    stageConfig: /** @type {StageConfigProviders} */ ({
        foundation: true,
        landmassPlates: true,
        coastlines: true,
        storySeed: true,
        storyHotspots: true,
        storyRifts: true,
        storyOrogeny: true,
        storyPaleo: true,
        storyCorridorsPre: true,
        mountains: true,
        volcanoes: true,
        climateBaseline: true,
        storySwatches: true,
        climateRefine: true,
        biomes: true,
        features: true,
    }),
    overrides: /** @type {Partial<MapConfig>} */ ({
        toggles: {
            STORY_ENABLE_HOTSPOTS: false,
            STORY_ENABLE_RIFTS: false,
            STORY_ENABLE_OROGENY: false,
            STORY_ENABLE_SWATCHES: false,
            STORY_ENABLE_PALEO: false,
            STORY_ENABLE_CORRIDORS: false,
        },
        landmass: {
            baseWaterPercent: 63,
            waterThumbOnScale: -6,
            jitterAmpFracBase: 0.02,
        },
        margins: {
            activeFraction: 0.34,
            passiveFraction: 0.18,
            minSegmentLength: 28,
        },
        coastlines: {
            plateBias: {
                threshold: 0.54,
                power: 1.25,
                convergent: 1.1,
                transform: 0.45,
                divergent: -0.2,
                interior: -0.15,
                bayWeight: 0.48,
                bayNoiseBonus: 1.2,
                fjordWeight: 1.05,
            },
        },
        mountains: {
            // Physics-threshold controls (higher intensity = more dramatic mountains)
            tectonicIntensity: 0.77,      // Moderate intensity for balanced mountains
            mountainThreshold: 0.62,     // Higher threshold = fewer mountains
            hillThreshold: 0.20,         // Higher threshold = fewer hills
            // Physics weights
            upliftWeight: 0.65,
            fractalWeight: 0.35,
            riftDepth: 0.4,
            boundaryWeight: 0.7,
            boundaryExponent: 1.35,
            interiorPenaltyWeight: 0.6,
            convergenceBonus: 0.9,
            transformPenalty: 0.3,
            riftPenalty: 0.9,
            hillBoundaryWeight: 0.5,
            hillRiftBonus: 0.52,
            hillConvergentFoothill: 0.4,
            hillInteriorFalloff: 0.3,
            hillUpliftWeight: 0.4,
        },
        volcanoes: {
            baseDensity: 1 / 175,
            minSpacing: 5,
            boundaryThreshold: 0.3,
            boundaryWeight: 1.6,
            convergentMultiplier: 3.25,
            transformMultiplier: 0.9,
            divergentMultiplier: 0.22,
            hotspotWeight: 0.16,
            shieldPenalty: 0.78,
            randomJitter: 0.12,
            minVolcanoes: 9,
            maxVolcanoes: 42,
        },
        climate: {
            baseline: {
                blend: {
                    baseWeight: 0.45,
                    bandWeight: 0.55,
                },
                bands: {
                    deg0to10: 92,
                    deg10to20: 64,
                    deg20to35: 32,
                    deg35to55: 52,
                    deg55to70: 34,
                    deg70plus: 18,
                },
                orographic: {
                    hi1Threshold: 280,
                    hi1Bonus: 6,
                    hi2Threshold: 540,
                    hi2Bonus: 18,
                },
                coastal: {
                    coastalLandBonus: 3,
                    shallowAdjBonus: 2,
                },
                noise: {
                    baseSpanSmall: 5,
                    spanLargeScaleFactor: 1.1,
                },
            },
            refine: /** @type {Partial<ClimateRefine>} */ ({
                waterGradient: {
                    radius: 7,
                    perRingBonus: 1.6,
                    lowlandBonus: 3,
                },
                orographic: {
                    steps: 6,
                    reductionBase: 34,
                    reductionPerStep: 14,
                },
                riverCorridor: {
                    lowlandAdjacencyBonus: 22,
                    highlandAdjacencyBonus: 11,
                },
                lowBasin: {
                    radius: 4,
                    delta: 16,
                },
            }),
        },
        story: {
            hotspot: {
                maxTrails: 9,
                steps: 13,
                stepLen: 2,
                minDistFromLand: 6,
                minTrailSeparation: 14,
                paradiseBias: 1,
                volcanicBias: 2,
                volcanicPeakChance: 0.58,
            },
            rift: {
                maxRiftsPerMap: 2,
                lineSteps: 22,
                stepLen: 3,
                shoulderWidth: 1,
            },
            orogeny: {
                beltMaxPerContinent: 4,
                beltMinLength: 16,
                radius: 7,
                windwardBoost: 24,
                leeDrynessAmplifier: 2.6,
            },
            swatches: {
                maxPerMap: 8,
                forceAtLeastOne: true,
                types: {
                    macroDesertBelt: {
                        weight: 20,
                        latitudeCenterDeg: 18,
                        halfWidthDeg: 18,
                        drynessDelta: 60,
                        bleedRadius: 10,
                    },
                    equatorialRainbelt: {
                        weight: 7,
                        latitudeCenterDeg: 4,
                        halfWidthDeg: 6,
                        wetnessDelta: 70,
                        bleedRadius: 5,
                    },
                    mountainForests: {
                        weight: 5,
                        coupleToOrogeny: true,
                        windwardBonus: 18,
                        leePenalty: 10,
                        bleedRadius: 5,
                    },
                    rainforestArchipelago: {
                        weight: 2,
                        islandBias: 1.5,
                        reefBias: 1.2,
                        wetnessDelta: 28,
                        bleedRadius: 4,
                    },
                },
            },
            paleo: {
                maxFossilChannels: 24,
                fossilChannelLengthTiles: 18,
                fossilChannelStep: 2,
                fossilChannelHumidity: 7,
                fossilChannelMinDistanceFromCurrentRivers: 5,
                sizeScaling: {
                    lengthMulSqrt: 0.8,
                },
                elevationCarving: {
                    enableCanyonRim: true,
                    rimWidth: 5,
                    canyonDryBonus: 12,
                    bluffWetReduction: 2,
                },
            },
        },
        microclimate: {
            rainfall: {
                riftBoost: 6,
                riftRadius: 2,
                paradiseDelta: 4,
                volcanicDelta: 5,
            },
            features: {
                paradiseReefChance: 18,
                volcanicForestChance: 14,
                volcanicTaigaChance: 12,
            },
        },
        biomes: {
            tundra: {
                latMin: 62,
                elevMin: 420,
                rainMax: 55,
            },
            tropicalCoast: {
                latMax: 22,
                rainMin: 115,
            },
            riverValleyGrassland: {
                latMax: 48,
                rainMin: 65,
            },
            riftShoulder: {
                grasslandLatMax: 48,
                grasslandRainMin: 55,
                tropicalLatMax: 28,
                tropicalRainMin: 95,
            },
        },
        featuresDensity: {
            rainforestExtraChance: 18,
            forestExtraChance: 12,
            taigaExtraChance: 2,
            shelfReefMultiplier: 0.85,
        },
        foundation: /** @type {Partial<FoundationCfg>} */ ({
            plates: {
                count: 23,
                convergenceMix: 0.55,
                relaxationSteps: 3,
                seedJitter: 5,
                interiorSmooth: 1.35,
                plateRotationMultiple: 3,
                // seedOffset: 2203, // tweak for alternate plate tessellations
            },
            dynamics: {
                wind: {
                    jetStreaks: 5,
                    jetStrength: 2.0,
                    variance: 0.4,
                    coriolisZonalScale: 2.1,
                },
                currents: {
                    basinGyreCountMax: 4,
                    westernBoundaryBias: 1.6,
                    currentStrength: 1.4,
                },
                mantle: {
                    bumps: 10,
                    amplitude: 6,
                    scale: 1.8,
                },
                directionality: {
                    cohesion: 0.48,
                    primaryAxes: {
                        plateAxisDeg: 47,
                        windBiasDeg: 24,
                        currentBiasDeg: 85,
                    },
                    interplay: {
                        windsFollowPlates: 0.55,
                        currentsFollowWinds: 0.62,
                        riftsFollowPlates: 0.78,
                        orogenyOpposesRifts: 0.62,
                    },
                    hemispheres: {
                        southernFlip: true,
                        equatorBandDeg: 14,
                        monsoonBias: 0.24,
                    },
                    variability: {
                        angleJitterDeg: 22,
                        magnitudeVariance: 0.45,
                        // seedOffset: 9053,
                    },
                },
            },
            policy: {
                windInfluence: 1.2,
                currentHumidityBias: 0.6,
                boundaryFjordBias: 1.1,
                shelfReefBias: 0.7,
                oceanSeparation: {
                    enabled: false,
                    baseSeparationTiles: 0,
                    boundaryClosenessMultiplier: 0,
                    maxPerRowDelta: 0,
                    minChannelWidth: 5,
                    respectSeaLanes: true,
                    edgeWest: {
                        enabled: false,
                        baseTiles: 0,
                        boundaryClosenessMultiplier: 1.0,
                        maxPerRowDelta: 1,
                    },
                    edgeEast: {
                        enabled: false,
                        baseTiles: 0,
                        boundaryClosenessMultiplier: 1.0,
                        maxPerRowDelta: 1,
                    },
                },
            },
        }),
    }),
});
import "./map_orchestrator.js";
</file>

<file path="mod/text/en_us/MapText.xml">
<?xml version="1.0" encoding="utf-8"?>
<Database>
	<EnglishText>
		<Row Tag="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_NAME">
			<Text>Swooper Desert Mountains</Text>
		</Row>
		<Row Tag="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_DESCRIPTION">
			<Text>Plate-forged mega ranges carve a hyper-arid world into stark basins and windward oases. Expect towering boundary cordilleras, savage lee-side deserts, and a handful of monsoon belts clinging to the mountains that feed them.</Text>
		</Row>

	</EnglishText>
</Database>
</file>

<file path="mod/text/en_us/ModuleText.xml">
<?xml version="1.0" encoding="utf-8"?>
<Database>
	<EnglishText>
		<Row Tag="LOC_MODULE_SWOOPER_MAPS_NAME">
			<Text>Swooper's Physics-Based Maps</Text>
		</Row>
		<Row Tag="LOC_MODULE_SWOOPER_MAPS_DESCRIPTION">
			<Text>Advanced map generation using plate tectonics, climate simulation, and narrative storytelling systems. Features convergent mountain chains, rift valleys, atmospheric pressure systems, and physics-driven coastlines. Replaces random terrain generation with realistic geological processes.</Text>
		</Row>
	</EnglishText>
</Database>
</file>

<file path="mod/swooper-maps.modinfo">
<?xml version="1.0" encoding="utf-8"?>
<Mod id="swooper-maps" version="1" xmlns="ModInfo">
	<Properties>
		<Name>LOC_MODULE_SWOOPER_MAPS_NAME</Name>
		<Description>LOC_MODULE_SWOOPER_MAPS_DESCRIPTION</Description>
		<Authors>Matei Canavra</Authors>
		<Package>Mod</Package>
	</Properties>
	<Dependencies>
		<Mod id="base-standard" title="LOC_MODULE_BASE_STANDARD_NAME"/>
	</Dependencies>
	<ActionCriteria>
		<Criteria id="always">
			<AlwaysMet></AlwaysMet>
		</Criteria>
	</ActionCriteria>
	<ActionGroups>
		<!-- Shell scope: Register maps in UI -->
		<ActionGroup id="shell-swooper-maps" scope="shell" criteria="always">
			<Actions>
				<UpdateDatabase>
					<Item>config/config.xml</Item>
				</UpdateDatabase>
				<UpdateText>
					<Item>text/en_us/MapText.xml</Item>
				</UpdateText>
			</Actions>
		</ActionGroup>
	</ActionGroups>
	<LocalizedText>
		<File>text/en_us/ModuleText.xml</File>
	</LocalizedText>
</Mod>
</file>

<file path="repomix-mod-package.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
mod/
  config/
    config.xml
  maps/
    base-standard/
      maps/
        archipelago.js
        assign-advanced-start-region.js
        assign-starting-plots.js
        continents-plus.js
        continents-voronoi.js
        continents.js
        discovery-generator.js
        elevation-terrain-generator.js
        feature-biome-generator.js
        fractal.js
        index.d.js
        map-debug-helpers.js
        map-globals.js
        map-utilities.js
        natural-wonder-generator.js
        pangaea-plus.js
        pangaea-voronoi.js
        resource-generator.js
        shuffle.js
        snow-generator.js
        terra-incognita.js
        volcano-generator.js
      scripts/
        voronoi_generators/
          continent-generator.js
          map-generator.js
        voronoi_maps/
          continents.js
          map-common.js
          pangaea.js
        voronoi_rules/
          avoid-edge.js
          avoid-other-regions.js
          cell-area.js
          near-map-center.js
          near-neighbor.js
          near-plate-boundary.js
          near-region-seed.js
          neighbors-in-region.js
          prefer-latitude.js
          rules-base.js
        age-transition-post-load.js
        heap.js
        index.d.js
        kd-tree.js
        quadtree.js
        random-pcg-32.js
        voronoi-builder.js
        voronoi-hex.js
        voronoi-plate.js
        voronoi-region.js
        voronoi-utils.js
      base-standard.modinfo
    bootstrap/
      defaults/
        base.js
      presets/
        classic.js
        temperate.js
      climate-tunables.js
      dev.js
      entry.js
      foundation-tunables.js
      map_config.types.js
      resolved.js
      runtime.js
      tunables.js
    core/
      adapters.js
      plot_tags.js
      types.js
      utils.js
    layers/
      biomes.js
      climate-engine.js
      coastlines.js
      features.js
      islands.js
      landmass_plate.js
      landmass_utils.js
      mountains.js
      placement.js
      volcanoes.js
    story/
      corridors.js
      overlays.js
      tagging.js
      tags.js
    world/
      model.js
      plate_seed.js
      plates.js
    map_orchestrator.js
    swooper-desert-mountains.js
  text/
    en_us/
      MapText.xml
      ModuleText.xml
  swooper-maps.modinfo
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="mod/config/config.xml">
<?xml version="1.0" encoding="utf-8"?>
<Database>
	<Maps>
		<!-- Base variant - Classic preset -->
		<Row
			File="{swooper-maps}/maps/swooper-desert-mountains.js"
			Name="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_NAME"
			Description="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_DESCRIPTION"
			SortIndex="500"
		/>
	</Maps>
</Database>
</file>

<file path="mod/maps/base-standard/maps/archipelago.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoasts, addMountains, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_CoastTerrain, g_NavigableRiverTerrain, g_OceanTerrain, g_LandmassFractal, g_FlatTerrain } from './map-globals.js';
import { needHumanNearEquator, addPlotTags, adjustOceanPlotTags, isAdjacentToLand, getSector, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script Archipelago.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = g_OceanWaterColumns;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
  } else {
    console.log("Standard Map");
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoasts(iWidth, iHeight);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iWidth / 2 < iX) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
        }
      }
    }
  }
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 70, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
  const PlayerList = Players.getAlive();
  for (let i = 0; i < PlayerList.length; ++i) {
    if (PlayerList[i].isValid && PlayerList[i].isMajor && PlayerList[i].isAI) {
      const playerAI = PlayerList[i].AI;
      playerAI?.scaleAiPreference("PseudoYieldBiases", "PSEUDOYIELD_STANDING_NAVY_UNIT", 200);
    }
  }
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded Archipelago.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
    }
  }
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    3
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    4
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    5
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    6
  );
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.removePlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function generateFractalLayerWithoutHills(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iCenterWeight = 0;
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain || GameplayMap.getTerrainType(iX, iY) == g_CoastTerrain) {
        let terrain = g_FlatTerrain;
        const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
        const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
        if (isAdjacentToLand(iX, iY)) {
          continue;
        } else if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
          continue;
        } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
          terrain = g_OceanTerrain;
        } else {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          let iStartSectorWeight = 0;
          let iFractalWeight = 1;
          if (iStartSectorRows > 0 && iStartSectorCols > 0 && startSectors[iSector]) {
            iStartSectorWeight = 0.5;
            iFractalWeight = 0.55;
          }
          const iPlotHeight = getHeightAdjustingForStartSector(
            iX,
            iY,
            iWaterHeight,
            iFractalWeight,
            iCenterWeight,
            iStartSectorWeight,
            continent1,
            continent2,
            iStartSectorRows,
            iStartSectorCols,
            startSectors
          );
          if (iPlotHeight < iWaterHeight) {
            continue;
          }
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
//# sourceMappingURL=archipelago.js.map
</file>

<file path="mod/maps/base-standard/maps/assign-advanced-start-region.js">
import { g_OceanTerrain, g_MountainTerrain, g_CoastTerrain, g_FlatTerrain, g_HillTerrain } from './map-globals.js';

const g_StartingScore = 20;
const g_BadTerrainScore = 1;
const g_GoodTerrainScore = 10;
const g_TooCloseToOtherPlayerPenalty = -3;
const g_TooCloseDistance = 10;
class AdvancedStartRegion {
  player;
  claimedPlots = [];
  potentialPlots;
  startPlot;
  constructor(inPlayer) {
    this.player = inPlayer;
    this.startPlot = { x: -1, y: -1 };
    this.potentialPlots = /* @__PURE__ */ new Map();
  }
}
function assignAdvancedStartRegions() {
  const playerIds = Players.getAliveIds();
  const playerRegions = [];
  const playerStartPositions = [];
  for (const playerId of playerIds) {
    const region = new AdvancedStartRegion(playerId);
    initializeRegion(region);
    playerStartPositions.push(region.startPlot);
    playerRegions.push(region);
  }
  let maxRegionSize = 0;
  const advStartParams = GameInfo.AdvancedStartParameters.lookup(Game.age);
  if (advStartParams !== null) {
    maxRegionSize = advStartParams.MaxRegionPlots;
  }
  let minRange = 3;
  const minRangeDef = GameInfo.GlobalParameters.lookup("CITY_MIN_RANGE");
  if (minRangeDef !== null) {
    minRange = parseInt(minRangeDef.Value);
  }
  for (let plotCount = 0; plotCount < maxRegionSize; plotCount++) {
    for (let i = 0; i < playerRegions.length; i++) {
      const plotIndex = claimPlot(playerRegions[i], playerStartPositions);
      if (plotIndex !== -1) {
        const plot = GameplayMap.getLocationFromIndex(plotIndex);
        const claimedPlots = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, minRange);
        for (let j = 0; j < playerRegions.length; j++) {
          if (i !== j) {
            for (const claimedPlot of claimedPlots) {
              playerRegions[j].potentialPlots.set(claimedPlot, -1);
            }
          }
        }
      }
    }
  }
  for (let i = 0; i < playerRegions.length; i++) {
    StartPositioner.setAdvancedStartRegion(playerRegions[i].player, playerRegions[i].claimedPlots);
  }
  dumpAdvancedStartRegions(playerRegions);
}
function initializeRegion(region) {
  const startPosition = StartPositioner.getStartPosition(region.player);
  if (startPosition === -1) {
    return;
  }
  region.startPlot = GameplayMap.getLocationFromIndex(startPosition);
  region.potentialPlots.set(startPosition, g_StartingScore + g_GoodTerrainScore);
}
function claimPlot(region, playerStartPositions) {
  let chosenPlot = -1;
  let maxScore = -1;
  for (const [potentialPlot, score] of region.potentialPlots.entries()) {
    if (score > maxScore) {
      maxScore = score;
      chosenPlot = potentialPlot;
    }
  }
  if (chosenPlot !== -1) {
    region.claimedPlots.push(chosenPlot);
    region.potentialPlots.set(chosenPlot, -1);
    const plot = GameplayMap.getLocationFromIndex(chosenPlot);
    const adjacentPlots = GameplayMap.getPlotIndicesInRadius(plot.x, plot.y, 1);
    for (let i = 0; i < adjacentPlots.length; i++) {
      const adjacentPlotIndex = adjacentPlots[i];
      if (region.potentialPlots.has(adjacentPlotIndex) == false) {
        const adjPlot = GameplayMap.getLocationFromIndex(adjacentPlotIndex);
        const terrainType = GameplayMap.getTerrainType(adjPlot.x, adjPlot.y);
        if (terrainType == g_OceanTerrain) {
          region.potentialPlots.set(adjacentPlotIndex, -1);
        } else if (terrainType == g_MountainTerrain || terrainType == g_CoastTerrain) {
          region.potentialPlots.set(adjacentPlotIndex, g_BadTerrainScore);
        } else {
          region.potentialPlots.set(adjacentPlotIndex, g_GoodTerrainScore);
        }
        let score = region.potentialPlots.get(adjacentPlotIndex);
        if (score) {
          if (score > 0) {
            let distScore = g_StartingScore - GameplayMap.getPlotDistance(region.startPlot.x, region.startPlot.y, adjPlot.x, adjPlot.y);
            if (distScore < 0) {
              distScore = 0;
            }
            score += distScore;
          }
          for (const playerPos of playerStartPositions) {
            const dist = GameplayMap.getPlotDistance(playerPos.x, playerPos.y, adjPlot.x, adjPlot.y);
            if (dist < g_TooCloseDistance) {
              score += g_TooCloseToOtherPlayerPenalty;
            }
          }
          region.potentialPlots.set(adjacentPlotIndex, score);
        }
      } else {
        const score = region.potentialPlots.get(adjacentPlotIndex);
        if (score && score > 0) {
          region.potentialPlots.set(adjacentPlotIndex, score + 1);
        }
      }
    }
  }
  return chosenPlot;
}
function dumpAdvancedStartRegions(playerRegions) {
  console.log("AdvancedStartRegions");
  const iHeight = GameplayMap.getGridHeight();
  const iWidth = GameplayMap.getGridWidth();
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      let terrainString = " ";
      if (terrain == g_FlatTerrain) {
        terrainString = ".";
      } else if (terrain == g_HillTerrain) {
        terrainString = "^";
      } else if (terrain == g_MountainTerrain) {
        terrainString = "M";
      } else if (terrain == g_OceanTerrain) {
        terrainString = "~";
      }
      str += terrainString;
      const plotIndex = GameplayMap.getIndexFromXY(iX, iY);
      const player = findPlotOwner(playerRegions, plotIndex);
      if (player !== -1) {
        str += player;
      } else {
        str += " ";
      }
    }
    console.log(str);
  }
}
function findPlotOwner(playerRegions, plot) {
  for (let player = 0; player < playerRegions.length; player++) {
    if (playerRegions[player].claimedPlots.indexOf(plot) !== -1) {
      return player;
    }
  }
  return -1;
}

export { assignAdvancedStartRegions };
//# sourceMappingURL=assign-advanced-start-region.js.map
</file>

<file path="mod/maps/base-standard/maps/assign-starting-plots.js">
import { g_DesiredBufferBetweenMajorStarts, g_RequiredBufferBetweenMajorStarts } from './map-globals.js';
import { getSectorRegion, shuffle, isOceanAccess } from './map-utilities.js';

class PlayerRegion {
  tiles = [];
  landmassId = 0;
  regionId = 0;
  toString() {
    return `[PlayerRegion] landmassId: ${this.landmassId}, regionId: ${this.regionId}, tile count: ${this.tiles.length}`;
  }
}
class PlayerRegionScores {
  scores = [];
  totalBias = 0;
  playerId = 0;
  playerIndex = 0;
  toString() {
    return `[PlayerRegionScores] playerId: ${this.playerId} (Index: ${this.playerIndex}), totalBias: ${this.totalBias}, scores: ${this.scores}`;
  }
}
function chooseStartSectors(iNumPlayersLandmass1, iNumPlayersLandmass2, iRows, iCols, bHumanNearEquator) {
  const returnValue = [];
  const iSectorsPerContinent = iRows * iCols;
  let iPlayersWestContinent = iNumPlayersLandmass1;
  let iPlayersEastContinent = iNumPlayersLandmass2;
  let iMaxNumMajors = 0;
  iMaxNumMajors = iPlayersWestContinent + iPlayersEastContinent;
  const aliveMajorIds = Players.getAliveMajorIds();
  const humanPlayers = [];
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
      humanPlayers.push(iMajorIndex);
    }
  }
  const numHumans = humanPlayers.length;
  const maxSide = Math.max(iPlayersWestContinent, iPlayersEastContinent);
  if (numHumans > maxSide) {
    const half = Math.floor(iMaxNumMajors / 2);
    iPlayersWestContinent = half;
    iPlayersEastContinent = iMaxNumMajors - half;
    iNumPlayersLandmass1 = iPlayersWestContinent;
    iNumPlayersLandmass2 = iPlayersEastContinent;
  }
  if (iNumPlayersLandmass1 == 1 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [[0], [1], [2], [3], [4], [5]];
    var validConfigs2 = [
      [0, 3, 4],
      [1, 2, 5]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 1) {
    var validConfigs1 = [
      [0, 3, 4],
      [1, 2, 5]
    ];
    var validConfigs2 = [[0], [1], [2], [3], [4], [5]];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 2) {
    var validConfigs1 = [
      [0, 2, 6, 8],
      [1, 3, 5, 7]
    ];
    var validConfigs2 = [
      [0, 8],
      [2, 6]
    ];
  } else if (iNumPlayersLandmass1 == 2 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 8],
      [2, 6]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8],
      [1, 3, 5, 7]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6, 8]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [3, 5, 7],
      [4, 6, 8]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 5) {
    var validConfigs1 = [
      [3, 5, 7],
      [4, 6, 8]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
    var validConfigs2 = [
      [1, 3, 5, 7],
      [4, 6, 8, 10]
    ];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 6) {
    var validConfigs1 = [
      [1, 3, 5, 7],
      [4, 6, 8, 10]
    ];
    var validConfigs2 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 2 && iNumPlayersLandmass2 == 2) {
    var validConfigs1 = [
      [0, 5],
      [1, 4]
    ];
    var validConfigs2 = [
      [0, 5],
      [1, 4]
    ];
  } else if (iNumPlayersLandmass1 == 3 && iNumPlayersLandmass2 == 3) {
    var validConfigs1 = [
      [0, 2, 7],
      [1, 6, 8]
    ];
    var validConfigs2 = [
      [0, 2, 7],
      [1, 6, 8]
    ];
  } else if (iNumPlayersLandmass1 == 4 && iNumPlayersLandmass2 == 4) {
    var validConfigs1 = [
      [0, 2, 6, 8],
      [3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8],
      [3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 5) {
    var validConfigs1 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 6, 8, 10],
      [1, 3, 5, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 6 && iNumPlayersLandmass2 == 6) {
    var validConfigs1 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
    var validConfigs2 = [
      [0, 2, 4, 6, 8, 10],
      [1, 3, 5, 7, 9, 11]
    ];
  } else if (iNumPlayersLandmass1 == 8 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6, 8, 9, 11]];
    var validConfigs2 = [[]];
  } else if (iNumPlayersLandmass1 == 5 && iNumPlayersLandmass2 == 0) {
    var validConfigs1 = [[0, 2, 3, 5, 6]];
    var validConfigs2 = [[]];
  } else {
    console.log("THIS SHOULD NOT BE HIT IN STARTING POSITION");
    var validConfigs1 = [[0], [1], [2], [3], [4], [5]];
    var validConfigs2 = [
      [0, 2, 4],
      [1, 3, 5]
    ];
  }
  let iWestContinentConfig = validConfigs1.length - 1;
  if (!bHumanNearEquator)
    iWestContinentConfig = TerrainBuilder.getRandomNumber(validConfigs1.length, "West Continent Start Positions");
  for (let i = 0; i < iSectorsPerContinent; i++) {
    let bFoundIt = false;
    for (let j = 0; j < iPlayersWestContinent; j++) {
      if (i == validConfigs1[iWestContinentConfig][j]) {
        bFoundIt = true;
        break;
      }
    }
    returnValue[i] = bFoundIt;
  }
  let iEastContinentConfig = validConfigs2.length - 1;
  if (!bHumanNearEquator)
    iEastContinentConfig = TerrainBuilder.getRandomNumber(validConfigs2.length, "East Continent Start Positions");
  for (let i = 0; i < iSectorsPerContinent; i++) {
    let bFoundIt = false;
    for (let j = 0; j < iPlayersEastContinent; j++) {
      if (i == validConfigs2[iEastContinentConfig][j]) {
        bFoundIt = true;
        break;
      }
    }
    returnValue[i + iSectorsPerContinent] = bFoundIt;
  }
  return returnValue;
}
function assignStartPositions(iNumWest, iNumEast, west, east, iStartSectorRows, iStartSectorCols, sectors) {
  console.log("Assigning Starting Positions");
  const startPositions = [];
  console.log("iStartSectorRows: " + iStartSectorRows);
  console.log("iStartSectorCols: " + iStartSectorCols);
  console.log("iNumWest: " + iNumWest);
  console.log("iNumEast: " + iNumEast);
  let iMaxNumMajors = 0;
  iMaxNumMajors = iNumWest + iNumEast;
  console.log("iMaxNumMajors: " + iMaxNumMajors);
  let bEastBias = false;
  if (iNumEast > iNumWest) {
    console.log("EastSide");
    bEastBias = true;
  }
  const aliveMajorIds = Players.getAliveMajorIds();
  if (iMaxNumMajors < aliveMajorIds.length) {
    console.log("The input total is less than the total alive majors: " + aliveMajorIds.length);
  }
  const humanPlayers = [];
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
      humanPlayers.push(iMajorIndex);
    }
  }
  let iNumberHomelands = 0;
  let bHumansLargestLandmass = GameInfo.Ages.lookup(Game.age).HumanPlayersPrimaryHemisphere;
  if (bEastBias && iNumEast < humanPlayers.length) {
    bHumansLargestLandmass = false;
  } else if (!bEastBias && iNumWest < humanPlayers.length) {
    bHumansLargestLandmass = false;
  }
  if (bHumansLargestLandmass) {
    if (bEastBias) {
      iNumberHomelands = iNumEast;
    } else {
      iNumberHomelands = iNumWest;
    }
  } else {
    iNumberHomelands = (iNumWest + iNumEast) / 2;
  }
  const [iHomelandTag, iDistantLandTag] = bEastBias ? [PlotTags.PLOT_TAG_EAST_LANDMASS, PlotTags.PLOT_TAG_WEST_LANDMASS] : [PlotTags.PLOT_TAG_WEST_LANDMASS, PlotTags.PLOT_TAG_EAST_LANDMASS];
  const homelandStartRegions = [];
  const distantStartRegions = [];
  let bAssignStartPositionsBySector = true;
  if (iStartSectorRows == 0 || iStartSectorCols == 0) {
    bAssignStartPositionsBySector = false;
  } else {
    bAssignStartPositionsBySector = checkStartSectorsViable(
      west,
      east,
      iStartSectorRows,
      iStartSectorCols,
      sectors
    );
  }
  if (bAssignStartPositionsBySector) {
    console.log("Using Sector-based Assignments");
    for (let iSector = 0; iSector < sectors.length; iSector++) {
      if (sectors[iSector] == true) {
        const region = getSectorRegion(
          iSector,
          iStartSectorRows,
          iStartSectorCols,
          east.south,
          east.north,
          west.west,
          west.east,
          east.west
        );
        const bEastHemis = iSector >= sectors.length / 2;
        let szHeading;
        if (bEastHemis == bEastBias) {
          homelandStartRegions.push(region);
          szHeading = "HOMELAND START REGION:";
        } else {
          distantStartRegions.push(region);
          szHeading = "DISTANT START REGION:";
        }
        console.log(szHeading);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("Start Sector: " + iSector);
      }
    }
  } else {
    console.log("Using Areas of Equal Fertility");
    const iMinMajorFertility = 25;
    const iMinMinorFertility = 5;
    {
      const iLeftCol = bEastBias ? east.west : west.west;
      const iRightCol = bEastBias ? east.east : west.east;
      StartPositioner.initializeValues();
      StartPositioner.divideMapIntoMajorRegions(
        iNumberHomelands,
        iMinMajorFertility,
        iMinMinorFertility,
        iLeftCol,
        iRightCol,
        iHomelandTag
      );
      console.log("Divided map into major regions for Homelands");
      for (let iRegion = 0; iRegion < iNumberHomelands; iRegion++) {
        homelandStartRegions[iRegion] = StartPositioner.getMajorStartRegion(iRegion);
        console.log("HOMELAND START REGION: " + iRegion);
        console.log("West: " + homelandStartRegions[iRegion].west);
        console.log("East: " + homelandStartRegions[iRegion].east);
        console.log("North: " + homelandStartRegions[iRegion].north);
        console.log("South: " + homelandStartRegions[iRegion].south);
        console.log("Continent: " + homelandStartRegions[iRegion].continent);
      }
    }
    {
      const iLeftCol = bEastBias ? west.west : east.west;
      const iRightCol = bEastBias ? west.east : east.east;
      StartPositioner.initializeValues();
      StartPositioner.divideMapIntoMajorRegions(
        iMaxNumMajors - iNumberHomelands,
        iMinMajorFertility,
        iMinMinorFertility,
        iLeftCol,
        iRightCol,
        iDistantLandTag
      );
      console.log("Divided map into major regions for Distant Lands");
      for (let iRegion = 0; iRegion < iMaxNumMajors - iNumberHomelands; iRegion++) {
        distantStartRegions[iRegion] = StartPositioner.getMajorStartRegion(iRegion);
        console.log("DISTANT START REGION: " + iRegion);
        console.log("West: " + distantStartRegions[iRegion].west);
        console.log("East: " + distantStartRegions[iRegion].east);
        console.log("North: " + distantStartRegions[iRegion].north);
        console.log("South: " + distantStartRegions[iRegion].south);
        console.log("Continent: " + distantStartRegions[iRegion].continent);
      }
    }
  }
  const homelandPlayers = [];
  const distantPlayers = [];
  if (bHumansLargestLandmass) {
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length && Players.isHuman(aliveMajorIds[iMajorIndex])) {
        homelandPlayers.push(iMajorIndex);
      }
    }
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length && Players.isAI(aliveMajorIds[iMajorIndex])) {
        if (homelandPlayers.length < iNumberHomelands) {
          homelandPlayers.push(iMajorIndex);
        } else {
          distantPlayers.push(iMajorIndex);
        }
      }
    }
    shuffle(homelandPlayers);
    shuffle(distantPlayers);
  } else {
    const tempPlayers = [];
    for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
      if (iMajorIndex < aliveMajorIds.length) {
        console.log("Found real major at: " + aliveMajorIds[iMajorIndex]);
        tempPlayers.push(iMajorIndex);
      }
    }
    shuffle(tempPlayers);
    for (let i = 0; i < tempPlayers.length; i++) {
      if (homelandPlayers.length < iNumberHomelands) {
        homelandPlayers.push(tempPlayers[i]);
      } else {
        distantPlayers.push(tempPlayers[i]);
      }
    }
  }
  console.log("homelandPlayers: " + homelandPlayers.length);
  console.log("homelandStartRegions: " + homelandStartRegions.length);
  console.log("distantPlayers: " + distantPlayers.length);
  console.log("distantStartRegions: " + distantStartRegions.length);
  console.log("Update homelandPlayers:");
  updateRegionsForStartBias(homelandPlayers, homelandStartRegions);
  console.log("Update distantPlayers:");
  updateRegionsForStartBias(distantPlayers, distantStartRegions);
  for (let i = 0; i < homelandPlayers.length; i++) {
    const iStartPosition = homelandPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    const plotIndex = pickStartPlot(
      homelandStartRegions[i],
      i,
      playerId,
      false,
      startPositions,
      iHomelandTag
    );
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  for (let i = 0; i < distantPlayers.length; i++) {
    const iStartPosition = distantPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    const plotIndex = pickStartPlot(
      distantStartRegions[i],
      i + homelandPlayers.length,
      playerId,
      false,
      startPositions,
      iDistantLandTag
    );
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  return startPositions;
}
function assignStartPositionsFromTiles(playerRegions) {
  console.log("Assigning Starting Positions");
  if (playerRegions.length === 0) {
    console.error("empty array passed to assignStartPositionsFromTiles()");
    return [];
  }
  const landmassRegions = /* @__PURE__ */ new Map();
  for (const region of playerRegions) {
    let regions = landmassRegions.get(region.landmassId) ?? [];
    regions.push(region.regionId);
    landmassRegions.set(region.landmassId, regions);
  }
  let largestLandmassId = -1;
  let largestTileCount = 0;
  for (const [id, lr] of landmassRegions) {
    const lrTileCount = lr.reduce((sum, regionId) => sum + playerRegions[regionId].tiles.length, 0);
    if (lrTileCount > largestTileCount) {
      largestTileCount = lrTileCount;
      largestLandmassId = id;
    }
  }
  const totalPlayers = playerRegions.length;
  console.log(
    `Largest landmass is region ${largestLandmassId} with ${landmassRegions.get(largestLandmassId).length} players and ${largestTileCount} total tiles.`
  );
  console.log(`Total players: ${totalPlayers}`);
  const aliveMajorIds = Players.getAliveMajorIds();
  let aliveMajorIndices = [...aliveMajorIds.keys()];
  if (totalPlayers !== aliveMajorIds.length) {
    console.log(`The input player total ${totalPlayers} is not equal to the alive majors: ${aliveMajorIds.length}`);
  }
  const regionGetter = {
    count: playerRegions.length,
    getTileCoords: function* (regionId) {
      for (const tile of playerRegions[regionId].tiles) yield [tile.x, tile.y];
    }
  };
  const playerRegionScores = getRegionScoresPerPlayer(aliveMajorIndices, regionGetter);
  console.log("Player region scores:");
  playerRegionScores.forEach((prs) => console.log(prs));
  const humanPlayerIndices = aliveMajorIndices.filter((index) => Players.isHuman(aliveMajorIds[index]));
  let bHumansTogether = humanPlayerIndices.length > 1 && GameInfo.Ages.lookup(Game.age).HumanPlayersPrimaryHemisphere && humanPlayerIndices.length <= landmassRegions.get(largestLandmassId).length;
  let regionPlayerBias = new Array(playerRegions.length).fill(-1);
  const assignPlayerBiases = (playerIndices, regions) => {
    for (const playerIndex of playerIndices) {
      let bestId = -1;
      let bestScore = -1;
      for (const regionId of regions) {
        const regionScore = playerRegionScores[playerIndex].scores[regionId];
        if (regionScore > bestScore && regionPlayerBias[regionId] == -1) {
          bestId = regionId;
          bestScore = regionScore;
        }
      }
      regionPlayerBias[bestId] = playerIndex;
    }
  };
  if (bHumansTogether) {
    console.log("Placing humans on same landmass.");
    aliveMajorIndices = aliveMajorIndices.filter((index) => !Players.isHuman(aliveMajorIds[index]));
    const regionsOnLargestLandmass = landmassRegions.get(largestLandmassId);
    humanPlayerIndices.sort((a, b) => playerRegionScores[b].totalBias - playerRegionScores[a].totalBias);
    assignPlayerBiases(humanPlayerIndices, regionsOnLargestLandmass);
  }
  aliveMajorIndices.sort((a, b) => playerRegionScores[b].totalBias - playerRegionScores[a].totalBias);
  console.log(`Sorted indices: ${aliveMajorIndices}`);
  assignPlayerBiases(
    aliveMajorIndices,
    playerRegions.map((v) => v.regionId)
  );
  console.log(`Player region biases:`);
  for (const [regionId, playerIndex] of regionPlayerBias.entries()) {
    const bestScore = playerRegionScores[playerIndex].scores.reduce((best, cur) => Math.max(best, cur), -1);
    const playerId = playerRegionScores[playerIndex].playerId;
    console.log(
      `  Player Id ${playerId} assigned to region ${regionId} with score ${playerRegionScores[playerIndex].scores[regionId]} (best score possible is ${bestScore})`
    );
  }
  let found = 0;
  let startPositions = new Array(regionPlayerBias.length);
  for (const [regionId, playerIndex] of regionPlayerBias.entries()) {
    const playerId = aliveMajorIds[playerIndex];
    const playerTiles = playerRegions[regionId].tiles;
    console.log(
      `Searching ${playerTiles.length} tiles in region ${regionId} (landmass ${playerRegions[regionId].landmassId}) for player ${playerId} (${Players.isHuman(playerId) ? "human" : "ai"})`
    );
    const plotIndex = pickStartPlotByTile(playerTiles, -1, found, playerId, false, startPositions);
    ++found;
    if (plotIndex >= 0) {
      startPositions[playerId] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId);
    }
  }
  return startPositions;
}
function assignSingleContinentStartPositions(iNumPlayers, primaryLandmass, iStartSectorRows, iStartSectorCols, sectors, uiPlotTagFilter = 4294967295) {
  console.log("Assigning Starting Positions");
  const startPositions = [];
  console.log("iStartSectorRows: " + iStartSectorRows);
  console.log("iStartSectorCols: " + iStartSectorCols);
  let iMaxNumMajors = 0;
  iMaxNumMajors = iNumPlayers;
  console.log("iMaxNumMajors: " + iMaxNumMajors);
  const aliveMajorIds = Players.getAliveMajorIds();
  if (iMaxNumMajors < aliveMajorIds.length) {
    console.log("The input total is less than the total alive majors: " + aliveMajorIds.length);
  }
  const homelandPlayers = [];
  const homelandStartRegions = [];
  let bAssignStartPositionsBySector = true;
  if (iStartSectorRows == 0 || iStartSectorCols == 0) {
    bAssignStartPositionsBySector = false;
  } else {
    bAssignStartPositionsBySector = checkStartSectorsViable(
      primaryLandmass,
      primaryLandmass,
      iStartSectorRows,
      iStartSectorCols,
      sectors
    );
  }
  if (bAssignStartPositionsBySector) {
    console.log("Using Sector-based Assignments");
    for (let iSector = 0; iSector < sectors.length; iSector++) {
      if (sectors[iSector] == true) {
        const region = getSectorRegion(
          iSector,
          iStartSectorRows,
          iStartSectorCols,
          primaryLandmass.south,
          primaryLandmass.north,
          primaryLandmass.west,
          primaryLandmass.east,
          primaryLandmass.west
        );
        let szHeading;
        homelandStartRegions.push(region);
        szHeading = "HOMELAND START REGION:";
        console.log(szHeading);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("Start Sector: " + iSector);
      }
    }
  } else {
    console.log("Assigning Starting Positions Across a Single Continent with Equal Fertility");
    const iMinMajorFertility = 25;
    const iMinMinorFertility = 5;
    StartPositioner.initializeValues();
    StartPositioner.divideMapIntoMajorRegions(
      iNumPlayers,
      iMinMajorFertility,
      iMinMinorFertility,
      primaryLandmass.west,
      primaryLandmass.east,
      uiPlotTagFilter
    );
    const potentialRegions = [];
    for (let i = 0; i < iNumPlayers; i++) {
      const region = StartPositioner.getMajorStartRegion(i);
      if (region && region.east > primaryLandmass.west && region.west < primaryLandmass.east) {
        potentialRegions.push(region);
      }
    }
    potentialRegions.sort(
      (a, b) => (b.east - b.west) * (b.north - b.south) - (a.east - a.west) * (a.north - a.south)
    );
    for (const region of potentialRegions) {
      if (homelandStartRegions.length < iNumPlayers) {
        homelandStartRegions.push(region);
      }
    }
    if (homelandStartRegions.length < iNumPlayers) {
      console.log("WARNING: Not enough fertile regions found within the selected continent.");
    }
  }
  for (let iMajorIndex = 0; iMajorIndex < iMaxNumMajors; iMajorIndex++) {
    if (iMajorIndex < aliveMajorIds.length) {
      homelandPlayers.push(iMajorIndex);
    }
  }
  shuffle(homelandPlayers);
  console.log("homelandPlayers: " + homelandPlayers.length);
  console.log("homelandStartRegions: " + homelandStartRegions.length);
  console.log("Update homelandPlayers:");
  updateRegionsForStartBias(homelandPlayers, homelandStartRegions);
  for (let i = 0; i < homelandPlayers.length; i++) {
    const iStartPosition = homelandPlayers[i];
    const playerId = aliveMajorIds[iStartPosition];
    let plotIndex = pickStartPlot(homelandStartRegions[i], i, playerId, false, startPositions);
    if (plotIndex >= 0) {
      startPositions[iStartPosition] = plotIndex;
      const location = GameplayMap.getLocationFromIndex(plotIndex);
      console.log("CHOICE FOR PLAYER: " + playerId + " (" + location.x + ", " + location.y + ")");
      StartPositioner.setStartPosition(plotIndex, playerId);
    } else {
      console.log("FAILED TO PICK LOCATION FOR: " + playerId + " - Retrying with alternative regions.");
      for (const retryRegion of homelandStartRegions) {
        plotIndex = pickStartPlot(retryRegion, i, playerId, false, startPositions);
        if (plotIndex >= 0) {
          startPositions[iStartPosition] = plotIndex;
          StartPositioner.setStartPosition(plotIndex, playerId);
          console.log("Successfully found an alternative start position for " + playerId);
          break;
        }
      }
      if (plotIndex < 0) {
        console.log("FAILED AGAIN - NO VALID LOCATION FOUND FOR: " + playerId);
      }
    }
  }
  return startPositions;
}
function checkStartSectorsViable(west, east, iStartSectorRows, iStartSectorCols, sectors) {
  const tempStartPositions = [];
  for (let iSector = 0; iSector < sectors.length; iSector++) {
    if (sectors[iSector] == true) {
      const region = getSectorRegion(
        iSector,
        iStartSectorRows,
        iStartSectorCols,
        east.south,
        east.north,
        west.west,
        west.east,
        east.west
      );
      const startPlot = pickStartPlot(region, 0, 0, true, tempStartPositions);
      if (startPlot == -1) {
        console.log("LOW FERTILITY START SECTOR: " + iSector);
        console.log("West: " + region.west);
        console.log("East: " + region.east);
        console.log("North: " + region.north);
        console.log("South: " + region.south);
        console.log("ABORTING - Falling back to Civ VI start position assignment algorithm");
        return false;
      }
    }
  }
  return true;
}
function getRegionScoresPerPlayer(majorGroup, startRegions) {
  const biomeBiases = Array.from(
    { length: majorGroup.length },
    () => new Array(GameInfo.Biomes.length).fill(0)
  );
  const navRiverBias = new Array(majorGroup.length).fill(0);
  const NWBias = new Array(majorGroup.length).fill(0);
  const aliveMajorIds = Players.getAliveMajorIds();
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const playerId = aliveMajorIds[majorGroup[iMajorGroup]];
    const player = Players.get(playerId);
    if (player == null) {
      continue;
    }
    const uiCivType = player.civilizationType;
    const uiLeaderType = player.leaderType;
    console.log("Player Id:" + playerId + ", " + player.civilizationName + ", " + player.leaderName);
    for (let startBiomeIdx = 0; startBiomeIdx < GameInfo.StartBiasBiomes.length; startBiomeIdx++) {
      const startBiomeDef = GameInfo.StartBiasBiomes[startBiomeIdx];
      if (startBiomeDef) {
        const civString = startBiomeDef.CivilizationType;
        const ldrString = startBiomeDef.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          const biomeDef = GameInfo.Biomes.lookup(startBiomeDef.BiomeType);
          if (biomeDef) {
            const biomeIndex = biomeDef.$index;
            console.log("biomeIndex: " + biomeIndex + ", Score: " + startBiomeDef.Score);
            biomeBiases[iMajorGroup][biomeIndex] += startBiomeDef.Score;
          }
        }
      }
    }
    for (let startRiverIdx = 0; startRiverIdx < GameInfo.StartBiasTerrains.length; startRiverIdx++) {
      const startBiasTerrainDef = GameInfo.StartBiasTerrains[startRiverIdx];
      if (startBiasTerrainDef) {
        if (startBiasTerrainDef.TerrainType == "TERRAIN_NAVIGABLE_RIVER") {
          const civString = startBiasTerrainDef.CivilizationType;
          const ldrString = startBiasTerrainDef.LeaderType;
          let civHash = 0;
          let ldrHash = 0;
          if (civString != null) {
            const civObj = GameInfo.Civilizations.lookup(civString);
            if (civObj) {
              civHash = civObj.$hash;
            }
          }
          if (ldrString != null) {
            const ldrObj = GameInfo.Leaders.lookup(ldrString);
            if (ldrObj) {
              ldrHash = ldrObj.$hash;
            }
          }
          if (civHash == uiCivType || ldrHash == uiLeaderType) {
            navRiverBias[iMajorGroup] += startBiasTerrainDef.Score;
          }
        }
      }
    }
    for (let startNWIdx = 0; startNWIdx < GameInfo.StartBiasNaturalWonders.length; startNWIdx++) {
      const startBiasNWDef = GameInfo.StartBiasNaturalWonders[startNWIdx];
      if (startBiasNWDef) {
        const civString = startBiasNWDef.CivilizationType;
        const ldrString = startBiasNWDef.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          NWBias[iMajorGroup] += startBiasNWDef.Score;
        }
      }
    }
  }
  console.log("biomeBiases " + biomeBiases);
  console.log("navRiverBias " + navRiverBias);
  console.log("NWBias " + NWBias);
  const startRegionCount = Array.isArray(startRegions) ? startRegions.length : startRegions.count;
  const biomeCounts = new Array(startRegionCount);
  for (let i = 0; i < startRegionCount; i++) {
    biomeCounts[i] = [];
  }
  const navRiverCounts = [];
  const NWCounts = [];
  for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
    for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
      biomeCounts[iRegion][iBiome] = 0;
    }
    navRiverCounts[iRegion] = 0;
    NWCounts[iRegion] = 0;
  }
  for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
    let tileCount = 0;
    const processTile = (xCoord, yCoord) => {
      const biomeType = GameplayMap.getBiomeType(xCoord, yCoord);
      biomeCounts[iRegion][biomeType]++;
      if (GameplayMap.isNavigableRiver(xCoord, yCoord)) {
        navRiverCounts[iRegion]++;
      }
      if (GameplayMap.isNaturalWonder(xCoord, yCoord)) {
        NWCounts[iRegion]++;
      }
      ++tileCount;
    };
    if (Array.isArray(startRegions)) {
      const region = startRegions[iRegion];
      for (let iX = region.west; iX <= region.east; iX++) {
        for (let iY = region.south; iY <= region.north; iY++) {
          processTile(iX, iY);
        }
      }
    } else {
      for (const [iX, iY] of startRegions.getTileCoords(iRegion)) {
        processTile(iX, iY);
      }
    }
    console.log(`Processed ${tileCount} tiles in region ${iRegion}`);
  }
  console.log("biomeCounts " + biomeCounts);
  console.log("navRiverCounts " + navRiverCounts);
  console.log("NWCounts " + NWCounts);
  let regionScores = [];
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const regionScore = new PlayerRegionScores();
    regionScore.playerIndex = majorGroup[iMajorGroup];
    regionScore.playerId = aliveMajorIds[majorGroup[iMajorGroup]];
    for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
      regionScore.totalBias += biomeBiases[iMajorGroup][iBiome];
    }
    regionScore.totalBias += navRiverBias[iMajorGroup];
    regionScore.totalBias += NWBias[iMajorGroup];
    regionScores.push(regionScore);
  }
  for (let iMajorGroup = 0; iMajorGroup < majorGroup.length; iMajorGroup++) {
    const regionScore = regionScores[iMajorGroup];
    for (let iRegion = 0; iRegion < startRegionCount; iRegion++) {
      let regionScoreForMajor = 0;
      for (let iBiome = 0; iBiome < GameInfo.Biomes.length; iBiome++) {
        regionScoreForMajor += biomeBiases[iMajorGroup][iBiome] * biomeCounts[iRegion][iBiome];
      }
      regionScoreForMajor += navRiverBias[iMajorGroup] * navRiverCounts[iRegion];
      regionScoreForMajor += NWBias[iMajorGroup] * NWCounts[iRegion];
      console.log(`majorIndex ${iMajorGroup}, regionScore: ${regionScoreForMajor}`);
      regionScore.scores.push(regionScoreForMajor);
    }
  }
  return regionScores;
}
function updateRegionsForStartBias(majorGroup, startRegions) {
  const regionScores = getRegionScoresPerPlayer(majorGroup, startRegions);
  console.log(`totalMajorBiases: ${regionScores.map((v) => v.totalBias)}`);
  regionScores.sort((a, b) => b.totalBias - a.totalBias);
  console.log(`sortedMajorIndices: ${regionScores.map((v) => v.playerId)}`);
  majorGroup.fill(-1);
  for (const playerRegionScores of regionScores) {
    let iBestScore = -1;
    let iBestRegion = -1;
    for (let iRegion = 0; iRegion < playerRegionScores.scores.length; iRegion++) {
      if (majorGroup[iRegion] == -1) {
        const regionScoreForPlayer = playerRegionScores.scores[iRegion];
        if (regionScoreForPlayer > iBestScore) {
          iBestScore = regionScoreForPlayer;
          iBestRegion = iRegion;
        }
      }
    }
    if (iBestRegion >= 0) {
      majorGroup[iBestRegion] = playerRegionScores.playerIndex;
      console.log(
        `Region ${iBestRegion} is best for major: ${playerRegionScores.playerId} (index: ${playerRegionScores.playerIndex})`
      );
    }
  }
  console.log("Majors (final form):" + majorGroup);
}
function pickStartPlotByTile(tiles, continentId, numFoundEarlier, playerId, ignoreBias, startPositions, plotTagFilter) {
  let chosenPlotIndex = -1;
  let highestScore = 0;
  for (const tile of tiles) {
    if (!plotTagFilter || GameplayMap.getPlotTag(tile.x, tile.y) & plotTagFilter) {
      let score = scorePlot(tile.x, tile.y, continentId);
      if (score > 0) {
        if (!ignoreBias) {
          score += adjustScoreByStartBias(tile.x, tile.y, playerId);
        }
        if (numFoundEarlier > 0) {
          score = adjustScoreByClosestStart(score, tile.x, tile.y, startPositions);
        }
        if (score > highestScore) {
          highestScore = score;
          chosenPlotIndex = tile.y * GameplayMap.getGridWidth() + tile.x;
        }
      }
    }
  }
  return chosenPlotIndex;
}
function pickStartPlot(region, numFoundEarlier, playerId, ignoreBias, startPositions, plotTagFilter) {
  const tiles = [];
  for (let iY = region.south; iY <= region.north; iY++) {
    for (let iX = region.west; iX <= region.east; iX++) {
      tiles.push({ x: iX, y: iY });
    }
  }
  return pickStartPlotByTile(
    tiles,
    region.continent,
    numFoundEarlier,
    playerId,
    ignoreBias,
    startPositions,
    plotTagFilter
  );
}
function scorePlot(iX, iY, iContinent) {
  let score = -1;
  if (!GameplayMap.isWater(iX, iY) && !GameplayMap.isMountain(iX, iY)) {
    if (iContinent == -1 || GameplayMap.getContinentType(iX, iY) == iContinent) {
      score = StartPositioner.getStartPositionScore(iX, iY);
    }
  }
  return score;
}
function adjustScoreByClosestStart(originalScore, iX, iY, startPositions) {
  let score = originalScore;
  if (g_DesiredBufferBetweenMajorStarts <= g_RequiredBufferBetweenMajorStarts) return score;
  const distance = getDistanceToClosestStart(iX, iY, startPositions);
  if (distance < g_RequiredBufferBetweenMajorStarts) {
    score = 0;
  } else if (distance < g_DesiredBufferBetweenMajorStarts) {
    score = score * (distance - g_RequiredBufferBetweenMajorStarts + 1) / (g_DesiredBufferBetweenMajorStarts - g_RequiredBufferBetweenMajorStarts + 1);
  }
  return score;
}
function getDistanceToClosestStart(iX, iY, startPositions) {
  let minDistance = 32768;
  for (let iStart = 0; iStart < startPositions.length; iStart++) {
    const startPlotIndex = startPositions[iStart];
    if (startPlotIndex) {
      const iStartX = startPlotIndex % GameplayMap.getGridWidth();
      const iStartY = startPlotIndex / GameplayMap.getGridWidth();
      const distance = GameplayMap.getPlotDistance(iX, iY, iStartX, iStartY);
      if (distance < minDistance) {
        minDistance = distance;
      }
    }
  }
  return minDistance;
}
function adjustScoreByStartBias(iX, iY, playerId) {
  let score = 0;
  const player = Players.get(playerId);
  if (player == null || player.isAlive == false) {
    return score;
  }
  const eCivType = player.civilizationType;
  const eLeaderType = player.leaderType;
  for (let biomeIdx = 0; biomeIdx < GameInfo.StartBiasBiomes.length; biomeIdx++) {
    const startBiasCivilization = GameInfo.StartBiasBiomes[biomeIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasBiomes[biomeIdx]?.LeaderType;
    const startBiasBiome = GameInfo.StartBiasBiomes[biomeIdx]?.BiomeType;
    if (startBiasBiome) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getBiomeStartBiasScore(startBiasBiome, GameInfo.StartBiasBiomes[biomeIdx].Score, iX, iY);
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getBiomeStartBiasScore(startBiasBiome, GameInfo.StartBiasBiomes[biomeIdx].Score, iX, iY);
        }
      }
    }
  }
  for (let terrainIdx = 0; terrainIdx < GameInfo.StartBiasTerrains.length; terrainIdx++) {
    const startBiasCivilization = GameInfo.StartBiasTerrains[terrainIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasTerrains[terrainIdx]?.LeaderType;
    const startBiasTerrain = GameInfo.StartBiasTerrains[terrainIdx]?.TerrainType;
    if (startBiasTerrain) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getTerrainStartBiasScore(
            startBiasTerrain,
            GameInfo.StartBiasTerrains[terrainIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getTerrainStartBiasScore(
            startBiasTerrain,
            GameInfo.StartBiasTerrains[terrainIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let riverIdx = 0; riverIdx < GameInfo.StartBiasRivers.length; riverIdx++) {
    const startBiasCivilization = GameInfo.StartBiasRivers[riverIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasRivers[riverIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getRiverStartBiasScore(GameInfo.StartBiasRivers[riverIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getRiverStartBiasScore(GameInfo.StartBiasRivers[riverIdx].Score, iX, iY);
      }
    }
  }
  for (let coastIdx = 0; coastIdx < GameInfo.StartBiasAdjacentToCoasts.length; coastIdx++) {
    const startBiasCivilization = GameInfo.StartBiasAdjacentToCoasts[coastIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasAdjacentToCoasts[coastIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getCoastStartBiasScore(GameInfo.StartBiasAdjacentToCoasts[coastIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getCoastStartBiasScore(GameInfo.StartBiasAdjacentToCoasts[coastIdx].Score, iX, iY);
      }
    }
  }
  for (let featureIdx = 0; featureIdx < GameInfo.StartBiasFeatureClasses.length; featureIdx++) {
    const startBiasCivilization = GameInfo.StartBiasFeatureClasses[featureIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasFeatureClasses[featureIdx]?.LeaderType;
    const startBiasFeature = GameInfo.StartBiasFeatureClasses[featureIdx]?.FeatureClassType;
    if (startBiasFeature) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getFeatureClassStartBiasScore(
            startBiasFeature,
            GameInfo.StartBiasFeatureClasses[featureIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getFeatureClassStartBiasScore(
            startBiasFeature,
            GameInfo.StartBiasFeatureClasses[featureIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let resourceIdx = 0; resourceIdx < GameInfo.StartBiasResources.length; resourceIdx++) {
    const startBiasCivilization = GameInfo.StartBiasResources[resourceIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasResources[resourceIdx]?.LeaderType;
    const startBiasResource = GameInfo.StartBiasResources[resourceIdx]?.ResourceType;
    if (startBiasResource) {
      if (startBiasCivilization) {
        const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
        const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
        if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
          score += getResourceStartBiasScore(
            startBiasResource,
            GameInfo.StartBiasResources[resourceIdx].Score,
            iX,
            iY
          );
        }
      }
      if (startBiasLeader) {
        const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
        const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
        if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
          score += getResourceStartBiasScore(
            startBiasResource,
            GameInfo.StartBiasResources[resourceIdx].Score,
            iX,
            iY
          );
        }
      }
    }
  }
  for (let lakeIdx = 0; lakeIdx < GameInfo.StartBiasLakes.length; lakeIdx++) {
    const startBiasCivilization = GameInfo.StartBiasLakes[lakeIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasLakes[lakeIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getLakeStartBiasScore(GameInfo.StartBiasLakes[lakeIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getLakeStartBiasScore(GameInfo.StartBiasLakes[lakeIdx].Score, iX, iY);
      }
    }
  }
  for (let nwIdx = 0; nwIdx < GameInfo.StartBiasNaturalWonders.length; nwIdx++) {
    const startBiasCivilization = GameInfo.StartBiasNaturalWonders[nwIdx]?.CivilizationType;
    const startBiasLeader = GameInfo.StartBiasNaturalWonders[nwIdx]?.LeaderType;
    if (startBiasCivilization) {
      const startBiasCivilizationTypeIndex = GameInfo.Civilizations.lookup(startBiasCivilization)?.$index;
      const civInfoTypeIndex = GameInfo.Civilizations.lookup(eCivType)?.$index;
      if (startBiasCivilizationTypeIndex == civInfoTypeIndex) {
        score += getNaturalWonderStartBiasScore(GameInfo.StartBiasNaturalWonders[nwIdx].Score, iX, iY);
      }
    }
    if (startBiasLeader) {
      const startBiasLeaderTypeIndex = GameInfo.Leaders.lookup(startBiasLeader)?.$index;
      const leaderInfoTypeIndex = GameInfo.Leaders.lookup(eLeaderType)?.$index;
      if (startBiasLeaderTypeIndex == leaderInfoTypeIndex) {
        score += getNaturalWonderStartBiasScore(GameInfo.StartBiasNaturalWonders[nwIdx].Score, iX, iY);
      }
    }
  }
  return score;
}
function getBiomeStartBiasScore(biome, score, iX, iY) {
  const startBiasBiomeTypeIndex = GameInfo.Biomes.lookup(biome)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const biomeInfoTypeIndex = GameInfo.Biomes.lookup(GameplayMap.getBiomeType(iLocation.x, iLocation.y))?.$index;
    if (startBiasBiomeTypeIndex == biomeInfoTypeIndex) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getTerrainStartBiasScore(terrain, score, iX, iY) {
  const startBiasTerrainTypeIndex = GameInfo.Terrains.lookup(terrain)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const terrainInfoTypeIndex = GameInfo.Terrains.lookup(
      GameplayMap.getTerrainType(iLocation.x, iLocation.y)
    )?.$index;
    if (startBiasTerrainTypeIndex == terrainInfoTypeIndex) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getRiverStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isRiver(iLocation.x, iLocation.y)) {
      let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
      if (distance < 1) {
        distance = 1;
      }
      outputScore += score / distance;
    }
  }
  return outputScore;
}
function getCoastStartBiasScore(score, iX, iY) {
  let outputScore = 0;
  if (isOceanAccess(iX, iY)) {
    outputScore += score;
  }
  return outputScore;
}
function getFeatureClassStartBiasScore(feature, score, iX, iY) {
  const startBiasFeatureTypeIndex = GameInfo.FeatureClasses.lookup(feature)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const featureInfoTypeIndex = GameInfo.Features.lookup(
      GameplayMap.getFeatureType(iLocation.x, iLocation.y)
    )?.FeatureClassType;
    if (featureInfoTypeIndex) {
      const featureClassInfoTypeIndex = GameInfo.FeatureClasses.lookup(featureInfoTypeIndex)?.$index;
      if (featureClassInfoTypeIndex == startBiasFeatureTypeIndex) {
        let distance = GameplayMap.getPlotDistance(iX, iY, iLocation.x, iLocation.y);
        if (distance < 1) {
          distance = 1;
        }
        outputScore += score / distance;
      }
    }
  }
  return outputScore;
}
function getResourceStartBiasScore(resource, score, iX, iY) {
  const startBiasResourceTypeIndex = GameInfo.Resources.lookup(resource)?.$index;
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    const resourceInfoTypeIndex = GameInfo.Resources.lookup(
      GameplayMap.getResourceType(iLocation.x, iLocation.y)
    )?.$index;
    if (startBiasResourceTypeIndex == resourceInfoTypeIndex) {
      outputScore += score;
    }
  }
  return outputScore;
}
function getLakeStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isLake(iLocation.x, iLocation.y)) {
      outputScore += score;
    }
  }
  if (outputScore > 0) {
    console.log("Start Bias Score: " + outputScore);
  }
  return outputScore;
}
function getNaturalWonderStartBiasScore(score, iX, iY) {
  const plots = GameplayMap.getPlotIndicesInRadius(iX, iY, 3);
  let outputScore = 0;
  for (let plot = 0; plot < plots.length; plot++) {
    const iLocation = GameplayMap.getLocationFromIndex(plots[plot]);
    if (GameplayMap.isNaturalWonder(iLocation.x, iLocation.y)) {
      outputScore += score;
    }
  }
  if (outputScore > 0) {
    console.log("Start Bias Score: " + outputScore);
  }
  return outputScore;
}

export { PlayerRegion, PlayerRegionScores, assignSingleContinentStartPositions, assignStartPositions, assignStartPositionsFromTiles, chooseStartSectors };
//# sourceMappingURL=assign-starting-plots.js.map
</file>

<file path="mod/maps/base-standard/maps/continents-plus.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpTerrain, dumpContinents, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_OceanWaterColumns, g_NavigableRiverTerrain, g_CoastTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, addPlotTags, createIslands, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, createOrganicLandmasses, adjustOceanPlotTags, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script continents-plus.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  let naturalWonderEvent = false;
  const requestedNaturalWonders = [];
  let liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_RACE_TO_WONDERS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    naturalWonderEvent = true;
    requestedNaturalWonders.push("FEATURE_BERMUDA_TRIANGLE");
  }
  liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_MARVELOUS_MOUNTAINS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    naturalWonderEvent = true;
    requestedNaturalWonders.push("FEATURE_MOUNT_EVEREST");
  }
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  console.log(
    westContinent.west,
    ", ",
    westContinent.east,
    ", ",
    eastContinent.west,
    ", ",
    eastContinent.east,
    ", ",
    westContinent2.west,
    ", ",
    westContinent2.east,
    ", ",
    eastContinent2.west,
    ", ",
    eastContinent2.east,
    ", "
  );
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash || naturalWonderEvent;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = !naturalWonderEvent ? TerrainBuilder.getRandomNumber(2, "East or West") : 0;
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    dumpTerrain(iWidth, iHeight);
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
    dumpTerrain(iWidth, iHeight);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 15;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    dumpTerrain(iWidth, iHeight);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
    dumpTerrain(iWidth, iHeight);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders, naturalWonderEvent, requestedNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iNumPlayers1 > iNumPlayers2) {
          if (iX < westContinent.west - 2 || iX > westContinent.east + 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          }
        } else {
          if (iX > eastContinent.east + 2 || iX < eastContinent.west - 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          }
        }
      }
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded continents-plus.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=continents-plus.js.map
</file>

<file path="mod/maps/base-standard/maps/continents-voronoi.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { PlayerRegion, assignStartPositionsFromTiles, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_FlatTerrain, g_MountainTerrain, g_HillTerrain, g_VolcanoFeature, g_OceanTerrain, g_CoastTerrain, g_NavigableRiverTerrain, g_AvoidSeamOffset } from './map-globals.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { kdTree } from '../scripts/kd-tree.js';
import { TerrainType } from '../scripts/voronoi-utils.js';
import { VoronoiContinents } from '../scripts/voronoi_maps/continents.js';
import { RuleAvoidEdge } from '../scripts/voronoi_rules/avoid-edge.js';
import './map-utilities.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../scripts/random-pcg-32.js';
import '../scripts/voronoi_generators/map-generator.js';
import '../scripts/voronoi_maps/map-common.js';
import '../scripts/voronoi-builder.js';
import '../scripts/voronoi-hex.js';
import '../../core/scripts/MathHelpers.js';
import '../scripts/heap.js';
import '../scripts/voronoi_generators/continent-generator.js';
import '../scripts/quadtree.js';
import '../scripts/voronoi-region.js';
import '../scripts/voronoi_rules/avoid-other-regions.js';
import '../scripts/voronoi_rules/rules-base.js';
import '../scripts/voronoi_rules/cell-area.js';
import '../scripts/voronoi_rules/near-map-center.js';
import '../scripts/voronoi_rules/near-neighbor.js';
import '../scripts/voronoi_rules/near-plate-boundary.js';
import '../scripts/voronoi_rules/near-region-seed.js';
import '../scripts/voronoi_rules/neighbors-in-region.js';
import '../scripts/voronoi_rules/prefer-latitude.js';

console.log("Generating using script Continents-Voronoi.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
async function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iTotalPlayers = Players.getAliveMajorIds().length;
  const startTime = Date.now();
  const voronoiMap = new VoronoiContinents();
  voronoiMap.init(mapInfo.$index);
  const rules = voronoiMap.getBuilder().getGenerator().getRules();
  for (const value of Object.values(rules)) {
    for (const rule of value) {
      if (rule.name == RuleAvoidEdge.getName()) {
        rule.configValues.poleDistance = g_PolarWaterRows;
      }
    }
  }
  const generatorSettings = voronoiMap.getBuilder().getGenerator().getSettings();
  const sizeRatio = generatorSettings.landmass[0].size / (generatorSettings.landmass[0].size + generatorSettings.landmass[1].size);
  const iNumPlayers1 = Math.round(iTotalPlayers * sizeRatio);
  const iNumPlayers2 = iTotalPlayers - iNumPlayers1;
  generatorSettings.landmass[0].playerAreas = iNumPlayers1;
  generatorSettings.landmass[1].playerAreas = iNumPlayers2;
  voronoiMap.getBuilder().simulate();
  const tiles = voronoiMap.getBuilder().getTiles();
  const landmassKdTree = new kdTree((tile) => tile.pos);
  landmassKdTree.build(tiles.flatMap((row) => row.filter((tile) => tile.landmassId > 0)));
  for (let y = 0; y < tiles.length; ++y) {
    for (let x = 0; x < tiles[y].length; ++x) {
      const tile = tiles[y][x];
      if (tile.isLand()) {
        const type = tile.terrainType === TerrainType.Flat ? g_FlatTerrain : tile.terrainType === TerrainType.Mountainous || tile.terrainType === TerrainType.Volcano ? g_MountainTerrain : tile.terrainType === TerrainType.Rough ? g_HillTerrain : g_FlatTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        if (tile.terrainType === TerrainType.Volcano) {
          TerrainBuilder.setFeatureType(x, y, {
            Feature: g_VolcanoFeature,
            Direction: -1,
            Elevation: 0
          });
        }
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_LANDMASS);
        if (tile.landmassId === 1) {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_LANDMASS);
        } else if (tile.landmassId === 2) {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_EAST_LANDMASS);
        } else {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND);
        }
      } else if (tile.isWater()) {
        const type = tile.terrainType === TerrainType.Ocean ? g_OceanTerrain : g_CoastTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
        if (tile.terrainType === TerrainType.Coast) {
          const landmassTile = landmassKdTree.search(tile.pos);
          if (landmassTile.landmassId === 1) {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_WATER);
          } else if (landmassTile.landmassId === 2) {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND_WATER);
          }
        }
      }
    }
  }
  const endTime = Date.now();
  console.log(`Initial Voronoi map generation took ${endTime - startTime} ms`);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  const lakeTiles = generateLakes(iWidth, iHeight, iTilesPerLake);
  console.log(`Updating plot tags for ${lakeTiles.length} lakes.`);
  for (const coord of lakeTiles) {
    const tile = tiles[coord.y][coord.x];
    TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WATER);
    if (tile.landmassId === 1) {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WEST_WATER);
    } else if (tile.landmassId === 2) {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_EAST_WATER);
    } else {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_ISLAND_WATER);
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  let startPositions = [];
  const USE_VORONOI_START_POSITIONS = true;
  if (USE_VORONOI_START_POSITIONS) {
    const fertilityGetter = (tile) => StartPositioner.getPlotFertilityForCoord(tile.coord.x, tile.coord.y);
    voronoiMap.getBuilder().createMajorPlayerAreas(fertilityGetter);
    const playerRegions = Array.from({ length: iTotalPlayers }, () => new PlayerRegion());
    playerRegions.forEach((region, index) => region.regionId = index);
    console.log(`Creating player regions.. initializing indices: ${playerRegions.map((pr) => pr.regionId)}`);
    let offset = 0;
    const offsets = [0].concat([...generatorSettings.landmass.map((n) => offset += n.playerAreas)]);
    for (const row of tiles) {
      for (const tile of row) {
        if (tile.majorPlayerRegionId >= 0 && tile.landmassId > 0) {
          const regionId = tile.majorPlayerRegionId + offsets[tile.landmassId - 1];
          const playerRegion = playerRegions[regionId];
          playerRegion.landmassId = tile.landmassId - 1;
          playerRegion.tiles.push({ x: tile.coord.x, y: tile.coord.y });
        }
      }
    }
    startPositions = assignStartPositionsFromTiles(playerRegions);
  } else {
    const continent = {
      west: g_AvoidSeamOffset,
      east: iWidth - g_AvoidSeamOffset,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    startPositions = assignStartPositions(iNumPlayers1, iNumPlayers2, continent, continent, 0, 0, []);
  }
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
//# sourceMappingURL=continents-voronoi.js.map
</file>

<file path="mod/maps/base-standard/maps/continents.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { expandCoasts, addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight, g_CoastTerrain } from './map-globals.js';
import { needHumanNearEquator, applyCoastalErosionAdjustingForStartSectors, addPlotTags, createOrganicLandmasses, applyCoastalErosion, adjustOceanPlotTags, adjustLakePlotTags, getHeightAdjustingForStartSector, getSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script Continents.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = g_OceanWaterColumns;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 18;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoasts(iWidth, iHeight);
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  adjustLakePlotTags(westContinent, true);
  adjustLakePlotTags(eastContinent, false);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded Continents.ts");
console.log("hey, continents is firing");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          if (startSectors[iSector]) {
            terrain = g_CoastTerrain;
          } else {
            terrain = g_OceanTerrain;
          }
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
//# sourceMappingURL=continents.js.map
</file>

<file path="mod/maps/base-standard/maps/discovery-generator.js">
import { g_OceanWaterColumns, g_RequiredDistanceFromMajorForDiscoveries, g_CoastTerrain, g_OceanTerrain } from './map-globals.js';
import { getDistanceToClosestStart } from './map-utilities.js';

function generateDiscoveries(iWidth, iHeight, startingPositions) {
  if (GameInfo.Ages.lookup(Game.age).GenerateDiscoveries == false) {
    console.log("DISCOVERIES TURNED OFF FOR " + Game.age);
    return;
  }
  if (Configuration.getGameValue("DiscoverySiftingType") == 2316276985) {
    console.log("DISCOVERIES TURNED OFF");
    return;
  }
  console.log("Discovery generation", iWidth, iHeight);
  let discoveryCounter = 0;
  let oceanDiscoveryCounter = 0;
  let discoveryPlacedCounter = 0;
  let totalCoastalDiscoveryNotPlaced = 0;
  let totalOceanDiscoveryNotPlaced = 0;
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 5;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  let distanceToClosestStart = 0;
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) {
    console.log("Skipping discoveries.  No mapInfo for map of size ", uiMapSize);
    return;
  }
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: iOceanWaterColumns / 2,
    east: iWidth / 2 - iOceanWaterColumns / 2,
    south: 0,
    north: 0,
    continent: 0
  };
  const eastContinent = {
    west: iWidth / 2 + iOceanWaterColumns / 2,
    east: iWidth - iOceanWaterColumns / 2,
    south: 0,
    north: 0,
    continent: 0
  };
  function DiscoveryDiceRoller() {
    const randomthing = TerrainBuilder.getRandomNumber(100, "Discovery Type Roll");
    if (randomthing <= 65) {
      return DiscoveryActivationTypes.BASIC;
    } else if (randomthing <= 100) {
      return DiscoveryActivationTypes.INVESTIGATION;
    } else {
      return DiscoveryActivationTypes.MYTHIC;
    }
  }
  function DiscoveryVisualString(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
        return "Cave";
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
        return "Ruins";
      case DiscoveryVisualTypes.IMPROVEMENT_CAMPFIRE:
        return "Campfire";
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
        return "Tents";
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
        return "Cairn";
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
        return "Rich";
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return "Wreckage";
      default:
        return "";
    }
  }
  function DiscoveryTypeString(numb) {
    switch (numb) {
      case DiscoveryActivationTypes.BASIC:
        return "Basic";
      case DiscoveryActivationTypes.INVESTIGATION:
        return "Investigation";
      default:
        return "Unknown";
    }
  }
  function AllowedDiscoveryVisual(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAMPFIRE:
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return true;
      default:
        return false;
    }
  }
  function AllowedDiscoveryVisualExploration(numb) {
    switch (numb) {
      case DiscoveryVisualTypes.IMPROVEMENT_CAVE:
      case DiscoveryVisualTypes.IMPROVEMENT_RUINS:
      case DiscoveryVisualTypes.IMPROVEMENT_TENTS:
      case DiscoveryVisualTypes.IMPROVEMENT_CAIRN:
      case DiscoveryVisualTypes.IMPROVEMENT_RICH:
      case DiscoveryVisualTypes.IMPROVEMENT_WRECKAGE:
        return true;
      default:
        return false;
    }
  }
  console.log("counting");
  console.log(DiscoveryVisualTypes.IMPROVEMENT_CAVE);
  const basicsMap = [];
  const investigationMap = [];
  if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
    GameInfo.DiscoverySiftingImprovements.forEach((discoverySift) => {
      if (AllowedDiscoveryVisualExploration(Database.makeHash(discoverySift.ConstructibleType))) {
        const amount = GameInfo.NarrativeStories.filter((def) => def.Queue == discoverySift.QueueType).length;
        if (amount > 0) {
          if (discoverySift.Activation === "BASIC") {
            basicsMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          } else if (discoverySift.Activation === "INVESTIGATION") {
            investigationMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          }
        }
      }
    });
  } else {
    GameInfo.DiscoverySiftingImprovements.forEach((discoverySift) => {
      if (AllowedDiscoveryVisual(Database.makeHash(discoverySift.ConstructibleType))) {
        const amount = GameInfo.NarrativeStories.filter((def) => def.Queue == discoverySift.QueueType).length;
        if (amount > 0) {
          if (discoverySift.Activation === "BASIC") {
            basicsMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          } else if (discoverySift.Activation === "INVESTIGATION") {
            investigationMap.push([Database.makeHash(discoverySift.ConstructibleType), amount]);
          }
        }
      }
    });
  }
  console.log("poisson number?: " + poisson);
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const iLocation = GameplayMap.getLocationFromIndex(index);
        const terrainType = GameplayMap.getTerrainType(iX, iY);
        if (startingPositions.length > 0) {
          distanceToClosestStart = getDistanceToClosestStart(
            iX,
            iY,
            startingPositions.length,
            startingPositions
          );
          if (distanceToClosestStart < g_RequiredDistanceFromMajorForDiscoveries) {
            continue;
          }
        } else {
          const owner = GameplayMap.getOwner(iX, iY);
          if (owner != PlayerIds.NO_PLAYER) {
            console.log(
              "Can't Place Discovery, tile already owned: ",
              "X=" + iLocation.x + " Y=" + iLocation.y
            );
            continue;
          }
        }
        if (GameplayMap.isImpassable(iX, iY)) {
          continue;
        }
        if (GameplayMap.isNavigableRiver(iX, iY)) {
          continue;
        }
        const resourceAtThisLocal = GameplayMap.getResourceType(iX, iY);
        if (resourceAtThisLocal !== -1) {
          continue;
        }
        if (GameplayMap.isNaturalWonder(iX, iY)) {
          continue;
        }
        if (terrainType === g_CoastTerrain && TerrainBuilder.getRandomNumber(100, "Coast Check") >= 65) {
          const discoveryType2 = DiscoveryDiceRoller();
          discoveryCounter++;
          if (MapConstructibles.addDiscovery(iX, iY, DiscoveryVisualTypes.IMPROVEMENT_COAST, discoveryType2)) {
            discoveryPlacedCounter++;
            console.log("Discovery #", discoveryCounter);
            console.log(
              "VALID coastal DISCOVERY SPOT FOUND!-------------------------------------",
              "X=" + iLocation.x + " Y=" + iLocation.y
            );
            continue;
          } else {
            ++totalCoastalDiscoveryNotPlaced;
            console.log("did not place COASTAL Discovery#: " + discoveryCounter);
            continue;
          }
        }
        if (terrainType === g_OceanTerrain) {
          if (Game.age == Database.makeHash("AGE_EXPLORATION") && TerrainBuilder.getRandomNumber(100, "Coast Check") >= 65) {
            if (iX < westContinent.west || iX > westContinent.east && iX < eastContinent.west || iX > eastContinent.east) {
              const discoveryType2 = DiscoveryDiceRoller();
              discoveryCounter++;
              if (MapConstructibles.addDiscovery(
                iX,
                iY,
                DiscoveryVisualTypes.IMPROVEMENT_SHIPWRECK,
                discoveryType2
              )) {
                discoveryPlacedCounter++;
                oceanDiscoveryCounter++;
                console.log("Discovery #", discoveryCounter);
                console.log(
                  "VALID coastal DISCOVERY SPOT FOUND!-------------------------------------",
                  "X=" + iLocation.x + " Y=" + iLocation.y
                );
                continue;
              } else {
                ++totalOceanDiscoveryNotPlaced;
                console.log("did not place OCEAN discovery#: " + discoveryCounter);
                continue;
              }
            }
          }
        }
        if (GameplayMap.isWater(iX, iY)) {
          continue;
        }
        discoveryCounter++;
        const discoveryType = DiscoveryDiceRoller();
        const discoveryTypeString = DiscoveryTypeString(discoveryType);
        let discoveryHash = DiscoveryVisualTypes.INVALID;
        let visualIndex = -1;
        if (discoveryType == DiscoveryActivationTypes.BASIC) {
          if (basicsMap.length > 0) {
            visualIndex = TerrainBuilder.getRandomNumber(basicsMap.length, "Discovery roll");
            discoveryHash = basicsMap[visualIndex][0];
          }
        } else {
          if (investigationMap.length > 0) {
            visualIndex = TerrainBuilder.getRandomNumber(investigationMap.length, "Discovery roll");
            discoveryHash = investigationMap[visualIndex][0];
          }
        }
        const discoveryVisual = DiscoveryVisualString(discoveryHash);
        if (discoveryHash == DiscoveryVisualTypes.INVALID) {
          console.log(
            "Could not find available discovery: ",
            discoveryTypeString,
            "Discovery#: ",
            discoveryCounter
          );
          continue;
        }
        if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
          console.log("in exploration age");
          console.log("Discovery #", discoveryCounter);
          console.log(
            "VALID DISCOVERY SPOT FOUND-------------------------------------",
            "X=" + iLocation.x + " Y=" + iLocation.y + "  Type: " + discoveryVisual
          );
          if (MapConstructibles.addDiscovery(iX, iY, discoveryHash, discoveryType)) {
            if (discoveryType == DiscoveryActivationTypes.BASIC) {
              --basicsMap[visualIndex][1];
              if (basicsMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                basicsMap.splice(visualIndex, 1);
              }
            } else {
              --investigationMap[visualIndex][1];
              if (investigationMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                investigationMap.splice(visualIndex, 1);
              }
            }
            discoveryPlacedCounter++;
            const discoveryX = iX;
            const discoveryY = iY;
            console.log(discoveryX, discoveryY, discoveryVisual, discoveryTypeString);
          } else {
            console.log(
              "did not place discovery#: " + discoveryCounter + " discovery visual: " + discoveryVisual + " discovery type: " + discoveryTypeString
            );
          }
        } else {
          console.log("in antiquity age");
          console.log("Discovery #", discoveryCounter);
          console.log(
            "VALID DISCOVERY SPOT FOUND-------------------------------------",
            "X=" + iLocation.x + " Y=" + iLocation.y + "  Type: " + discoveryVisual
          );
          if (MapConstructibles.addDiscovery(iX, iY, discoveryHash, discoveryType)) {
            if (discoveryType == DiscoveryActivationTypes.BASIC) {
              --basicsMap[visualIndex][1];
              if (basicsMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                basicsMap.splice(visualIndex, 1);
              }
            } else {
              --investigationMap[visualIndex][1];
              if (investigationMap[visualIndex][1] < 1) {
                console.log("No more ", discoveryTypeString, discoveryVisual);
                investigationMap.splice(visualIndex, 1);
              }
            }
            discoveryPlacedCounter++;
            const discoveryX = iX;
            const discoveryY = iY;
            console.log(discoveryX, discoveryY, discoveryVisual, discoveryTypeString);
          } else {
            console.log(
              "did not place discovery#: " + discoveryCounter + " discovery visual: " + discoveryVisual + " discovery type: " + discoveryTypeString
            );
          }
        }
      }
    }
  }
  console.log("Basics: ");
  for (const [key, value] of basicsMap) {
    console.log(key, "->", value);
  }
  console.log("investigations: ");
  for (const [key, value] of investigationMap) {
    console.log(key, "->", value);
  }
  console.log("Total Discoveries Placed: " + discoveryPlacedCounter);
  console.log("Total ocean Discoveries Placed: " + oceanDiscoveryCounter);
  console.log("Total Coastal Discoveries Not Placed: " + totalCoastalDiscoveryNotPlaced);
  console.log("Total Ocean Discoveries Not Placed: " + totalOceanDiscoveryNotPlaced);
  console.log("could not place this many discoveries: " + (discoveryCounter - discoveryPlacedCounter));
}

export { generateDiscoveries };
//# sourceMappingURL=discovery-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/elevation-terrain-generator.js">
import { g_MountainFractal, g_HillFractal, g_MountainTerrain, g_FlatTerrain, g_HillTerrain, g_OceanTerrain, g_OceanWaterColumns, g_CoastTerrain, g_StandardRainfall, g_MountainTopIncrease, g_RainShadowDrop, g_RainShadowIncreasePerHex } from './map-globals.js';
import { isCliff } from './map-utilities.js';

function addMountains(iWidth, iHeight) {
  const adjustment = 3;
  let extra_mountains = 0;
  const iFlags = 0;
  const grainAmount = 5;
  const liveEventDBRow = GameInfo.GlobalParameters.lookup("REGISTERED_MARVELOUS_MOUNTAINS_EVENT");
  if (liveEventDBRow && liveEventDBRow.Value != "0") {
    extra_mountains = 40;
  }
  const mountains = 93 - adjustment - extra_mountains;
  FractalBuilder.create(g_MountainFractal, iWidth, iHeight, grainAmount, iFlags);
  FractalBuilder.create(g_HillFractal, iWidth, iHeight, grainAmount, iFlags);
  const iMountainThreshold = FractalBuilder.getHeightFromPercent(g_MountainFractal, mountains);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = GameplayMap.getTerrainType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false) {
        const iMountainHeight = FractalBuilder.getHeight(g_MountainFractal, iX, iY);
        if (iMountainHeight >= iMountainThreshold) {
          terrain = g_MountainTerrain;
        }
        if (terrain != g_FlatTerrain) {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      }
    }
  }
}
function addHills(iWidth, iHeight) {
  const adjustment = 3;
  const base_hills_threshold = 950;
  const extra_hills = 0;
  const hillsThreshold = base_hills_threshold - adjustment * 20 - extra_hills;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false && GameplayMap.isMountain(iX, iY) == false) {
        const iIndex = GameplayMap.getIndexFromXY(iX, iY);
        const iLocation = GameplayMap.getLocationFromIndex(iIndex);
        let iHillScore = 0;
        const iElevation = GameplayMap.getElevation(iX, iY);
        for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
          if (GameplayMap.isCliffCrossing(iX, iY, iDirection) == false) {
            const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
            const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
            const iAdjacentElevation = GameplayMap.getElevation(iAdjacentX, iAdjacentY);
            const iElevationDifference = iAdjacentElevation - iElevation;
            if (iElevationDifference > 0) {
              iHillScore = iHillScore + iElevationDifference;
            } else {
              iHillScore = iHillScore - iElevationDifference;
            }
          }
        }
        if (iHillScore > hillsThreshold) {
          TerrainBuilder.setTerrainType(iX, iY, g_HillTerrain);
        }
      }
    }
  }
}
function expandCoasts(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (iX > g_OceanWaterColumns / 2 && (iX < (iWidth - g_OceanWaterColumns) / 2 || iX > (iWidth + g_OceanWaterColumns) / 2) && iX < iWidth - g_OceanWaterColumns / 2) {
          if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(4, "Shallow Water Scater Scatter") == 0) {
            TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
          }
        }
      }
    }
  }
}
function generateLakes(iWidth, iHeight, iTilesPerLake) {
  let iLakesAdded = 0;
  if (iTilesPerLake == 0) iTilesPerLake = 25;
  const ilakePlotRand = Math.floor(iWidth * iHeight / iTilesPerLake);
  console.log("Num Directions" + DirectionTypes.NUM_DIRECTION_TYPES);
  const lakeTiles = [];
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        if (GameplayMap.isCoastalLand(iX, iY) == false) {
          if (GameplayMap.isImpassable(iX, iY) == false) {
            const r = TerrainBuilder.getRandomNumber(ilakePlotRand, "MapGenerator AddLakes");
            if (r == 0) {
              iLakesAdded = iLakesAdded + 1;
              lakeTiles.push(...addMoreLake(iX, iY));
              lakeTiles.push({ x: iX, y: iY });
              TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
            }
          }
        }
      }
    }
  }
  if (iLakesAdded > 0) {
    console.log("Lakes Added: " + iLakesAdded);
  }
  return lakeTiles;
}
function addMoreLake(iX, iY) {
  let iLargeLakes = 0;
  const lakeTiles = [];
  const adjacentPlots = [];
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.isWater(iAdjacentX, iAdjacentY) == false) {
      if (GameplayMap.isAdjacentToShallowWater(iAdjacentX, iAdjacentY) == false) {
        if (GameplayMap.isImpassable(iAdjacentX, iAdjacentY) == false) {
          const r = TerrainBuilder.getRandomNumber(4 + iLargeLakes, "MapGenerator Enlarge Lakes");
          if (r < 3) {
            adjacentPlots.push(iAdjacentPlot);
            iLargeLakes = iLargeLakes + 1;
          }
        }
      }
    }
  }
  for (let adjacentIdx = 0; adjacentIdx < adjacentPlots.length; adjacentIdx++) {
    const x = adjacentPlots[adjacentIdx].x;
    const y = adjacentPlots[adjacentIdx].y;
    TerrainBuilder.setTerrainType(x, y, g_CoastTerrain);
    lakeTiles.push({ x, y });
  }
  return lakeTiles;
}
function buildRainfallMap(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    let iMountainXTilesAgo = -1;
    for (let iX = 0; iX < iWidth; iX++) {
      let iRainfall = g_StandardRainfall;
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (GameplayMap.isLake(iX, iY) == true) {
        TerrainBuilder.setRainfall(iX, iY, iRainfall * 2);
      } else if (GameplayMap.isWater(iX, iY) == false) {
        if (terrain == g_MountainTerrain || isCliff(iX, iY)) {
          iMountainXTilesAgo = 0;
        } else if (iMountainXTilesAgo >= 0) {
          iMountainXTilesAgo++;
        }
        if (iMountainXTilesAgo == 0) {
          iRainfall += g_MountainTopIncrease;
        } else if (iMountainXTilesAgo > 0) {
          iRainfall += g_RainShadowDrop;
          iRainfall += iMountainXTilesAgo * g_RainShadowIncreasePerHex;
          if (iRainfall > g_StandardRainfall) {
            iRainfall = g_StandardRainfall;
          }
        }
        TerrainBuilder.setRainfall(iX, iY, iRainfall);
      } else {
        iMountainXTilesAgo = -1;
      }
    }
  }
}

export { addHills, addMountains, buildRainfallMap, expandCoasts, generateLakes };
//# sourceMappingURL=elevation-terrain-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/feature-biome-generator.js">
import { g_PlainsLatitude, g_MarineBiome, g_TropicalLatitude, g_PlainsBiome, g_TropicalBiome, g_DesertLatitude, g_DesertBiome, g_GrasslandLatitude, g_GrasslandBiome, g_TundraBiome } from './map-globals.js';
import { isAdjacentToNaturalWonder } from './map-utilities.js';

function designateBiomes(iWidth, iHeight) {
  console.log("Biomes");
  let iTotalLandPlots = 0;
  let iTotalLandPlotsAbove = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const latitude = GameplayMap.getPlotLatitude(iX, iY);
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots = iTotalLandPlots + 1;
      }
      if (!GameplayMap.isWater(iX, iY) && g_PlainsLatitude < latitude) {
        iTotalLandPlotsAbove = iTotalLandPlotsAbove + 1;
      }
    }
  }
  let iPlainsLowering = 0;
  let iDesertLowering = 0;
  let iGrassLowering = 0;
  let iTropicalLowering = 0;
  if (Math.round(iTotalLandPlots / 5 * 2 * 0.75) > iTotalLandPlotsAbove) {
    iPlainsLowering += 5;
    iDesertLowering += 4;
    iGrassLowering += 4;
    iTropicalLowering += 2;
    console.log(
      "Less  iTotalLandPlots: " + iTotalLandPlots + " iTotalLandPlotsAbove: " + iTotalLandPlotsAbove
    );
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY)) {
        TerrainBuilder.setBiomeType(iX, iY, g_MarineBiome);
      } else {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude;
        latitude += Math.round(GameplayMap.getElevation(iX, iY) / 120);
        if (GameplayMap.isRiver(iX, iY)) {
          latitude -= 10;
        } else if (GameplayMap.isAdjacentToRivers(iX, iY, 1)) {
          latitude -= 5;
        }
        const rainfall = GameplayMap.getRainfall(iX, iY);
        if (latitude < g_TropicalLatitude - iTropicalLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_PlainsBiome);
        } else if (latitude < g_TropicalLatitude - iTropicalLowering) {
          TerrainBuilder.setBiomeType(iX, iY, g_TropicalBiome);
        } else if (latitude < g_PlainsLatitude - iPlainsLowering || latitude < g_TropicalLatitude - iTropicalLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_PlainsBiome);
        } else if (latitude < g_DesertLatitude - iDesertLowering || latitude < g_PlainsLatitude - iPlainsLowering && rainfall < 85) {
          TerrainBuilder.setBiomeType(iX, iY, g_DesertBiome);
        } else if (latitude < g_GrasslandLatitude - iGrassLowering) {
          TerrainBuilder.setBiomeType(iX, iY, g_GrasslandBiome);
        } else {
          TerrainBuilder.setBiomeType(iX, iY, g_TundraBiome);
        }
      }
    }
  }
}
function addFeatures(iWidth, iHeight) {
  console.log("Features");
  addPositionalFeatures(iWidth, iHeight);
  scatterFeatures(iWidth, iHeight);
  addIce(iWidth, iHeight);
  addReefs(iWidth, iHeight);
}
function addPositionalFeatures(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false && feature == FeatureTypes.NO_FEATURE && GameplayMap.isNavigableRiver(iX, iY) == false) {
        if (GameplayMap.isCoastalLand(iX, iY)) {
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              true,
              false,
              false,
              false,
              false
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        } else if (GameplayMap.isAdjacentToRivers(iX, iY, 2)) {
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              true,
              false,
              false,
              false
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        } else {
          if (GameplayMap.isAdjacentToRivers(iX, iY, 1)) {
            continue;
          } else if (GameplayMap.isCoastalLand(iX, iY)) {
            continue;
          }
          for (var featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (!GameplayMap.isAdjacentToFeature(iX, iY, featIdx) && canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              false,
              true,
              false,
              false
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        }
      }
    }
  }
}
function scatterFeatures(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == false && feature == FeatureTypes.NO_FEATURE && GameplayMap.isNavigableRiver(iX, iY) == false) {
        for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
          if (canAddFeature(
            iX,
            iY,
            featIdx,
            true,
            false,
            false,
            false,
            false,
            false,
            false
          )) {
            const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
            const iRoll = TerrainBuilder.getRandomNumber(100, "Feature Scatter");
            if (iRoll < iScatterChance) {
              const featureParam = {
                Feature: featIdx,
                Direction: -1,
                Elevation: 0
              };
              TerrainBuilder.setFeatureType(iX, iY, featureParam);
              break;
            }
          }
        }
      }
    }
  }
}
function addReefs(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude;
        for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
          if (canAddFeature(
            iX,
            iY,
            featIdx,
            false,
            false,
            false,
            false,
            false,
            true,
            false
          )) {
            if (GameInfo.Features[featIdx].MinLatitude <= latitude && GameInfo.Features[featIdx].MaxLatitude > latitude) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              const iWeight = (latitude + 50) * 2;
              const iRoll = TerrainBuilder.getRandomNumber(iWeight, "Feature Reef");
              if (iRoll < iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        }
      }
    }
  }
}
function addIce(iWidth, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (GameplayMap.isWater(iX, iY) == true && feature == FeatureTypes.NO_FEATURE) {
        let latitude = GameplayMap.getPlotLatitude(iX, iY);
        if (latitude < 0) latitude = -1 * latitude - 5;
        if (latitude > 78) {
          for (let featIdx = 0; featIdx < GameInfo.Features.length; featIdx++) {
            if (canAddFeature(
              iX,
              iY,
              featIdx,
              false,
              false,
              false,
              false,
              false,
              false,
              true
            )) {
              const iScatterChance = GameInfo.Features[featIdx].PlacementDensity;
              let iScore = TerrainBuilder.getRandomNumber(100, "Feature Ice");
              iScore = iScore + latitude;
              if (GameplayMap.isAdjacentToLand(iX, iY)) {
                iScore = 0;
              }
              if (isAdjacentToNaturalWonder(iX, iY)) {
                iScore = 0;
              }
              if (iScore > iScatterChance) {
                const featureParam = {
                  Feature: featIdx,
                  Direction: -1,
                  Elevation: 0
                };
                TerrainBuilder.setFeatureType(iX, iY, featureParam);
                break;
              }
            }
          }
        }
      }
    }
  }
}
function canAddFeature(iX, iY, feature, bScatterable, bRiverMouth, bCoastal, bNearRiver, bIsolated, bReef, bIce) {
  if (!bScatterable || GameInfo.Features[feature].PlacementClass == "SCATTER") {
    if (!bRiverMouth || GameInfo.Features[feature].PlacementClass == "RIVERMOUTH") {
      if (!bCoastal || GameInfo.Features[feature].PlacementClass == "COASTAL") {
        if (!bNearRiver || GameInfo.Features[feature].PlacementClass == "NEARRIVER") {
          if (!bIsolated || GameInfo.Features[feature].PlacementClass == "ISOLATED") {
            if (!bReef || GameInfo.Features[feature].PlacementClass == "REEF") {
              if (!bIce || GameInfo.Features[feature].PlacementClass == "ICE") {
                return TerrainBuilder.canHaveFeature(iX, iY, feature);
              }
            }
          }
        }
      }
    }
  }
  return false;
}

export { addFeatures, designateBiomes };
//# sourceMappingURL=feature-biome-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/fractal.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_OceanWaterColumns, g_NavigableRiverTerrain, g_CoastTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_StartSectorWeight } from './map-globals.js';
import { needHumanNearEquator, addPlotTags, createIslands, createOrganicLandmasses, adjustOceanPlotTags, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script fractal.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 3;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 12;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    console.log("BIGGEST AREA");
    console.log("  West: " + kBoundaries.west);
    console.log("  East: " + kBoundaries.east);
    console.log("  South: " + kBoundaries.south);
    console.log("  North: " + kBoundaries.north);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iNumPlayers1 > iNumPlayers2) {
          if (iX < westContinent.west - 2 || iX > westContinent.east + 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          }
        } else {
          if (iX > eastContinent.east + 2 || iX < eastContinent.west - 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          }
        }
      }
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded fractal.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 3, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 13.5);
  const iBuffer2 = Math.floor(iWidth / 21);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          0,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * (g_FractalWeight + g_StartSectorWeight)) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=fractal.js.map
</file>

<file path="mod/maps/base-standard/maps/index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="mod/maps/base-standard/maps/map-debug-helpers.js">
import { g_FlatTerrain, g_HillTerrain, g_MountainTerrain, g_OceanTerrain, g_StandardRainfall, g_MountainTopIncrease, g_MarineBiome, g_PlainsBiome, g_DesertBiome, g_TropicalBiome, g_TundraBiome, g_GrasslandBiome } from './map-globals.js';

function dumpStartSectors(sectors) {
  for (let iX = 0; iX < sectors.length; iX++) {
    console.log(iX + ": " + sectors[iX]);
  }
}
function dumpContinents(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let terrainString = " ";
      if (GameplayMap.isWater(iX, iY) == false) {
        const continent = GameplayMap.getContinentType(iX, iY);
        if (typeof continent == "number") {
          terrainString = Math.floor(continent % 10).toString();
        }
      }
      str += terrainString + " ";
    }
    console.log(str);
  }
}
function dumpTerrain(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      let terrainString = " ";
      if (terrain == g_FlatTerrain) {
        terrainString = ".";
      } else if (terrain == g_HillTerrain) {
        terrainString = "^";
      } else if (terrain == g_MountainTerrain) {
        terrainString = "M";
      } else if (terrain == g_OceanTerrain) {
        terrainString = "~";
      }
      str += terrainString + " ";
    }
    console.log(str);
  }
}
function dumpElevation(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        const elevation = GameplayMap.getElevation(iX, iY);
        let elevationToDisplay = " ";
        const iNumToDisplay = Math.floor(elevation / 100);
        elevationToDisplay = iNumToDisplay.toString();
        str += elevationToDisplay + " ";
      } else {
        str += "  ";
      }
    }
    console.log(str);
  }
}
function dumpRainfall(iWidth, iHeight) {
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.isWater(iX, iY) == false) {
        const rainfall = GameplayMap.getRainfall(iX, iY);
        let rainfallToDisplay = " ";
        if (rainfall == g_StandardRainfall + g_MountainTopIncrease) {
          rainfallToDisplay = "D";
        } else if (rainfall == g_StandardRainfall) {
          rainfallToDisplay = "s";
        } else {
          const iNumToDisplay = Math.floor(rainfall / 10);
          rainfallToDisplay = iNumToDisplay.toString();
        }
        str += rainfallToDisplay + " ";
      } else {
        str += "  ";
      }
    }
    console.log(str);
  }
}
function dumpBiomes(iWidth, iHeight) {
  const biomes = new Array(GameInfo.Biomes.length);
  for (let biomeIdx = 0; biomeIdx < GameInfo.Biomes.length; biomeIdx++) {
    biomes[biomeIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const biome = GameplayMap.getBiomeType(iX, iY);
      let biomeString = " ";
      if (biome == g_MarineBiome) {
        biomeString = " ";
      } else if (biome == g_PlainsBiome) {
        biomeString = "_";
      } else if (biome == g_DesertBiome) {
        biomeString = ".";
      } else if (biome == g_TropicalBiome) {
        biomeString = "#";
      } else if (biome == g_TundraBiome) {
        biomeString = "*";
      } else if (biome == g_GrasslandBiome) {
        biomeString = "~";
      }
      str += biomeString + " ";
      if (typeof biome == "number") {
        biomes[biome]++;
      }
    }
    console.log(str);
  }
  for (let biomeIDx = 0; biomeIDx < GameInfo.Biomes.length; biomeIDx++) {
    let str = "";
    str += GameInfo.Biomes[biomeIDx].Name + " ( " + biomeIDx + " )  Count: " + biomes[biomeIDx];
    console.log(str);
  }
}
function getFeatureTypeIndex(name) {
  const def = GameInfo.Features.lookup(name);
  if (def) {
    return def.$index;
  }
  return -1;
}
function dumpFeatures(iWidth, iHeight) {
  console.log("Feature placement");
  const displayTypes = [
    { index: getFeatureTypeIndex("FEATURE_SAGEBRUSH_STEPPE"), ch: "P" },
    { index: getFeatureTypeIndex("FEATURE_OASIS"), ch: "O" },
    { index: getFeatureTypeIndex("FEATURE_DESERT_FLOODPLAIN_MINOR"), ch: "d" },
    { index: getFeatureTypeIndex("FEATURE_DESERT_FLOODPLAIN_NAVIGABLE"), ch: "d" },
    { index: getFeatureTypeIndex("FEATURE_FOREST"), ch: "F" },
    { index: getFeatureTypeIndex("FEATURE_MARSH"), ch: "M" },
    { index: getFeatureTypeIndex("FEATURE_GRASSLAND_FLOODPLAIN_MINOR"), ch: "g" },
    { index: getFeatureTypeIndex("FEATURE_GRASSLAND_FLOODPLAIN_NAVIGABLE"), ch: "g" },
    { index: getFeatureTypeIndex("FEATURE_REEF"), ch: "E" },
    { index: getFeatureTypeIndex("FEATURE_COLD_REEF"), ch: "E" },
    { index: getFeatureTypeIndex("FEATURE_ICE"), ch: "I" },
    { index: getFeatureTypeIndex("FEATURE_SAVANNA_WOODLAND"), ch: "T" },
    { index: getFeatureTypeIndex("FEATURE_WATERING_HOLE"), ch: "W" },
    { index: getFeatureTypeIndex("FEATURE_PLAINS_FLOODPLAIN_MINOR"), ch: "p" },
    { index: getFeatureTypeIndex("FEATURE_PLAINS_FLOODPLAIN_NAVIGABLE"), ch: "p" },
    { index: getFeatureTypeIndex("FEATURE_RAINFOREST"), ch: "R" },
    { index: getFeatureTypeIndex("FEATURE_MANGROVE"), ch: "G" },
    { index: getFeatureTypeIndex("FEATURE_TROPICAL_FLOODPLAIN_MINOR"), ch: "t" },
    { index: getFeatureTypeIndex("FEATURE_TROPICAL_FLOODPLAIN_NAVIGABLE"), ch: "t" },
    { index: getFeatureTypeIndex("FEATURE_TAIGA"), ch: "T" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_BOG"), ch: "B" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_FLOODPLAIN_MINOR"), ch: "u" },
    { index: getFeatureTypeIndex("FEATURE_TUNDRA_FLOODPLAIN_NAVIGABLE"), ch: "u" },
    { index: getFeatureTypeIndex("FEATURE_VOLCANO"), ch: "%" },
    // Wonders
    { index: getFeatureTypeIndex("FEATURE_VALLEY_OF_FLOWERS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_BARRIER_REEF"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_BERMUDA_TRIANGLE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_REDWOOD_FOREST"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_GRAND_CANYON"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_GULLFOSS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_IGUAZU_FALLS"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_KILIMANJARO"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_ZHANGJIAJIE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_THERA"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_TORRES_DEL_PAINE"), ch: "@" },
    { index: getFeatureTypeIndex("FEATURE_ULURU"), ch: "@" }
  ];
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let featureString = GameplayMap.isWater(iX, iY) == false ? "." : " ";
      const feature = GameplayMap.getFeatureType(iX, iY);
      if (feature != FeatureTypes.NO_FEATURE) {
        for (const entry of displayTypes) {
          if (entry.index == feature) {
            featureString = entry.ch;
            break;
          }
        }
      }
      str += featureString + " ";
    }
    console.log(str);
  }
}
function dumpResources(iWidth, iHeight) {
  const resources = new Array(GameInfo.Resources.length);
  for (var resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resources[resourceIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const resource = GameplayMap.getResourceType(iX, iY);
      let resourcestring = " ";
      if (resource != ResourceTypes.NO_RESOURCE && typeof resource == "number") {
        resourcestring = resource.toString();
        resources[resource]++;
      } else {
        if (GameplayMap.isWater(iX, iY) == false) {
          resourcestring = "*";
        }
      }
      str += resourcestring + " ";
    }
    console.log(str);
  }
  let totalCount = 0;
  for (var resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    let str = "";
    str += GameInfo.Resources[resourceIdx].Name + " ( " + resourceIdx + " )  Count: " + resources[resourceIdx];
    totalCount += resources[resourceIdx];
    console.log(str);
  }
  console.log("Total resources on map after generation: " + totalCount);
}
function dumpNoisePredicate(iWidth, iHeight, noise, pred) {
  console.log("NOISE MAP (Predicate)");
  if (!pred) {
    console.log("dumpNoiseInterp error: no predicate provided");
    return;
  }
  if (noise.length != iWidth * iHeight) {
    console.log("dumpNoiseInterp error: noise map does not match map width*height");
    return;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      str += pred(noise[index]);
    }
    console.log(str);
  }
}

export { dumpBiomes, dumpContinents, dumpElevation, dumpFeatures, dumpNoisePredicate, dumpRainfall, dumpResources, dumpStartSectors, dumpTerrain };
//# sourceMappingURL=map-debug-helpers.js.map
</file>

<file path="mod/maps/base-standard/maps/map-globals.js">
const g_MountainTerrain = GameInfo.Terrains.find(
  (t) => t.TerrainType == "TERRAIN_MOUNTAIN"
).$index;
const g_HillTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_HILL").$index;
const g_FlatTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_FLAT").$index;
const g_CoastTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_COAST").$index;
const g_OceanTerrain = GameInfo.Terrains.find((t) => t.TerrainType == "TERRAIN_OCEAN").$index;
const g_NavigableRiverTerrain = GameInfo.Terrains.find(
  (t) => t.TerrainType == "TERRAIN_NAVIGABLE_RIVER"
).$index;
const g_TundraBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TUNDRA").$index;
const g_GrasslandBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_GRASSLAND").$index;
const g_PlainsBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_PLAINS").$index;
const g_TropicalBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TROPICAL").$index;
const g_DesertBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_DESERT").$index;
const g_MarineBiome = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_MARINE").$index;
const g_VolcanoFeature = GameInfo.Features.find((t) => t.FeatureType == "FEATURE_VOLCANO").$index;
let temp;
let g_GrasslandLatitude = 0;
let g_PlainsLatitude = 0;
let g_DesertLatitude = 0;
let g_TropicalLatitude = 0;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_GRASSLAND").MaxLatitude;
if (temp) g_GrasslandLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_PLAINS").MaxLatitude;
if (temp) g_PlainsLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_DESERT").MaxLatitude;
if (temp) g_DesertLatitude = temp;
temp = GameInfo.Biomes.find((t) => t.BiomeType == "BIOME_TROPICAL").MaxLatitude;
if (temp) g_TropicalLatitude = temp;
const g_LandmassFractal = 0;
const g_MountainFractal = 1;
const g_HillFractal = 2;
const g_PolarWaterRows = 2;
const g_OceanWaterColumns = 4;
const g_FractalWeight = 0.8;
const g_WaterPercent = 20;
const g_IgnoreStartSectorPctFromCtr = 93;
const g_StartSectorWeight = 0.5;
const g_CenterWeight = 0.7;
const g_CenterExponent = 1.5;
const g_Cutoff = 2;
const g_AvoidSeamOffset = 2;
const g_IslandWidth = 5;
const g_StandardRainfall = 100;
const g_MountainTopIncrease = 100;
const g_RainShadowDrop = -80;
const g_RainShadowIncreasePerHex = 10;
const g_RequiredBufferBetweenMajorStarts = 6;
const g_DesiredBufferBetweenMajorStarts = 12;
const g_RequiredDistanceFromMajorForDiscoveries = 3;

export { g_AvoidSeamOffset, g_CenterExponent, g_CenterWeight, g_CoastTerrain, g_Cutoff, g_DesertBiome, g_DesertLatitude, g_DesiredBufferBetweenMajorStarts, g_FlatTerrain, g_FractalWeight, g_GrasslandBiome, g_GrasslandLatitude, g_HillFractal, g_HillTerrain, g_IgnoreStartSectorPctFromCtr, g_IslandWidth, g_LandmassFractal, g_MarineBiome, g_MountainFractal, g_MountainTerrain, g_MountainTopIncrease, g_NavigableRiverTerrain, g_OceanTerrain, g_OceanWaterColumns, g_PlainsBiome, g_PlainsLatitude, g_PolarWaterRows, g_RainShadowDrop, g_RainShadowIncreasePerHex, g_RequiredBufferBetweenMajorStarts, g_RequiredDistanceFromMajorForDiscoveries, g_StandardRainfall, g_StartSectorWeight, g_TropicalBiome, g_TropicalLatitude, g_TundraBiome, g_VolcanoFeature, g_WaterPercent };
//# sourceMappingURL=map-globals.js.map
</file>

<file path="mod/maps/base-standard/maps/map-utilities.js">
import { g_LandmassFractal, g_CenterExponent, g_IgnoreStartSectorPctFromCtr, g_FlatTerrain, g_OceanTerrain, g_CoastTerrain } from './map-globals.js';

const EAST_LAND_MASS_ID = 0;
const WEST_LAND_MASS_ID = 1;
const AVAILABLE_ON_ALL_LANDMASSES_ID = 2;
function needHumanNearEquator() {
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  let iPlayerCount = 0;
  if (mapInfo) iPlayerCount = mapInfo.PlayersLandmass1 + mapInfo.PlayersLandmass2;
  for (let iPlay = 0; iPlay < iPlayerCount; iPlay++) {
    if (Players.getEverAlive()[iPlay] && Players.getEverAlive()[iPlay].isHuman) {
      const uiCivType = Players.getEverAlive()[iPlay].civilizationType;
      const uiLeaderType = Players.getEverAlive()[iPlay].leaderType;
      for (let startBiomeIdx = 0; startBiomeIdx < GameInfo.StartBiasBiomes.length; startBiomeIdx++) {
        const civString = GameInfo.StartBiasBiomes[startBiomeIdx]?.CivilizationType;
        const ldrString = GameInfo.StartBiasBiomes[startBiomeIdx]?.LeaderType;
        let civHash = 0;
        let ldrHash = 0;
        if (civString != null && GameInfo.Civilizations.lookup(civString) != null) {
          const civObj = GameInfo.Civilizations.lookup(civString);
          if (civObj) {
            civHash = civObj.$hash;
          }
        }
        if (ldrString != null && GameInfo.Leaders.lookup(ldrString) != null) {
          const ldrObj = GameInfo.Leaders.lookup(ldrString);
          if (ldrObj) {
            ldrHash = ldrObj.$hash;
          }
        }
        if (civHash == uiCivType || ldrHash == uiLeaderType) {
          const szBiome = GameInfo.StartBiasBiomes[startBiomeIdx].BiomeType;
          console.log(szBiome);
          if (szBiome == "BIOME_TROPICAL") {
            console.log("Human player needing a Tropical start.");
            return true;
          }
        }
      }
    }
  }
  return false;
}
function getMinimumResourcePlacementModifier() {
  const mapSizeInfo = GameInfo.Maps.lookup(GameplayMap.getMapSize());
  if (mapSizeInfo == null) return;
  let iMapMinimumModifer = 0;
  const mapType = Configuration.getMapValue("Name");
  for (const option of GameInfo.MapResourceMinimumAmountModifier) {
    if (option.MapType === mapType && option.MapSizeType == mapSizeInfo.MapSizeType) {
      iMapMinimumModifer = option.Amount;
      break;
    }
  }
  if (iMapMinimumModifer == 0) {
    for (const option of GameInfo.MapResourceMinimumAmountModifier) {
      if (option.MapType === "DEFAULT" && option.MapSizeType == mapSizeInfo.MapSizeType) {
        iMapMinimumModifer = option.Amount;
        console.log(
          "Using default map size for resuource placemtn, please update the table for this map type. Modifer is " + iMapMinimumModifer + " by default."
        );
        break;
      }
    }
  }
  return iMapMinimumModifer;
}
function getDistanceFromContinentCenter(iX, iY, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol, iEastContinentRightCol) {
  let iContinentLeftEdge = iWestContinentLeftCol;
  let iContinentRightEdge = iWestContinentRightCol;
  if (iX >= iEastContinentLeftCol) {
    iContinentLeftEdge = iEastContinentLeftCol;
    iContinentRightEdge = iEastContinentRightCol;
  }
  const iContinentHeight = iContinentTopRow - iContinentBottomRow;
  const iContinentWidth = iContinentRightEdge - iContinentLeftEdge;
  const iContinentCenterX = iContinentLeftEdge + iContinentWidth / 2;
  const iContinentCenterY = iContinentBottomRow + iContinentHeight / 2;
  const iDistance = GameplayMap.getPlotDistance(iX, iY, iContinentCenterX, iContinentCenterY);
  return iDistance;
}
function getMaxDistanceFromContinentCenter(iX, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol, iEastContinentRightCol) {
  let iContinentLeftEdge = iWestContinentLeftCol;
  let iContinentRightEdge = iWestContinentRightCol;
  if (iX >= iEastContinentLeftCol) {
    iContinentLeftEdge = iEastContinentLeftCol;
    iContinentRightEdge = iEastContinentRightCol;
  }
  const iContinentHeight = iContinentTopRow - iContinentBottomRow;
  const iContinentWidth = iContinentRightEdge - iContinentLeftEdge;
  const iContinentCenterX = iContinentLeftEdge + iContinentWidth / 2;
  const iContinentCenterY = iContinentBottomRow + iContinentHeight / 2;
  const iDistance = GameplayMap.getPlotDistance(
    iContinentLeftEdge,
    iContinentBottomRow,
    iContinentCenterX,
    iContinentCenterY
  );
  return iDistance;
}
function getSector(iX, iY, iRows, iCols, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol) {
  let iContinentBase = 0;
  if (iX >= iEastContinentLeftCol) {
    iContinentBase += iRows * iCols;
    iX = iX - iEastContinentLeftCol + iWestContinentLeftCol;
  }
  const iXSector = Math.floor(
    (iX - iWestContinentLeftCol) / ((iWestContinentRightCol - iWestContinentLeftCol) / iCols)
  );
  const iYSector = Math.floor(
    (iY - iContinentBottomRow) / ((iContinentTopRow - iContinentBottomRow) / iRows)
  );
  const iSector = iYSector * iCols + iXSector;
  const iReturnValue = iContinentBase + iSector;
  return iReturnValue;
}
function getSectorRegion(iSector, iRows, iCols, iContinentBottomRow, iContinentTopRow, iWestContinentLeftCol, iWestContinentRightCol, iEastContinentLeftCol) {
  const region = { west: 0, east: 0, south: 0, north: 0, continent: 0 };
  if (iCols == 0) return region;
  const bIsEastContinent = iSector >= iRows * iCols;
  let iSectorAdjust = 0;
  if (bIsEastContinent) {
    iSectorAdjust = iRows * iCols;
  }
  const row = Math.floor((iSector - iSectorAdjust) / iCols);
  const col = Math.floor(iSector - iSectorAdjust - row * iCols);
  const iSectorWidth = (iWestContinentRightCol - iWestContinentLeftCol) / iCols;
  const iSectorHeight = (iContinentTopRow - iContinentBottomRow) / iRows;
  let iXAdjust = iWestContinentLeftCol;
  if (bIsEastContinent) {
    iXAdjust = iEastContinentLeftCol;
  }
  region.west = Math.floor(iXAdjust + iSectorWidth * col);
  region.east = Math.floor(iXAdjust + iSectorWidth * (col + 1));
  region.south = Math.floor(iContinentBottomRow + iSectorHeight * row);
  region.north = Math.floor(iContinentBottomRow + iSectorHeight * (row + 1));
  region.continent = -1;
  return region;
}
function getHeightAdjustingForStartSector(iX, iY, iWaterHeight, iFractalWeight, iCenterWeight, iStartSectorWeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  let iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
  iPlotHeight *= iFractalWeight;
  const iDistanceFromCenter = getDistanceFromContinentCenter(
    iX,
    iY,
    continent1.south,
    continent1.north,
    continent1.west,
    continent1.east,
    continent2.west,
    continent2.east
  );
  const iMaxDistanceFromCenter = getMaxDistanceFromContinentCenter(
    iX,
    continent1.south,
    continent1.north,
    continent1.west,
    continent1.east,
    continent2.west,
    continent2.east
  );
  const iPercentFromCenter = Math.min(100 * iDistanceFromCenter / iMaxDistanceFromCenter, 100);
  iPlotHeight += iCenterWeight * Math.pow(iWaterHeight * (100 - iPercentFromCenter) / 100, g_CenterExponent);
  if (iPercentFromCenter < g_IgnoreStartSectorPctFromCtr) {
    const iSector = getSector(
      iX,
      iY,
      iStartSectorRows,
      iStartSectorCols,
      continent1.south,
      continent1.north,
      continent1.west,
      continent1.east,
      continent2.west
    );
    if (startSectors[iSector]) {
      const sectorCenterX = (continent1.west + continent1.east) / 2;
      const sectorCenterY = (continent1.south + continent1.north) / 2;
      const distanceToSectorCenter = Math.sqrt((iX - sectorCenterX) ** 2 + (iY - sectorCenterY) ** 2);
      const maxSectorRadius = Math.min(continent1.east - continent1.west, continent1.north - continent1.south) / 3;
      const sectorBoostFactor = 1 - Math.pow(Math.min(distanceToSectorCenter / maxSectorRadius, 1), 1.5);
      iPlotHeight += iStartSectorWeight * iWaterHeight * sectorBoostFactor;
      if (iPercentFromCenter < g_IgnoreStartSectorPctFromCtr * 2 / 3) {
        iPlotHeight += iStartSectorWeight * iWaterHeight;
      }
    }
    if (iStartSectorCols > 2 && iStartSectorRows > 2) {
      let iTestSector = iSector;
      if (iTestSector >= iStartSectorRows * iStartSectorCols) {
        iTestSector = iSector - iStartSectorRows * iStartSectorCols;
      }
      if (iTestSector % iStartSectorCols > 0 && iTestSector % iStartSectorCols < iStartSectorCols - 1) {
        if (iTestSector >= iStartSectorCols && iTestSector < iStartSectorRows * iStartSectorCols - iStartSectorCols) {
          iPlotHeight += iCenterWeight * iWaterHeight;
        }
      }
    }
  }
  return iPlotHeight;
}
function createIslands(iWidth, iHeight, continent1, continent2, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iBuffer = Math.floor(iWidth / 24);
  const terrain = g_FlatTerrain;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      if (iY >= continent1.south + iRandom && iY <= continent1.north - iRandom && (iX >= continent1.west && iX <= continent1.east || iX >= continent2.west && iX <= continent2.east)) {
        const iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
        if (iPlotHeight > iWaterHeight) {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
          TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
        }
      }
    }
  }
}
function applyCoastalErosion(continent, strength, falloff, minRadiusFactor, verticalOnly) {
  console.log(
    `Applying Coastal Erosion with strength ${strength} to continent at (${continent.west}, ${continent.east})`
  );
  const centerX = (continent.west + continent.east) / 2;
  const centerY = (continent.south + continent.north) / 2;
  const maxRadiusY = (continent.north - continent.south) / 2;
  const maxRadius = verticalOnly ? maxRadiusY : Math.min(continent.east - continent.west, continent.north - continent.south) / 2;
  const minRadius = maxRadius * minRadiusFactor;
  const erosionTiles = [];
  for (let iY = continent.south; iY <= continent.north; iY++) {
    for (let iX = continent.west; iX <= continent.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) continue;
      let distance = 0;
      if (verticalOnly) {
        distance = Math.abs(iY - (continent.south + continent.north) / 2);
      } else {
        distance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);
      }
      if (distance <= minRadius) continue;
      const erosionFactor = distance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;
      const erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;
      const randomChance = TerrainBuilder.getRandomNumber(100, "Coastal Erosion") / 100;
      if (randomChance < erosionThreshold) {
        erosionTiles.push({ x: iX, y: iY });
      }
    }
  }
  const expandedErosion = /* @__PURE__ */ new Set();
  function addErosionTile(x, y) {
    const key = `${x},${y}`;
    if (!expandedErosion.has(key)) {
      expandedErosion.add(key);
      TerrainBuilder.setTerrainType(x, y, g_OceanTerrain);
      TerrainBuilder.setPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
    }
  }
  for (const tile of erosionTiles) {
    addErosionTile(tile.x, tile.y);
    const expansionChance = TerrainBuilder.getRandomNumber(100, "Erosion Expansion") / 100;
    if (expansionChance < 0.7) {
      const neighbors = [
        { x: tile.x + 1, y: tile.y },
        { x: tile.x - 1, y: tile.y },
        { x: tile.x, y: tile.y + 1 },
        { x: tile.x, y: tile.y - 1 }
      ];
      for (const neighbor of neighbors) {
        if (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== g_OceanTerrain) {
          addErosionTile(neighbor.x, neighbor.y);
        }
      }
    }
  }
  console.log("Coastal Erosion Applied.");
}
function applyCoastalErosionAdjustingForStartSectors(continent1, continent2, strength, falloff, minRadiusFactor, iStartSectorRows, iStartSectorCols, startSectors) {
  console.log(
    `Applying Coastal Erosion Ajdusting for Start Sectors with strength ${strength} to continent at (${continent1.west}, ${continent1.east})`
  );
  const centerX = (continent1.west + continent1.east) / 2;
  const centerY = (continent1.south + continent1.north) / 2;
  const maxRadius = Math.min(continent1.east - continent1.west, continent1.north - continent1.south) / 2;
  const minRadius = maxRadius * minRadiusFactor;
  const erosionTiles = [];
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) continue;
      let distance = 0;
      distance = Math.sqrt((iX - centerX) ** 2 + (iY - centerY) ** 2);
      if (distance <= minRadius) continue;
      const erosionFactor = distance > minRadius ? ((distance - minRadius) / (maxRadius - minRadius)) ** falloff : 0;
      let erosionThreshold = distance > minRadius ? strength * erosionFactor : 0;
      const randomChance = TerrainBuilder.getRandomNumber(100, "Coastal Erosion") / 100;
      const iSector = getSector(
        iX,
        iY,
        iStartSectorRows,
        iStartSectorCols,
        continent1.south,
        continent1.north,
        continent1.west,
        continent1.east,
        continent2.west
      );
      if (startSectors[iSector]) {
        if (!isNearContinentCorner(iX, iY, continent1, 0.1)) {
          erosionThreshold = erosionThreshold / 10;
        }
      }
      if (randomChance < erosionThreshold) {
        erosionTiles.push({ x: iX, y: iY });
      }
    }
  }
  function isNearContinentCorner(iX, iY, continent, bufferScale) {
    const continentWidth = continent.east - continent.west;
    const continentHeight = continent.north - continent.south;
    const bufferX = Math.max(2, Math.min(Math.floor(continentWidth * bufferScale), 10));
    const bufferY = Math.max(2, Math.min(Math.floor(continentHeight * bufferScale), 10));
    const topLeft = { x: continent.west, y: continent.north };
    const topRight = { x: continent.east, y: continent.north };
    const bottomLeft = { x: continent.west, y: continent.south };
    const bottomRight = { x: continent.east, y: continent.south };
    function isNearCorner(cornerX, cornerY) {
      return Math.abs(iX - cornerX) <= bufferX && Math.abs(iY - cornerY) <= bufferY;
    }
    return isNearCorner(topLeft.x, topLeft.y) || isNearCorner(topRight.x, topRight.y) || isNearCorner(bottomLeft.x, bottomLeft.y) || isNearCorner(bottomRight.x, bottomRight.y);
  }
  const expandedErosion = /* @__PURE__ */ new Set();
  function addErosionTile(x, y) {
    const key = `${x},${y}`;
    if (!expandedErosion.has(key)) {
      expandedErosion.add(key);
      TerrainBuilder.setTerrainType(x, y, g_OceanTerrain);
      TerrainBuilder.setPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
    }
  }
  for (const tile of erosionTiles) {
    addErosionTile(tile.x, tile.y);
    const expansionChance = TerrainBuilder.getRandomNumber(100, "Erosion Expansion") / 100;
    if (expansionChance < 0.7) {
      const neighbors = [
        { x: tile.x + 1, y: tile.y },
        { x: tile.x - 1, y: tile.y },
        { x: tile.x, y: tile.y + 1 },
        { x: tile.x, y: tile.y - 1 }
      ];
      for (const neighbor of neighbors) {
        if (GameplayMap.getTerrainType(neighbor.x, neighbor.y) !== g_OceanTerrain) {
          addErosionTile(neighbor.x, neighbor.y);
        }
      }
    }
  }
  console.log("Coastal Erosion Applied.");
}
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex;
  while (0 !== currentIndex) {
    randomIndex = TerrainBuilder.getRandomNumber(currentIndex, "Array Shuffle");
    currentIndex -= 1;
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }
  return array;
}
function getContinentEdgeHeightBump(iX, iY) {
  if (GameplayMap.findSecondContinent(iX, iY, 1)) {
    return 100;
  } else if (GameplayMap.findSecondContinent(iX, iY, 2)) {
    return 40;
  } else if (GameplayMap.findSecondContinent(iX, iY, 3)) {
    return 20;
  }
  return 0;
}
function getDistanceToClosestStart(iX, iY, numFoundEarlier, startPositions) {
  let minDistance = 32768;
  for (let iStart = 0; iStart < numFoundEarlier; iStart++) {
    const startPlotIndex = startPositions[iStart];
    const iStartX = startPlotIndex % GameplayMap.getGridWidth();
    const iStartY = Math.floor(startPlotIndex / GameplayMap.getGridWidth());
    const distance = GameplayMap.getPlotDistance(iX, iY, iStartX, iStartY);
    if (distance < minDistance) {
      minDistance = distance;
    }
  }
  return minDistance;
}
function addLandmassPlotTags(iX, iY, iEastContinentLeftCol) {
  TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_LANDMASS);
  if (iX >= iEastContinentLeftCol) {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_LANDMASS);
  } else {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_LANDMASS);
  }
}
function addWaterPlotTags(iX, iY, iEastContinentLeftCol) {
  TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
  if (iX >= iEastContinentLeftCol - 1) {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
  } else {
    TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
  }
}
function adjustOceanPlotTags(bWestSide) {
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (bWestSide) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
        }
      }
    }
  }
}
function adjustLakePlotTags(region, bWestSide) {
  for (let iY = region.south; iY <= region.north; iY++) {
    for (let iX = region.west; iX <= region.east; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        TerrainBuilder.addPlotTag(
          iX,
          iY,
          bWestSide ? PlotTags.PLOT_TAG_WEST_WATER : PlotTags.PLOT_TAG_EAST_WATER
        );
      }
    }
  }
}
function isAdjacentToNaturalWonder(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    if (GameplayMap.isNaturalWonder(iAdjacentX, iAdjacentY)) {
      return true;
    }
  }
  return false;
}
function isCliff(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    if (GameplayMap.isCliffCrossing(iX, iY, iDirection) == false) {
      return true;
    }
  }
  return false;
}
function isOceanAccess(iX, iY) {
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentIndex = GameplayMap.getIndexFromXY(iAdjacentX, iAdjacentY);
    if (GameplayMap.getRiverType(iAdjacentX, iAdjacentY) == RiverTypes.RIVER_NAVIGABLE && MapRivers.isRiverConnectedToOcean(iAdjacentIndex)) {
      return true;
    }
    if (GameplayMap.getAreaId(iAdjacentX, iAdjacentY) > -1 && GameplayMap.getAreaIsWater(iAdjacentX, iAdjacentY) && AreaBuilder.isAreaConnectedToOcean(GameplayMap.getAreaId(iAdjacentX, iAdjacentY))) {
      return true;
    }
  }
  return false;
}
function removeRuralDistrict(iX, iY) {
  const districtID = MapCities.getDistrict(iX, iY);
  if (districtID != null) {
    const cityID = MapCities.getCity(iX, iY);
    if (cityID != null) {
      const city = Cities.get(cityID);
      if (city != null) {
        if (city.location.x != iX || city.location.y != iY) {
          console.log("Removed district at (" + iX + ", " + iY + ")");
          city.Districts?.removeDistrict(districtID);
        }
      }
    }
  }
}
function placeRuralDistrict(iX, iY) {
  const cityID = MapCities.getCity(iX, iY);
  if (cityID != null) {
    const city = Cities.get(cityID);
    if (city != null) {
      if (city.location.x != iX || city.location.y != iY) {
        console.log("Placed district at (" + iX + ", " + iY + ")");
        city.Growth?.claimPlot({ x: iX, y: iY });
      }
    }
  }
}
function replaceIslandResources(iWidth, iHeight, zResourceClassType) {
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resources = [];
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    const resourceInfo = GameInfo.Resources.lookup(resourceIdx);
    if (resourceInfo && resourceInfo.Tradeable) {
      if (GameInfo.Resources.lookup(resourceIdx)?.ResourceClassType == zResourceClassType) {
        resources.push(resourceIdx);
      }
      resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
    }
    resourceRunningWeight[resourceIdx] = 0;
  }
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {
        const resourceAtLocation = GameplayMap.getResourceType(iX, iY);
        if (resourceAtLocation != ResourceTypes.NO_RESOURCE) {
          if (resources.length > 0) {
            let resourceChosen = ResourceTypes.NO_RESOURCE;
            let resourceChosenIndex = 0;
            for (let iI = 0; iI < resources.length; iI++) {
              if (resources[iI] != resourceAtLocation) {
                if (ResourceBuilder.canHaveResource(iX, iY, resources[iI], true)) {
                  if (resourceChosen == ResourceTypes.NO_RESOURCE) {
                    resourceChosen = resources[iI];
                    resourceChosenIndex = resources[iI];
                  } else {
                    if (resourceRunningWeight[resources[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                      resourceChosen = resources[iI];
                      resourceChosenIndex = resources[iI];
                    } else if (resourceRunningWeight[resources[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                      const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                      if (iRoll >= 1) {
                        resourceChosen = resources[iI];
                        resourceChosenIndex = resources[iI];
                      }
                    }
                  }
                }
              }
            }
            if (resourceChosen != ResourceTypes.NO_RESOURCE) {
              const iResourcePlotIndex = GameplayMap.getIndexFromXY(iX, iY);
              if (iResourcePlotIndex != -1) {
                removeRuralDistrict(iX, iY);
                ResourceBuilder.setResourceType(iX, iY, ResourceTypes.NO_RESOURCE);
                ResourceBuilder.setResourceType(iX, iY, resourceChosen);
                placeRuralDistrict(iX, iY);
                resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
                const oldName = GameInfo.Resources.lookup(resourceAtLocation)?.Name;
                const name = GameInfo.Resources.lookup(resourceChosenIndex)?.Name;
                console.log("Replaced " + Locale.compose(oldName) + " at (" + iX + ", " + iY + ")");
                console.log("Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")");
              } else {
                console.log("Resource Index Failure");
              }
            } else {
              console.log("No valid resource replacement");
            }
          }
        }
      }
    }
  }
}
function isAdjacentToLand(iX, iY) {
  if (GameplayMap.hasPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND)) {
    return true;
  } else {
    for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
      const iIndex = GameplayMap.getIndexFromXY(iX, iY);
      const iLocation = GameplayMap.getLocationFromIndex(iIndex);
      const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
      const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
      if (GameplayMap.hasPlotTag(iAdjacentX, iAdjacentY, PlotTags.PLOT_TAG_ISLAND)) {
        return true;
      }
    }
  }
  return false;
}
function shiftTerrain(iWidth, iHeight) {
  let shift_x = 0;
  let shift_y = 0;
  shift_x = determineXShift(iWidth, iHeight);
  shift_y = determineYShift(iWidth, iHeight);
  console.log("shift_x: " + shift_x);
  console.log("shift_y: ", shift_y);
  shiftPlotTypesBy(iWidth, iHeight, shift_x, shift_y);
}
function shiftPlotTypesBy(iWidth, iHeight, xshift, yshift) {
  if (xshift > 0 || yshift > 0) {
    const iTempTerrainArray = Array(iWidth).fill(g_OceanTerrain).map((_) => Array(iHeight));
    for (let iX = 0; iX < iWidth; iX++) {
      for (let iY = 0; iY < iHeight; iY++) {
        iTempTerrainArray[iX][iY] = GameplayMap.getTerrainType(iX, iY);
      }
    }
    for (let iDestX = 0; iDestX < iWidth; iDestX++) {
      for (let iDestY = 0; iDestY < iHeight; iDestY++) {
        const iSourceX = (iDestX + xshift) % iWidth;
        const iSourceY = (iDestY + yshift) % iHeight;
        const iTerrain = iTempTerrainArray[iSourceX][iSourceY];
        TerrainBuilder.setTerrainType(iDestX, iDestY, iTerrain);
      }
    }
  }
}
function determineXShift(iWidth, iHeight) {
  const waterTotals = [];
  for (let iX = 0; iX < iWidth; iX++) {
    let colWaterCount = 0;
    for (let iY = 0; iY < iHeight; iY++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain) {
        colWaterCount = colWaterCount + 1;
      }
    }
    waterTotals.push(colWaterCount);
  }
  const columnGroups = [];
  const groupRadius = Math.floor(iWidth / 10);
  for (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {
    let currentGroupTotal = 0;
    for (let currentCol = columnIndex - groupRadius; currentCol <= columnIndex + groupRadius; currentCol++) {
      const currentIdx = (currentCol + iWidth) % iWidth;
      currentGroupTotal = currentGroupTotal + waterTotals[currentIdx];
    }
    columnGroups.push(currentGroupTotal);
  }
  let bestValue = 0;
  let bestGroup = 0;
  for (let columnIndex = 0; columnIndex < iWidth; columnIndex++) {
    if (columnGroups[columnIndex] > bestValue) {
      bestValue = columnGroups[columnIndex];
      bestGroup = columnIndex;
    }
  }
  const x_shift = bestGroup;
  return x_shift;
}
function determineYShift(iWidth, iHeight) {
  const waterTotals = [];
  for (let iY = 0; iY < iHeight; iY++) {
    let rowWaterCount = 0;
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain) {
        rowWaterCount = rowWaterCount + 1;
      }
    }
    waterTotals.push(rowWaterCount);
  }
  const rowGroups = [];
  const groupRadius = Math.floor(iHeight / 15);
  for (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {
    let currentGroupTotal = 0;
    for (let currentRow = rowIndex - groupRadius; currentRow <= rowIndex + groupRadius; currentRow++) {
      const currentIdx = (currentRow + iHeight) % iHeight;
      currentGroupTotal = currentGroupTotal + waterTotals[currentIdx];
    }
    rowGroups.push(currentGroupTotal);
  }
  let bestValue = 0;
  let bestGroup = 0;
  for (let rowIndex = 0; rowIndex < iHeight; rowIndex++) {
    if (rowGroups[rowIndex] > bestValue) {
      bestValue = rowGroups[rowIndex];
      bestGroup = rowIndex;
    }
  }
  const y_shift = bestGroup;
  return y_shift;
}
function createOrganicLandmasses(iWidth, iHeight, continent1, continent2, iFractalGrain, iWaterPercent, iLargestContinentPercent) {
  let bLargeEnoughFound = false;
  while (!bLargeEnoughFound) {
    let iFlags = 0;
    iFlags = 1;
    iFlags += 2;
    FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iFractalGrain, iFlags);
    const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iWaterPercent);
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        let terrain = g_OceanTerrain;
        const iPlotHeight = FractalBuilder.getHeight(g_LandmassFractal, iX, iY);
        if (iPlotHeight >= iWaterHeight) {
          terrain = g_FlatTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
    shiftTerrain(iWidth, iHeight);
    let iTilesChoppedInGutter = 0;
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        if (GameplayMap.getTerrainType(iX, iY) != g_OceanTerrain) {
          if (iY < continent1.south || iY >= continent1.north) {
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iY == continent1.south || iY == continent1.north - 1) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
          if (iX < continent1.west || iX > continent2.east - 1) {
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iX == continent1.west || iX == continent2.east - 1) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
          if (iX > continent1.east - 1 && iX < continent2.west) {
            iTilesChoppedInGutter = iTilesChoppedInGutter + 1;
            TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
          } else if (iX == continent1.east - 1 || iX == continent2.west) {
            if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
              TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
            }
          }
        }
      }
    }
    console.log("Tiles in Center Gutter:" + iTilesChoppedInGutter);
    const iMaxTilesToChop = iHeight * (continent2.west - continent1.east) / 2;
    console.log("Max Tiles to Chop: " + iMaxTilesToChop);
    if (iTilesChoppedInGutter >= iMaxTilesToChop) {
      console.log("Fail. Too many tiles lost in center gutter");
    } else {
      AreaBuilder.recalculateAreas();
      const iAreaID = AreaBuilder.findBiggestArea(false);
      const iPlotCount = AreaBuilder.getPlotCount(iAreaID);
      console.log("Plots in Largest Landmass:" + iPlotCount);
      const iPlotsNeeded = iWidth * iHeight * iLargestContinentPercent / 100;
      console.log("Plots Needed:" + iPlotsNeeded);
      if (iPlotCount >= iPlotsNeeded) {
        console.log("Useable continent found");
        bLargeEnoughFound = true;
      }
    }
  }
}
function addPlotTags(iHeight, iWidth, iEastContinentLeftCol) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        addLandmassPlotTags(iX, iY, iEastContinentLeftCol);
      } else {
        addWaterPlotTags(iX, iY, iEastContinentLeftCol);
      }
    }
  }
}
function clearContinent(continent1) {
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = g_OceanTerrain;
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}

export { AVAILABLE_ON_ALL_LANDMASSES_ID, EAST_LAND_MASS_ID, WEST_LAND_MASS_ID, addLandmassPlotTags, addPlotTags, addWaterPlotTags, adjustLakePlotTags, adjustOceanPlotTags, applyCoastalErosion, applyCoastalErosionAdjustingForStartSectors, clearContinent, createIslands, createOrganicLandmasses, determineXShift, determineYShift, getContinentEdgeHeightBump, getDistanceFromContinentCenter, getDistanceToClosestStart, getHeightAdjustingForStartSector, getMaxDistanceFromContinentCenter, getMinimumResourcePlacementModifier, getSector, getSectorRegion, isAdjacentToLand, isAdjacentToNaturalWonder, isCliff, isOceanAccess, needHumanNearEquator, placeRuralDistrict, removeRuralDistrict, replaceIslandResources, shiftPlotTypesBy, shiftTerrain, shuffle };
//# sourceMappingURL=map-utilities.js.map
</file>

<file path="mod/maps/base-standard/maps/natural-wonder-generator.js">
import { shuffle } from './map-utilities.js';
import './map-globals.js';

function addNaturalWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive = false, requestedWonders = []) {
  if (GameInfo.Feature_NaturalWonders.length < iNumNaturalWonders) {
    iNumNaturalWonders = GameInfo.Feature_NaturalWonders.length;
  }
  console.log("Generating " + iNumNaturalWonders + " Natural Wonders");
  if (wonderEventActive) {
    console.log("Race to wonders event registered");
  }
  placeWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive, requestedWonders);
}
function placeWonders(iWidth, iHeight, iNumNaturalWonders, wonderEventActive, requestedWonders) {
  let aPossibleWonders = [];
  let iPlacedWonders = 0;
  const requests = [];
  const configRequests = Configuration.getMapValue("RequestedNaturalWonders");
  if (configRequests) {
    for (const requested of configRequests) {
      if (typeof requested == "string") {
        requests.push(Database.makeHash(requested));
      } else if (typeof requested == "number") {
        requests.push(requested);
      }
    }
  }
  for (const nwDef of GameInfo.Feature_NaturalWonders) {
    if (requestedWonders.includes(nwDef.FeatureType)) {
      requests.push(nwDef.$hash);
    }
    aPossibleWonders.push(nwDef.$hash);
  }
  if (aPossibleWonders.length > 0) {
    aPossibleWonders = shuffle(aPossibleWonders);
    for (const requested of requests) {
      const index = aPossibleWonders.indexOf(requested);
      if (index >= 1) {
        aPossibleWonders.splice(index, 1);
        aPossibleWonders.unshift(requested);
      }
    }
    for (let iI = 0; iI < aPossibleWonders.length; iI++) {
      if (iPlacedWonders < iNumNaturalWonders) {
        const eFeature = aPossibleWonders[iI];
        const nwDef = GameInfo.Feature_NaturalWonders.lookup(eFeature);
        if (nwDef != null) {
          if (nwDef.PlaceFirst == true) {
            const aPossibleLocations = [];
            for (let iY = iHeight - 1; iY >= 0; iY--) {
              for (let iX = 0; iX < iWidth; iX++) {
                const iElevation = GameplayMap.getElevation(iX, iY);
                const featureParam = {
                  Feature: eFeature,
                  Direction: nwDef.Direction,
                  Elevation: iElevation
                };
                if (TerrainBuilder.canHaveFeatureParam(iX, iY, featureParam)) {
                  if (wonderEventActive) {
                    if (GameplayMap.getHemisphere(iX) != GameplayMap.getPrimaryHemisphere()) {
                      aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                    }
                  } else {
                    aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                  }
                }
              }
            }
            if (aPossibleLocations.length > 0) {
              const randomIndex = TerrainBuilder.getRandomNumber(
                aPossibleLocations.length,
                "Natural Wonder placement location"
              );
              const placementLocation = GameplayMap.getLocationFromIndex(
                aPossibleLocations[randomIndex]
              );
              const iElevation = GameplayMap.getElevation(placementLocation.x, placementLocation.y);
              const featureParam = {
                Feature: eFeature,
                Direction: nwDef.Direction,
                Elevation: iElevation
              };
              console.log("FeatureParam Elevation: " + featureParam.Elevation);
              TerrainBuilder.setFeatureType(placementLocation.x, placementLocation.y, featureParam);
              iPlacedWonders++;
              console.log(
                "Placed A Top Priority Natural Wonder " + nwDef.FeatureType + " At X:" + placementLocation.x + " Y:" + placementLocation.y + " out of " + aPossibleLocations.length + " possible locations."
              );
            } else {
              console.log("No valid location for " + nwDef.FeatureType);
            }
          }
        }
      }
    }
    for (let iI = 0; iI < aPossibleWonders.length; iI++) {
      if (iPlacedWonders < iNumNaturalWonders) {
        const eFeature = aPossibleWonders[iI];
        const nwDef = GameInfo.Feature_NaturalWonders.lookup(eFeature);
        if (nwDef != null && nwDef.PlaceFirst == false) {
          let iPlacementPercent = nwDef.PlacementPercentage;
          if (requests.indexOf(eFeature) != -1) {
            iPlacementPercent = 100;
            console.log(nwDef.FeatureType + " is requested to be placed.");
          }
          const iRoll = TerrainBuilder.getRandomNumber(100, "Random Natural Wonder Chance");
          if (iPlacementPercent > iRoll) {
            const aPossibleLocations = [];
            for (let iY = iHeight - 1; iY >= 0; iY--) {
              for (let iX = 0; iX < iWidth; iX++) {
                const iElevation = GameplayMap.getElevation(iX, iY);
                const featureParam = {
                  Feature: eFeature,
                  Direction: nwDef.Direction,
                  Elevation: iElevation
                };
                if (TerrainBuilder.canHaveFeatureParam(iX, iY, featureParam)) {
                  if (wonderEventActive) {
                    if (GameplayMap.getHemisphere(iX) != GameplayMap.getPrimaryHemisphere()) {
                      aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                    }
                  } else {
                    aPossibleLocations.push(GameplayMap.getIndexFromXY(iX, iY));
                  }
                }
              }
            }
            if (aPossibleLocations.length > 0) {
              const randomIndex = TerrainBuilder.getRandomNumber(
                aPossibleLocations.length,
                "Natural Wonder placement location"
              );
              const placementLocation = GameplayMap.getLocationFromIndex(
                aPossibleLocations[randomIndex]
              );
              const iElevation = GameplayMap.getElevation(placementLocation.x, placementLocation.y);
              const featureParam = {
                Feature: eFeature,
                Direction: nwDef.Direction,
                Elevation: iElevation
              };
              console.log("FeatureParam Elevation: " + featureParam.Elevation);
              TerrainBuilder.setFeatureType(placementLocation.x, placementLocation.y, featureParam);
              iPlacedWonders++;
              console.log(
                "Placed A Natural Wonder " + nwDef.FeatureType + " At X:" + placementLocation.x + " Y:" + placementLocation.y + " out of " + aPossibleLocations.length + " possible locations."
              );
            } else {
              console.log("No valid location for " + nwDef.FeatureType);
            }
          }
        }
      }
    }
  }
}

export { addNaturalWonders };
//# sourceMappingURL=natural-wonder-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/pangaea-plus.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignSingleContinentStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight, g_CoastTerrain } from './map-globals.js';
import { needHumanNearEquator, createIslands, applyCoastalErosionAdjustingForStartSectors, createOrganicLandmasses, addPlotTags, applyCoastalErosion, adjustOceanPlotTags, adjustLakePlotTags, replaceIslandResources, getHeightAdjustingForStartSector, addLandmassPlotTags, addWaterPlotTags, clearContinent } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script pangaea-plus.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iNumPlayers1 = mapInfo.PlayersLandmass1;
  const iNumPlayers2 = mapInfo.PlayersLandmass2;
  const bWestDominant = TerrainBuilder.getRandomNumber(2, "Choose Dominant Hemisphere") === 0;
  console.log(`Dominant Landmass: ${bWestDominant ? "West (80%)" : "East (80%)"}`);
  let westContinent;
  let westContinent2;
  let eastContinent;
  let eastContinent2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  if (bWestDominant) {
    westContinent2 = {
      west: g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.1),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    westContinent = {
      west: westContinent2.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.8) - g_AvoidSeamOffset,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent = {
      west: westContinent.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.9),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent2 = {
      west: eastContinent.east,
      east: iWidth - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
  } else {
    westContinent2 = {
      west: g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.1),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    westContinent = {
      west: westContinent2.east,
      east: Math.floor(iWidth * 0.2) - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent = {
      west: westContinent.east + g_AvoidSeamOffset * 2,
      east: Math.floor(iWidth * 0.8),
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    eastContinent2 = {
      west: eastContinent.east + g_AvoidSeamOffset * 2,
      east: iWidth - g_AvoidSeamOffset * 2,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
  }
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const ISLAND_COVERAGE_TARGET = 0.04;
  const totalTiles = iWidth * iHeight;
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced && totalTiles != 0) {
    console.log("Balanced Map");
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createPrimaryLandmass(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      bWestDominant,
      iOceanWaterColumns
    );
    if (bWestDominant) {
      createSecondaryLandmass(iWidth, iHeight, eastContinent, eastContinent2);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 4);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 5);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      applyCoastalErosionAdjustingForStartSectors(
        westContinent,
        eastContinent,
        0.1,
        1.5,
        0.8,
        iStartSectorRows,
        iStartSectorCols,
        startSectors
      );
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    } else {
      createSecondaryLandmass(iWidth, iHeight, westContinent, westContinent2);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 4);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 5);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      applyCoastalErosionAdjustingForStartSectors(
        eastContinent,
        westContinent,
        0.1,
        1.5,
        0.8,
        iStartSectorRows,
        iStartSectorCols,
        startSectors
      );
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    }
  } else if (totalTiles != 0) {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 30;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    addPlotTags(iHeight, iWidth, eastContinent.west);
    if (bWestDominant) {
      createSecondaryLandmass(iWidth, iHeight, eastContinent, eastContinent2);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 4);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
      applyCoastalErosion(westContinent, 0.15, 1.5, 0.8, false);
      applyCoastalErosion(eastContinent, 0.01, 1.5, 0.8, true);
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, westContinent2, westContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    } else {
      createSecondaryLandmass(iWidth, iHeight, westContinent, westContinent2);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 4);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
      applyCoastalErosion(westContinent, 0.01, 1.5, 0.8, true);
      applyCoastalErosion(eastContinent, 0.15, 1.5, 0.8, false);
      let islandTiles = countIslandTiles(iWidth, iHeight);
      let islandRatio = islandTiles / totalTiles;
      let attempts = 0;
      while (islandRatio < ISLAND_COVERAGE_TARGET && attempts < 3) {
        console.log("Island coverage too low: " + (islandRatio * 100).toFixed(2) + "%. Adding more islands.");
        createIslands(iWidth, iHeight, eastContinent2, eastContinent2, 6);
        islandTiles = countIslandTiles(iWidth, iHeight);
        islandRatio = islandTiles / totalTiles;
        attempts++;
      }
    }
    applyCoastalErosion(westContinent2, 0.01, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.01, 1.5, 0.8, true);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  adjustOceanPlotTags(bWestDominant);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  adjustLakePlotTags(westContinent, true);
  adjustLakePlotTags(westContinent2, true);
  adjustLakePlotTags(eastContinent, false);
  adjustLakePlotTags(eastContinent2, false);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpStartSectors(startSectors);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  if (bWestDominant) {
    generateResources(iWidth, iHeight);
    startPositions = assignSingleContinentStartPositions(
      iNumPlayers1 + iNumPlayers2,
      westContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  } else {
    generateResources(iWidth, iHeight);
    startPositions = assignSingleContinentStartPositions(
      iNumPlayers1 + iNumPlayers2,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  }
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded pangaea-plus.ts");
function createPrimaryLandmass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        addLandmassPlotTags(iX, iY, continent2.west);
      } else {
        addWaterPlotTags(iX, iY, continent2.west);
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createSecondaryLandmass(iWidth, iHeight, continent1, continent2) {
  console.log("Generating secondary landmass as small islands...");
  clearContinent(continent1);
  clearContinent(continent2);
  createIslands(iWidth, iHeight, continent1, continent2, 4);
  createIslands(iWidth, iHeight, continent1, continent2, 6);
  createIslands(iWidth, iHeight, continent1, continent2, 6);
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}
function countIslandTiles(iWidth, iHeight) {
  let islandCount = 0;
  for (let y = 0; y < iHeight; y++) {
    for (let x = 0; x < iWidth; x++) {
      if (GameplayMap.hasPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND)) {
        islandCount++;
      }
    }
  }
  return islandCount;
}

export { expandCoastsPlus };
//# sourceMappingURL=pangaea-plus.js.map
</file>

<file path="mod/maps/base-standard/maps/pangaea-voronoi.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { PlayerRegion, assignStartPositionsFromTiles, assignSingleContinentStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources } from './map-debug-helpers.js';
import { g_PolarWaterRows, g_FlatTerrain, g_MountainTerrain, g_HillTerrain, g_VolcanoFeature, g_OceanTerrain, g_CoastTerrain, g_NavigableRiverTerrain, g_AvoidSeamOffset } from './map-globals.js';
import { replaceIslandResources } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { kdTree } from '../scripts/kd-tree.js';
import { TerrainType } from '../scripts/voronoi-utils.js';
import { VoronoiPangaea } from '../scripts/voronoi_maps/pangaea.js';
import { RuleAvoidEdge } from '../scripts/voronoi_rules/avoid-edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../scripts/random-pcg-32.js';
import '../scripts/voronoi_generators/map-generator.js';
import '../scripts/voronoi_maps/map-common.js';
import '../scripts/voronoi-builder.js';
import '../scripts/voronoi-hex.js';
import '../../core/scripts/MathHelpers.js';
import '../scripts/heap.js';
import '../scripts/voronoi_generators/continent-generator.js';
import '../scripts/quadtree.js';
import '../scripts/voronoi-region.js';
import '../scripts/voronoi_rules/avoid-other-regions.js';
import '../scripts/voronoi_rules/rules-base.js';
import '../scripts/voronoi_rules/cell-area.js';
import '../scripts/voronoi_rules/near-map-center.js';
import '../scripts/voronoi_rules/near-neighbor.js';
import '../scripts/voronoi_rules/near-plate-boundary.js';
import '../scripts/voronoi_rules/near-region-seed.js';
import '../scripts/voronoi_rules/neighbors-in-region.js';
import '../scripts/voronoi_rules/prefer-latitude.js';

console.log("Generating using script pangaea-voronoi.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  const iTotalPlayers = Players.getAliveMajorIds().length;
  const startTime = Date.now();
  const voronoiMap = new VoronoiPangaea();
  voronoiMap.init(mapInfo.$index);
  const rules = voronoiMap.getBuilder().getGenerator().getRules();
  for (const value of Object.values(rules)) {
    for (const rule of value) {
      if (rule.name == RuleAvoidEdge.getName()) {
        rule.configValues.poleDistance = g_PolarWaterRows;
      }
    }
  }
  const generatorSettings = voronoiMap.getBuilder().getGenerator().getSettings();
  generatorSettings.landmass[0].playerAreas = iTotalPlayers;
  voronoiMap.getBuilder().simulate();
  const tiles = voronoiMap.getBuilder().getTiles();
  const landmassKdTree = new kdTree((tile) => tile.pos);
  landmassKdTree.build(tiles.flatMap((row) => row.filter((tile) => tile.landmassId > 0)));
  for (let y = 0; y < tiles.length; ++y) {
    for (let x = 0; x < tiles[y].length; ++x) {
      const tile = tiles[y][x];
      if (tile.isLand()) {
        const type = tile.terrainType === TerrainType.Flat ? g_FlatTerrain : tile.terrainType === TerrainType.Mountainous || tile.terrainType === TerrainType.Volcano ? g_MountainTerrain : tile.terrainType === TerrainType.Rough ? g_HillTerrain : g_FlatTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        if (tile.terrainType === TerrainType.Volcano) {
          TerrainBuilder.setFeatureType(x, y, {
            Feature: g_VolcanoFeature,
            Direction: -1,
            Elevation: 0
          });
        }
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_LANDMASS);
        if (tile.landmassId === 1) {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_LANDMASS);
        } else {
          TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND);
        }
      } else {
        const type = tile.terrainType === TerrainType.Ocean ? g_OceanTerrain : g_CoastTerrain;
        TerrainBuilder.setTerrainType(x, y, type);
        TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WATER);
        if (tile.terrainType === TerrainType.Coast) {
          const landmassTile = landmassKdTree.search(tile.pos);
          if (landmassTile.landmassId == 1) {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(x, y, PlotTags.PLOT_TAG_ISLAND_WATER);
          }
        }
      }
    }
  }
  const endTime = Date.now();
  console.log(`Initial Voronoi map generation took ${endTime - startTime} ms`);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  const lakeTiles = generateLakes(iWidth, iHeight, iTilesPerLake);
  console.log(`Updating plot tags for ${lakeTiles.length} lakes.`);
  for (const coord of lakeTiles) {
    const tile = tiles[coord.y][coord.x];
    TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WATER);
    if (tile.landmassId === 1) {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_WEST_WATER);
    } else {
      TerrainBuilder.addPlotTag(coord.x, coord.y, PlotTags.PLOT_TAG_ISLAND_WATER);
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  let startPositions = [];
  const USE_VORONOI_START_POSITIONS = true;
  if (USE_VORONOI_START_POSITIONS) {
    voronoiMap.getBuilder().createMajorPlayerAreas(
      (tile) => StartPositioner.getPlotFertilityForCoord(tile.coord.x, tile.coord.y)
    );
    const playerRegions = Array.from({ length: iTotalPlayers }, () => new PlayerRegion());
    playerRegions.forEach((region, index) => {
      region.regionId = index;
      region.landmassId = 0;
    });
    for (const row of tiles) {
      for (const tile of row) {
        if (tile.landmassId == 1 && tile.majorPlayerRegionId >= 0) {
          playerRegions[tile.majorPlayerRegionId].tiles.push({ x: tile.coord.x, y: tile.coord.y });
        }
      }
    }
    startPositions = assignStartPositionsFromTiles(playerRegions);
  } else {
    const continent = {
      west: g_AvoidSeamOffset,
      east: iWidth - g_AvoidSeamOffset,
      south: g_PolarWaterRows,
      north: iHeight - g_PolarWaterRows,
      continent: 0
    };
    startPositions = assignSingleContinentStartPositions(
      iTotalPlayers,
      continent,
      0,
      0,
      [],
      PlotTags.PLOT_TAG_WEST_LANDMASS
    );
  }
  replaceIslandResources(iWidth, iHeight, "RESOURCECLASS_TREASURE");
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded pangaea-voronoi.ts");
//# sourceMappingURL=pangaea-voronoi.js.map
</file>

<file path="mod/maps/base-standard/maps/resource-generator.js">
import { getMinimumResourcePlacementModifier, AVAILABLE_ON_ALL_LANDMASSES_ID, EAST_LAND_MASS_ID, WEST_LAND_MASS_ID, replaceIslandResources, shuffle } from './map-utilities.js';
import './map-globals.js';

function generateResources(iWidth, iHeight) {
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountHome = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountDistant = new Array(GameInfo.Resources.length);
  const resourcesPlacedCount = new Array(GameInfo.Resources.length);
  let minimumResourcePlacementModifer = getMinimumResourcePlacementModifier();
  if (minimumResourcePlacementModifer == void 0) {
    minimumResourcePlacementModifer = 0;
  }
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resourceWeight[resourceIdx] = 0;
    resourceRunningWeight[resourceIdx] = 0;
    resourcesPlacedCount[resourceIdx] = 0;
  }
  const aResourceTypes = [];
  const resources = ResourceBuilder.getGeneratedMapResources();
  for (let ridx = 0; ridx < resources.length; ++ridx) {
    const resourceInfo = GameInfo.Resources.lookup(resources[ridx]);
    if (resourceInfo && resourceInfo.Tradeable) {
      resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
      aResourceTypes.push(resourceInfo.$index);
      importantResourceRegionalCountHome[resourceInfo.$index] = 0;
      importantResourceRegionalCountDistant[resourceInfo.$index] = 0;
    }
  }
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    for (let iX = 0; iX < iWidth; iX++) {
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const resources2 = [];
        aResourceTypes.forEach((resourceIdx) => {
          const assignedLandmass = ResourceBuilder.getResourceLandmass(resourceIdx);
          if (assignedLandmass == AVAILABLE_ON_ALL_LANDMASSES_ID) {
            if (canHaveFlowerPlot(iX, iY, resourceIdx)) {
              resources2.push(resourceIdx);
            }
          } else if (assignedLandmass == EAST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS) {
            if (canHaveFlowerPlot(iX, iY, resourceIdx)) {
              resources2.push(resourceIdx);
            }
          } else if (assignedLandmass == WEST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
            if (canHaveFlowerPlot(iX, iY, resourceIdx)) {
              resources2.push(resourceIdx);
            }
          }
        });
        if (resources2.length > 0) {
          let resourceChosen = ResourceTypes.NO_RESOURCE;
          let resourceChosenIndex = 0;
          for (let iI = 0; iI < resources2.length; iI++) {
            if (resourceChosen == ResourceTypes.NO_RESOURCE) {
              resourceChosen = resources2[iI];
              resourceChosenIndex = resources2[iI];
            } else {
              if (resourceRunningWeight[resources2[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                resourceChosen = resources2[iI];
                resourceChosenIndex = resources2[iI];
              } else if (resourceRunningWeight[resources2[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                if (iRoll >= 1) {
                  resourceChosen = resources2[iI];
                  resourceChosenIndex = resources2[iI];
                }
              }
            }
          }
          if (resourceChosen != ResourceTypes.NO_RESOURCE) {
            const iResourcePlotIndex = getFlowerPlot(iX, iY, resourceChosen);
            if (iResourcePlotIndex != -1) {
              const iLocation = GameplayMap.getLocationFromIndex(iResourcePlotIndex);
              const iResourceX = iLocation.x;
              const iResourceY = iLocation.y;
              ResourceBuilder.setResourceType(iResourceX, iResourceY, resourceChosen);
              resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
              resourcesPlacedCount[resourceChosenIndex]++;
              plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS ? importantResourceRegionalCountHome[resourceChosenIndex]++ : importantResourceRegionalCountDistant[resourceChosenIndex]++;
            } else {
              console.log("Resource Index Failure");
            }
          } else {
            console.log("Resource Type Failure");
          }
        }
      }
    }
  }
  let checkHomeHemisphereLP = true;
  let checkDistantHemisphereLP = true;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      const resourceAtLocation = GameplayMap.getResourceType(iX, iY);
      if (resourceAtLocation == ResourceTypes.NO_RESOURCE) {
        const resourcesEligible = [];
        for (let i = 0; i < resourcesPlacedCount.length; ++i) {
          const resourceToPlace = GameInfo.Resources.lookup(i);
          if (resourceToPlace) {
            const assignedLandmass = ResourceBuilder.getResourceLandmass(i);
            if (assignedLandmass == AVAILABLE_ON_ALL_LANDMASSES_ID || assignedLandmass == EAST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS || assignedLandmass == WEST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
              const minimumPerLandMass = resourceToPlace.MinimumPerHemisphere > 0 ? resourceToPlace.MinimumPerHemisphere + minimumResourcePlacementModifer : 0;
              if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS && importantResourceRegionalCountHome[i] < minimumPerLandMass || plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS && importantResourceRegionalCountDistant[i] < minimumPerLandMass) {
                if (checkHomeHemisphereLP && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS) {
                  checkHomeHemisphereLP = ResourceBuilder.isResourceClassRequiredForLegacyPath(
                    i,
                    plotTag
                  );
                } else if (checkDistantHemisphereLP && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
                  checkDistantHemisphereLP = ResourceBuilder.isResourceClassRequiredForLegacyPath(
                    i,
                    plotTag
                  );
                }
                if (ResourceBuilder.isResourceRequiredForAge(i)) {
                  if (ResourceBuilder.canHaveResource(iX, iY, i, false)) {
                    let hasAdjResource = false;
                    for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
                      const iIndex = GameplayMap.getIndexFromXY(iX, iY);
                      const iLocation = GameplayMap.getLocationFromIndex(iIndex);
                      const iAdjacentX = GameplayMap.getAdjacentPlotLocation(
                        iLocation,
                        iDirection
                      ).x;
                      const iAdjacentY = GameplayMap.getAdjacentPlotLocation(
                        iLocation,
                        iDirection
                      ).y;
                      if (GameplayMap.getResourceType(iAdjacentX, iAdjacentY) != ResourceTypes.NO_RESOURCE) {
                        hasAdjResource = true;
                        break;
                      }
                    }
                    if (!hasAdjResource) {
                      resourcesEligible.push(i);
                    }
                  }
                }
              }
            }
          }
        }
        let resourceChosenIndex = -1;
        if (resourcesEligible.length > 0) {
          let resourceChosen = ResourceTypes.NO_RESOURCE;
          for (let iI = 0; iI < resourcesEligible.length; iI++) {
            if (resourceChosen == ResourceTypes.NO_RESOURCE) {
              resourceChosen = resourcesEligible[iI];
              resourceChosenIndex = resourcesEligible[iI];
            } else {
              if (resourceRunningWeight[resourcesEligible[iI]] > resourceRunningWeight[resourceChosenIndex]) {
                resourceChosen = resourcesEligible[iI];
                resourceChosenIndex = resourcesEligible[iI];
              } else if (resourceRunningWeight[resourcesEligible[iI]] == resourceRunningWeight[resourceChosenIndex]) {
                const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
                if (iRoll >= 1) {
                  resourceChosen = resourcesEligible[iI];
                  resourceChosenIndex = resourcesEligible[iI];
                }
              }
            }
          }
        }
        if (resourceChosenIndex > -1) {
          ResourceBuilder.setResourceType(iX, iY, resourceChosenIndex);
          resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
          const name = GameInfo.Resources.lookup(resourceChosenIndex)?.Name;
          console.log("Force Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")");
          plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS ? importantResourceRegionalCountHome[resourceChosenIndex]++ : importantResourceRegionalCountDistant[resourceChosenIndex]++;
          break;
        }
      }
    }
  }
  const definition = GameInfo.Ages.lookup(Game.age);
  if (definition) {
    const mapType = Configuration.getMapValue("Name");
    for (const option of GameInfo.MapIslandBehavior) {
      if (option.MapType === mapType) {
        replaceIslandResources(iWidth, iHeight, option.ResourceClassType);
      }
    }
  }
}
function canHaveFlowerPlot(iX, iY, resourceType) {
  if (ResourceBuilder.canHaveResource(iX, iY, resourceType, false)) {
    return true;
  }
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    if (ResourceBuilder.canHaveResource(iAdjacentX, iAdjacentY, resourceType, false)) {
      return true;
    }
  }
  return false;
}
function getFlowerPlot(iX, iY, resourceType) {
  if (ResourceBuilder.canHaveResource(iX, iY, resourceType, false)) {
    return GameplayMap.getIndexFromXY(iX, iY);
  }
  const resourcePlotIndexes = [];
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const iAdjacentX = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).x;
    const iAdjacentY = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection).y;
    const iAdjacentIndex = GameplayMap.getIndexFromXY(iAdjacentX, iAdjacentY);
    if (ResourceBuilder.canHaveResource(iAdjacentX, iAdjacentY, resourceType, false)) {
      resourcePlotIndexes.push(iAdjacentIndex);
    }
  }
  if (resourcePlotIndexes.length > 0) {
    return shuffle(resourcePlotIndexes)[0];
  } else {
    return -1;
  }
}

export { canHaveFlowerPlot, generateResources, getFlowerPlot };
//# sourceMappingURL=resource-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/shuffle.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_NavigableRiverTerrain, g_CoastTerrain, g_OceanTerrain, g_LandmassFractal, g_FlatTerrain, g_WaterPercent, g_StartSectorWeight, g_FractalWeight, g_CenterWeight, g_Cutoff } from './map-globals.js';
import { needHumanNearEquator, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, addPlotTags, createIslands, adjustOceanPlotTags, isAdjacentToLand, getSector, getHeightAdjustingForStartSector } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes } from './volcano-generator.js';

console.log("Generating using script shuffle.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
  if (iRandom == 1) {
    const iNum1 = iNumPlayers1;
    const iNum2 = iNumPlayers2;
    iNumPlayers1 = iNum2;
    iNumPlayers2 = iNum1;
  }
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iOceanWaterColumns
    );
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
  } else {
    console.log("Standard Map");
    createLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iOceanWaterColumns
    );
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
  }
  addPlotTags(iHeight, iWidth, eastContinent.west);
  TerrainBuilder.validateAndFixTerrain();
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
  createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  const iRandomRiver = TerrainBuilder.getRandomNumber(10, "Intensity of Rivers");
  if (iRandomRiver == 0) {
    TerrainBuilder.modelRivers(10, 85, g_NavigableRiverTerrain);
  } else if (iRandomRiver < 3) {
    TerrainBuilder.modelRivers(5, 70, g_NavigableRiverTerrain);
  } else {
    TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  }
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_CoastTerrain) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iNumPlayers1 > iNumPlayers2) {
          if (iX < westContinent.west - 2 || iX > westContinent.east + 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          }
        } else {
          if (iX > eastContinent.east + 2 || iX < eastContinent.west - 2) {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
          } else {
            TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
          }
        }
      }
    }
  }
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded shuffle.ts");
function createLandmasses(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iOceanWaterColumns) {
  const iRandomLandmassSetup = TerrainBuilder.getRandomNumber(4, "Shuffle Map Landmass Structure");
  if (iRandomLandmassSetup == 0) {
    createArchipelago(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Archipelago");
  } else if (iRandomLandmassSetup == 1) {
    createContinents(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Continents");
  } else if (iRandomLandmassSetup == 2) {
    createFractal(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors);
    console.log("Random Landmass Setup: Fractal");
  } else if (iRandomLandmassSetup == 3) {
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      }
    }
    createTerraMass(
      iWidth,
      iHeight,
      continent1,
      continent2,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      true,
      iOceanWaterColumns
    );
    createTerraMass(
      iWidth,
      iHeight,
      continent1,
      continent2,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      false,
      iOceanWaterColumns
    );
    console.log("Random Landmass Setup: Terra");
  }
}
function createArchipelago(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setTerrainType(iX, iY, g_OceanTerrain);
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
    }
  }
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    3
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    4
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    5
  );
  generateFractalLayerWithoutHills(
    iWidth,
    iHeight,
    continent1,
    continent2,
    iStartSectorRows,
    iStartSectorCols,
    startSectors,
    6
  );
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.removePlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function generateFractalLayerWithoutHills(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, iSize) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iwater_percent = 50 + iSize * 7;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iwater_percent);
  const iCenterWeight = 0;
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.getTerrainType(iX, iY) == g_OceanTerrain || GameplayMap.getTerrainType(iX, iY) == g_CoastTerrain) {
        let terrain = g_FlatTerrain;
        const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
        const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
        if (isAdjacentToLand(iX, iY)) {
          continue;
        } else if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
          continue;
        } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
          terrain = g_OceanTerrain;
        } else {
          const iSector = getSector(
            iX,
            iY,
            iStartSectorRows,
            iStartSectorCols,
            continent1.south,
            continent1.north,
            continent1.west,
            continent1.east,
            continent2.west
          );
          let iStartSectorWeight = 0;
          let iFractalWeight = 1;
          if (startSectors[iSector]) {
            iStartSectorWeight = 0.7;
            iFractalWeight = 0.35;
          }
          const iPlotHeight = getHeightAdjustingForStartSector(
            iX,
            iY,
            iWaterHeight,
            iFractalWeight,
            iCenterWeight,
            iStartSectorWeight,
            continent1,
            continent2,
            iStartSectorRows,
            iStartSectorCols,
            startSectors
          );
          if (iPlotHeight < iWaterHeight) {
            continue;
          }
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_ISLAND);
      }
    }
  }
}
function createContinents(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}
function createFractal(iWidth, iHeight, westContinent, eastContinent, iStartSectorRows, iStartSectorCols, startSectors) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 3, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 13.5);
  const iBuffer2 = Math.floor(iWidth / 21);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < westContinent.south + iRandom || iY >= westContinent.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX == 0) {
        terrain = g_OceanTerrain;
      } else if (iX < westContinent.west + iRandom2 || iX >= eastContinent.east - iRandom2) {
        terrain = g_OceanTerrain;
      } else if (iX >= westContinent.east - iRandom2 && iX < eastContinent.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          iFractalWeight,
          0,
          iStartSectorWeight,
          westContinent,
          eastContinent,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * (g_FractalWeight + g_StartSectorWeight)) {
          terrain = g_OceanTerrain;
        }
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createTerraMass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bFirst, iOceanWaterColumns) {
  const iSize = TerrainBuilder.getRandomNumber(6, "Random Land Size") + 2;
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iRanHeight = 100 - (iSize * 10 - 20);
  const iMaxHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, iRanHeight);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (bFirst == true) {
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      }
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        if (bFirst == true) {
          terrain = g_OceanTerrain;
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        if (bFirst == true) {
          terrain = g_OceanTerrain;
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      } else if (bFirst == true && iX > continent1.east + iOceanWaterColumns || bFirst == false && iX < continent2.west - iOceanWaterColumns) {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iMaxHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iMaxHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (bFirst == false && iX > continent1.east + iOceanWaterColumns || bFirst == true && iX < continent2.west - iOceanWaterColumns) {
        let iStartSectorWeight = 0;
        let iFractalWeight = 1;
        if (iStartSectorRows > 0 && iStartSectorCols > 0) {
          iStartSectorWeight = g_StartSectorWeight;
          iFractalWeight = g_FractalWeight;
        }
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iMaxHeight,
          iFractalWeight,
          g_CenterWeight,
          iStartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iMaxHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=shuffle.js.map
</file>

<file path="mod/maps/base-standard/maps/snow-generator.js">
import { g_PolarWaterRows } from './map-globals.js';

function generateSnow(mapWidth, mapHeight) {
  console.log("Generating permanent snow");
  const mapHalfHeight = GameplayMap.getGridHeight() / 2;
  const snowLatitudeEnd = 60;
  const snowRowEnd = Math.ceil(mapHalfHeight * ((90 - snowLatitudeEnd) / 90));
  const snowRowStarts = [g_PolarWaterRows, g_PolarWaterRows];
  const snowRowLimits = [
    snowRowEnd > snowRowStarts[0] ? snowRowEnd - snowRowStarts[0] : 0,
    snowRowEnd > snowRowStarts[1] ? snowRowEnd - snowRowStarts[1] : 0
  ];
  const snowRowDeltas = [-1, 1];
  console.log(
    "Snow latitude:" + snowLatitudeEnd.toString() + ", rows:" + snowRowStarts[0].toString() + " to " + (snowRowStarts[0] + snowRowLimits[0]).toString()
  );
  const aLightSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "LIGHT", "PERMANENT"]);
  const aMediumSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "MEDIUM", "PERMANENT"]);
  const aHeavySnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "HEAVY", "PERMANENT"]);
  const weightRange = 3;
  const changeTotalAdjustment = 60;
  const aWeightEffect = [-1, -1, -1];
  aWeightEffect[0] = aLightSnowEffects ? aLightSnowEffects[0] : -1;
  aWeightEffect[1] = aMediumSnowEffects ? aMediumSnowEffects[0] : -1;
  aWeightEffect[2] = aHeavySnowEffects ? aHeavySnowEffects[0] : -1;
  const colEnd = mapWidth;
  const rowStart = [mapHeight - 1 - snowRowStarts[0], snowRowStarts[1]];
  for (let pole = 0; pole != 2; ++pole) {
    const rowCount = snowRowLimits[pole];
    if (rowCount > 0) {
      const nextRowDelta = snowRowDeltas[pole];
      const rowEnd = rowStart[pole] + rowCount * nextRowDelta;
      const chanceAdjustment = Math.ceil(changeTotalAdjustment / rowCount);
      const aWeightChance = [10, 30, 60];
      let chanceForAny = 90;
      for (let row = rowStart[pole]; row != rowEnd; row += nextRowDelta) {
        for (let col = 0; col < colEnd; ++col) {
          if (GameplayMap.isWater(col, row) == false) {
            let rndVal = TerrainBuilder.getRandomNumber(100, "Any Snow");
            if (rndVal <= chanceForAny) {
              rndVal = TerrainBuilder.getRandomNumber(100, "Snow Weight");
              for (let weight = weightRange - 1; weight >= 0; --weight) {
                if (rndVal < aWeightChance[weight]) {
                  MapPlotEffects.addPlotEffect(
                    GameplayMap.getIndexFromXY(col, row),
                    aWeightEffect[weight]
                  );
                  break;
                } else {
                  rndVal -= aWeightChance[weight];
                }
              }
            }
          }
        }
        chanceForAny -= chanceAdjustment;
        const adjustBy = chanceAdjustment;
        aWeightChance[2] -= adjustBy;
        for (let weight = weightRange - 2; weight >= 0; --weight) {
          aWeightChance[weight] += adjustBy;
        }
      }
    }
  }
}
function dumpPermanentSnow(iWidth, iHeight) {
  console.log("Permanent Snow");
  console.log("@ = heavy");
  console.log("# = medium");
  console.log("* = light");
  console.log(". = no-snow");
  const aLightSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "LIGHT", "PERMANENT"]);
  const aMediumSnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "MEDIUM", "PERMANENT"]);
  const aHeavySnowEffects = MapPlotEffects.getPlotEffectTypesContainingTags(["SNOW", "HEAVY", "PERMANENT"]);
  const eLightPlotEffect = aLightSnowEffects ? aLightSnowEffects[0] : -1;
  const eMediumPlotEffect = aMediumSnowEffects ? aMediumSnowEffects[0] : -1;
  const eHeavyPlotEffect = aHeavySnowEffects ? aHeavySnowEffects[0] : -1;
  for (let iY = iHeight - 1; iY >= 0; iY--) {
    let str = "";
    if (iY % 2 == 1) {
      str += " ";
    }
    for (let iX = 0; iX < iWidth; iX++) {
      let effectString = " ";
      if (GameplayMap.isWater(iX, iY) == false) {
        const iIndex = GameplayMap.getIndexFromXY(iX, iY);
        if (MapPlotEffects.hasPlotEffect(iIndex, eLightPlotEffect)) {
          effectString = "*";
        } else if (MapPlotEffects.hasPlotEffect(iIndex, eMediumPlotEffect)) {
          effectString = "#";
        } else if (MapPlotEffects.hasPlotEffect(iIndex, eHeavyPlotEffect)) {
          effectString = "@";
        } else {
          effectString = ".";
        }
      }
      str += effectString + " ";
    }
    console.log(str);
  }
}

export { dumpPermanentSnow, generateSnow };
//# sourceMappingURL=snow-generator.js.map
</file>

<file path="mod/maps/base-standard/maps/terra-incognita.js">
import { assignAdvancedStartRegions } from './assign-advanced-start-region.js';
import { chooseStartSectors, assignStartPositions } from './assign-starting-plots.js';
import { generateDiscoveries } from './discovery-generator.js';
import { addMountains, generateLakes, addHills, buildRainfallMap } from './elevation-terrain-generator.js';
import { designateBiomes, addFeatures } from './feature-biome-generator.js';
import { dumpStartSectors, dumpContinents, dumpTerrain, dumpElevation, dumpRainfall, dumpBiomes, dumpFeatures, dumpResources, dumpNoisePredicate } from './map-debug-helpers.js';
import { g_OceanWaterColumns, g_PolarWaterRows, g_AvoidSeamOffset, g_IslandWidth, g_WaterPercent, g_Cutoff, g_NavigableRiverTerrain, g_LandmassFractal, g_FlatTerrain, g_OceanTerrain, g_FractalWeight, g_CenterWeight, g_StartSectorWeight, g_CoastTerrain } from './map-globals.js';
import { needHumanNearEquator, createIslands, applyCoastalErosionAdjustingForStartSectors, applyCoastalErosion, createOrganicLandmasses, clearContinent, addPlotTags, adjustOceanPlotTags, adjustLakePlotTags, getHeightAdjustingForStartSector, addLandmassPlotTags, addWaterPlotTags } from './map-utilities.js';
import { addNaturalWonders } from './natural-wonder-generator.js';
import { generateResources } from './resource-generator.js';
import { generateSnow, dumpPermanentSnow } from './snow-generator.js';
import { addVolcanoes, addTundraVolcanoes } from './volcano-generator.js';

console.log("Generating using script terra-incognita.ts");
function requestMapData(initParams) {
  console.log(initParams.width);
  console.log(initParams.height);
  console.log(initParams.topLatitude);
  console.log(initParams.bottomLatitude);
  console.log(initParams.wrapX);
  console.log(initParams.wrapY);
  console.log(initParams.mapSize);
  engine.call("SetMapInitData", initParams);
}
function generateMap() {
  console.log("Generating a map!");
  console.log(`Age - ${GameInfo.Ages.lookup(Game.age).AgeType}`);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  const uiMapSize = GameplayMap.getMapSize();
  let startPositions = [];
  const mapInfo = GameInfo.Maps.lookup(uiMapSize);
  if (mapInfo == null) return;
  const iNumNaturalWonders = mapInfo.NumNaturalWonders;
  const iTilesPerLake = mapInfo.LakeGenerationFrequency;
  let iNumPlayers1 = mapInfo.PlayersLandmass1;
  let iNumPlayers2 = mapInfo.PlayersLandmass2;
  const iOceanWaterColumns = (g_OceanWaterColumns + mapInfo.OceanWidth) * 1.75;
  const westContinent = {
    west: 3 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth / 2 - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent = {
    west: westContinent.east + 4 * g_AvoidSeamOffset + g_IslandWidth,
    east: iWidth - g_AvoidSeamOffset,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const westContinent2 = {
    west: g_AvoidSeamOffset,
    east: g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  const eastContinent2 = {
    west: iWidth / 2 + g_AvoidSeamOffset,
    east: iWidth / 2 + g_AvoidSeamOffset + g_IslandWidth,
    south: g_PolarWaterRows,
    north: iHeight - g_PolarWaterRows,
    continent: 0
  };
  let startSectors = [];
  let iStartSectorRows = 0;
  let iStartSectorCols = 0;
  let startPosition = Configuration.getMapValue("StartPosition");
  if (startPosition == null) {
    startPosition = Database.makeHash("START_POSITION_STANDARD");
  }
  startPosition = Number(BigInt.asIntN(32, BigInt(startPosition)));
  const startPositionHash = Database.makeHash("START_POSITION_BALANCED");
  const bIsBalanced = startPosition == startPositionHash;
  if (bIsBalanced) {
    console.log("Balanced Map");
    const iRandom = TerrainBuilder.getRandomNumber(2, "East or West");
    console.log("Random Hemisphere: " + iRandom);
    if (iRandom == 1) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
    }
    const bHumanNearEquator = needHumanNearEquator();
    iStartSectorRows = mapInfo.StartSectorRows;
    iStartSectorCols = mapInfo.StartSectorCols;
    startSectors = chooseStartSectors(
      iNumPlayers1,
      iNumPlayers2,
      iStartSectorRows,
      iStartSectorCols,
      bHumanNearEquator
    );
    dumpStartSectors(startSectors);
    createPrimaryLandmass(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iNumPlayers1 > iNumPlayers2,
      iOceanWaterColumns
    );
    createSecondaryLandmassBalanced(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iStartSectorRows,
      iStartSectorCols,
      startSectors,
      iNumPlayers1 > iNumPlayers2,
      iOceanWaterColumns
    );
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 4);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    applyCoastalErosionAdjustingForStartSectors(
      westContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosionAdjustingForStartSectors(
      eastContinent,
      eastContinent,
      0.02,
      1.5,
      0.8,
      iStartSectorRows,
      iStartSectorCols,
      startSectors
    );
    applyCoastalErosion(westContinent2, 0.02, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.02, 1.5, 0.8, true);
  } else {
    console.log("Standard Map");
    const iFractalGrain = 2;
    const iWaterPercent = g_WaterPercent * g_Cutoff;
    const iLargestContinentPercent = 15;
    createOrganicLandmasses(
      iWidth,
      iHeight,
      westContinent,
      eastContinent,
      iFractalGrain,
      iWaterPercent,
      iLargestContinentPercent
    );
    const iAreaID = AreaBuilder.findBiggestArea(false);
    const kBoundaries = AreaBuilder.getAreaBoundary(iAreaID);
    if (kBoundaries.west > iWidth / 2) {
      const iNum1 = iNumPlayers1;
      const iNum2 = iNumPlayers2;
      iNumPlayers1 = iNum2;
      iNumPlayers2 = iNum1;
      clearContinent(westContinent);
      createSecondaryLandmassStandard(westContinent);
    } else {
      clearContinent(eastContinent);
      createSecondaryLandmassStandard(eastContinent);
    }
    addPlotTags(iHeight, iWidth, eastContinent.west);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 5);
    createIslands(iWidth, iHeight, westContinent2, eastContinent2, 6);
    applyCoastalErosion(westContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(eastContinent, 0.02, 1.5, 0.8, false);
    applyCoastalErosion(westContinent2, 0.1, 1.5, 0.8, true);
    applyCoastalErosion(eastContinent2, 0.1, 1.5, 0.8, true);
  }
  TerrainBuilder.validateAndFixTerrain();
  expandCoastsPlus(westContinent.west, westContinent.east, iHeight);
  expandCoastsPlus(eastContinent.west, eastContinent.east, iHeight);
  expandCoastsPlus(0, westContinent.west - g_OceanWaterColumns, iHeight);
  expandCoastsPlus(
    westContinent.east + g_OceanWaterColumns,
    eastContinent.west - g_OceanWaterColumns,
    iHeight
  );
  expandCoastsPlus(eastContinent.east + g_OceanWaterColumns, 0, iHeight);
  adjustOceanPlotTags(iNumPlayers1 > iNumPlayers2);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.stampContinents();
  addMountains(iWidth, iHeight);
  addVolcanoes(iWidth, iHeight);
  generateLakes(iWidth, iHeight, iTilesPerLake);
  adjustLakePlotTags(westContinent, true);
  adjustLakePlotTags(westContinent2, true);
  adjustLakePlotTags(eastContinent, false);
  adjustLakePlotTags(eastContinent2, false);
  AreaBuilder.recalculateAreas();
  TerrainBuilder.buildElevation();
  addHills(iWidth, iHeight);
  buildRainfallMap(iWidth, iHeight);
  TerrainBuilder.modelRivers(5, 15, g_NavigableRiverTerrain);
  TerrainBuilder.validateAndFixTerrain();
  TerrainBuilder.defineNamedRivers();
  designateBiomes(iWidth, iHeight);
  addTundraVolcanoes(iWidth, iHeight);
  addNaturalWonders(iWidth, iHeight, iNumNaturalWonders);
  TerrainBuilder.addFloodplains(4, 10);
  addFeatures(iWidth, iHeight);
  TerrainBuilder.validateAndFixTerrain();
  AreaBuilder.recalculateAreas();
  TerrainBuilder.storeWaterData();
  generateSnow(iWidth, iHeight);
  dumpStartSectors(startSectors);
  dumpContinents(iWidth, iHeight);
  dumpTerrain(iWidth, iHeight);
  dumpElevation(iWidth, iHeight);
  dumpRainfall(iWidth, iHeight);
  dumpBiomes(iWidth, iHeight);
  dumpFeatures(iWidth, iHeight);
  dumpPermanentSnow(iWidth, iHeight);
  generateResources(iWidth, iHeight);
  startPositions = assignStartPositions(
    iNumPlayers1,
    iNumPlayers2,
    westContinent,
    eastContinent,
    iStartSectorRows,
    iStartSectorCols,
    startSectors
  );
  generateDiscoveries(iWidth, iHeight, startPositions);
  dumpResources(iWidth, iHeight);
  FertilityBuilder.recalculate();
  const seed = GameplayMap.getRandomSeed();
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const poissonPred = (val) => {
    return val >= 1 ? "*" : " ";
  };
  dumpNoisePredicate(iWidth, iHeight, poisson, poissonPred);
  assignAdvancedStartRegions();
}
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Loaded terra-incognita.ts");
function createPrimaryLandmass(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, 2, 0);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(g_LandmassFractal, g_WaterPercent);
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        terrain = g_OceanTerrain;
      } else {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
      }
      if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
        addLandmassPlotTags(iX, iY, continent2.west);
      } else {
        addWaterPlotTags(iX, iY, continent2.west);
      }
      TerrainBuilder.setTerrainType(iX, iY, terrain);
    }
  }
}
function createSecondaryLandmassBalanced(iWidth, iHeight, continent1, continent2, iStartSectorRows, iStartSectorCols, startSectors, bWestSide, iOceanWaterColumns) {
  const iSize = TerrainBuilder.getRandomNumber(6, "Random Land Size");
  console.log("Random Land Size " + iSize);
  FractalBuilder.create(g_LandmassFractal, iWidth, iHeight, iSize, 0);
  const iRanHeight = 130 - iSize * 10;
  const iWaterHeight = FractalBuilder.getHeightFromPercent(
    g_LandmassFractal,
    g_WaterPercent * iRanHeight / 100
  );
  const iBuffer = Math.floor(iHeight / 18);
  const iBuffer2 = Math.floor(iWidth / 28);
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      let terrain = g_FlatTerrain;
      const iRandom = TerrainBuilder.getRandomNumber(iBuffer, "Random Top/Bottom Edges");
      const iRandom2 = TerrainBuilder.getRandomNumber(iBuffer2, "Random Left/Right Edges");
      if (iY < continent1.south + iRandom || iY >= continent1.north - iRandom) {
        terrain = g_OceanTerrain;
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
        if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
          addLandmassPlotTags(iX, iY, continent2.west);
        } else {
          addWaterPlotTags(iX, iY, continent2.west);
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (iX < continent1.west + iRandom2 || iX >= continent2.east - iRandom2 || iX >= continent1.east - iRandom2 && iX < continent2.west + iRandom2) {
        terrain = g_OceanTerrain;
        TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
        if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
          addLandmassPlotTags(iX, iY, continent2.west);
        } else {
          addWaterPlotTags(iX, iY, continent2.west);
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      } else if (bWestSide && iX > continent1.east + iOceanWaterColumns || bWestSide == false && iX < continent2.west - iOceanWaterColumns) {
        const iPlotHeight = getHeightAdjustingForStartSector(
          iX,
          iY,
          iWaterHeight,
          g_FractalWeight,
          g_CenterWeight,
          g_StartSectorWeight,
          continent1,
          continent2,
          iStartSectorRows,
          iStartSectorCols,
          startSectors
        );
        if (iPlotHeight < iWaterHeight * g_Cutoff) {
          terrain = g_OceanTerrain;
        }
        if (terrain != g_OceanTerrain && terrain != g_CoastTerrain) {
          addLandmassPlotTags(iX, iY, continent2.west);
        } else {
          addWaterPlotTags(iX, iY, continent2.west);
        }
        TerrainBuilder.setTerrainType(iX, iY, terrain);
      }
    }
  }
}
function createSecondaryLandmassStandard(continent1) {
  console.log("Creating new landmass in this box");
  console.log("  North: " + continent1.north);
  console.log("  South: " + continent1.south);
  console.log("  East:  " + continent1.east);
  console.log("  West:  " + continent1.west);
  const iGrain = TerrainBuilder.getRandomNumber(3, "Secondary Landmass Fractal Grain") + 2;
  console.log("Secondary Landmass Fractal Grain: " + iGrain);
  FractalBuilder.create(
    g_LandmassFractal,
    continent1.east - continent1.west + 1,
    continent1.north - continent1.south + 1,
    iGrain,
    0
  );
  const iWaterHeightRange = 30;
  const iRanHeight = TerrainBuilder.getRandomNumber(iWaterHeightRange, "Random Water Height");
  console.log("Random Water Height: " + iRanHeight);
  const iWaterHeight = FractalBuilder.getHeightFromPercent(
    g_LandmassFractal,
    g_WaterPercent * g_Cutoff + iRanHeight - 5
  );
  for (let iY = continent1.south; iY <= continent1.north; iY++) {
    for (let iX = continent1.west; iX <= continent1.east; iX++) {
      const terrain = g_FlatTerrain;
      const iPlotHeight = FractalBuilder.getHeight(
        g_LandmassFractal,
        iX - continent1.west,
        iY - continent1.south
      );
      if (iPlotHeight >= iWaterHeight) {
        if (iY == continent1.south || iY == continent1.north || iX == continent1.west || iX == continent1.east) {
          if (TerrainBuilder.getRandomNumber(2, "Feather hard edges") == 0) {
            TerrainBuilder.setTerrainType(iX, iY, terrain);
          }
        } else {
          TerrainBuilder.setTerrainType(iX, iY, terrain);
        }
      }
    }
  }
}
function expandCoastsPlus(iWest, iEast, iHeight) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = iWest; iX < iEast; iX++) {
      const terrain = GameplayMap.getTerrainType(iX, iY);
      if (terrain == g_OceanTerrain) {
        if (GameplayMap.isAdjacentToShallowWater(iX, iY) && TerrainBuilder.getRandomNumber(2, "Shallow Water Scater Scatter") == 0) {
          TerrainBuilder.setTerrainType(iX, iY, g_CoastTerrain);
        }
      }
    }
  }
}

export { expandCoastsPlus };
//# sourceMappingURL=terra-incognita.js.map
</file>

<file path="mod/maps/base-standard/maps/volcano-generator.js">
import { g_VolcanoFeature, g_MountainTerrain, g_TundraBiome } from './map-globals.js';

function getContinentBoundaryPlotCount(iWidth, iHeight) {
  let iContinentBoundaryPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (GameplayMap.findSecondContinent(iX, iY, 3)) {
        iContinentBoundaryPlots = iContinentBoundaryPlots + 1;
      }
    }
  }
  return iContinentBoundaryPlots;
}
function getNumberAdjacentMountains(iX, iY) {
  let iCount = 0;
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const pAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.isMountain(pAdjacentPlot.x, pAdjacentPlot.y)) {
      iCount = iCount + 1;
    }
  }
  return iCount;
}
function getNumberAdjacentVolcanoes(iX, iY) {
  let iCount = 0;
  for (let iDirection = 0; iDirection < DirectionTypes.NUM_DIRECTION_TYPES; iDirection++) {
    const iIndex = GameplayMap.getIndexFromXY(iX, iY);
    const iLocation = GameplayMap.getLocationFromIndex(iIndex);
    const pAdjacentPlot = GameplayMap.getAdjacentPlotLocation(iLocation, iDirection);
    if (GameplayMap.getFeatureType(pAdjacentPlot.x, pAdjacentPlot.y) == g_VolcanoFeature) {
      iCount = iCount + 1;
    }
  }
  return iCount;
}
function addVolcanoes(iWidth, iHeight, spacing = 2) {
  console.log("Volcanoes");
  const iMountainPercentByDistance = [30, 18, 6];
  let iCountVolcanoesPlaced = 0;
  const placedVolcanoes = [];
  const minDistanceBetweenVolcanoes = spacing;
  let iTotalLandPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots = iTotalLandPlots + 1;
      }
    }
  }
  const iDesiredVolcanoes = iTotalLandPlots / 150;
  console.log("Desired Volcanoes: " + iDesiredVolcanoes);
  const iContinentBoundaryPlots = getContinentBoundaryPlotCount(iWidth, iHeight);
  console.log("Continent Boundary Plots: " + iContinentBoundaryPlots);
  const iDesiredNearBoundaries = iDesiredVolcanoes * 2 / 3;
  console.log("Desired Boundary Volcanoes: " + iDesiredNearBoundaries);
  if (iDesiredNearBoundaries > 0) {
    const iBoundaryPlotsPerVolcano = iContinentBoundaryPlots / iDesiredNearBoundaries;
    console.log("Boundary Plots Per Volcano: " + iBoundaryPlotsPerVolcano);
    for (let iY = 0; iY < iHeight; iY++) {
      for (let iX = 0; iX < iWidth; iX++) {
        if (!GameplayMap.isWater(iX, iY)) {
          let iPlotsFromBoundary = -1;
          let bVolcanoHere = false;
          const iNumAdjacentMountains = getNumberAdjacentMountains(iX, iY);
          if (iNumAdjacentMountains != 6) {
            if (GameplayMap.findSecondContinent(iX, iY, 1)) {
              if (TerrainBuilder.getRandomNumber(iBoundaryPlotsPerVolcano * 0.7, "Volcano on boundary") == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 1;
            } else if (GameplayMap.findSecondContinent(iX, iY, 2)) {
              if (TerrainBuilder.getRandomNumber(iBoundaryPlotsPerVolcano, "Volcano 1 from boundary") == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 2;
            } else if (GameplayMap.findSecondContinent(iX, iY, 3)) {
              if (TerrainBuilder.getRandomNumber(
                iBoundaryPlotsPerVolcano * 1.5,
                "Volcano 2 from boundary"
              ) == 0) {
                bVolcanoHere = true;
              }
              iPlotsFromBoundary = 3;
            }
          }
          if (bVolcanoHere && !isTooCloseToExistingVolcanoes(iX, iY, placedVolcanoes, minDistanceBetweenVolcanoes)) {
            TerrainBuilder.setTerrainType(iX, iY, g_MountainTerrain);
            TerrainBuilder.setFeatureType(iX, iY, {
              Feature: g_VolcanoFeature,
              Direction: -1,
              Elevation: 0
            });
            placedVolcanoes.push({ x: iX, y: iY });
            iCountVolcanoesPlaced++;
          } else if (iPlotsFromBoundary > 0) {
            let iMountainChance = iMountainPercentByDistance[iPlotsFromBoundary - 1];
            if (getNumberAdjacentVolcanoes(iX, iY) > 0) {
              iMountainChance = iMountainChance / 2;
            }
            if (TerrainBuilder.getRandomNumber(100, "Mountain near boundary") < iMountainChance) {
              TerrainBuilder.setTerrainType(iX, iY, g_MountainTerrain);
            }
          }
        }
      }
    }
  }
  console.log("Continent Edge Volcanoes Placed: " + iCountVolcanoesPlaced);
}
function isTooCloseToExistingVolcanoes(iX, iY, existingVolcanoes, minDistance) {
  for (const volcano of existingVolcanoes) {
    const dx = volcano.x - iX;
    const dy = volcano.y - iY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < minDistance) return true;
  }
  return false;
}
function addTundraVolcanoes(iWidth, iHeight, spacing = 3) {
  console.log(`Adding tundra volcanoes`);
  let iTotalLandPlots = 0;
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      if (!GameplayMap.isWater(iX, iY)) {
        iTotalLandPlots++;
      }
    }
  }
  let tundraVolcanoesPlaced = 0;
  const iDesiredVolcanoes = Math.floor(iTotalLandPlots / 300);
  console.log("Desired Tundra Volcanoes: " + iDesiredVolcanoes);
  const placedVolcanoes = [];
  const tundraCandidates = [];
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const biome = GameplayMap.getBiomeType(iX, iY);
      if (biome === g_TundraBiome && GameplayMap.isMountain(iX, iY)) {
        const isInland = !GameplayMap.isCoastalLand(iX, iY);
        tundraCandidates.push({ x: iX, y: iY, isInland });
      }
    }
  }
  shuffleCandidates(tundraCandidates);
  tundraCandidates.sort((a, b) => {
    if (a.isInland === b.isInland) return 0;
    return a.isInland ? -1 : 1;
  });
  const baseChance = 20;
  const falloffPerVolcano = 5;
  for (const { x, y } of tundraCandidates) {
    if (tundraVolcanoesPlaced >= iDesiredVolcanoes) break;
    if (!isTooCloseToExistingVolcanoes(x, y, placedVolcanoes, spacing)) {
      const currentChance = Math.max(1, baseChance - tundraVolcanoesPlaced * falloffPerVolcano);
      if (TerrainBuilder.getRandomNumber(100, "Tundra Volcano Roll") < currentChance) {
        TerrainBuilder.setTerrainType(x, y, g_MountainTerrain);
        TerrainBuilder.setFeatureType(x, y, {
          Feature: g_VolcanoFeature,
          Direction: -1,
          Elevation: 0
        });
        placedVolcanoes.push({ x, y });
        tundraVolcanoesPlaced++;
        console.log(`Tundra Volcano Placed at (${x}, ${y})  chance was ${currentChance}%`);
      }
    }
  }
  console.log(`Total Tundra Volcanoes Placed: ${tundraVolcanoesPlaced}`);
  function shuffleCandidates(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = TerrainBuilder.getRandomNumber(i + 1, "Shuffle");
      [array[i], array[j]] = [array[j], array[i]];
    }
  }
}

export { addTundraVolcanoes, addVolcanoes, isTooCloseToExistingVolcanoes };
//# sourceMappingURL=volcano-generator.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_generators/continent-generator.js">
import { sub2, rotate2, add2, dot2, dot2_90, mul2s, mul2 } from '../../../core/scripts/MathHelpers.js';
import { Aabb2, QuadTree } from '../quadtree.js';
import { kdTree } from '../kd-tree.js';
import { RandomImpl } from '../random-pcg-32.js';
import { PlateRegion, LandmassRegion } from '../voronoi-region.js';
import { PlateBoundaryPosGetter, RegionType, MapSize, VoronoiUtils, MapDims, RegionCell, RegionCellPosGetter, TerrainType } from '../voronoi-utils.js';
import { MapGenerator, GeneratorType } from './map-generator.js';
import { RuleAvoidEdge } from '../voronoi_rules/avoid-edge.js';
import { RuleAvoidOtherRegions } from '../voronoi_rules/avoid-other-regions.js';
import { RuleCellArea } from '../voronoi_rules/cell-area.js';
import { RuleNearMapCenter } from '../voronoi_rules/near-map-center.js';
import { RuleNearNeighbor } from '../voronoi_rules/near-neighbor.js';
import { RuleNearPlateBoundary } from '../voronoi_rules/near-plate-boundary.js';
import { RuleNearRegionSeed } from '../voronoi_rules/near-region-seed.js';
import { RuleNeighborsInRegion } from '../voronoi_rules/neighbors-in-region.js';
import { RulePreferLatitude } from '../voronoi_rules/prefer-latitude.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../voronoi_rules/rules-base.js';

class ContinentGenerator extends MapGenerator {
  m_plateRegions = [];
  m_landmassRegions = [];
  m_plateBoundaries = new kdTree(PlateBoundaryPosGetter);
  m_platesDiagram;
  m_plateRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.15, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.8, record: { scaleFactor: 0.5 } }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.02, record: {} }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.6, record: { preferredNeighborCount: 6, deviation: 3 } }]
  ];
  m_landmassRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 6,
          poleFalloffCurve: 0.2,
          meridianDistance: 2,
          meridianDistanceFalloff: 6,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleCellArea, { isActive: true, weight: 0.1, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.5, record: {} }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.05, record: { scaleFactor: 8 } }],
    [
      RuleNeighborsInRegion,
      { isActive: true, weight: 0.25, record: { preferredNeighborCount: 4, deviation: 1.5 } }
    ],
    [RuleNearMapCenter, { isActive: false, weight: 0.05, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 8, falloffCurve: 0.2, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 3, directionInfluence: 0.5 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ],
    [RulePreferLatitude, { isActive: true, weight: 0.5, record: {} }]
  ];
  m_coastalIslandRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 4,
          poleFalloffCurve: 0.2,
          meridianDistance: 2,
          meridianDistanceFalloff: 10,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleNearNeighbor, { isActive: true, weight: 0.5, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Other Landmass",
        key: "avoidOther",
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Own Landmass",
        key: "avoidSelf",
        isActive: true,
        weight: 1,
        record: { minDistance: 0.25, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleAvoidOtherRegions,
      {
        nameOverride: "Avoid Islands",
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 2, falloffCurve: 0.25, regionType: RegionType.Island }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 3, directionInfluence: 0.5 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ],
    [RuleNearRegionSeed, { isActive: true, weight: 0.3, record: { scaleFactor: 15, invert: 1 } }]
  ];
  m_islandRuleConfigs = [
    [
      RuleAvoidEdge,
      {
        isActive: true,
        weight: 1,
        record: {
          poleDistance: 2,
          poleDistanceFalloff: 8,
          poleFalloffCurve: 0.5,
          meridianDistance: 2,
          meridianDistanceFalloff: 10,
          meridianFalloffCurve: 0.3,
          avoidCorners: 12
        }
      }
    ],
    [RuleCellArea, { isActive: true, weight: 0.15, record: {} }],
    [RuleNearNeighbor, { isActive: true, weight: 0.9, record: { scaleFactor: 0.5 } }],
    [RuleNearRegionSeed, { isActive: true, weight: 0.03, record: {} }],
    [
      RuleNeighborsInRegion,
      { isActive: true, weight: 0.6, record: { preferredNeighborCount: 1.5, deviation: 0.5 } }
    ],
    [RuleNearMapCenter, { isActive: true, weight: 0.04, record: {} }],
    [
      RuleAvoidOtherRegions,
      {
        isActive: true,
        weight: 1,
        record: { minDistance: 4, distanceFalloff: 4, falloffCurve: 0.15, regionType: RegionType.Landmass }
      }
    ],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 2, directionInfluence: 0.8 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ]
  ];
  m_mountainRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.3, record: { invert: true } }],
    [RuleNearNeighbor, { isActive: false, weight: 0.25, record: {} }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.6, record: { preferredNeighborCount: 6, deviation: 4 } }],
    [
      RuleNearPlateBoundary,
      {
        isActive: true,
        weight: 0.75,
        record: { scaleFactor: 1, directionInfluence: 0.4 },
        internalConfig: { m_plateBoundaries: this.m_plateBoundaries }
      }
    ]
  ];
  m_volcanoRuleConfigs = [
    [RuleCellArea, { isActive: true, weight: 0.3, record: { invert: true } }],
    [RuleNeighborsInRegion, { isActive: true, weight: 0.9, record: { preferredNeighborCount: 0, deviation: 1 } }]
  ];
  m_plateRules = [];
  m_landmassRules = [];
  m_coastalIslandRules = [];
  m_islandRules = [];
  m_mountainRules = [];
  m_volcanoRules = [];
  static plateDistributionDescription = "The distribution of sizes of plates is controlled by 'Plate Curve Power' and 'Plate Linear Strength'. This helps the world have a mix of plate sizes. The calculation is a lerp between y=x^(Plate Curve Power) and y=x (linear) based on 'Linear Strength'. A 'Linear Strength' of 1 will mean all the plates are about the same size, less than that and the distribution becomes more curved. 'Plate Curve Power' affects the steepness of the curve";
  m_generatorSettingsSchema = [
    {
      groupLabel: "Plates",
      key: "plate",
      children: {
        type: "configs",
        data: [
          {
            key: "factor",
            label: "Plate Factor",
            description: "Number of tectonic plates to spawn per 100 tiles.",
            min: 0,
            max: 2,
            default: 0.38,
            step: 0.01
          },
          {
            key: "curvePower",
            label: "Plate Curve Power",
            description: ContinentGenerator.plateDistributionDescription,
            min: 1,
            max: 50,
            default: 4,
            step: 1
          },
          {
            key: "linearStrength",
            label: "Plate Linear Strength",
            description: ContinentGenerator.plateDistributionDescription,
            min: 0,
            max: 1,
            default: 0.6,
            step: 0.01
          },
          {
            key: "useUniqueVoronoi",
            label: "Use Unique Voronoi",
            description: "Causes the plate generation to create it's own unique voronoi diagram instead of using the same one as the rest of the map. This allows using fewer cells for plates, leading to more blobby shapes and higher performance.",
            min: 0,
            max: 1,
            default: 1,
            step: 1
          },
          {
            key: "voronoiCellRatio",
            label: "Cell Count Multiple",
            description: "When 'Use Unique Voronoi' is on, this affects the ratio of plate voronoi cells relative to the rest of the map, squared.",
            min: 1e-3,
            max: 1,
            default: 0.25,
            step: 1e-3
          },
          {
            key: "plateRotationMultiple",
            label: "Plate Rotation Multiple",
            description: "A scalar for plate rotation. This is useful since larger plates on big maps will move more around the edges of the plate than smaller ones for the same rotation value.",
            min: 0,
            max: 10,
            default: 1,
            step: 0.1
          }
        ]
      }
    },
    {
      groupLabel: "Landmass",
      key: "landmass",
      childCount: 2,
      children: {
        type: "configs",
        data: [
          {
            key: "enabled",
            label: "Enabled",
            description: "Controls if this landmass is created. Useful for quickly turning on and off a landmass without removing its settings entirely.",
            min: 0,
            max: 1,
            default: 1,
            step: 1
          },
          {
            key: "size",
            label: "Size %",
            description: "The size of the landmass as a percentage of total map area.",
            min: 5,
            max: 40,
            default: 17,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance +/- %",
            description: "The random variance (plus or minus) percentage of the total size.",
            min: 0,
            max: 10,
            default: 1,
            step: 0.01
          },
          {
            key: "spawnCenterDistance",
            label: "Spawn Distance From Center",
            description: "The distance from center with 0 being center and 1 being the edge of a circle squished into the map dimensions",
            min: 0.25,
            max: 0.75,
            default: 0.5,
            step: 0.01
          },
          {
            key: "erosionPercent",
            label: "Erosion Percent",
            description: "The percent of cells in this region to erode.",
            min: 0,
            max: 25,
            step: 0.1,
            default: 8
          },
          {
            key: "playerAreas",
            label: "Player Areas",
            description: "The number of player areas to spawn on this landmass.",
            min: 0,
            max: 20,
            default: 4
          },
          {
            key: "coastalIslands",
            label: "Coastal Islands",
            description: "The number of spawn locations for coastal islands. These are cells just off the coast of landmasses, not too close to other landmasses or islands, which are used to add land to the landmass they spawn near. They follow their own grow rules.",
            min: 0,
            max: 20,
            default: 8
          },
          {
            key: "coastalIslandsMinDistance",
            label: "Coastal Islands Min Distance",
            description: "The minimum distance from the landmass for coastal islands to spawn",
            min: 1,
            max: 4,
            default: 2,
            step: 0.1
          },
          {
            key: "coastalIslandsMaxDistance",
            label: "Coastal Islands max Distance",
            description: "The maximum distance from the landmass for coastal islands to spawn",
            min: 1,
            max: 4,
            default: 3,
            step: 0.1
          },
          {
            key: "coastalIslandsSize",
            label: "Coastal Islands Size %",
            description: "The total amount of land area to create as coastal islands around this landmass as a percent of map size.",
            min: 0,
            max: 5,
            default: 1,
            step: 0.01
          },
          {
            key: "coastalIslandsSizeVariance",
            label: "Coastal Islands Size Variance %",
            description: "The random variance (plus or minus) percentage of the total coastal island size.",
            min: 0,
            max: 5,
            default: 0.5,
            step: 0.01
          }
        ]
      }
    },
    {
      groupLabel: "Islands",
      key: "island",
      children: {
        type: "configs",
        data: [
          {
            key: "factor",
            label: "Factor",
            description: "The number of distant land islands to spawn per 100 tiles.",
            min: 0,
            max: 2,
            default: 0.3,
            step: 0.01
          },
          {
            key: "minSize",
            label: "Minimum Size %",
            description: "The minimum size of -each- island as a percentage of total map size.",
            min: 0,
            max: 4,
            default: 0.33,
            step: 0.01
          },
          {
            key: "maxSize",
            label: "Maximum Size %",
            description: "The maximum size of -each- island as a percentage of total map size.",
            min: 0,
            max: 4,
            default: 2,
            step: 0.01
          },
          {
            key: "totalSize",
            label: "Size %",
            description: "The total size of all islands combined as a percentage of total map size.",
            min: 0,
            max: 10,
            default: 4,
            step: 0.01
          },
          {
            key: "variance",
            label: "Variance +/- %",
            description: "The random plus or minus variance in the total size of all islands as a percentage of total map size.",
            min: 0,
            max: 2,
            default: 0.2,
            step: 0.01
          },
          {
            key: "poleDistance",
            label: "Pole Distance Hexes",
            description: "The minimum distance from the poles that distant land islands can spawn.",
            min: 0,
            max: 10,
            default: 5
          },
          {
            key: "meridianDistance",
            label: "Meridian Distance Hexes",
            description: "The minimum distance from the meridian that distant land islands can spawn.",
            min: 0,
            max: 10,
            default: 5
          },
          {
            key: "landmassDistance",
            label: "Min Landmass Distance Hexes",
            description: "The minimum distance from the major landmasses that distant land islands can spawn.",
            min: 0,
            max: 15,
            default: 4
          },
          {
            key: "islandDistance",
            label: "Min Island Distance Hexes",
            description: "The minimum distance from other islands that distant land islands can spawn.",
            min: 0,
            max: 15,
            default: 3
          },
          {
            key: "erosionPercent",
            label: "Erosion Percent",
            description: "The percent of cells on any given distant land island to erode.",
            min: 0,
            max: 50,
            default: 20
          }
        ]
      }
    },
    {
      groupLabel: "Mountains",
      key: "mountain",
      children: {
        type: "configs",
        data: [
          {
            key: "percent",
            label: "Percent of Land",
            description: "The percentage of all land that should be mountainous",
            min: 0,
            max: 50,
            default: 8,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance Percent",
            description: "The random +/- percent to the total area covered by mountains",
            min: 0,
            max: 10,
            default: 2,
            step: 0.1
          },
          {
            key: "randomize",
            label: "Randomize",
            description: "The randomization applied to mountain scores",
            min: 0,
            max: 100,
            default: 2,
            step: 1
          }
        ]
      }
    },
    {
      groupLabel: "Volcanos",
      key: "volcano",
      children: {
        type: "configs",
        data: [
          {
            key: "percent",
            label: "Percent of Mountains",
            description: "The percentage of all mountains that should be volcanos",
            min: 0,
            max: 50,
            default: 15,
            step: 0.1
          },
          {
            key: "variance",
            label: "Variance Percent",
            description: "The random +/- percent to the total number of mountains that are volcanos",
            min: 0,
            max: 10,
            default: 5,
            step: 0.1
          },
          {
            key: "randomize",
            label: "Randomize",
            description: "The randomization applied to volcano scores",
            min: 0,
            max: 100,
            default: 10,
            step: 1
          }
        ]
      }
    }
  ];
  // Overrides for specific map sizes
  m_mapSizeSettings = {
    [MapSize.Tiny]: {},
    [MapSize.Small]: {},
    [MapSize.Standard]: {},
    [MapSize.Large]: {},
    [MapSize.Huge]: {}
  };
  constructor() {
    super();
    this.initializeRules();
    this.buildDefaultSettings(this.m_generatorSettingsSchema, this.m_mapSizeSettings);
  }
  initializeRules() {
    const initializeRuleGroup = (rules, config) => {
      rules.length = 0;
      for (const [ruleClass, ruleSetting] of config) {
        const rule = new ruleClass();
        rule.initialize(ruleSetting);
        rules.push(rule);
      }
    };
    initializeRuleGroup(this.m_plateRules, this.m_plateRuleConfigs);
    initializeRuleGroup(this.m_landmassRules, this.m_landmassRuleConfigs);
    initializeRuleGroup(this.m_coastalIslandRules, this.m_coastalIslandRuleConfigs);
    initializeRuleGroup(this.m_islandRules, this.m_islandRuleConfigs);
    initializeRuleGroup(this.m_mountainRules, this.m_mountainRuleConfigs);
    initializeRuleGroup(this.m_volcanoRules, this.m_volcanoRuleConfigs);
    const volcanoNeighborRule = this.m_volcanoRules.find(
      (rule) => rule.name === RuleNeighborsInRegion.getName()
    );
    volcanoNeighborRule.inRegionCheck = (_ctx, thisCell, neighborCell) => {
      return thisCell.terrainType === neighborCell.terrainType;
    };
  }
  resetToDefault() {
    super.resetToDefault();
    this.initializeRules();
  }
  getType() {
    return GeneratorType.Continent;
  }
  getGeneratorSettingsConfig() {
    return this.m_generatorSettingsSchema;
  }
  getTypedSettings() {
    return this.getSettings();
  }
  getRules() {
    return {
      Plates: this.m_plateRules,
      Landmasses: this.m_landmassRules,
      "Coastal Islands": this.m_coastalIslandRules,
      Islands: this.m_islandRules,
      Mountains: this.m_mountainRules,
      Volcanoes: this.m_volcanoRules
    };
  }
  simulate() {
    for (const regionCell of this.m_regionCells) {
      regionCell.reset();
    }
    VoronoiUtils.performanceMarker("Grow Plates");
    this.growPlates();
    VoronoiUtils.performanceMarker("Grow Landmasses");
    this.growLandmasses();
    VoronoiUtils.performanceMarker("Grow Islands");
    this.growIslands();
    VoronoiUtils.performanceMarker("Grow Coastal Islands");
    this.growCoastalIslands();
    VoronoiUtils.performanceMarker("Force Polar Margin");
    this.forcePoles();
    VoronoiUtils.performanceMarker("Mark Land and Ocean Tiles");
    this.markLandAndOcean();
    VoronoiUtils.performanceMarker("Remove Lakes");
    this.removeLakes();
    VoronoiUtils.performanceMarker("Add Coasts & Costal Erosion");
    this.addCoasts();
    VoronoiUtils.performanceMarker("Add Mountains & Volcanos");
    this.addMountains();
  }
  choosePlateToGrow(power, linearStrength, plateCount) {
    const x = RandomImpl.fRand("Plate Growth");
    const curve = plateCount * Math.pow(x, power);
    const linear = plateCount * x;
    return Math.floor(VoronoiUtils.lerp(curve, linear, linearStrength));
  }
  growPlates() {
    const area = this.m_worldDims.x * this.m_worldDims.y;
    const plateCount = Math.round(this.getTypedSettings().plate.factor * 0.01 * area) + 1;
    const power = this.getTypedSettings().plate.curvePower;
    const linearStrength = this.getTypedSettings().plate.linearStrength;
    const useUniqueDiagram = this.getTypedSettings().plate.useUniqueVoronoi;
    let voronoiCellRatio = this.getTypedSettings().plate.voronoiCellRatio;
    voronoiCellRatio *= voronoiCellRatio;
    const plateRotationMultiple = this.getTypedSettings().plate.plateRotationMultiple;
    const bbox = { xl: 0, xr: this.m_worldDims.x, yt: 0, yb: this.m_worldDims.y };
    const sites = VoronoiUtils.createRandomSites(plateCount, bbox.xr, bbox.yb);
    const diagram = VoronoiUtils.computeVoronoi(sites, bbox, 5);
    let plateDiagramCells = this.m_regionCells;
    let cellKdTree = this.m_kdTree;
    if (useUniqueDiagram) {
      const cellCount = Math.floor(
        MapDims[this.m_mapSize].x * MapDims[this.m_mapSize].y * voronoiCellRatio
      );
      const sites2 = VoronoiUtils.createRandomSites(cellCount, bbox.xr, bbox.yb);
      this.m_platesDiagram = VoronoiUtils.computeVoronoi(sites2, bbox, 2);
      plateDiagramCells = this.m_platesDiagram.cells.map((cell, index) => {
        const area2 = VoronoiUtils.calculateCellArea(cell);
        const regionCell = new RegionCell(cell, index, area2);
        return regionCell;
      });
      cellKdTree = new kdTree(RegionCellPosGetter);
      cellKdTree.build(plateDiagramCells);
    } else {
      this.m_platesDiagram = void 0;
    }
    this.m_plateRegions = diagram.cells.map((cell, index) => {
      const region = new PlateRegion("Plate" + index, index, 0, bbox.xr * bbox.yb, {
        x: RandomImpl.fRand("Plate Color R"),
        y: RandomImpl.fRand("Plate Color G"),
        z: RandomImpl.fRand("Plate Color B")
      });
      region.seedLocation = { x: cell.site.x, y: cell.site.y };
      const regionCell = cellKdTree.search(region.seedLocation);
      region.considerationList.push({ id: regionCell.id, score: 1 });
      return region;
    });
    for (const region of this.m_plateRegions) {
      region.prepareGrowth(
        plateDiagramCells,
        this.m_plateRegions,
        this.m_plateRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      region.growStep();
    }
    const regionFull = new Array(plateCount).fill(false);
    let growingCount = plateCount;
    while (growingCount > 0) {
      let plateToGrow = this.choosePlateToGrow(power, linearStrength, plateCount);
      if (regionFull[plateToGrow]) {
        plateToGrow = 0;
        while (regionFull[plateToGrow]) {
          ++plateToGrow;
        }
      }
      const canGrow = this.m_plateRegions[plateToGrow].growStep();
      if (!canGrow) {
        regionFull[plateToGrow] = true;
        --growingCount;
      }
    }
    if (useUniqueDiagram) {
      for (const regionCell of this.m_regionCells) {
        const plateCell = cellKdTree.search(regionCell.cell.site);
        regionCell.plateId = plateCell?.plateId;
      }
    }
    for (const plateRegion of this.m_plateRegions) {
      plateRegion.logStats();
    }
    const plateBoundaries = [];
    for (const plateCell of plateDiagramCells) {
      plateCell.ruleConsideration = true;
      for (const neighborId of plateCell.cell.getNeighborIds()) {
        const neighbor = plateDiagramCells[neighborId];
        if (neighbor.plateId !== plateCell.plateId && !neighbor.ruleConsideration) {
          const pos = {
            x: (plateCell.cell.site.x + neighbor.cell.site.x) * 0.5,
            y: (plateCell.cell.site.y + neighbor.cell.site.y) * 0.5
          };
          const normal = VoronoiUtils.normalize({
            x: neighbor.cell.site.x - plateCell.cell.site.x,
            y: neighbor.cell.site.y - plateCell.cell.site.y
          });
          const calculateMovement = (plate, pos2) => {
            const relPos = sub2(pos2, plate.seedLocation);
            const angularMovement = plate.m_rotation * Math.PI / 180 * plateRotationMultiple;
            const rotatedPos = rotate2(relPos, angularMovement);
            const rotationMovement = sub2(relPos, rotatedPos);
            const movement = add2(rotationMovement, plate.m_movement);
            return movement;
          };
          const plate1Movement = calculateMovement(this.m_plateRegions[plateCell.plateId], pos);
          const plate2Movement = calculateMovement(this.m_plateRegions[neighbor.plateId], pos);
          const subduction = dot2(normal, plate1Movement) - dot2(normal, plate2Movement);
          const sliding = Math.abs(dot2_90(normal, plate1Movement) - dot2_90(normal, plate2Movement));
          plateBoundaries.push({
            pos,
            normal,
            plateSubduction: subduction,
            plateSliding: sliding,
            id1: plateCell.plateId,
            id2: neighbor.plateId
          });
        }
      }
    }
    this.m_plateBoundaries.build(plateBoundaries);
  }
  growLandmasses() {
    this.m_landmassRegions = this.getLandmassRegions();
    for (const region of this.m_landmassRegions) {
      region.considerationList = [];
    }
    for (let i = 1; i < this.m_landmassRegions.length; i++) {
      const cell = this.m_kdTree.search(this.m_landmassRegions[i].seedLocation);
      this.m_landmassRegions[i].considerationList.push({ id: cell.id, score: 1 });
    }
    const growingRegions = this.m_landmassRegions.slice(1);
    const quadRegion = new Aabb2({ x: 0, y: 0 }, this.m_worldDims);
    const quadTree = new QuadTree(
      quadRegion,
      (item) => item.cell.site
    );
    for (const region of growingRegions) {
      region.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_landmassRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      region.SetQuadTree(quadTree);
    }
    for (const rule of this.m_landmassRules) {
      if (rule.name == RuleAvoidOtherRegions.getName()) {
        rule.setQuadTree(quadTree);
      }
    }
    let regionIndex = 0;
    while (growingRegions.length > 0) {
      if (!growingRegions[regionIndex].growStep()) {
        growingRegions.splice(regionIndex, 1);
      } else {
        regionIndex++;
      }
      regionIndex %= growingRegions.length;
    }
    for (const region of this.m_landmassRegions.slice(1)) {
      region.logStats();
    }
  }
  growIslands() {
    const area = this.getUsableArea();
    const islandSettings = this.getTypedSettings().island;
    let islandMinSize = islandSettings.minSize;
    let islandMaxSize = islandSettings.maxSize;
    const islandCount = Math.round(islandSettings.factor * area * 0.01);
    const randsForIndices = Array.from({ length: islandCount }, () => RandomImpl.fRand("Island Index"));
    if (islandMinSize > islandMaxSize) {
      console.log("Error: Island min size is larger than max size. Capping min size to the max size");
      islandMinSize = islandMaxSize;
    }
    if (islandMinSize * islandCount > islandSettings.totalSize - islandSettings.variance) {
      console.log("Error: Island min size is too large. Capping value to total size / the number of islands.");
      islandMinSize = (islandSettings.totalSize - islandSettings.variance) / islandCount;
    }
    if (islandMaxSize * islandCount < islandSettings.totalSize + islandSettings.variance) {
      console.log("Error: Island max size is too small. Capping value to total size / the number of islands.");
      islandMaxSize = (islandSettings.totalSize + islandSettings.variance) / islandCount;
    }
    const finalTotalSize = islandSettings.totalSize + RandomImpl.fRand("Island Size Variance") * islandSettings.variance * 2 - islandSettings.variance;
    const maxMinDifference = islandMaxSize - islandMinSize;
    let randomSizeRemaining = finalTotalSize - islandMinSize * islandCount;
    const islandSizes = Array.from({ length: islandCount }, () => islandMinSize);
    for (let i = 0; i < islandSizes.length - 1; ++i) {
      const maxAdded = Math.min(maxMinDifference, randomSizeRemaining);
      const averageRandomSize = randomSizeRemaining / islandCount;
      const randomPower = Math.log(averageRandomSize / maxAdded) / Math.log(0.5);
      const randomSize = Math.pow(RandomImpl.fRand("Island Random Size"), randomPower) * maxAdded;
      randomSizeRemaining -= randomSize;
      islandSizes[i] += randomSize;
    }
    islandSizes[islandSizes.length - 1] += randomSizeRemaining;
    console.log(`Creating ${islandSizes.length} islands. Sizes: ${islandSizes}`);
    const commonIslandsRegion = new LandmassRegion(
      "Islands",
      this.m_landmassRegions.length,
      RegionType.Island,
      0,
      0,
      { x: 0.7, y: 0.7, z: 0.2 }
    );
    this.m_landmassRegions.push(commonIslandsRegion);
    const landmassesKdTree = new kdTree((data) => {
      return { x: data.cell.site.x, y: data.cell.site.y };
    });
    landmassesKdTree.build(
      this.m_regionCells.filter(
        (value) => this.m_landmassRegions[value.landmassId].type === RegionType.Landmass
      )
    );
    for (let i = 0; i < islandCount; ++i) {
      const islandKdTree = new kdTree((data) => {
        return { x: data.cell.site.x, y: data.cell.site.y };
      });
      islandKdTree.build(
        this.m_regionCells.filter(
          (value) => this.m_landmassRegions[value.landmassId].type === RegionType.Island
        )
      );
      const scoreCtx = {
        cells: this.m_regionCells,
        region: commonIslandsRegion,
        regions: this.m_landmassRegions,
        plateRegions: this.m_plateRegions,
        m_worldDims: this.m_worldDims,
        totalArea: 0,
        cellCount: 0,
        rules: this.m_islandRules
      };
      const islandSeedCandidates = [];
      for (const regionCell of this.m_regionCells) {
        const x = regionCell.cell.site.x;
        const y = regionCell.cell.site.y;
        if (x < islandSettings.meridianDistance || x > this.m_worldDims.x - islandSettings.meridianDistance || y < islandSettings.poleDistance || y > this.m_worldDims.y - islandSettings.poleDistance || regionCell.landmassId > 0)
          continue;
        const nearestLandmassCell = landmassesKdTree.search({ x, y });
        const nearestIslandCell = islandKdTree.search({ x, y });
        const distanceToLandmass = VoronoiUtils.distanceBetweenSites(
          regionCell.cell.site,
          nearestLandmassCell.cell.site
        );
        const distanceToIsland = nearestIslandCell ? VoronoiUtils.distanceBetweenSites(regionCell.cell.site, nearestIslandCell.cell.site) : 1e3;
        const nearestPlate = this.m_plateBoundaries.search(regionCell.cell.site).pos;
        const distanceToNearestPlate = Math.sqrt(
          VoronoiUtils.sqDistance(nearestPlate, regionCell.cell.site)
        );
        if (distanceToLandmass > islandSettings.landmassDistance && distanceToIsland > islandSettings.islandDistance) {
          let score = 0;
          for (const rule of this.m_islandRules) {
            if (rule.isActive) {
              score += rule.score(regionCell, scoreCtx);
            }
          }
          score *= distanceToIsland;
          islandSeedCandidates.push([score, regionCell]);
        }
      }
      if (islandSeedCandidates.length == 0) {
        console.log("Failed to find any candidate locations for island.");
        break;
      }
      islandSeedCandidates.sort((a, b) => a[0] - b[0]);
      const randomIndex = Math.floor(
        VoronoiUtils.lerp(islandSeedCandidates.length * 0.9, islandSeedCandidates.length, randsForIndices[i])
      );
      const finalIslandSize = islandSizes[i] * 0.01 * area;
      const islandRegion = new LandmassRegion(
        "Island" + String(i),
        this.m_landmassRegions.length,
        RegionType.Island,
        finalIslandSize,
        0,
        { x: 0.7, y: 0.7, z: 0.2 }
      );
      islandRegion.seedLocation = islandSeedCandidates[randomIndex][1].cell.site;
      this.m_landmassRegions.push(islandRegion);
      islandRegion.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_islandRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      islandRegion.considerationList.push({ id: islandSeedCandidates[randomIndex][1].id, score: 1 });
      while (islandRegion.growStep()) {
        continue;
      }
      islandRegion.logStats();
      this.m_landmassRegions.pop();
      this.m_regionCells.forEach((value) => {
        if (value.landmassId === islandRegion.id) {
          value.landmassId = commonIslandsRegion.id;
        }
      });
    }
  }
  growCoastalIslands() {
    const oceanCells = this.m_regionCells.filter((cell) => cell.landmassId === 0);
    for (let i = 1; i < this.m_landmassRegions.length; ++i) {
      const landmassRegion = this.m_landmassRegions[i];
      if (landmassRegion.type !== RegionType.Landmass) {
        continue;
      }
      const landmassSettings = this.getTypedSettings().landmass[i - 1];
      const coastalIslandSpawnCount = landmassSettings.coastalIslands;
      if (coastalIslandSpawnCount === 0) {
        continue;
      }
      const minLandmassRange = landmassSettings.coastalIslandsMinDistance;
      const maxLandmassRange = landmassSettings.coastalIslandsMaxDistance;
      const nearCoastCells = oceanCells.filter((cell) => {
        let nearRegion = false;
        const filterCallback = (considerCell) => {
          if (considerCell.landmassId === landmassRegion.id) {
            if (VoronoiUtils.distanceBetweenSites(cell.cell.site, considerCell.cell.site) > minLandmassRange) {
              nearRegion = true;
            } else {
              return VoronoiUtils.RegionCellFilterResult.HaltFail;
            }
          } else if (considerCell.landmassId > 0) {
            return VoronoiUtils.RegionCellFilterResult.HaltFail;
          }
          return VoronoiUtils.RegionCellFilterResult.Continue;
        };
        const filterResult = VoronoiUtils.regionCellAreaFilter(
          cell,
          this.m_regionCells,
          maxLandmassRange,
          filterCallback
        );
        return filterResult === VoronoiUtils.RegionCellFilterResult.Continue ? nearRegion : false;
      });
      console.log(
        "Checking " + nearCoastCells.length + " cells near landmass " + landmassRegion.id + " for coastal island spots"
      );
      const minOtherLandmassRange = 4;
      const islandSpawnList = nearCoastCells.filter((cell) => {
        const filterCallback = (considerCell) => {
          if (considerCell.landmassId != 0 && considerCell.landmassId != landmassRegion.id) {
            return VoronoiUtils.RegionCellFilterResult.HaltFail;
          }
          return VoronoiUtils.RegionCellFilterResult.Continue;
        };
        const filterResult = VoronoiUtils.regionCellAreaFilter(
          cell,
          this.m_regionCells,
          minOtherLandmassRange,
          filterCallback
        );
        return filterResult === VoronoiUtils.RegionCellFilterResult.Continue;
      });
      for (const rule of this.m_coastalIslandRules) {
        if (rule instanceof RuleAvoidOtherRegions) {
          const avoidOtherRegionsRule = rule;
          if (avoidOtherRegionsRule.key === "avoidSelf") {
            avoidOtherRegionsRule.configValues.regionId = landmassRegion.id;
            console.log("setting islands for landmass " + landmassRegion.id + " to slightly avoid self");
          } else if (avoidOtherRegionsRule.key === "avoidOther") {
            avoidOtherRegionsRule.configValues.regionId = landmassRegion.id === 1 ? 2 : 1;
            console.log(
              "setting islands for landmass " + landmassRegion.id + " to strongly avoid " + avoidOtherRegionsRule.configValues.regionId
            );
          }
        }
      }
      const area = this.getUsableArea();
      const coastalIslandSize = landmassSettings.coastalIslandsSize;
      let coastalIslandSizeVariance = landmassSettings.coastalIslandsSizeVariance;
      coastalIslandSizeVariance *= RandomImpl.fRand("Coastal Island Size Variance") * 2 - 1;
      const finalIslandSize = (coastalIslandSize + coastalIslandSizeVariance) * 0.01 * area;
      const coastalIslandRegion = new LandmassRegion(
        "CoastalIsland",
        this.m_landmassRegions.length,
        RegionType.CoastalIsland,
        finalIslandSize,
        0,
        { x: 0.4, y: 0.7, z: 0.2 }
      );
      coastalIslandRegion.seedLocation = landmassRegion.seedLocation;
      coastalIslandRegion.prepareGrowth(
        this.m_regionCells,
        this.m_landmassRegions,
        this.m_coastalIslandRules,
        this.m_worldDims,
        this.m_plateRegions
      );
      console.log("Found " + islandSpawnList.length + " cells for coastal island spots");
      let scoredIslandSpawnList = [];
      for (const cell of islandSpawnList) {
        scoredIslandSpawnList.push({ cell, score: coastalIslandRegion.scoreSingleCell(cell) });
      }
      scoredIslandSpawnList.sort((a, b) => b.score - a.score);
      scoredIslandSpawnList = scoredIslandSpawnList.slice(
        0,
        Math.max(coastalIslandSpawnCount, scoredIslandSpawnList.length * 0.25)
      );
      VoronoiUtils.shuffle(scoredIslandSpawnList, coastalIslandSpawnCount);
      scoredIslandSpawnList = scoredIslandSpawnList.slice(0, coastalIslandSpawnCount);
      scoredIslandSpawnList.forEach((tuple) => {
        coastalIslandRegion.considerationList.push({ id: tuple.cell.id, score: 100 });
      });
      while (coastalIslandRegion.growStep()) {
        continue;
      }
      this.m_regionCells.forEach((cell) => {
        if (cell.landmassId == coastalIslandRegion.id) {
          cell.landmassId = landmassRegion.id;
        }
      });
    }
  }
  forcePoles() {
    for (const cell of this.m_regionCells) {
      const minDist = 2;
      if (cell.cell.site.y < minDist || cell.cell.site.y > this.m_worldDims.y - minDist) {
        cell.landmassId = 0;
      }
    }
  }
  markLandAndOcean() {
    for (const cell of this.m_regionCells) {
      cell.terrainType = cell.landmassId > 0 ? TerrainType.Flat : TerrainType.Ocean;
    }
  }
  removeLakes() {
    for (let cell of this.m_regionCells) {
      if (cell.terrainType == TerrainType.Unknown) {
        let isInlandSea = false;
        let neighboringLandmassId = 0;
        const considerationList = [cell];
        const lakeList = [];
        cell.ruleConsideration = true;
        while (considerationList.length > 0) {
          cell = considerationList.pop();
          lakeList.push(cell);
          let neighborsLand = false;
          for (const neighborId of cell.cell.getNeighborIds()) {
            const neighbor = this.m_regionCells[neighborId];
            if (!neighbor.ruleConsideration) {
              if (neighbor.terrainType == TerrainType.Unknown) {
                neighbor.ruleConsideration = true;
                considerationList.push(neighbor);
              } else {
                neighborsLand = true;
                neighboringLandmassId = neighbor.landmassId;
              }
            }
          }
          if (!neighborsLand) {
            isInlandSea = true;
          }
        }
        if (isInlandSea) {
          lakeList.forEach((cell2) => {
            cell2.ruleConsideration = false;
            cell2.terrainType = TerrainType.Ocean;
          });
        } else {
          lakeList.forEach((cell2) => {
            cell2.ruleConsideration = false;
            cell2.terrainType = TerrainType.Flat;
            cell2.landmassId = neighboringLandmassId;
          });
        }
      }
    }
  }
  addCoasts() {
    for (const region of this.m_landmassRegions) {
      if (region.id === 0) continue;
      const coastalCells = [];
      const regionCells = this.m_regionCells.filter((cell) => cell.landmassId === region.id);
      for (const regionCell of regionCells) {
        for (const neighborId of regionCell.cell.getNeighborIds()) {
          let onCoast = false;
          if (this.m_regionCells[neighborId].terrainType == TerrainType.Ocean) {
            onCoast = true;
            this.m_regionCells[neighborId].terrainType = TerrainType.Coast;
            this.m_regionCells[neighborId].landmassId = regionCell.landmassId;
          }
          if (onCoast) {
            coastalCells.push(regionCell);
          }
        }
      }
      const erosionPercent = 0.01 * (region.type === RegionType.Landmass ? this.getTypedSettings().landmass[region.id - 1].erosionPercent : this.getTypedSettings().island.erosionPercent);
      let erosionCount = 0;
      const cellsInRegion = regionCells.length;
      const cellsToErode = erosionPercent * cellsInRegion;
      VoronoiUtils.shuffle(coastalCells);
      for (let i = 0; i < coastalCells.length; ++i) {
        const cell = coastalCells[i];
        if (i < cellsToErode) {
          const neighbors = cell.cell.getNeighborIds();
          for (const neighborId of neighbors) {
            const neighbor = this.m_regionCells[neighborId];
            if (neighbor.landmassId == region.id) {
              neighbor.terrainType = TerrainType.Coast;
              neighbor.landmassId = cell.landmassId;
              ++erosionCount;
              break;
            }
          }
        }
      }
      console.log(
        "Eroded " + erosionCount + " cells on landmass " + region.id + " from a total of " + region.considerationList.length + " coasts on a landmass with " + cellsInRegion + " cells."
      );
    }
  }
  addMountains() {
    const scoreCtx = {
      cells: this.m_regionCells,
      region: this.m_landmassRegions[1],
      regions: this.m_landmassRegions,
      plateRegions: this.m_plateRegions,
      m_worldDims: this.m_worldDims,
      totalArea: 0,
      cellCount: 0,
      rules: this.m_mountainRules
    };
    for (const rule of this.m_mountainRules) {
      if (rule.isActive) {
        rule.scoreAllCells(
          (cell) => cell.terrainType == TerrainType.Flat,
          scoreCtx,
          (cell) => this.m_landmassRegions[cell.landmassId],
          rule.weight
        );
      }
    }
    const mountainSettings = this.getTypedSettings().mountain;
    const scoredCells = this.m_regionCells.filter((cell) => cell.currentScore > 0);
    scoredCells.sort((a, b) => b.currentScore - a.currentScore);
    const mountainVariance = (RandomImpl.fRand("Mountain Variance") * 2 - 1) * mountainSettings.variance;
    const percentMountains = (mountainSettings.percent + mountainVariance) * 0.01;
    const totalMountains = Math.round(scoredCells.length * percentMountains);
    const totalMountainsToConsider = totalMountains + mountainSettings.randomize * 0.01 * (scoredCells.length - totalMountains);
    let mountainCells = scoredCells.slice(0, totalMountainsToConsider);
    VoronoiUtils.shuffle(mountainCells, totalMountains);
    mountainCells = mountainCells.slice(0, totalMountains);
    mountainCells.forEach((cell) => {
      cell.terrainType = TerrainType.Mountainous;
      cell.currentScore = 0;
    });
    scoreCtx.rules = this.m_volcanoRules;
    for (const rule of this.m_volcanoRules) {
      if (rule.isActive) {
        rule.scoreCells(
          mountainCells,
          scoreCtx,
          (cell) => this.m_landmassRegions[cell.landmassId],
          rule.weight
        );
      }
    }
    const volcanoSettings = this.getTypedSettings().volcano;
    const scoredVolcanoCells = mountainCells.filter((cell) => cell.currentScore > 0);
    scoredVolcanoCells.sort((a, b) => b.currentScore - a.currentScore);
    const volcanoVariance = (RandomImpl.fRand("Volcano Variance") * 2 - 1) * volcanoSettings.variance;
    const percentVolcanos = (volcanoSettings.percent + volcanoVariance) * 0.01;
    const totalVolcanos = Math.round(mountainCells.length * percentVolcanos);
    const totalVolcanosToConsider = totalVolcanos + volcanoSettings.randomize * 0.01 * (scoredVolcanoCells.length - totalVolcanos);
    let volcanoCells = scoredVolcanoCells.slice(0, totalVolcanosToConsider);
    VoronoiUtils.shuffle(volcanoCells, totalVolcanos);
    volcanoCells = volcanoCells.slice(0, totalVolcanos);
    volcanoCells.forEach((cell) => {
      cell.terrainType = TerrainType.Volcano;
    });
    this.m_regionCells.forEach((cell) => cell.currentScore = 0);
  }
  getLandmassRegions() {
    const regions = [
      new LandmassRegion("ocean", 0, RegionType.Ocean, 0, 0, { x: 0.2, y: 0.2, z: 0.8 })
    ];
    const area = this.getUsableArea();
    const numLandmasses = this.getTypedSettings().landmass.length;
    const arcOffset = Math.PI * 2 / numLandmasses;
    const randSpawnOffset = arcOffset * RandomImpl.fRand("Landmass spawn offset");
    for (let i = 0; i < numLandmasses; ++i) {
      const landmassSettings = this.getTypedSettings().landmass[i];
      if (!landmassSettings.enabled) {
        continue;
      }
      const landmassSize = landmassSettings.size * 0.01 * area + landmassSettings.variance * 0.01 * area * RandomImpl.fRand("Landmass " + i + " size variance") - landmassSettings.variance * 0.5;
      const landmassPlayerAreas = landmassSettings.playerAreas;
      const spawnOffset = randSpawnOffset + arcOffset * i;
      let circleOffset = { x: Math.cos(spawnOffset), y: Math.sin(spawnOffset) };
      circleOffset = mul2s(circleOffset, landmassSettings.spawnCenterDistance);
      const landmass = new LandmassRegion(
        "landmass" + i,
        1 + i,
        RegionType.Landmass,
        landmassSize,
        landmassPlayerAreas,
        { x: 0, y: 0.8, z: 0 }
      );
      const halfMapDims = mul2s(this.m_worldDims, 0.5);
      landmass.seedLocation = add2(mul2(circleOffset, halfMapDims), halfMapDims);
      regions.push(landmass);
    }
    return regions;
  }
  getLandmasses() {
    return this.m_landmassRegions;
  }
  getPlates() {
    return this.m_plateRegions;
  }
  getPlatesDiagram() {
    return this.m_platesDiagram || this.m_diagram;
  }
  getUsableArea() {
    const meridianMargin = 2;
    const polarMargin = 2;
    const width = this.m_worldDims.x - meridianMargin * 2;
    const height = this.m_worldDims.y - polarMargin * 2;
    return width * height;
  }
}

export { ContinentGenerator };
//# sourceMappingURL=continent-generator.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_generators/map-generator.js">
import { kdTree } from '../kd-tree.js';
import { VoronoiUtils, MapSize, RegionCellPosGetter, RegionCell } from '../voronoi-utils.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

var GeneratorType = /* @__PURE__ */ ((GeneratorType2) => {
  GeneratorType2[GeneratorType2["Continent"] = 0] = "Continent";
  return GeneratorType2;
})(GeneratorType || {});
class GeneratorSettingConfigGroup {
  groupLabel = "";
  key = "";
  childCount;
  // define this to allow this group to contain arrays of settings.
  children = { type: "configs", data: [] };
}
class MapGenerator {
  m_defaultGeneratorSettings = {};
  m_mapSizeOverrides = VoronoiUtils.defaultEnumRecord(MapSize);
  m_generatorSettings = {};
  m_regionCells = [];
  m_diagram;
  // initialized in init()
  m_worldDims = { x: 0, y: 0 };
  m_mapSize = MapSize.Standard;
  m_kdTree = new kdTree(RegionCellPosGetter);
  init(worldDims, diagram, mapSize) {
    this.m_diagram = diagram;
    this.m_worldDims = worldDims;
    this.m_mapSize = mapSize;
    if (Object.entries(this.m_generatorSettings).length === 0) {
      this.m_generatorSettings = VoronoiUtils.clone(this.m_defaultGeneratorSettings);
    }
    VoronoiUtils.deepMerge(this.m_generatorSettings, this.m_mapSizeOverrides[this.m_mapSize]);
    this.m_regionCells = diagram.cells.map((cell, index) => {
      const area = VoronoiUtils.calculateCellArea(cell);
      const regionCell = new RegionCell(cell, index, area);
      return regionCell;
    });
    this.m_kdTree.build(this.m_regionCells);
  }
  logSettings() {
    console.log(
      "generator " + this.getType() + " for map size [" + this.m_mapSize + "] initialized with the following settings:"
    );
    const logObject = (obj, indent, lastKey = "") => {
      if (obj === null) {
        console.log(indent + "null");
      } else if (Array.isArray(obj)) {
        console.log(indent + lastKey + ": [");
        for (let i = 0; i < obj.length; ++i) {
          logObject(obj[i], indent + "  ", i.toString());
        }
        console.log(indent + "]");
      } else if (typeof obj === "object") {
        if (lastKey != "") {
          console.log(indent + lastKey + ": ");
        }
        for (const [key, value] of Object.entries(obj)) {
          if (key[0] === "_") continue;
          logObject(value, indent + "  ", key);
        }
      } else {
        console.log(indent + lastKey + ": " + obj);
      }
    };
    logObject(this.m_generatorSettings, "  ");
    console.log("Rules:");
    const rules = this.getRules();
    for (const ruleSection of Object.keys(rules)) {
      console.log("  " + ruleSection + ":");
      for (const rule of rules[ruleSection]) {
        console.log("    " + rule.name + ": weight: " + rule.weight);
        for (const [key, value] of Object.entries(rule.configValues)) {
          logObject(value, "      ", key);
        }
      }
    }
  }
  buildDefaultSettings(nodes, mapsSizeOverrides) {
    const processConfigNodes = (nodes2) => {
      const out = {};
      for (const node of nodes2) {
        if ("children" in node) {
          if (node.children.type === "configs") {
            if (node.childCount && node.childCount > 0) {
              out["_defaultChild"] = processConfigNodes(node.children.data);
              const arr = [];
              for (let i = 0; i < node.childCount; ++i) {
                arr[i] = processConfigNodes(node.children.data);
              }
              out[node.key] = arr;
            } else {
              out[node.key] = processConfigNodes(node.children.data);
            }
          }
        } else {
          out[node.key] = node.default;
        }
      }
      return out;
    };
    this.m_defaultGeneratorSettings = processConfigNodes(nodes);
    this.m_mapSizeOverrides = mapsSizeOverrides;
  }
  getRegionCells() {
    return this.m_regionCells;
  }
  getKdTree() {
    return this.m_kdTree;
  }
  getSettings() {
    return this.m_generatorSettings;
  }
  getDiagram() {
    return this.m_diagram;
  }
  getPlatesDiagram() {
    return this.m_diagram;
  }
  resetToDefault() {
    this.m_generatorSettings = VoronoiUtils.clone(this.m_defaultGeneratorSettings);
    VoronoiUtils.deepMerge(this.m_generatorSettings, this.m_mapSizeOverrides[this.m_mapSize]);
  }
}

export { GeneratorSettingConfigGroup, GeneratorType, MapGenerator };
//# sourceMappingURL=map-generator.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_maps/continents.js">
import { RandomImpl } from '../random-pcg-32.js';
import { MapDims } from '../voronoi-utils.js';
import { GeneratorType } from '../voronoi_generators/map-generator.js';
import { VoronoiMap } from './map-common.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../kd-tree.js';
import '../voronoi-builder.js';
import '../voronoi-hex.js';
import '../../../core/scripts/MathHelpers.js';
import '../heap.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../voronoi-region.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';

const continentSettings = {
  "generatorKey": 0,
  "mapConfig": {
    "totalLandmassSize": 42,
    "minLandmassSize": 16
  },
  "generatorConfig": {
    "plate": {
      "plateRotationMultiple": 5
    },
    "landmass": [
      {
        "variance": 5,
        "erosionPercent": 4,
        "coastalIslands": 12
      },
      {
        "variance": 5,
        "erosionPercent": 4,
        "coastalIslands": 12
      }
    ],
    "island": {
      "totalSize": 5.5,
      "variance": 1,
      "meridianDistance": 3,
      "landmassDistance": 5,
      "erosionPercent": 15
    },
    "mountain": {
      "percent": 12,
      "randomize": 35
    }
  },
  "rulesConfig": {
    "Plates": {
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.8,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.02,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 3
    },
    "Landmasses": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 12,
      "Cell Area.weight": 0.01,
      "Near Neighbor.weight": 0.75,
      "Near Region Seed.weight": 0.05,
      "Near Region Seed.scaleFactor": 8,
      "Neighbors In Region.weight": 0.25,
      "Neighbors In Region.preferredNeighborCount": 3.5,
      "Neighbors In Region.deviation": 1.5,
      "Near Map Center.weight": 0.05,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.minDistance": 5,
      "Avoid Other Regions.distanceFalloff": 8,
      "Avoid Other Regions.falloffCurve": 0.2,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1.5,
      "Prefer Latitude.weight": 0.76,
      "Prefer Latitude.overlap": 4,
      "Prefer Latitude.latitudes": [
        {
          "latitude": 25,
          "weight": 20
        },
        {
          "latitude": 45,
          "weight": 20
        },
        {
          "latitude": 70,
          "weight": 20
        }
      ]
    },
    "Coastal Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 5,
      "Avoid Edge.meridianFalloffCurve": 0.2,
      "Avoid Edge.avoidCorners": 12,
      "Near Neighbor.weight": 0.5,
      "Avoid Other Landmass.weight": 1,
      "Avoid Other Landmass.distanceFalloff": 2,
      "Avoid Other Landmass.regionType": 2,
      "Avoid Other Landmass.regionId": 1,
      "Avoid Own Landmass.weight": 1,
      "Avoid Own Landmass.minDistance": 1,
      "Avoid Own Landmass.distanceFalloff": 2,
      "Avoid Own Landmass.regionType": 2,
      "Avoid Own Landmass.regionId": 2,
      "Avoid Islands.weight": 1,
      "Avoid Islands.distanceFalloff": 2,
      "Avoid Islands.regionType": 3,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Region Seed.weight": 0.3,
      "Near Region Seed.scaleFactor": 15,
      "Near Region Seed.invert": 1
    },
    "Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 4,
      "Avoid Edge.poleFalloffCurve": 0.5,
      "Avoid Edge.meridianDistance": 1,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 6,
      "Cell Area.weight": 0.15,
      "Cell Area.scaleFactor": -0.2,
      "Near Neighbor.weight": 0.9,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.03,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 1.5,
      "Neighbors In Region.deviation": 0.5,
      "Near Map Center.weight": 0.04,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.falloffCurve": 0.15,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.8
    },
    "Mountains": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Near Neighbor.weight": 0.25,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 4,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1,
      "Near Plate Boundary.directionInfluence": 0.4
    },
    "Volcanoes": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Neighbors In Region.weight": 0.9,
      "Neighbors In Region.preferredNeighborCount": 0
    }
  }
};

class VoronoiContinents extends VoronoiMap {
  m_schema = {
    voronoiCellCountMultiple: {
      label: "Cell Count Multiple",
      description: "The number of voronoi cells to use relative to hexes.",
      default: 1,
      min: 0.5,
      max: 4,
      step: 0.1
    },
    voronoiRelaxationSteps: {
      label: "Cell Relaxation Steps",
      description: "The number times to relax the voronoi diagram from its original random positions.",
      default: 3,
      min: 0,
      max: 10,
      step: 1
    },
    totalLandmassSize: {
      label: "Total Landmass Size",
      description: "The total percentage of land to be taken up by the major landmasses.",
      default: 32,
      min: 20,
      max: 50,
      step: 0.25
    },
    minLandmassSize: {
      label: "Minimum Landmass Size",
      description: "The minimum size a specific landmass can be.",
      default: 12,
      min: 5,
      max: 30,
      step: 0.25
    }
  };
  m_settings;
  constructor() {
    super();
    this.m_settings = this.createDefaultSettings();
  }
  getName() {
    return "Continents";
  }
  init(mapSize) {
    this.initInternal(
      mapSize,
      GeneratorType.Continent,
      continentSettings,
      this.m_settings.voronoiCellCountMultiple,
      this.m_settings.voronoiRelaxationSteps
    );
    const generatorSettings = this.getBuilder().getGenerator().getSettings();
    const landmassCount = generatorSettings.landmass.length;
    const totalSize = this.m_settings.totalLandmassSize;
    const minSize = this.m_settings.minLandmassSize;
    const dims = MapDims[mapSize];
    const tileCount = dims.x * dims.y;
    const avgDim = dims.x + dims.y / 2;
    const landmassSeparationWidth = 4;
    const landmassSeparationTiles = avgDim * (landmassCount - 1) * landmassSeparationWidth;
    const usablePercentage = (tileCount - landmassSeparationTiles) / tileCount;
    const adjustedTotalSize = totalSize * usablePercentage;
    const adjustedMinSize = minSize * usablePercentage;
    let minTotalSize = adjustedMinSize * landmassCount;
    if (adjustedMinSize > adjustedTotalSize) {
      console.error(
        `Minimum landmass size of ${minSize} is too large to fit ${landmassCount} landmasses with less than ${totalSize} total size.`
      );
      minTotalSize = adjustedTotalSize / landmassCount;
    }
    const remaining = adjustedTotalSize - minTotalSize;
    const cuts = Array.from(
      { length: landmassCount - 1 },
      (_value, index) => RandomImpl.fRand(`Landmass ${index + 1} Size Variance`) * remaining
    );
    cuts.sort((a, b) => a - b);
    const landmassSizes = [];
    let prev = 0;
    for (const cut of cuts) {
      landmassSizes.push(cut - prev + adjustedMinSize);
      prev = cut;
    }
    landmassSizes.push(remaining - prev + adjustedMinSize);
    generatorSettings.landmass.forEach((value, index) => {
      value.size = landmassSizes[index];
    });
    const settingsConfig = this.getBuilder().getGenerator().getGeneratorSettingsConfig();
    const landmassConfig = settingsConfig.find(
      (value) => value.key == "landmass"
    );
    const sizeConfig = landmassConfig.children.data.find(
      (value) => value.key == "size"
    );
    sizeConfig.locked = true;
    this.m_builder.getGenerator().logSettings();
  }
  getSettings() {
    return this.getTypedSettings();
  }
  getTypedSettings() {
    return this.m_settings;
  }
  getSettingsConfig() {
    return this.m_schema;
  }
  getFilename() {
    return "continents.mapconfig.js";
  }
}

export { VoronoiContinents };
//# sourceMappingURL=continents.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_maps/map-common.js">
import { VoronoiBuilder } from '../voronoi-builder.js';
import { VoronoiUtils } from '../voronoi-utils.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../voronoi-hex.js';
import '../../../core/scripts/MathHelpers.js';
import '../heap.js';
import '../kd-tree.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../random-pcg-32.js';
import '../voronoi-region.js';
import '../voronoi_generators/map-generator.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

var MapType = /* @__PURE__ */ ((MapType2) => {
  MapType2[MapType2["Continents"] = 0] = "Continents";
  MapType2[MapType2["Pangaea"] = 1] = "Pangaea";
  return MapType2;
})(MapType || {});
class VoronoiMap {
  m_builder = new VoronoiBuilder();
  m_initialized = false;
  getBuilder() {
    return this.m_builder;
  }
  initInternal(mapSize, generatorType, defaultGeneratorSettings, cellCountMultiple, relaxationSteps) {
    this.m_builder.init(mapSize, generatorType, cellCountMultiple, relaxationSteps);
    if (defaultGeneratorSettings && !this.m_initialized) {
      VoronoiUtils.loadSettingsFromJson(defaultGeneratorSettings, this);
    }
    this.m_initialized = true;
  }
  createDefaultSettings() {
    const settings = {};
    for (const [key, value] of Object.entries(this.getSettingsConfig())) {
      settings[key] = value.default;
    }
    return settings;
  }
}

export { MapType, VoronoiMap };
//# sourceMappingURL=map-common.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_maps/pangaea.js">
import { GeneratorType } from '../voronoi_generators/map-generator.js';
import { VoronoiMap } from './map-common.js';
import '../kd-tree.js';
import '../voronoi-utils.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';
import '../voronoi-builder.js';
import '../voronoi-hex.js';
import '../../../core/scripts/MathHelpers.js';
import '../heap.js';
import '../voronoi_generators/continent-generator.js';
import '../quadtree.js';
import '../voronoi-region.js';
import '../voronoi_rules/avoid-edge.js';
import '../voronoi_rules/rules-base.js';
import '../voronoi_rules/avoid-other-regions.js';
import '../voronoi_rules/cell-area.js';
import '../voronoi_rules/near-map-center.js';
import '../voronoi_rules/near-neighbor.js';
import '../voronoi_rules/near-plate-boundary.js';
import '../voronoi_rules/near-region-seed.js';
import '../voronoi_rules/neighbors-in-region.js';
import '../voronoi_rules/prefer-latitude.js';

const pangaeaSettings = {
  "generatorKey": 0,
  "mapConfig": {},
  "generatorConfig": {
    "plate": {
      "plateRotationMultiple": 5
    },
    "landmass": [
      {
        "size": 44,
        "spawnCenterDistance": 0.25,
        "coastalIslands": 20,
        "coastalIslandsSize": 3
      }
    ],
    "island": {
      "minSize": 0.15,
      "maxSize": 2.25,
      "totalSize": 6,
      "poleDistance": 3,
      "meridianDistance": 2
    },
    "mountain": {
      "percent": 12,
      "randomize": 50
    }
  },
  "rulesConfig": {
    "Plates": {
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.8,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.02,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 3
    },
    "Landmasses": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 5,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 4,
      "Avoid Edge.polePerturbationWavelength": 5,
      "Avoid Edge.meridianDistanceFalloff": 12,
      "Avoid Edge.meridianFalloffCurve": 0.3,
      "Avoid Edge.avoidCorners": 18,
      "Cell Area.weight": 0.02,
      "Cell Area.scaleFactor": -0.5,
      "Near Neighbor.weight": 0.8,
      "Near Region Seed.weight": 0.04,
      "Near Region Seed.scaleFactor": 8,
      "Neighbors In Region.weight": 0.25,
      "Neighbors In Region.preferredNeighborCount": 4,
      "Neighbors In Region.deviation": 1.5,
      "Near Map Center.weight": 0.39,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.distanceFalloff": 8,
      "Avoid Other Regions.falloffCurve": 0.2,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.7,
      "Prefer Latitude.weight": 0.76,
      "Prefer Latitude.overlap": 4,
      "Prefer Latitude.latitudes": [
        {
          "latitude": 25,
          "weight": 20
        },
        {
          "latitude": 45,
          "weight": 20
        },
        {
          "latitude": 70,
          "weight": 20
        }
      ]
    },
    "Coastal Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 2,
      "Avoid Edge.poleFalloffCurve": 0.2,
      "Avoid Edge.polePerturbationScale": 3,
      "Avoid Edge.polePerturbationWavelength": 2,
      "Avoid Edge.meridianDistanceFalloff": 6,
      "Avoid Edge.meridianFalloffCurve": 0.5,
      "Avoid Edge.avoidCorners": 12,
      "Near Neighbor.weight": 0.5,
      "Avoid Other Landmass.weight": 1,
      "Avoid Other Landmass.distanceFalloff": 2,
      "Avoid Other Landmass.regionType": 2,
      "Avoid Other Landmass.regionId": 2,
      "Avoid Own Landmass.weight": 0.63,
      "Avoid Own Landmass.minDistance": 0.9,
      "Avoid Own Landmass.distanceFalloff": 3,
      "Avoid Own Landmass.falloffCurve": 0.7,
      "Avoid Own Landmass.regionType": 2,
      "Avoid Own Landmass.regionId": 1,
      "Avoid Islands.weight": 1,
      "Avoid Islands.distanceFalloff": 2,
      "Avoid Islands.regionType": 3,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 3,
      "Near Region Seed.weight": 0.3,
      "Near Region Seed.scaleFactor": 15,
      "Near Region Seed.invert": 1
    },
    "Islands": {
      "Avoid Edge.weight": 1,
      "Avoid Edge.poleDistanceFalloff": 4,
      "Avoid Edge.poleFalloffCurve": 0.5,
      "Avoid Edge.meridianDistanceFalloff": 10,
      "Avoid Edge.meridianFalloffCurve": 0.3,
      "Avoid Edge.avoidCorners": 12,
      "Cell Area.weight": 0.15,
      "Near Neighbor.weight": 0.9,
      "Near Neighbor.scaleFactor": 0.5,
      "Near Region Seed.weight": 0.03,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 1.5,
      "Neighbors In Region.deviation": 0.5,
      "Near Map Center.weight": 0.04,
      "Avoid Other Regions.weight": 1,
      "Avoid Other Regions.falloffCurve": 0.15,
      "Avoid Other Regions.regionType": 2,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 2,
      "Near Plate Boundary.directionInfluence": 0.8
    },
    "Mountains": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Near Neighbor.weight": 0.25,
      "Neighbors In Region.weight": 0.6,
      "Neighbors In Region.preferredNeighborCount": 6,
      "Neighbors In Region.deviation": 4,
      "Near Plate Boundary.weight": 0.75,
      "Near Plate Boundary.scaleFactor": 1,
      "Near Plate Boundary.directionInfluence": 0.4
    },
    "Volcanoes": {
      "Cell Area.weight": 0.3,
      "Cell Area.invert": true,
      "Neighbors In Region.weight": 0.9,
      "Neighbors In Region.preferredNeighborCount": 0
    }
  }
};

class VoronoiPangaea extends VoronoiMap {
  m_schema = {
    voronoiCellCountMultiple: {
      label: "Cell Count Multiple",
      description: "The number of voronoi cells to use relative to hexes.",
      default: 1,
      min: 0.5,
      max: 4,
      step: 0.1
    },
    voronoiRelaxationSteps: {
      label: "Cell Relaxation Steps",
      description: "The number times to relax the voronoi diagram from its original random positions.",
      default: 3,
      min: 0,
      max: 10,
      step: 1
    }
  };
  m_settings;
  constructor() {
    super();
    this.m_settings = this.createDefaultSettings();
  }
  getName() {
    return "Continents";
  }
  init(mapSize) {
    this.initInternal(
      mapSize,
      GeneratorType.Continent,
      pangaeaSettings,
      this.m_settings.voronoiCellCountMultiple,
      this.m_settings.voronoiRelaxationSteps
    );
    this.m_builder.getGenerator().logSettings();
  }
  getSettings() {
    return this.getTypedSettings();
  }
  getTypedSettings() {
    return this.m_settings;
  }
  getSettingsConfig() {
    return this.m_schema;
  }
  getFilename() {
    return "pangaea.mapconfig.js";
  }
}

export { VoronoiPangaea };
//# sourceMappingURL=pangaea.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/avoid-edge.js">
import { RandomImpl } from '../random-pcg-32.js';
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

class RuleAvoidEdge extends Rule {
  static getName() {
    return "Avoid Edge";
  }
  name = RuleAvoidEdge.getName();
  description = "This rule is used to avoid edges of the map (poles and meridian) and also contains some useful parameters to help break up the edges. It will forcibly disqualify cells that get too close, and allows for a tapering of the score as cells get closer to the edge.";
  configDefs = {
    poleDistance: {
      label: "Polar Margin",
      description: "Cells within this many hexes of either pole are excluded.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    poleDistanceFalloff: {
      label: "Poles Distance Falloff",
      description: "The distance from the poles beyond the margin at which scores will start to be reduced, gently pushing new cells away from the poles.",
      defaultValue: 6,
      min: 0,
      max: 10,
      step: 0.1
    },
    poleFalloffCurve: {
      label: "Pole Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    polePerturbationScale: {
      label: "Pole Perturbation Scale",
      description: "The maximum distance to perturb the polar margins with a sine wave.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    polePerturbationWavelength: {
      label: "Pole Perturbation Wavelength",
      description: "The wavelength of the perturbation sine wave.",
      defaultValue: 4,
      min: 1,
      max: 10,
      step: 0.1
    },
    meridianDistance: {
      label: "Meridian Margin",
      description: "Cells within this many hexes of either meridian are excluded.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    meridianDistanceFalloff: {
      label: "Meridian Distance Falloff",
      description: "The distance from the meridian beyond the margin at which scores will start to be reduced, gently pushing new cells away from the meridian.",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    meridianFalloffCurve: {
      label: "Meridian Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    avoidCorners: {
      label: "Avoid Corners",
      description: "Increases the meridian falloff by this much as it approaches the poles to discourage cells from clumping up in the corners of the map.",
      defaultValue: 8,
      min: 0,
      max: 20,
      step: 0.1
    }
  };
  configValues = {
    poleDistance: this.configDefs.poleDistance.defaultValue,
    poleDistanceFalloff: this.configDefs.poleDistanceFalloff.defaultValue,
    poleFalloffCurve: this.configDefs.poleFalloffCurve.defaultValue,
    polePerturbationScale: this.configDefs.polePerturbationScale.defaultValue,
    polePerturbationWavelength: this.configDefs.polePerturbationWavelength.defaultValue,
    meridianDistance: this.configDefs.meridianDistance.defaultValue,
    meridianDistanceFalloff: this.configDefs.meridianDistanceFalloff.defaultValue,
    meridianFalloffCurve: this.configDefs.meridianFalloffCurve.defaultValue,
    avoidCorners: this.configDefs.avoidCorners.defaultValue
  };
  randomOffsetTop = 0;
  randomOffsetBottom = 0;
  prepare() {
    this.randomOffsetTop = RandomImpl.fRand("RuleAvoidEdge random offset top");
    this.randomOffsetBottom = RandomImpl.fRand("RuleAvoidEdge random offset bottom");
  }
  score(regionCell, ctx) {
    let cornerAvoidance = Math.abs(ctx.m_worldDims.y - 2 * regionCell.cell.site.y) / ctx.m_worldDims.y;
    cornerAvoidance *= cornerAvoidance * this.configValues.avoidCorners;
    const meridianDistance = Math.min(regionCell.cell.site.x, ctx.m_worldDims.x - regionCell.cell.site.x);
    const meridianDistanceHex = meridianDistance;
    const minMeridianDistance = this.configValues.meridianDistance;
    const maxMeridianDistance = this.configValues.meridianDistance + this.configValues.meridianDistanceFalloff + cornerAvoidance;
    let meridianScore = VoronoiUtils.clamp(
      VoronoiUtils.iLerp(minMeridianDistance, maxMeridianDistance, meridianDistanceHex),
      0,
      1
    );
    meridianScore = Math.pow(meridianScore, this.configValues.meridianFalloffCurve);
    if (meridianDistanceHex < minMeridianDistance) {
      meridianScore = -100;
    }
    let poleDistance = Math.min(regionCell.cell.site.y, ctx.m_worldDims.y - regionCell.cell.site.y);
    const scale = this.configValues.polePerturbationScale * 0.5;
    const wavelength = this.configValues.polePerturbationWavelength;
    const randomOffset = regionCell.cell.site.y < ctx.m_worldDims.y - regionCell.cell.site.y ? this.randomOffsetTop : this.randomOffsetBottom;
    const randomPerturbation = scale + Math.sin((regionCell.cell.site.x + randomOffset * ctx.m_worldDims.x) / wavelength) * scale;
    poleDistance -= randomPerturbation;
    const minPoleDistance = this.configValues.poleDistance;
    const maxPoleDistance = minPoleDistance + this.configValues.poleDistanceFalloff;
    let poleScore = VoronoiUtils.clamp(VoronoiUtils.iLerp(minPoleDistance, maxPoleDistance, poleDistance), 0, 1);
    poleScore = Math.pow(poleScore, this.configValues.poleFalloffCurve);
    if (poleDistance < minPoleDistance) {
      poleScore = -100;
    }
    return Math.min(meridianScore, poleScore);
  }
}

export { RuleAvoidEdge };
//# sourceMappingURL=avoid-edge.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/avoid-other-regions.js">
import { RegionType, VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleAvoidOtherRegions extends Rule {
  static getName() {
    return "Avoid Other Regions";
  }
  name = RuleAvoidOtherRegions.getName();
  description = "This rule is used to avoid other regions within some radius. Cells that are too close will be forcibly disqualified, and scores will be tapered as they get close to this minimum distance. By default any region not in the source region is filtered, but at the code level filters can be added to avoid only specific region types or region ids.";
  configDefs = {
    minDistance: {
      label: "Minimum Separation",
      description: "Cells within this many hexes of another region are excluded.",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    distanceFalloff: {
      label: "Distance Falloff",
      description: "The distance from other regions beyond the minimum at which scores will start to be reduced, gently pushing new cells away from other regions.",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    falloffCurve: {
      label: "Falloff Curve",
      description: "The power (or steepness) of the curve of the falloff. 1 is linear from the start of the falloff until the margin. Higher values will push cells away from the edges sooner, lower values will reduce the scores more slowly until near the margin.",
      defaultValue: 0.25,
      min: 0,
      max: 1,
      step: 0.05
    },
    regionType: {
      label: "Region Type",
      description: "Used to only avoid a specific region type instead of all regions.",
      defaultValue: RegionType.None,
      visible: false
    },
    regionId: {
      label: "Region Id",
      description: "Used to avoid only a specific region ID.",
      defaultValue: -1,
      visible: false
    }
  };
  configValues = {
    minDistance: this.configDefs.minDistance.defaultValue,
    distanceFalloff: this.configDefs.distanceFalloff.defaultValue,
    falloffCurve: this.configDefs.falloffCurve.defaultValue,
    regionType: this.configDefs.regionType.defaultValue,
    regionId: this.configDefs.regionId.defaultValue
  };
  quadtree;
  score(regionCell, ctx) {
    const minDistance = this.configValues.minDistance;
    const minDistanceSq = minDistance * minDistance;
    const maxDistance = minDistance + this.configValues.distanceFalloff;
    const maxDistanceSq = maxDistance * maxDistance;
    let closestDistSq = maxDistanceSq;
    if (this.quadtree) {
      const filter = (item) => ctx.region.getRegionIdForCell(item) != ctx.region.id;
      const nearest = this.quadtree.nearest(regionCell.cell.site, filter, maxDistanceSq);
      if (nearest.cell) {
        closestDistSq = nearest.distSq;
      }
    } else {
      regionCell.ruleConsideration = true;
      const considerList = [regionCell.id];
      const clearList = [regionCell];
      while (considerList.length > 0) {
        const cellId = considerList.pop();
        const cell = ctx.cells[cellId];
        const distanceSq = VoronoiUtils.sqDistanceBetweenSites(regionCell.cell.site, cell.cell.site);
        if (distanceSq < closestDistSq) {
          const regionId = ctx.region.getRegionIdForCell(cell);
          let bAvoidRegion = regionId != ctx.region.id && (regionId === this.configValues.regionId || this.configValues.regionId === -1);
          bAvoidRegion = bAvoidRegion && (this.configValues.regionType === RegionType.None || ctx.regions[regionId].type == this.configValues.regionType);
          if (bAvoidRegion) {
            closestDistSq = Math.min(distanceSq, closestDistSq);
            if (closestDistSq < minDistanceSq) {
              break;
            }
          } else {
            for (const neighborId of cell.cell.getNeighborIds()) {
              const neighbor = ctx.cells[neighborId];
              if (!neighbor.ruleConsideration) {
                neighbor.ruleConsideration = true;
                clearList.push(neighbor);
                considerList.push(neighborId);
              }
            }
          }
        }
      }
      for (const cell of clearList) {
        cell.ruleConsideration = false;
      }
    }
    if (closestDistSq < minDistanceSq) {
      return -100;
    }
    const closestDist = Math.sqrt(closestDistSq);
    let score = VoronoiUtils.clamp(VoronoiUtils.iLerp(minDistance, maxDistance, closestDist), 0, 1);
    score = Math.pow(score, this.configValues.falloffCurve);
    return score;
  }
  setQuadTree(quadtree) {
    this.quadtree = quadtree;
  }
}

export { RuleAvoidOtherRegions };
//# sourceMappingURL=avoid-other-regions.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/cell-area.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleCellArea extends Rule {
  static getName() {
    return "Cell Area";
  }
  name = RuleCellArea.getName();
  description = "This is a simple rule that scores larger cells higher than smaller cells. This is primary used to add some random variation to the score.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The cell area that represents a score of 0.5. Any cell smaller will score between 0 and 0.5, and any cell larger will score between 0.5 and 1.0",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    },
    invert: {
      label: "Invert",
      description: "Invert the calculation to score smaller cells higher.",
      defaultValue: 0,
      min: 0,
      max: 1,
      step: 1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    invert: this.configDefs.invert.defaultValue
  };
  score(cell, _ctx) {
    const cellArea = VoronoiUtils.calculateCellArea(cell.cell);
    let score = cellArea / (cellArea + this.configValues.scaleFactor);
    if (this.configValues.invert > 0) {
      score = 1 - score;
    }
    return score;
  }
}

export { RuleCellArea };
//# sourceMappingURL=cell-area.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-map-center.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearMapCenter extends Rule {
  static getName() {
    return "Near Map Center";
  }
  name = RuleNearMapCenter.getName();
  description = "This is a simple rule that scores cells closer to the map center higher than cells further away.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor %",
      description: "The distance from the center as a percentage of map width that represents a score of 0.5. Any distance smaller will score between 0.5 and 1.0, and any distance larger will score between 0.0 and 0.5",
      defaultValue: 50,
      min: 0,
      max: 100,
      step: 0.1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue
  };
  score(regionCell, ctx) {
    let distanceToCenter = VoronoiUtils.sqDistance(
      { x: ctx.m_worldDims.x * 0.5, y: ctx.m_worldDims.y * 0.5 },
      { x: regionCell.cell.site.x, y: regionCell.cell.site.y }
    );
    distanceToCenter = Math.sqrt(distanceToCenter);
    let scaleFactor = this.configValues.scaleFactor * 0.01 * ctx.m_worldDims.x;
    scaleFactor *= 0.5;
    return 1 - distanceToCenter / (distanceToCenter + scaleFactor);
  }
}

export { RuleNearMapCenter };
//# sourceMappingURL=near-map-center.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-neighbor.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearNeighbor extends Rule {
  static getName() {
    return "Near Neighbor";
  }
  name = RuleNearNeighbor.getName();
  description = "This is a simple rule that scores nearby cells higher than cells farther away. This is primary used to add some random variation to the score.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The distance from a neighboring cell that represents a score of 0.5. Any distance smaller will score between 0.5 and 1.0, and any distance larger will score between 0.0 and 0.5",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue
  };
  score(regionCell, ctx) {
    let neighborDistanceScore = 1;
    for (const neighborId of regionCell.cell.getNeighborIds()) {
      const neighbor = ctx.cells[neighborId];
      if (ctx.region.getRegionIdForCell(neighbor) == ctx.region.id) {
        const neighborDistance = VoronoiUtils.distanceBetweenSites(
          regionCell.cell.site,
          neighbor.cell.site
        );
        neighborDistanceScore = Math.min(
          neighborDistanceScore,
          neighborDistance / (neighborDistance + this.configValues.scaleFactor)
        );
      }
    }
    return 1 - neighborDistanceScore;
  }
}

export { RuleNearNeighbor };
//# sourceMappingURL=near-neighbor.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-plate-boundary.js">
import { kdTree } from '../kd-tree.js';
import { PlateBoundaryPosGetter, VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearPlateBoundary extends Rule {
  static getName() {
    return "Near Plate Boundary";
  }
  name = RuleNearPlateBoundary.getName();
  description = "Scores cells based on the distance from their site to the nearest plate boundary.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor",
      description: "The distance from a plate boundary that represents a score of 0.5. Any cell nearer to a plate boundary will score between 0.5 and 1.0, and any cell farther away will score between 0.0 and 0.5",
      defaultValue: 4,
      min: 0,
      max: 10,
      step: 0.1
    },
    directionInfluence: {
      label: "Plate Direction Influence",
      description: "How much the direction of plate movement relative to the neighboring plate influences the score.",
      defaultValue: 0.5,
      min: 0,
      max: 1,
      step: 0.05
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    directionInfluence: this.configDefs.directionInfluence.defaultValue
  };
  // This must be provided before the rule can run.
  m_plateBoundaries = new kdTree(PlateBoundaryPosGetter);
  score(regionCell, _ctx) {
    const cellPos = { x: regionCell.cell.site.x, y: regionCell.cell.site.y };
    const boundary = this.m_plateBoundaries.search(cellPos);
    const distance = Math.sqrt(VoronoiUtils.sqDistance(cellPos, boundary.pos));
    const distanceScore = 1 - distance / (distance + this.configValues.scaleFactor);
    const plateMovementScore = distanceScore * boundary.plateSubduction * 0.5;
    return VoronoiUtils.lerp(distanceScore, plateMovementScore, this.configValues.directionInfluence);
  }
}

export { RuleNearPlateBoundary };
//# sourceMappingURL=near-plate-boundary.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/near-region-seed.js">
import { VoronoiUtils } from '../voronoi-utils.js';
import { Rule } from './rules-base.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import '../random-pcg-32.js';

class RuleNearRegionSeed extends Rule {
  static getName() {
    return "Near Region Seed";
  }
  name = RuleNearRegionSeed.getName();
  description = "This rule scores cells nearer to the region seed higher than cells farther away.";
  configDefs = {
    scaleFactor: {
      label: "Scale Factor %",
      description: "The distance from the region seed as a percentage of map width that represents a score of 0.5. Any cell nearer to the region seed will score between 0.5 and 1.0, and any cell farther away will score between 0.0 and 0.5",
      defaultValue: 20,
      min: 0,
      max: 100,
      step: 0.1
    },
    invert: {
      label: "Invert",
      description: "Invert the calculation to prefer tile further away from the region seed.",
      defaultValue: 0,
      min: 0,
      max: 1,
      step: 1
    }
  };
  configValues = {
    scaleFactor: this.configDefs.scaleFactor.defaultValue,
    invert: this.configDefs.invert.defaultValue
  };
  score(regionCell, ctx) {
    let distanceToSeed = VoronoiUtils.sqDistance(
      { x: ctx.region.seedLocation.x, y: ctx.region.seedLocation.y },
      { x: regionCell.cell.site.x, y: regionCell.cell.site.y }
    );
    distanceToSeed = Math.sqrt(distanceToSeed);
    let scaleFactor = this.configValues.scaleFactor * 0.01 * ctx.m_worldDims.x;
    scaleFactor *= 0.5;
    let score = distanceToSeed / (distanceToSeed + scaleFactor);
    if (!this.configValues.invert) {
      score = 1 - score;
    }
    return score;
  }
}

export { RuleNearRegionSeed };
//# sourceMappingURL=near-region-seed.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/neighbors-in-region.js">
import { Rule } from './rules-base.js';

class RuleNeighborsInRegion extends Rule {
  static getName() {
    return "Neighbors In Region";
  }
  name = RuleNeighborsInRegion.getName();
  description = "Scores cells based on how many of their neighbors are already in the region";
  configDefs = {
    preferredNeighborCount: {
      label: "Preferred Neighbor Count",
      description: "The normal distribution used for scoring is centered on this value. Any cells with exactly this number of neighbors will score 1, everything else will be less than that.",
      defaultValue: 3,
      min: 0,
      max: 10,
      step: 0.1
    },
    deviation: {
      label: "Preferred Neighbors Deviation",
      description: "The standard deviation for the normal distribution. Higher values will score number near the preferred count higher.",
      defaultValue: 1,
      min: 0,
      max: 5,
      step: 0.1
    }
  };
  configValues = {
    preferredNeighborCount: this.configDefs.preferredNeighborCount.defaultValue,
    deviation: this.configDefs.deviation.defaultValue
  };
  // Can be replaced with custom logic.
  inRegionCheck = (ctx, _thisCell, neighborCell) => {
    return ctx.region.getRegionIdForCell(neighborCell) === ctx.region.id;
  };
  score(regionCell, ctx) {
    let neighborCount = 0;
    for (const neighborId of regionCell.cell.getNeighborIds()) {
      const neighbor = ctx.cells[neighborId];
      if (this.inRegionCheck(ctx, regionCell, neighbor)) {
        neighborCount++;
      }
    }
    const x = neighborCount;
    const d = this.configValues.deviation;
    const m = this.configValues.preferredNeighborCount;
    const zScore = (x - m) / d;
    const score = Math.exp(-0.5 * zScore * zScore);
    return score;
  }
}

export { RuleNeighborsInRegion };
//# sourceMappingURL=neighbors-in-region.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/prefer-latitude.js">
import { Rule } from './rules-base.js';

class LatitudeCells {
  totalCells = 0;
  cellsPerLatitude;
  constructor(numLatitudes) {
    this.cellsPerLatitude = new Array(numLatitudes).fill(0);
  }
}
class RulePreferLatitude extends Rule {
  static getName() {
    return "Prefer Latitude";
  }
  name = RulePreferLatitude.getName();
  description = "This rule scores cells based on how much area a given region occupies at different latitudes. When it is lacking certain latitudes, then it scores cells in that are higher. When it already has plenty of cells in a latitude, those cells will be scored lower. ";
  configDefs = {
    overlap: {
      label: "Overlap %",
      description: "The amount of overlap allowed between latitudes",
      defaultValue: 2,
      min: 0,
      max: 10,
      step: 0.1
    },
    mirror: {
      label: "Mirror",
      description: "Should the preferred latitudes be mirrored across the equator",
      defaultValue: true,
      min: 0,
      max: 1,
      step: 1
    },
    latitudes: {
      label: "Latitudes",
      description: "latitude bands from -90 to +90 degrees",
      defaultValue: [],
      arrayField: {
        latitude: {
          label: "Latitude",
          description: "A latitude bands between -90 and +90 degrees",
          defaultValue: 0
        },
        weight: {
          label: "Weight %",
          description: "What percentage of this continent should be in this latitude band",
          defaultValue: 0,
          min: 0,
          max: 100,
          step: 1
        }
      }
    }
  };
  configValues = {
    overlap: this.configDefs.overlap.defaultValue,
    mirror: this.configDefs.mirror.defaultValue,
    latitudes: new Array(0)
  };
  m_latitudeBounds = [];
  m_regionLatitudeCells = /* @__PURE__ */ new Map();
  prepare() {
    super.prepare();
    this.m_latitudeBounds = [];
    this.m_regionLatitudeCells.clear();
    let previousBoundary = 0;
    const overlap = this.configValues.overlap * 0.01;
    const halfOverlap = overlap * 0.5;
    let latitudes = this.configValues.latitudes.map((value, index) => [index, value]);
    if (this.configValues.mirror) {
      latitudes = latitudes.concat(
        latitudes.map((value) => {
          return [value[0], { latitude: -value[1].latitude, weight: value[1].weight }];
        })
      );
    }
    latitudes.sort((a, b) => b[1].latitude - a[1].latitude);
    for (let i = 0; i < latitudes.length; ++i) {
      const latitudeDegrees = latitudes[i][1].latitude;
      const latitude = -latitudeDegrees / 180 + 0.5;
      const last = i === latitudes.length - 1;
      const nextBoundary = (() => {
        if (last) {
          return 1;
        } else {
          const nextLatitudeDegrees = latitudes[i + 1][1].latitude;
          const nextLatitude = -nextLatitudeDegrees / 180 + 0.5;
          const difference = nextLatitude - latitude;
          return latitude + 0.5 * difference;
        }
      })();
      const latitudeSetting = {
        min: Math.max(0, previousBoundary - halfOverlap),
        max: Math.min(1, nextBoundary + halfOverlap),
        center: latitude,
        weight: latitudes[i][1].weight * 0.01,
        index: latitudes[i][0]
      };
      this.m_latitudeBounds.push(latitudeSetting);
      previousBoundary = nextBoundary;
    }
  }
  score(regionCell, ctx) {
    let latitudeCells = this.m_regionLatitudeCells.get(ctx.region.id);
    if (!latitudeCells) {
      latitudeCells = new LatitudeCells(this.configValues.latitudes.length);
      this.m_regionLatitudeCells.set(regionCell.landmassId, latitudeCells);
    }
    const overlap = this.configValues.overlap * 0.01;
    const yPos = regionCell.cell.site.y / ctx.m_worldDims.y;
    let score = 0;
    for (let i = 0; i < this.m_latitudeBounds.length; ++i) {
      const bounds = this.m_latitudeBounds[i];
      if (yPos < bounds.min || yPos > bounds.max) continue;
      const weight = yPos < bounds.min + overlap ? (yPos - bounds.min) / overlap : yPos > bounds.max - overlap ? (bounds.max - yPos) / overlap : 1;
      const currentPercentage = (latitudeCells.cellsPerLatitude[bounds.index] ?? 0) / Math.max(latitudeCells.totalCells, 1);
      const desiredPercentage = bounds.weight;
      score += weight * Math.min(1, Math.max(0, (desiredPercentage - currentPercentage) / desiredPercentage));
    }
    return score;
  }
  notifySelectedCell(cell, ctx) {
    super.notifySelectedCell(cell, ctx);
    let latitudeCells = this.m_regionLatitudeCells.get(cell.landmassId);
    if (!latitudeCells) {
      latitudeCells = new LatitudeCells(this.configValues.latitudes.length);
      this.m_regionLatitudeCells.set(cell.landmassId, latitudeCells);
    }
    latitudeCells.totalCells++;
    const overlap = this.configValues.overlap * 0.01;
    const yPos = cell.cell.site.y / ctx.m_worldDims.y;
    for (let i = 0; i < this.m_latitudeBounds.length; ++i) {
      const bounds = this.m_latitudeBounds[i];
      if (yPos < bounds.min) break;
      if (yPos < bounds.min + overlap) {
        latitudeCells.cellsPerLatitude[bounds.index] += (yPos - bounds.min) / overlap;
      } else if (yPos < bounds.max - overlap) {
        latitudeCells.cellsPerLatitude[bounds.index] += 1;
      } else if (yPos < bounds.max) {
        latitudeCells.cellsPerLatitude[bounds.index] += (bounds.max - yPos) / overlap;
      }
    }
  }
}

export { RulePreferLatitude };
//# sourceMappingURL=prefer-latitude.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi_rules/rules-base.js">
class RuleSetting {
  isActive = false;
  weight = 0;
  record = {};
  nameOverride;
  internalConfig = {};
  key;
}
class Rule {
  key;
  description;
  isActive = false;
  weight = 1;
  notifySelectedCell(_cell, _ctx) {
  }
  initialize(config) {
    this.isActive = config.isActive;
    this.weight = config.weight;
    this.name = config.nameOverride ?? this.name;
    this.key = config.key ?? this.name;
    for (const [recordName, recordValue] of Object.entries(config.record)) {
      if (recordName in this.configValues) {
        this.configValues[recordName] = recordValue;
      }
    }
    if (config.internalConfig) {
      for (const [recordName, recordValue] of Object.entries(config.internalConfig)) {
        if (recordName in this) {
          this[recordName] = recordValue;
        } else {
          console.log("Unable to find " + recordName + " in " + this.name);
        }
      }
    }
  }
  prepare() {
  }
  // Optionally overridden
  scoreAllCells(filter, ctx, regionIdGetter, weight = 1) {
    for (const cell of ctx.cells) {
      if (filter(cell)) {
        ctx.region = regionIdGetter(cell);
        cell.currentScore += this.score(cell, ctx) * weight;
      }
    }
  }
  scoreCells(cells, ctx, regionIdGetter, weight = 1) {
    for (const cell of cells) {
      ctx.region = regionIdGetter(cell);
      cell.currentScore += this.score(cell, ctx) * weight;
    }
  }
}

export { Rule, RuleSetting };
//# sourceMappingURL=rules-base.js.map
</file>

<file path="mod/maps/base-standard/scripts/age-transition-post-load.js">
import { generateDiscoveries } from '../maps/discovery-generator.js';
import { dumpResources } from '../maps/map-debug-helpers.js';
import { removeRuralDistrict, placeRuralDistrict, getMinimumResourcePlacementModifier, shuffle, AVAILABLE_ON_ALL_LANDMASSES_ID, EAST_LAND_MASS_ID, WEST_LAND_MASS_ID, replaceIslandResources } from '../maps/map-utilities.js';
import '../maps/map-globals.js';

console.log("Loading age-transition-post-load.ts");
let g_numMajorPlayers = 0;
let g_incomingAge = 0;
function requestInitializationParameters(initParams) {
  console.log("Getting Age Transition Parameters");
  console.log("Players: ", initParams.numMajorPlayers);
  console.log("Old Age: ", initParams.outgoingAge);
  console.log("New Age: ", initParams.incomingAge);
  g_numMajorPlayers = initParams.numMajorPlayers;
  g_incomingAge = initParams.incomingAge;
  engine.call("SetAgeInitializationParameters", initParams);
}
function doMapUpdates() {
  TerrainBuilder.storeWaterData();
}
function generateTransition() {
  console.log("Generating age transition!");
  const setting = Configuration.getGameValue("AgeTransitionSettingName");
  console.log("Age Transition Setting: " + setting);
  let continuityMode = false;
  if (setting == "AGE_TRANSITION_SETTING_KEEP_MORE") {
    console.log("Using continuity setting");
    continuityMode = true;
  }
  doMapUpdates();
  const iRemovedResourcePlots = [];
  const aGeneratedResources = ResourceBuilder.getGeneratedMapResources();
  removeObsoleteResources(iRemovedResourcePlots, aGeneratedResources);
  addNewResources(iRemovedResourcePlots, aGeneratedResources);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  generateDiscoveries(iWidth, iHeight, []);
  for (let iPlayer = 0; iPlayer < g_numMajorPlayers; iPlayer++) {
    if (!Players.get(iPlayer)?.isAlive) {
      continue;
    }
    const regressedCities = regressCitiesToTowns(iPlayer);
    if (continuityMode) {
      positionUnits(iPlayer);
    } else {
      positionArmyCommanders(iPlayer);
      positionFleetCommanders(iPlayer);
    }
    capGold(iPlayer, continuityMode);
    capInfluence(iPlayer, continuityMode);
    changeCapitalCards(iPlayer);
    generateDarkAgeCards(iPlayer);
    generateDynamicVictoryCards(iPlayer);
    generateRetainCityCards(iPlayer, regressedCities);
    Players.AdvancedStart.get(iPlayer)?.dynamicCardsAddedComplete();
  }
}
function removeObsoleteResources(iRemovedResourcePlots, aGeneratedResources) {
  console.log("Removing old resources");
  const aTypesRemoved = [];
  const aCutResources = [];
  const resourcesAvailable = ResourceBuilder.getResourceCounts(-1);
  let countOnMap = 0;
  let countRemoved = 0;
  for (let i = 0; i < resourcesAvailable.length; ++i) {
    if (resourcesAvailable[i] > 0) {
      countOnMap++;
    }
  }
  const countToAdd = aGeneratedResources.length;
  console.log("Adding new resources: " + countToAdd);
  console.log("Resources already on map: " + countOnMap);
  let totalResourceToCut = countOnMap + countToAdd - countOnMap;
  if (totalResourceToCut < 0) {
    totalResourceToCut = 0;
  }
  console.log("Number of resources to cut: " + totalResourceToCut);
  const resourceToCut = ResourceBuilder.getBestMapResourceCuts(aGeneratedResources, totalResourceToCut);
  for (let iI = 0; iI < resourceToCut.length; ++iI) {
    const resourceInfo = GameInfo.Resources.lookup(resourceToCut[iI]);
    if (resourceInfo) {
      aCutResources.push(resourceInfo.$index);
    }
  }
  console.log("Cutting " + aCutResources.length + " resources");
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const iIndex = iY * iWidth + iX;
      const resource = GameplayMap.getResourceType(iX, iY);
      if (resource != ResourceTypes.NO_RESOURCE) {
        let removeResource = false;
        if (aCutResources.find((x) => x == resource)) {
          removeResource = true;
        }
        if (!removeResource && !ResourceBuilder.isResourceValidForAge(resource, g_incomingAge)) {
          removeResource = true;
        }
        if (removeResource) {
          const resourceInfo = GameInfo.Resources.lookup(resource);
          if (resourceInfo) {
            countRemoved++;
            removeRuralDistrict(iX, iY);
            ResourceBuilder.setResourceType(iX, iY, ResourceTypes.NO_RESOURCE);
            console.log(
              "Removed resource: " + Locale.compose(resourceInfo.Name) + " at (" + iX + ", " + iY + ")"
            );
            iRemovedResourcePlots.push(iIndex);
            placeRuralDistrict(iX, iY);
            const resourceType = resourceInfo.$index;
            if (!aTypesRemoved.find((x) => x == resourceType)) {
              aTypesRemoved.push(resourceType);
            }
          }
        }
      }
    }
  }
  console.log("Removed total resource locations: " + countRemoved);
  return aTypesRemoved.length;
}
function addNewResources(iRemovedResourcePlots, aGeneratedResources) {
  console.log("Adding new resources");
  const iResourceCounts = ResourceBuilder.getResourceCounts(-1);
  const aResourceTypes = [];
  for (let ridx = 0; ridx < aGeneratedResources.length; ++ridx) {
    const resourceInfo = GameInfo.Resources.lookup(aGeneratedResources[ridx]);
    if (resourceInfo && resourceInfo.Tradeable) {
      if (iResourceCounts[resourceInfo.$index] == 0) {
        aResourceTypes.push(resourceInfo.$index);
      }
    }
  }
  let iMapMinimumModifer = getMinimumResourcePlacementModifier();
  if (iMapMinimumModifer == void 0) {
    iMapMinimumModifer = 0;
  }
  const aPlacementPlots = [];
  const seed = GameplayMap.getRandomSeed() * (1 + g_incomingAge);
  const avgDistanceBetweenPoints = 3;
  const normalizedRangeSmoothing = 2;
  const poisson = TerrainBuilder.generatePoissonMap(seed, avgDistanceBetweenPoints, normalizedRangeSmoothing);
  const iWidth = GameplayMap.getGridWidth();
  const iHeight = GameplayMap.getGridHeight();
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const index = iY * iWidth + iX;
      if (poisson[index] >= 1) {
        const districtID = MapCities.getDistrict(iX, iY);
        if (districtID == null) {
          aPlacementPlots.push(index);
        }
      }
    }
  }
  iRemovedResourcePlots.forEach((index) => {
    if (index) {
      if (!aPlacementPlots.find((x) => x == index)) {
        aPlacementPlots.push(index);
      }
    }
  });
  shuffle(aPlacementPlots);
  const resourceWeight = new Array(GameInfo.Resources.length);
  const resourceRunningWeight = new Array(GameInfo.Resources.length);
  const resourcesPlacedCount = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountHome = new Array(GameInfo.Resources.length);
  const importantResourceRegionalCountDistant = new Array(GameInfo.Resources.length);
  for (let resourceIdx = 0; resourceIdx < GameInfo.Resources.length; resourceIdx++) {
    resourceWeight[resourceIdx] = 0;
    resourceRunningWeight[resourceIdx] = 0;
    resourcesPlacedCount[resourceIdx] = 0;
    importantResourceRegionalCountHome[resourceIdx] = 0;
    importantResourceRegionalCountDistant[resourceIdx] = 0;
  }
  let maxPerHemisphere = 0;
  const resourceDistribution = GameInfo.Resource_Distribution.lookup(g_incomingAge);
  if (resourceDistribution) {
    maxPerHemisphere = resourceDistribution.ResourceTypeMaxPerHemisphere;
  }
  aResourceTypes.forEach((resourceType) => {
    if (resourceType) {
      const resourceInfo = GameInfo.Resources[resourceType];
      if (resourceInfo) {
        resourceWeight[resourceInfo.$index] = resourceInfo.Weight;
      }
    }
  });
  let iNumPlaced = 0;
  aPlacementPlots.forEach((index) => {
    if (index) {
      const kLocation = GameplayMap.getLocationFromIndex(index);
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(kLocation.x, kLocation.y) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(kLocation.x, kLocation.y) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      const resources = [];
      aResourceTypes.forEach((resourceIdx) => {
        const assignedLandmass = ResourceBuilder.getResourceLandmass(resourceIdx);
        if (assignedLandmass == AVAILABLE_ON_ALL_LANDMASSES_ID || assignedLandmass == EAST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS || assignedLandmass == WEST_LAND_MASS_ID && plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS) {
          const existingResource = GameplayMap.getResourceType(kLocation.x, kLocation.y);
          if (existingResource != ResourceTypes.NO_RESOURCE && !ResourceBuilder.isResourceClassRequiredForLegacyPath(existingResource, assignedLandmass)) {
            if (ResourceBuilder.canHaveResource(kLocation.x, kLocation.y, resourceIdx, true)) {
              resources.push(resourceIdx);
            }
          } else {
            if (ResourceBuilder.canHaveResource(kLocation.x, kLocation.y, resourceIdx, true)) {
              resources.push(resourceIdx);
            }
          }
        }
      });
      if (resources.length > 0) {
        let resourceChosen = ResourceTypes.NO_RESOURCE;
        let resourceChosenIndex = 0;
        for (let iI = 0; iI < resources.length; iI++) {
          if (resourceChosen == ResourceTypes.NO_RESOURCE) {
            resourceChosen = resources[iI];
            resourceChosenIndex = resources[iI];
          } else {
            if (resourceRunningWeight[resources[iI]] > resourceRunningWeight[resourceChosenIndex]) {
              resourceChosen = resources[iI];
              resourceChosenIndex = resources[iI];
            } else if (resourceRunningWeight[resources[iI]] == resourceRunningWeight[resourceChosenIndex]) {
              const iRoll = TerrainBuilder.getRandomNumber(2, "Resource Scatter");
              if (iRoll >= 1) {
                resourceChosen = resources[iI];
                resourceChosenIndex = resources[iI];
              }
            }
          }
        }
        if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS && importantResourceRegionalCountHome[resourceChosenIndex] < maxPerHemisphere || plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS && importantResourceRegionalCountDistant[resourceChosenIndex] < maxPerHemisphere) {
          if (resourceChosen != ResourceTypes.NO_RESOURCE) {
            ResourceBuilder.setResourceType(kLocation.x, kLocation.y, resourceChosen);
            resourceRunningWeight[resourceChosenIndex] -= resourceWeight[resourceChosenIndex];
            const name = GameInfo.Resources[resourceChosenIndex].Name;
            console.log(
              "Placed " + Locale.compose(name) + " at (" + kLocation.x + ", " + kLocation.y + ")"
            );
            iNumPlaced++;
            if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS) {
              importantResourceRegionalCountHome[resourceChosenIndex]++;
            } else {
              importantResourceRegionalCountDistant[resourceChosenIndex]++;
            }
            resourcesPlacedCount[resourceChosenIndex]++;
            removeRuralDistrict(kLocation.x, kLocation.y);
            placeRuralDistrict(kLocation.x, kLocation.y);
          } else {
            console.log("Resource Type Failure");
          }
        }
      }
    }
  });
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      const districtID = MapCities.getDistrict(iX, iY);
      let plotTag = PlotTags.PLOT_TAG_NONE;
      if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_EAST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_EAST_LANDMASS;
      } else if (GameplayMap.getPlotTag(iX, iY) & PlotTags.PLOT_TAG_WEST_LANDMASS) {
        plotTag = PlotTags.PLOT_TAG_WEST_LANDMASS;
      }
      if (districtID == null) {
        for (let i = 0; i < resourcesPlacedCount.length; ++i) {
          const resourceToPlace = GameInfo.Resources.lookup(i);
          if (resourceToPlace) {
            const assignedLandmass = ResourceBuilder.getResourceLandmass(i);
            if (assignedLandmass != AVAILABLE_ON_ALL_LANDMASSES_ID && (assignedLandmass == EAST_LAND_MASS_ID && plotTag != PlotTags.PLOT_TAG_EAST_LANDMASS || assignedLandmass == WEST_LAND_MASS_ID && plotTag != PlotTags.PLOT_TAG_WEST_LANDMASS)) {
              continue;
            }
            const minimumPerLandMass = resourceToPlace.MinimumPerHemisphere > 0 ? resourceToPlace.MinimumPerHemisphere + iMapMinimumModifer : 0;
            if (plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS && importantResourceRegionalCountHome[i] < minimumPerLandMass || plotTag == PlotTags.PLOT_TAG_WEST_LANDMASS && importantResourceRegionalCountDistant[i] < minimumPerLandMass) {
              if (resourcesPlacedCount[i] > 0 && ResourceBuilder.isResourceRequiredForAge(i)) {
                if (ResourceBuilder.canHaveResource(iX, iY, i, false)) {
                  ResourceBuilder.setResourceType(iX, iY, i);
                  const name = GameInfo.Resources.lookup(i)?.Name;
                  console.log(
                    "Force Placed " + Locale.compose(name) + " at (" + iX + ", " + iY + ")"
                  );
                  plotTag == PlotTags.PLOT_TAG_EAST_LANDMASS ? importantResourceRegionalCountHome[i]++ : importantResourceRegionalCountDistant[i]++;
                  removeRuralDistrict(iX, iY);
                  placeRuralDistrict(iX, iY);
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
  const ageDefinition = GameInfo.Ages.lookup(g_incomingAge);
  if (ageDefinition) {
    const mapType = Configuration.getMapValue("Name");
    for (const option of GameInfo.MapIslandBehavior) {
      if (option.MapType === mapType && option.AgeType == ageDefinition.AgeType) {
        replaceIslandResources(iWidth, iHeight, option.ResourceClassType);
      }
    }
  }
  dumpResources(iWidth, iHeight);
}
var DynamicCardTypes = /* @__PURE__ */ ((DynamicCardTypes2) => {
  DynamicCardTypes2[DynamicCardTypes2["None"] = 0] = "None";
  DynamicCardTypes2[DynamicCardTypes2["Capital"] = 1] = "Capital";
  DynamicCardTypes2[DynamicCardTypes2["City"] = 2] = "City";
  DynamicCardTypes2[DynamicCardTypes2["Commander"] = 3] = "Commander";
  DynamicCardTypes2[DynamicCardTypes2["Wonder"] = 4] = "Wonder";
  DynamicCardTypes2[DynamicCardTypes2["Gold"] = 5] = "Gold";
  DynamicCardTypes2[DynamicCardTypes2["DarkAge"] = 6] = "DarkAge";
  DynamicCardTypes2[DynamicCardTypes2["Victory"] = 7] = "Victory";
  DynamicCardTypes2[DynamicCardTypes2["Unit"] = 8] = "Unit";
  return DynamicCardTypes2;
})(DynamicCardTypes || {});
function regressCitiesToTowns(iPlayer) {
  const player = Players.get(iPlayer);
  const playerSettlements = player?.Cities?.getCityIds();
  const regressedCities = [];
  if (playerSettlements != null) {
    for (let i = 0; i < playerSettlements.length; i++) {
      const settlement = Cities.get(playerSettlements[i]);
      if (settlement != null) {
        if (!settlement.isCapital && !settlement.isTown) {
          regressedCities.push(playerSettlements[i]);
          settlement.changeHasBuildQueue(-1);
        }
      }
    }
  }
  return regressedCities;
}
function changeCapitalCards(iPlayer) {
  const capitalOptions = 2;
  const player = Players.get(iPlayer);
  let playerSettlements = player?.Cities?.getCityIds();
  let currentPlayerCapitalName = "LOC_ERROR_NO_CAPITAL_NAME";
  const currentPlayerCapital = player?.Cities?.getCapital();
  if (currentPlayerCapital != null) {
    currentPlayerCapitalName = currentPlayerCapital.name;
  }
  if (player != null && playerSettlements != null) {
    playerSettlements = playerSettlements.sort((a, b) => {
      const popA = Cities.get(a)?.population;
      const popB = Cities.get(b)?.population;
      if (popA == null) return 1;
      if (popB == null) return -1;
      return popB - popA;
    });
    let capitalName = "LOC_ERROR_NO_CAPITAL_NAME";
    const civ = GameInfo.Civilizations.lookup(player.civilizationType);
    if (civ != null) {
      capitalName = civ.CapitalName;
    }
    let cardsGenerated = 0;
    for (let i = 0; i < playerSettlements.length && cardsGenerated < capitalOptions; i++) {
      const settlement = Cities.get(playerSettlements[i]);
      if (settlement != null) {
        if (!settlement.isCapital && settlement.Trade != null && settlement.Trade.isConnectedToOwnersCapitalByLand()) {
          const card = {
            id: "CARD_AT_CHANGE_CAPITAL_" + cardsGenerated,
            name: "LOC_CARD_AT_CHANGE_CAPITAL",
            description: "LOC_CARD_AT_CHANGE_CAPITAL_DESCRIPTION\\" + settlement.name + "\\" + capitalName + "\\" + currentPlayerCapitalName,
            tooltip: "",
            iconOverride: "",
            limitID: "CARD_AT_CHANGE_CAPITAL_0",
            individualLimit: 1,
            groupLimit: 1,
            categorySortOrder: 100,
            cost: [{ category: CardCategories.CARD_CATEGORY_WILDCARD, value: 0 }],
            effects: [
              {
                id: "CARD_AT_CHANGE_CAPITAL_" + cardsGenerated,
                type: "CARD_AT_CHANGE_CAPITAL",
                name: "",
                description: "",
                amount: 1,
                special: 0,
                metadata: {
                  Type: 1 /* Capital */,
                  SettlementId: settlement.id.id
                }
              }
            ],
            aiModifierLists: []
          };
          Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
          cardsGenerated += 1;
        }
      }
    }
  }
}
function positionUnits(iPlayer) {
  const player = Players.get(iPlayer);
  if (player != null) {
    const playerUnits = player?.Units;
    if (playerUnits != null) {
      let commanderIds = playerUnits.getUnitIds();
      if (commanderIds != null) {
        commanderIds = commanderIds.filter((unitId) => {
          return Units.get(unitId)?.isCommanderUnit;
        });
        const shadows = playerUnits.getUnitShadows();
        for (const shadow of shadows) {
          const unit = createUnitFromShadowAtLocation(player, shadow, shadow.location);
          if (unit != null && shadow.isInCommander) {
            console.log("In commander");
            for (const commanderId of commanderIds) {
              const army = Armies.get(commanderId);
              console.log(
                "Locations: " + army?.location.x + "," + army?.location.y + " " + shadow.location.x + "," + shadow.location.y + " " + (army != null) + " " + (army?.location == shadow.location)
              );
              if (army != null && army.location.x == shadow.location.x && army.location.y == shadow.location.y) {
                console.log("Packing");
                army.packUnit(unit);
              }
            }
          }
        }
      }
    }
  }
}
function positionArmyCommanders(iPlayer) {
  const LAND_DOMAIN_HASH = Database.makeHash("DOMAIN_LAND");
  const CORE_CLASS_MILITARY_HASH = Database.makeHash("CORE_CLASS_MILITARY");
  const numDefensiveUnits = getNumDefenders();
  const player = Players.get(iPlayer);
  if (player != null) {
    let playerSettlements = player?.Cities?.getCityIds();
    if (playerSettlements != null && playerSettlements.length > 0) {
      playerSettlements = playerSettlements.sort((a, b) => {
        const popA = Cities.get(a)?.population;
        const popB = Cities.get(b)?.population;
        if (popA == null) return 1;
        if (popB == null) return -1;
        return popB - popA;
      });
      const cityCount = playerSettlements.length;
      console.log("Cities available ", cityCount);
      const playerUnits = player?.Units;
      if (playerUnits != null) {
        let totalUnitsCreated = 0;
        let shadows = playerUnits.getUnitShadows();
        let unitIds = player?.Units?.getUnitIds();
        if (unitIds != null) {
          unitIds.forEach((unitID) => {
            const unit = Units.get(unitID);
            if (unit != null && unit.isArmyCommander) {
              console.log("Packing commander with previous units");
              const army = Armies.get(unit.armyId);
              let packedUnits = [];
              for (let i = 0; i < shadows.length; i++) {
                if (shadows[i].location.x == unit.location.x && shadows[i].location.y == unit.location.y && shadows[i].isInCommander) {
                  console.log("Found previous packed unit");
                  packedUnits.push(i);
                }
              }
              for (let i = 0; i < packedUnits.length; i++) {
                const newUnitID = createUnitFromShadowAtLocation(
                  player,
                  shadows[packedUnits[i]],
                  unit.location
                );
                totalUnitsCreated++;
                if (newUnitID != null) {
                  console.log("Packing unit");
                  army?.packUnit(newUnitID);
                }
              }
              while (packedUnits.length > 0) {
                const index = packedUnits.pop();
                if (index != null) {
                  playerUnits.removeUnitShadowAtIndex(index);
                }
              }
              shadows = playerUnits.getUnitShadows();
            }
          });
        }
        shadows = playerUnits.getUnitShadows();
        for (let i = 0; i < shadows.length; i++) {
          console.log(JSON.stringify(shadows[i]));
        }
        let cityIndex = 0;
        for (let i = 0; i < numDefensiveUnits; i++) {
          const city = Cities.get(playerSettlements[cityIndex]);
          if (city != null) {
            const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
              city.location,
              LAND_DOMAIN_HASH,
              CORE_CLASS_MILITARY_HASH
            );
            if (shadowIndex >= 0 && shadowIndex < shadows.length) {
              createUnitFromShadowAtLocation(player, shadows[shadowIndex], city.location);
              playerUnits.removeUnitShadowAtIndex(shadowIndex);
              shadows = playerUnits.getUnitShadows();
              totalUnitsCreated++;
            } else if (totalUnitsCreated < numDefensiveUnits) {
              console.log("Spawning free unit as defender");
              player.AdvancedStart?.createDefender(
                city.location,
                Database.makeHash("UNIT_CLASS_INFANTRY")
              );
              totalUnitsCreated++;
            }
          }
          cityIndex++;
          if (cityIndex >= cityCount) {
            cityIndex = 0;
          }
        }
        unitIds = player?.Units?.getUnitIds();
        if (unitIds != null) {
          unitIds = unitIds.filter((unitId) => {
            return Units.get(unitId)?.Experience?.canEarnExperience == true && Units.get(unitId)?.isArmyCommander;
          });
          unitIds = unitIds.sort((a, b) => {
            let expA = 0;
            let expB = 0;
            const expCompA = Units.get(a)?.Experience;
            if (expCompA != null) {
              expA = expCompA.experiencePoints;
            }
            const expCompB = Units.get(b)?.Experience;
            if (expCompB != null) {
              expB = expCompB.experiencePoints;
            }
            return expB - expA;
          });
          if (unitIds.length == 0) {
            const city = Cities.get(playerSettlements[0]);
            if (city != null) {
              const commanderType = player.Units?.getBuildUnit("UNIT_ARMY_COMMANDER");
              const result = Units.create(player.id, { Type: commanderType, Location: city.location });
              if (result.Success && result.ID) {
                unitIds.push(result.ID);
              }
            }
          }
          unitIds.forEach((unitID) => {
            const unit = Units.get(unitID);
            if (unit != null && playerSettlements != null) {
              console.log(Locale.compose(unit.name));
              if (unit.isArmyCommander) {
                const army = Armies.get(unit.armyId);
                const prevArmyLocation = unit.location;
                const city = player.Cities?.findClosest(unit.location);
                if (city != null && army != null) {
                  Units.setLocation(unitID, city.location);
                  unit.setProperty("PROPERTY_CHECK_COMMANDER", true);
                  unit.setProperty("PROPERTY_KEEP_COMMANDER", true);
                  const capacityRemaining = army.combatUnitCapacity - army.unitCount;
                  for (let i = 0; i < capacityRemaining && shadows.length > 0; i++) {
                    const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
                      prevArmyLocation,
                      LAND_DOMAIN_HASH,
                      CORE_CLASS_MILITARY_HASH
                    );
                    if (shadowIndex >= 0 && shadowIndex < shadows.length) {
                      const newUnitID = createUnitFromShadowAtLocation(
                        player,
                        shadows[shadowIndex],
                        city.location
                      );
                      playerUnits.removeUnitShadowAtIndex(shadowIndex);
                      shadows = playerUnits.getUnitShadows();
                      totalUnitsCreated++;
                      if (newUnitID != null) {
                        army.packUnit(newUnitID);
                      }
                    }
                  }
                }
              }
            }
          });
        }
      }
    }
  }
}
function positionFleetCommanders(iPlayer) {
  const SEA_DOMAIN_HASH = Database.makeHash("DOMAIN_SEA");
  const CORE_CLASS_MILITARY_HASH = Database.makeHash("CORE_CLASS_MILITARY");
  const player = Players.get(iPlayer);
  if (player != null) {
    let unitIds = player?.Units?.getUnitIds();
    if (unitIds != null) {
      unitIds = unitIds.filter((unitId) => {
        return Units.get(unitId)?.Experience?.canEarnExperience == true && Units.get(unitId)?.isFleetCommander;
      });
      unitIds = unitIds.sort((a, b) => {
        let expA = 0;
        let expB = 0;
        const expCompA = Units.get(a)?.Experience;
        if (expCompA != null) {
          expA = expCompA.experiencePoints;
        }
        const expCompB = Units.get(b)?.Experience;
        if (expCompB != null) {
          expB = expCompB.experiencePoints;
        }
        return expB - expA;
      });
      const playerUnits = player?.Units;
      if (playerUnits != null) {
        let shadows = playerUnits.getUnitShadows();
        unitIds.forEach((unitID) => {
          const unit = Units.get(unitID);
          if (unit != null) {
            console.log(Locale.compose(unit.name));
            if (unit.isFleetCommander) {
              const army = Armies.get(unit.armyId);
              const locationIndex = Game.PlacementRules.getValidOceanNavalLocation(iPlayer);
              console.log("Location Index: " + locationIndex);
              if (army != null && locationIndex != -1) {
                const location = GameplayMap.getLocationFromIndex(locationIndex);
                const prevArmyLocation = unit.location;
                Units.setLocation(unitID, location);
                console.log("Location: " + JSON.stringify(location));
                unit.setProperty("PROPERTY_CHECK_COMMANDER", true);
                unit.setProperty("PROPERTY_KEEP_COMMANDER", true);
                for (let i = 0; i < army.combatUnitCapacity && shadows.length > 0; i++) {
                  const shadowIndex = playerUnits.getShadowIndexClosestToLocation(
                    prevArmyLocation,
                    SEA_DOMAIN_HASH,
                    CORE_CLASS_MILITARY_HASH
                  );
                  if (shadowIndex >= 0 && shadowIndex < shadows.length) {
                    const newUnitID = createUnitFromShadowAtLocation(
                      player,
                      shadows[shadowIndex],
                      prevArmyLocation
                    );
                    playerUnits.removeUnitShadowAtIndex(shadowIndex);
                    shadows = playerUnits.getUnitShadows();
                    if (newUnitID != null) {
                      army.packUnit(newUnitID);
                    }
                  } else {
                    console.log("Shadow index outside of valid range");
                  }
                }
              }
            }
          }
        });
      }
    }
  }
}
function createUnitFromShadowAtLocation(player, shadow, location) {
  for (const shadowOption of GameInfo.Unit_ShadowReplacements) {
    if (Database.makeHash(shadowOption.Domain) == shadow.domainHash && Database.makeHash(shadowOption.CoreClass) == shadow.coreClassHash && Database.makeHash(shadowOption.Tag) == shadow.tagHash) {
      const buildUnit = player.Units?.getBuildUnit(shadowOption.UnitType);
      if (buildUnit != null) {
        const result = Units.create(player.id, { Type: buildUnit, Location: location, Validate: true });
        if (result.Success && result.ID) {
          return result.ID;
        }
      }
    }
  }
  return null;
}
function getNumDefenders() {
  const definition = GameInfo.Ages.lookup(Game.age);
  if (definition != null) {
    return definition.NumDefenders;
  }
  return 0;
}
function capGold(iPlayer, bContinuityMode) {
  const player = Players.get(iPlayer);
  let defaultGold = Game.EconomicRules.adjustForGameSpeed(3e3);
  if (bContinuityMode) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      defaultGold = Game.EconomicRules.adjustForGameSpeed(6e3);
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      defaultGold = Game.EconomicRules.adjustForGameSpeed(9e3);
    }
  }
  console.log("Default gold: " + defaultGold);
  const currentGold = player?.Treasury?.goldBalance;
  if (currentGold != null) {
    if (currentGold > defaultGold) {
      player?.Treasury?.changeGoldBalance(defaultGold - currentGold);
    }
  }
}
function capInfluence(iPlayer, bContinuityMode) {
  const player = Players.get(iPlayer);
  let defaultInfluence = Game.EconomicRules.adjustForGameSpeed(500);
  if (bContinuityMode) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      defaultInfluence = Game.EconomicRules.adjustForGameSpeed(800);
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      defaultInfluence = Game.EconomicRules.adjustForGameSpeed(1200);
    }
  }
  console.log("Default influence: " + defaultInfluence);
  const currentInfluence = player?.DiplomacyTreasury?.diplomacyBalance;
  if (currentInfluence != null) {
    if (currentInfluence > defaultInfluence) {
      player?.DiplomacyTreasury?.changeDiplomacyBalance(defaultInfluence - currentInfluence);
    }
  }
}
function generateDarkAgeCards(iPlayer) {
  if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
    const card = {
      id: "CARD_AT_EXP_DARK_AGE_MILITARY",
      name: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_DARK_AGE_NAME",
      description: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_DARK_AGE_DESCRIPTION",
      tooltip: "",
      iconOverride: "agecard_dark.png",
      limitID: "",
      individualLimit: 1,
      unlock: "UNLOCK_DARK_AGE_MILITARISTIC_1",
      categorySortOrder: 100,
      cost: [{ category: CardCategories.CARD_CATEGORY_DARK_AGE, value: 1 }],
      effects: [
        {
          id: "CARD_AT_EXP_DARK_AGE_ARMY",
          type: "CARD_ADD_ARMY_CAVALRY_PLUS_SIEGE",
          name: "",
          description: "",
          amount: 3,
          special: 0,
          metadata: {
            Type: 6 /* DarkAge */
          }
        },
        {
          id: "CARD_AT_EXP_DARK_AGE_LOSE_ALL_BUT_CAPITAL",
          type: "",
          name: "",
          description: "",
          amount: 1,
          special: 0,
          metadata: {
            Type: 6 /* DarkAge */
          }
        }
      ],
      aiModifierLists: ["Dark Age Armies Pseudoyields"]
    };
    Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
  }
}
function generateRetainCityCards(iPlayer, aSettlements) {
  const player = Players.get(iPlayer);
  if (player != null) {
    if (aSettlements.length > 0) {
      if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
        const card = {
          id: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC",
          name: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_GOLDEN_AGE_NAME",
          description: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_GOLDEN_AGE_DESCRIPTION",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_EXP_VICTORY_CULTURE_GOLDEN_AGE",
          individualLimit: 1,
          goldenAgeReward: true,
          categorySortOrder: 10,
          unlock: "UNLOCK_WON_ECONOMIC_VICTORY_1",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [],
          aiModifierLists: []
        };
        for (let i = 0; i < aSettlements.length; i++) {
          card.effects.push({
            id: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC_" + i,
            type: "CARD_AT_EXP_GOLDEN_AGE_ECONOMIC",
            name: "",
            description: "",
            amount: 1,
            special: 0,
            metadata: {
              Type: 2 /* City */,
              SettlementId: aSettlements[i].id
            }
          });
        }
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      } else if (Game.age == Database.makeHash("AGE_MODERN")) {
        const card = {
          id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC",
          name: "LOC_LEGACY_PATH_EXPLORATION_ECONOMIC_GOLDEN_AGE_NAME",
          description: "LOC_LEGACY_PATH_EXPLORATION_ECONOMIC_GOLDEN_AGE_DESCRIPTION",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_MOD_VICTORY_MILITARISTIC_FIRST",
          individualLimit: 1,
          goldenAgeReward: true,
          categorySortOrder: 10,
          unlock: "UNLOCK_WON_ECONOMIC_VICTORY_2",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_POPULATION",
              type: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_POPULATION",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {}
            }
          ],
          aiModifierLists: []
        };
        for (let i = 0; i < aSettlements.length; i++) {
          card.effects.push({
            id: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC_" + i,
            type: "CARD_AT_MOD_GOLDEN_AGE_ECONOMIC",
            name: "",
            description: "",
            amount: 1,
            special: 0,
            metadata: {
              Type: 2 /* City */,
              SettlementId: aSettlements[i].id
            }
          });
        }
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    }
  }
}
function generateDynamicVictoryCards(iPlayer) {
  const player = Players.get(iPlayer);
  if (player != null) {
    if (Game.age == Database.makeHash("AGE_EXPLORATION")) {
      let yield_multiplier = 5;
      const numberOfroutes = player.getProperty("PROPERTY_ANTIQUITY_TRADE_ROUTE_TOTAL");
      let totalYield = numberOfroutes * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
          name: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_ANTIQUITY_ECONOMIC_MILESTONE_2_DESCRIPTION_DYNAMIC\\5\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          categorySortOrder: 20,
          unlock: "UNLOCK_AT_LEAST_SECOND_ECONOMIC_VICTORY_1",
          cost: [{ category: CardCategories.CARD_CATEGORY_ECONOMIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
              type: "CARD_AT_EXP_VICTORY_ECONOMIC_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
      yield_multiplier = 1;
      const numberOfGreatWorks = player.getProperty("PROPERTY_PREVIOUS_AGE_GREAT_WORK_TOTAL");
      totalYield = numberOfGreatWorks * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
          name: "LOC_LEGACY_PATH_ANTIQUITY_SCIENCE_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_ANTIQUITY_SCIENCE_MILESTONE_2_DESCRIPTION_DYNAMIC\\1\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          unlock: "UNLOCK_AT_LEAST_SECOND_SCIENTIFIC_VICTORY_1",
          categorySortOrder: 20,
          cost: [{ category: CardCategories.CARD_CATEGORY_SCIENTIFIC, value: 2 }],
          effects: [
            {
              id: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
              type: "CARD_AT_EXP_VICTORY_SCIENTIFIC_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
      {
        const card = {
          id: "CARD_AT_EXP_VICTORY_MILITARISTIC_UNITS",
          name: "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_GOLDEN_AGE_NAME",
          description: "",
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "CARD_AT_EXP_VICTORY_CULTURE_GOLDEN_AGE",
          individualLimit: 1,
          goldenAgeReward: true,
          unlock: "UNLOCK_WON_MILITARISTIC_VICTORY_1",
          categorySortOrder: 10,
          cost: [{ category: CardCategories.CARD_CATEGORY_MILITARISTIC, value: 2 }],
          effects: [],
          aiModifierLists: []
        };
        let totalUnits = 0;
        if (player.Cities?.getCities() != null) {
          for (const city of player.Cities?.getCities()) {
            if (city.getProperty(Database.makeHash("PROPERTY_WAS_CONQUERED"))) {
              console.log("Was conquered: " + city.name);
              card.effects.push({
                id: "CARD_EFFECT_AT_EXP_VICTORY_MILITARISTIC_UNITS" + totalUnits,
                type: "CARD_AT_EXP_VICTORY_MILITARISTIC_UNITS",
                name: "",
                description: "",
                amount: 1,
                special: 0,
                metadata: {
                  Type: 8 /* Unit */,
                  SettlementId: city.id.id
                }
              });
              totalUnits++;
            }
          }
        }
        card.description = "LOC_LEGACY_PATH_ANTIQUITY_MILITARY_GOLDEN_AGE_DESCRIPTION_DYNAMIC\\" + totalUnits;
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    } else if (Game.age == Database.makeHash("AGE_MODERN")) {
      const yield_multiplier = 2;
      const numberOfGreatWorks = player.getProperty("PROPERTY_PREVIOUS_AGE_GREAT_WORK_TOTAL");
      const totalYield = numberOfGreatWorks * yield_multiplier;
      if (totalYield > 0) {
        const card = {
          id: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
          name: "LOC_LEGACY_PATH_EXPLORATION_CULTURE_MILESTONE_2_NAME\\",
          description: "LOC_LEGACY_PATH_EXPLORATION_CULTURE_MILESTONE_2_DESCRIPTION_DYNAMIC\\2\\" + totalYield,
          tooltip: "",
          iconOverride: "agecard_victory.png",
          limitID: "",
          individualLimit: 1,
          unlock: "UNLOCK_AT_LEAST_SECOND_CULTURAL_VICTORY_2",
          categorySortOrder: 20,
          cost: [{ category: CardCategories.CARD_CATEGORY_CULTURAL, value: 2 }],
          effects: [
            {
              id: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
              type: "CARD_AT_MOD_VICTORY_CULTURAL_SECOND",
              name: "",
              description: "",
              amount: 1,
              special: 0,
              metadata: {
                Type: 7 /* Victory */,
                Amount: totalYield
              }
            }
          ],
          aiModifierLists: []
        };
        Players.AdvancedStart.get(iPlayer)?.addDynamicAvailableCard(card);
      }
    }
  }
}
engine.on("RequestAgeInitializationParameters", requestInitializationParameters);
engine.on("GenerateAgeTransition", generateTransition);
console.log("Loaded age-transition-post-load.ts");
//# sourceMappingURL=age-transition-post-load.js.map
</file>

<file path="mod/maps/base-standard/scripts/heap.js">
class Heap {
  constructor(compare) {
    this.compare = compare;
  }
  items = [];
  get size() {
    return this.items.length;
  }
  peak() {
    return this.items[0];
  }
  push(value) {
    this.items.push(value);
    this.bubbleUp(this.items.length - 1);
  }
  pop() {
    const top = this.items[0];
    const last = this.items.pop();
    if (this.items.length > 0) {
      this.items[0] = last;
      this.bubbleDown(0);
    }
    return top;
  }
  clear() {
    this.items = [];
  }
  bubbleUp(index) {
    while (index > 0) {
      const parent = Math.floor((index - 1) / 2);
      if (this.compare(this.items[index], this.items[parent]) >= 0) break;
      [this.items[parent], this.items[index]] = [this.items[index], this.items[parent]];
      index = parent;
    }
  }
  bubbleDown(index) {
    const length = this.items.length;
    while (true) {
      const left = 2 * index + 1;
      const right = left + 1;
      let smallest = index;
      if (left < length && this.compare(this.items[left], this.items[smallest]) < 0) {
        smallest = left;
      }
      if (right < length && this.compare(this.items[right], this.items[smallest]) < 0) {
        smallest = right;
      }
      if (smallest === index) break;
      [this.items[index], this.items[smallest]] = [this.items[smallest], this.items[index]];
      index = smallest;
    }
  }
}

export { Heap };
//# sourceMappingURL=heap.js.map
</file>

<file path="mod/maps/base-standard/scripts/index.d.js">
//# sourceMappingURL=index.d.js.map
</file>

<file path="mod/maps/base-standard/scripts/kd-tree.js">
class kdNode {
  data;
  left;
  right;
  constructor(data) {
    this.data = data;
  }
}
class kdTree {
  rootNode;
  getPos;
  constructor(getPos) {
    this.getPos = getPos;
  }
  build(data) {
    this.rootNode = this.buildInternal([...data]);
  }
  search(pos) {
    return this.searchInternal(this.rootNode, pos, 0, [], 1)[0]?.data;
  }
  searchMultiple(pos, count) {
    return this.searchInternal(this.rootNode, pos, 0, [], count).sort((a, b) => a.distSq - b.distSq);
  }
  buildInternal(data, axis = 0) {
    if (data.length === 0) return void 0;
    data.sort((a, b) => axis === 0 ? this.getPos(a).x - this.getPos(b).x : this.getPos(a).y - this.getPos(b).y);
    const midIndex = Math.floor(data.length / 2);
    const midItem = data[midIndex];
    axis = (axis + 1) % 2;
    const node = new kdNode(midItem);
    node.left = this.buildInternal(data.slice(0, midIndex), axis);
    node.right = this.buildInternal(data.slice(midIndex + 1), axis);
    return node;
  }
  searchInternal(node, pos, axis, bestList, maxCount) {
    if (!node) return bestList;
    const distSq = this.distSq(pos, this.getPos(node.data));
    if (bestList.length < maxCount) {
      bestList.push({ data: node.data, distSq });
    } else {
      let bestI = 0;
      for (let i = 1; i < bestList.length; ++i) {
        if (bestList[i].distSq > bestList[bestI].distSq) {
          bestI = i;
        }
      }
      if (bestList[bestI].distSq > distSq) {
        bestList[bestI] = { data: node.data, distSq };
      }
    }
    const diff = axis === 0 ? pos.x - this.getPos(node.data).x : pos.y - this.getPos(node.data).y;
    const nearChild = diff < 0 ? node.left : node.right;
    const farChild = diff < 0 ? node.right : node.left;
    bestList = this.searchInternal(nearChild, pos, (axis + 1) % 2, bestList, maxCount);
    const axisDistSq = diff * diff;
    const furthestDistanceSq = bestList.reduce((max, data) => Math.max(max, data.distSq), 0);
    if (axisDistSq < furthestDistanceSq) {
      bestList = this.searchInternal(farChild, pos, (axis + 1) % 2, bestList, maxCount);
    }
    return bestList;
  }
  distSq(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }
}

export { kdTree };
//# sourceMappingURL=kd-tree.js.map
</file>

<file path="mod/maps/base-standard/scripts/quadtree.js">
import { sub2, dot2, div2s, add2 } from '../../core/scripts/MathHelpers.js';
import { VoronoiUtils } from './voronoi-utils.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';

class Aabb2 {
  min = { x: 0, y: 0 };
  max = { x: 0, y: 0 };
  constructor(min, max) {
    this.min = min;
    this.max = max;
  }
  contains(pos) {
    return pos.x >= this.min.x && pos.x <= this.max.x && pos.y >= this.min.y && pos.y <= this.max.y;
  }
  size() {
    return sub2(this.max, this.min);
  }
  distSqToPoint(p) {
    const d = { x: 0, y: 0 };
    if (p.x < this.min.x) d.x = this.min.x - p.x;
    else if (p.x >= this.max.x) d.x = p.x - this.max.x;
    if (p.y < this.min.y) d.y = this.min.y - p.y;
    else if (p.y >= this.max.y) d.y = p.y - this.max.y;
    return dot2(d, d);
  }
  intersects(other) {
    return !(other.min.x >= this.max.x || other.max.x <= other.min.x || other.min.y >= this.max.y || other.max.y <= other.min.y);
  }
}
var QuadIdx = /* @__PURE__ */ ((QuadIdx2) => {
  QuadIdx2[QuadIdx2["NW"] = 0] = "NW";
  QuadIdx2[QuadIdx2["NE"] = 1] = "NE";
  QuadIdx2[QuadIdx2["SE"] = 2] = "SE";
  QuadIdx2[QuadIdx2["SW"] = 3] = "SW";
  return QuadIdx2;
})(QuadIdx || {});
class QuadTree {
  bounds;
  capacity;
  maxDepth;
  depth;
  getPos;
  items = [];
  children = null;
  constructor(bounds, getPos, capacity = 4, maxDepth = 16, depth = 0) {
    this.bounds = bounds;
    this.getPos = getPos;
    this.capacity = capacity;
    this.maxDepth = maxDepth;
    this.depth = depth;
  }
  size() {
    return this.items.length + (this.children ? this.children.reduce((a, c) => a + c.size(), 0) : 0);
  }
  insert(item) {
    if (!this.bounds.contains(this.getPos(item))) return false;
    if (!this.children) {
      if (this.items.length < this.capacity || this.depth >= this.maxDepth) {
        this.items.push(item);
        return true;
      }
      this.subdivide();
      this.items.forEach((item2) => this.insertIntoChild(item2));
      this.items.length = 0;
    }
    return this.insertIntoChild(item);
  }
  nearest(target, filter = void 0, bestDistSq = Infinity, best = null) {
    for (const item of this.items) {
      if (filter && filter(item)) {
        const d = VoronoiUtils.sqDistance(this.getPos(item), target);
        if (d < bestDistSq) {
          bestDistSq = d;
          best = item;
        }
      }
    }
    if (!this.children) {
      return { cell: best, distSq: bestDistSq };
    }
    const ordered = this.children.map((child) => ({ child, d: child.bounds.distSqToPoint(target) })).sort((a, b) => a.d - b.d);
    for (const { child, d } of ordered) {
      if (d > bestDistSq) break;
      const candidate = child.nearest(target, filter, bestDistSq, best);
      if (candidate.cell) {
        [best, bestDistSq] = [candidate.cell, candidate.distSq];
      }
    }
    return { cell: best, distSq: bestDistSq };
  }
  queryRange(range = this.bounds, out = []) {
    if (!this.bounds.intersects(range)) return out;
    for (const item of this.items) {
      if (range.contains(this.getPos(item))) out.push(item);
    }
    if (this.children) {
      for (const child of this.children) child.queryRange(range, out);
    }
    return out;
  }
  insertIntoChild(item) {
    this.children[this.childIndex(item)].insert(item);
  }
  subdivide() {
    const childDepth = this.depth + 1;
    const min = this.bounds.min;
    const hDims = div2s(this.bounds.size(), 2);
    const mins = [min, { x: min.x + hDims.x, y: min.y }, add2(min, hDims), { x: min.x, y: min.y + hDims.y }];
    const maxes = mins.map((v) => add2(v, hDims));
    const c = Array.from(
      { length: 4 },
      (_v, k) => new QuadTree(new Aabb2(mins[k], maxes[k]), this.getPos, this.capacity, this.maxDepth, childDepth)
    );
    this.children = [c[0], c[1], c[2], c[3]];
  }
  childIndex(item) {
    const center = add2(this.bounds.min, div2s(this.bounds.size(), 2));
    const pos = this.getPos(item);
    const east = pos.x >= center.x;
    const south = pos.y >= center.y;
    return south ? east ? 2 /* SE */ : 3 /* SW */ : east ? 1 /* NE */ : 0 /* NW */;
  }
}

export { Aabb2, QuadTree };
//# sourceMappingURL=quadtree.js.map
</file>

<file path="mod/maps/base-standard/scripts/random-pcg-32.js">
var RandomPCG32;
((RandomPCG322) => {
  class RandomState {
    state = 0x08f5dc87e5c07d8an;
    inc = 0x3n;
  }
  RandomPCG322.RandomState = RandomState;
  function seed(value) {
    RandomPCG322.randomPCG32State.state = 0n;
    RandomPCG322.randomPCG32State.inc = 0x3n;
    rand();
    RandomPCG322.randomPCG32State.state += BigInt(value);
    rand();
  }
  RandomPCG322.seed = seed;
  function rand() {
    const oldState = RandomPCG322.randomPCG32State.state;
    RandomPCG322.randomPCG32State.state = (oldState * 6364136223846793005n & 0xffffffffffffffffn) + RandomPCG322.randomPCG32State.inc & 0xffffffffffffffffn;
    const xorshifted = (oldState >> 18n ^ oldState) >> 27n & 0xffffffffn;
    const rot0 = oldState >> 59n & 0xffffffffn;
    const rot1 = ~rot0 + 1n & 31n;
    const output = (xorshifted >> rot0 | xorshifted << rot1) & 0xffffffffn;
    return Number(output);
  }
  RandomPCG322.rand = rand;
  function fRand(strLog) {
    return getRandomNumber(65535, strLog) / 65535;
  }
  RandomPCG322.fRand = fRand;
  function getRandomNumber(iRange, strLog) {
    if (typeof TerrainBuilder == "object" && typeof TerrainBuilder.getRandomNumber == "function") {
      return TerrainBuilder.getRandomNumber(iRange, strLog);
    } else {
      return Math.floor((rand() & 65535) * (iRange / 65536));
    }
  }
  RandomPCG322.getRandomNumber = getRandomNumber;
  function getState() {
    return { state: RandomPCG322.randomPCG32State.state, inc: RandomPCG322.randomPCG32State.inc };
  }
  RandomPCG322.getState = getState;
  function setState(state) {
    RandomPCG322.randomPCG32State.state = state.state;
    RandomPCG322.randomPCG32State.inc = state.inc;
  }
  RandomPCG322.setState = setState;
  RandomPCG322.randomPCG32State = new RandomState();
})(RandomPCG32 || (RandomPCG32 = {}));
var GameCoreRandom;
((GameCoreRandom2) => {
  const RANDOM_A = 1103515245n;
  const RANDOM_C = 12345n;
  const RANDOM_SHIFT = 16n;
  const LOG_OUTPUT = false;
  class RandomState {
    state = 0x08f5dc87e5c07d8an;
  }
  GameCoreRandom2.RandomState = RandomState;
  function seed(value) {
    GameCoreRandom2.randomState.state = BigInt(value);
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: setting seed to " + value);
    }
  }
  GameCoreRandom2.seed = seed;
  function rand() {
    GameCoreRandom2.randomState.state = RANDOM_A * GameCoreRandom2.randomState.state + RANDOM_C & 0xffffffffn;
    return GameCoreRandom2.randomState.state >> RANDOM_SHIFT & 0xffffn;
  }
  GameCoreRandom2.rand = rand;
  function fRand(strLog) {
    return getRandomNumber(65535, strLog) / 65535;
  }
  GameCoreRandom2.fRand = fRand;
  function getRandomNumber(iRange, strLog) {
    let num = 0;
    if (typeof TerrainBuilder == "object" && typeof TerrainBuilder.getRandomNumber == "function") {
      num = TerrainBuilder.getRandomNumber(iRange, strLog);
    } else {
      num = Math.floor(Number(rand()) * (iRange / 65536));
    }
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: getRandomNumber(" + iRange + ', "' + strLog + '") = ' + num);
    }
    return num;
  }
  GameCoreRandom2.getRandomNumber = getRandomNumber;
  function getState() {
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: getState() called with current state " + GameCoreRandom2.randomState.state);
    }
    return { state: GameCoreRandom2.randomState.state };
  }
  GameCoreRandom2.getState = getState;
  function setState(state) {
    if (LOG_OUTPUT) {
      console.log("GameCoreRandom: setState(" + state.state + ")");
    }
    GameCoreRandom2.randomState.state = state.state;
  }
  GameCoreRandom2.setState = setState;
  GameCoreRandom2.randomState = new RandomState();
})(GameCoreRandom || (GameCoreRandom = {}));
const RandomImpl = GameCoreRandom;

export { GameCoreRandom, RandomImpl, RandomPCG32 };
//# sourceMappingURL=random-pcg-32.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-builder.js">
import { Diagram } from '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import { VoronoiHex } from './voronoi-hex.js';
import { MapDims, VoronoiUtils } from './voronoi-utils.js';
import { ContinentGenerator } from './voronoi_generators/continent-generator.js';
import { GeneratorType } from './voronoi_generators/map-generator.js';
import '../../core/scripts/MathHelpers.js';
import './heap.js';
import './kd-tree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';
import './quadtree.js';
import './voronoi-region.js';
import './voronoi_rules/avoid-edge.js';
import './voronoi_rules/rules-base.js';
import './voronoi_rules/avoid-other-regions.js';
import './voronoi_rules/cell-area.js';
import './voronoi_rules/near-map-center.js';
import './voronoi_rules/near-neighbor.js';
import './voronoi_rules/near-plate-boundary.js';
import './voronoi_rules/near-region-seed.js';
import './voronoi_rules/neighbors-in-region.js';
import './voronoi_rules/prefer-latitude.js';

class VoronoiBuilder {
  m_generators = {
    [GeneratorType.Continent]: ContinentGenerator
  };
  m_diagram = new Diagram();
  m_diagramDims = { x: 0, y: 0 };
  m_hexDims = { x: 0, y: 0 };
  m_generator;
  m_hexTiles = new VoronoiHex();
  m_generatorType = void 0;
  constructor() {
  }
  init(mapSize, generatorType, cellCountMultiple, relaxationSteps) {
    this.m_generatorType = generatorType;
    this.m_diagramDims = { x: MapDims[mapSize].x * Math.sqrt(3) * 0.5, y: MapDims[mapSize].y * 0.75 };
    this.m_hexDims = MapDims[mapSize];
    const totalCells = MapDims[mapSize].x * MapDims[mapSize].y * cellCountMultiple;
    console.log("Initializing voronoi-builder");
    console.log("  Diagram dims: {x:" + this.m_diagramDims.x + ", y:" + this.m_diagramDims.y + "}");
    console.log("  Hex dims {x:" + this.m_hexDims.x + ", y:" + this.m_hexDims.y + "}");
    console.log("  Total cells: " + totalCells + ", relaxed " + relaxationSteps + " times.");
    this.buildVoronoi(this.m_diagramDims.x, this.m_diagramDims.y, totalCells, relaxationSteps);
    console.log("  voronoi built...");
    const newGenerator = new this.m_generators[generatorType]();
    console.log("  generator created...");
    if (!this.m_generator || this.m_generator.constructor.name != newGenerator.constructor.name) {
      this.m_generator = newGenerator;
    }
    this.m_generator.init(this.m_diagramDims, this.m_diagram, mapSize);
    console.log("  generator initialized...");
  }
  simulate() {
    this.m_generator.simulate();
    this.m_hexTiles.init(this.m_generator, this.m_hexDims.x, this.m_hexDims.y);
    this.m_hexTiles.validate();
  }
  createMajorPlayerAreas(valueFunction) {
    const playerLandmasses = [];
    for (const landmass of this.m_generator.getLandmasses()) {
      if (landmass.playerAreas > 0) {
        playerLandmasses.push(landmass);
      }
    }
    this.m_hexTiles.createMajorPlayerAreas(playerLandmasses, valueFunction);
  }
  getDiagram() {
    return this.m_diagram;
  }
  getGenerator() {
    return this.m_generator;
  }
  getGeneratorType() {
    return this.m_generatorType;
  }
  getTiles() {
    return this.m_hexTiles.getTiles();
  }
  buildVoronoi(width, height, cellCount, relaxationSteps) {
    const bbox = { xl: 0, xr: width, yt: 0, yb: height };
    const sites = VoronoiUtils.createRandomSites(cellCount, width, height);
    this.m_diagram = VoronoiUtils.computeVoronoi(sites, bbox, relaxationSteps);
  }
}

export { VoronoiBuilder };
//# sourceMappingURL=voronoi-builder.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-hex.js">
import { rotate2, add2 } from '../../core/scripts/MathHelpers.js';
import { Heap } from './heap.js';
import { kdTree } from './kd-tree.js';
import { TerrainType, BiomeType, DetailsType, VoronoiUtils } from './voronoi-utils.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';
import './random-pcg-32.js';

class HexTile {
  pos = { x: 0, y: 0 };
  coord = { x: 0, y: 0 };
  plateId = -1;
  landmassId = -1;
  elevation = 0;
  majorPlayerRegionId = -1;
  terrainType = TerrainType.Unknown;
  biomeType = BiomeType.Unknown;
  detailsType = DetailsType.None;
  visited = 0;
  // used during map creation and processing.
  isLand() {
    return this.terrainType === TerrainType.Flat || this.terrainType === TerrainType.Mountainous || this.terrainType === TerrainType.Volcano || this.terrainType === TerrainType.Rough;
  }
  isWater() {
    return this.terrainType === TerrainType.Ocean || this.terrainType === TerrainType.Coast || this.terrainType === TerrainType.NavRiver;
  }
}
var FloodFillResult = /* @__PURE__ */ ((FloodFillResult2) => {
  FloodFillResult2[FloodFillResult2["Include"] = 0] = "Include";
  FloodFillResult2[FloodFillResult2["Exclude"] = 1] = "Exclude";
  FloodFillResult2[FloodFillResult2["Halt"] = 2] = "Halt";
  return FloodFillResult2;
})(FloodFillResult || {});
class VoronoiHex {
  static POLE_MARGIN = 2;
  // guaranteed rows of ocean near poles.
  m_tiles = [];
  m_wrappedXIndices = [];
  // Saves lots of % calls
  init(generator, width, height) {
    this.m_wrappedXIndices = Array.from({ length: width * 3 }, (_, index) => index % width);
    const tree = generator.getKdTree();
    const yOffset = 0.325;
    this.m_tiles = new Array(height);
    const offsetPoint = { x: 0.736 * 0.5, y: 0 };
    const offsetPoints = [{ x: 0, y: 0 }];
    for (let i = 0; i < 6; ++i) {
      offsetPoints.push(rotate2(offsetPoint, i * Math.PI / 3));
    }
    for (let y = 0; y < height; ++y) {
      this.m_tiles[y] = new Array(width);
      const xOffset = y % 2 == 0 ? 0 : Math.sqrt(3) * 0.25;
      for (let x = 0; x < width; ++x) {
        const center = { x: xOffset + x * Math.sqrt(3) * 0.5, y: yOffset + y * 0.75 };
        const getRegionCellKey = (cell) => {
          return `${cell.terrainType}`;
        };
        const regionCells = /* @__PURE__ */ new Map();
        for (const offsetPos of offsetPoints) {
          const samplePos = add2(offsetPos, center);
          const regionCell = tree.search(samplePos);
          if (regionCell) {
            const regionCellKey = getRegionCellKey(regionCell);
            const entry = regionCells.get(regionCellKey);
            if (entry) {
              entry[0]++;
            } else {
              regionCells.set(regionCellKey, [1, regionCell]);
            }
          }
        }
        let dominantCell = null;
        let maxCount = 0;
        for (const [_key, [count, cell]] of regionCells) {
          if (count > maxCount) {
            dominantCell = cell;
            maxCount = count;
          }
        }
        const hexTile = new HexTile();
        if (dominantCell) {
          hexTile.pos = center;
          hexTile.coord = { x, y };
          hexTile.plateId = dominantCell.plateId;
          hexTile.landmassId = dominantCell.landmassId;
          hexTile.terrainType = dominantCell.terrainType;
          hexTile.biomeType = dominantCell.biomeType;
          hexTile.detailsType = dominantCell.detailsType;
        }
        this.m_tiles[y][x] = hexTile;
      }
    }
  }
  // returns neighbors in clockwise order starting from upper-right. Tiles may be undefined if near poles. Wraps in x.
  getNeighbors(tile) {
    return this.getNeighborsOfArr(tile.coord, this.m_tiles);
  }
  EvenRowDeltas = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1]
  ];
  OddRowDeltas = [
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 0],
    [0, -1]
  ];
  getNeighborsOfArr(coord, arr) {
    const deltas = coord.y % 2 === 0 ? this.EvenRowDeltas : this.OddRowDeltas;
    return deltas.map(([dx, dy]) => {
      const ny = coord.y + dy;
      if (ny < 0 || ny >= arr.length) return void 0;
      const nx = coord.x + dx + arr[0].length;
      return arr[ny][this.m_wrappedXIndices[nx]];
    });
  }
  validate() {
    this.validatePoles();
    this.validateCoasts();
    this.removeLakes();
    this.removeAdjacentVolcanoes();
    this.removeBridgingCoasts();
  }
  validatePoles() {
    for (let y = 0; y < VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        tile.terrainType = TerrainType.Ocean;
      }
    }
    for (let y = this.m_tiles.length - VoronoiHex.POLE_MARGIN; y < this.m_tiles.length; ++y) {
      for (const tile of this.m_tiles[y]) {
        tile.terrainType = TerrainType.Ocean;
      }
    }
  }
  validateCoasts() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType !== TerrainType.Ocean && tile.terrainType !== TerrainType.Coast) {
          const neighbors = this.getNeighbors(tile);
          for (const neighbor of neighbors) {
            if (neighbor && neighbor.terrainType === TerrainType.Ocean) {
              neighbor.terrainType = TerrainType.Coast;
              neighbor.landmassId = tile.landmassId;
            }
          }
        }
      }
    }
  }
  removeLakes() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType === TerrainType.Coast && !tile.visited) {
          let foundOcean = false;
          let landmassId = 0;
          const floodTiles = this.floodFill(tile, (tile2) => {
            if (tile2.terrainType === TerrainType.Coast) {
              return 0 /* Include */;
            } else if (tile2.terrainType === TerrainType.Ocean) {
              foundOcean = true;
            } else if (tile2.terrainType === TerrainType.Flat) {
              landmassId = tile2.landmassId;
            }
            return 1 /* Exclude */;
          });
          if (!foundOcean) {
            for (const tile2 of floodTiles) {
              tile2.terrainType = TerrainType.Flat;
              tile2.landmassId = landmassId;
            }
          }
        }
      }
    }
    this.clearVisited();
  }
  removeAdjacentVolcanoes() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType === TerrainType.Volcano) {
          for (const neighbor of this.getNeighbors(tile)) {
            if (neighbor?.terrainType === TerrainType.Volcano) {
              tile.terrainType = TerrainType.Mountainous;
            }
          }
        }
      }
    }
  }
  removeBridgingCoasts() {
    for (let y = VoronoiHex.POLE_MARGIN; y < this.m_tiles.length - VoronoiHex.POLE_MARGIN; ++y) {
      for (const tile of this.m_tiles[y]) {
        if (tile.terrainType === TerrainType.Coast) {
          let allNeighborsAreWater = true;
          let hasForeignNeighbor = false;
          for (const neighbor of this.getNeighbors(tile)) {
            if (neighbor?.terrainType !== TerrainType.Coast && neighbor?.terrainType !== TerrainType.Ocean) {
              allNeighborsAreWater = false;
              break;
            }
            if (neighbor.landmassId != tile.landmassId && neighbor.landmassId != 0) {
              hasForeignNeighbor = true;
            }
          }
          if (allNeighborsAreWater && hasForeignNeighbor) {
            tile.landmassId = 0;
            tile.terrainType = TerrainType.Ocean;
          }
        }
      }
    }
  }
  createMajorPlayerAreas(landmasses, valueFunction) {
    console.log("Creating major player regions...");
    const detailedLogs = false;
    VoronoiUtils.performanceMarker("createMajorPlayerAreas - Begin");
    for (const landmass of landmasses) {
      console.log(`Requesting ${landmass.playerAreas} player areas on landmass ${landmass.id}`);
      if (landmass.playerAreas == 0) continue;
      let landmassTiles = this.m_tiles.flatMap(
        (row) => row.filter((tile) => tile.landmassId === landmass.id)
      );
      const tileIsPassable = (tile) => {
        return tile.terrainType != TerrainType.Mountainous && tile.terrainType != TerrainType.Volcano && tile.terrainType != TerrainType.Ocean;
      };
      const floodBucket = [];
      for (const tile of landmassTiles) {
        if (!tile.visited) {
          floodBucket.push(
            this.floodFill(
              tile,
              (tile2) => tileIsPassable(tile2) ? 0 /* Include */ : 1 /* Exclude */
            )
          );
        }
      }
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        tile.majorPlayerRegionId = -1;
      });
      landmassTiles = floodBucket.sort((a, b) => b.length - a.length)[0];
      if (landmass.playerAreas == 1) {
        landmassTiles.forEach((tile) => tile.majorPlayerRegionId = 0);
        continue;
      }
      const landmassKdTree = new kdTree((tile) => tile.pos);
      landmassKdTree.build(landmassTiles);
      class SeedTile {
        tile;
        count;
      }
      const seedTiles = new Array(landmass.playerAreas);
      for (let i = 0; i < landmass.playerAreas; ++i) {
        seedTiles[i] = {
          tile: landmassTiles[i * Math.floor(landmassTiles.length / landmass.playerAreas)],
          count: 0
        };
      }
      const getAverageRegionPositions = (seedTiles2) => {
        for (let j = 0; j < seedTiles2.length; ++j) {
          const totalPos = { x: 0, y: 0 };
          const tilesForSeed = landmassTiles.filter((tile) => tile.majorPlayerRegionId == j);
          tilesForSeed.forEach((tile) => {
            totalPos.x += tile.pos.x;
            totalPos.y += tile.pos.y;
          });
          const averagePos = {
            x: totalPos.x / tilesForSeed.length,
            y: totalPos.y / tilesForSeed.length
          };
          seedTiles2[j] = { tile: landmassKdTree.search(averagePos), count: 0 };
        }
      };
      const relaxationSteps = 10;
      let lastSizeDiff = Infinity;
      for (let i = 0; i < relaxationSteps; ++i) {
        for (const tile of landmassTiles) {
          let bestRegion = 0;
          let closestDistSq = VoronoiUtils.sqDistance(seedTiles[0].tile.pos, tile.pos);
          for (let j = 1; j < seedTiles.length; ++j) {
            const distSq = VoronoiUtils.sqDistance(seedTiles[j].tile.pos, tile.pos);
            if (distSq < closestDistSq) {
              bestRegion = j;
              closestDistSq = distSq;
            }
          }
          tile.majorPlayerRegionId = bestRegion;
          ++seedTiles[bestRegion].count;
        }
        const counts = seedTiles.map((seedTile) => seedTile.count);
        const sizeDiff = Math.max(...counts) - Math.min(...counts);
        if (detailedLogs) {
          console.log("Player region sizes: " + counts.join(", ") + ". Total size difference: " + sizeDiff);
        }
        if (Math.abs(lastSizeDiff - sizeDiff) < 5) {
          break;
        }
        lastSizeDiff = sizeDiff;
        getAverageRegionPositions(seedTiles);
      }
      landmassTiles.forEach((tile) => tile.majorPlayerRegionId = -1);
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - K-means clustering done");
      class ScoredTile {
        tile;
        scores = new Array(playerRegions.length).fill(-1);
        expScores = new Array(playerRegions.length).fill(-1);
        expSum = 0;
        constructor(tile) {
          this.tile = tile;
        }
      }
      class MajorPlayerRegion {
        id = 0;
        totalValue = 0;
        centerPos = { x: 0, y: 0 };
        considerationHeap;
        finalSet = /* @__PURE__ */ new Set();
        borderSet = Array.from({ length: landmass.playerAreas }, () => /* @__PURE__ */ new Set());
      }
      const playerRegions = Array.from({ length: seedTiles.length }, () => new MajorPlayerRegion());
      const scoredTiles = this.m_tiles.map((row) => row.map((item) => new ScoredTile(item)));
      const getScoredTile = (tile) => scoredTiles[tile.coord.y][tile.coord.x];
      const getTileCost = (tile) => {
        return [TerrainType.Coast, TerrainType.NavRiver, TerrainType.Rough].includes(tile.terrainType) ? 2 : 1;
      };
      for (let playerRegionId = 0; playerRegionId < playerRegions.length; ++playerRegionId) {
        const playerRegionBit = 1 << playerRegionId;
        const initialTile = getScoredTile(seedTiles[playerRegionId].tile);
        initialTile.scores[playerRegionId] = 0;
        const considerationHeap = new Heap(
          (a, b) => a.scores[playerRegionId] - b.scores[playerRegionId]
        );
        considerationHeap.push(initialTile);
        while (considerationHeap.size > 0) {
          const bestTile = considerationHeap.pop();
          for (const neighbor of this.getNeighbors(bestTile.tile)) {
            if (neighbor && (neighbor.visited & playerRegionBit) == 0) {
              neighbor.visited |= playerRegionBit;
              const scoredNeighbor = getScoredTile(neighbor);
              scoredNeighbor.scores[playerRegionId] = bestTile.scores[playerRegionId] + getTileCost(neighbor);
              considerationHeap.push(scoredNeighbor);
            }
          }
        }
      }
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        const scoredTile = getScoredTile(tile);
        const softMaxTemp = 5;
        scoredTile.expScores = scoredTile.scores.map((s) => Math.exp(-s / softMaxTemp));
        scoredTile.expSum = scoredTile.expScores.reduce((a, b) => a + b, 0);
      });
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Scoring Done");
      let majorPlayerRegionId = 0;
      for (const region of playerRegions) {
        const seedTile = seedTiles[majorPlayerRegionId].tile;
        const scoredSeedTile = getScoredTile(seedTile);
        scoredSeedTile.scores[majorPlayerRegionId] = 0;
        scoredSeedTile.tile.visited = 1 << majorPlayerRegionId;
        region.id = majorPlayerRegionId;
        region.considerationHeap = new Heap((a, b) => {
          const scoreA = a.expScores[region.id] / a.expSum;
          const scoreB = b.expScores[region.id] / b.expSum;
          return scoreB - scoreA;
        });
        region.considerationHeap.push(scoredSeedTile);
        region.centerPos = seedTile.pos;
        ++majorPlayerRegionId;
      }
      const scoringRegions = [...playerRegions];
      while (scoringRegions.length > 0) {
        for (const scoringRegion of scoringRegions) {
          let bestTile = void 0;
          while (bestTile === void 0 && scoringRegion.considerationHeap.size > 0) {
            bestTile = scoringRegion.considerationHeap.pop();
            if (bestTile.tile.majorPlayerRegionId != -1) {
              bestTile = void 0;
            }
          }
          if (bestTile === void 0) {
            scoringRegions.splice(scoringRegions.indexOf(scoringRegion), 1);
            continue;
          }
          bestTile.tile.majorPlayerRegionId = scoringRegion.id;
          scoringRegion.finalSet.add(bestTile.tile);
          const regionBit = 1 << scoringRegion.id;
          for (const neighbor of this.getNeighborsOfArr(bestTile.tile.coord, scoredTiles)) {
            if (neighbor?.tile.majorPlayerRegionId == -1 && (neighbor.tile.visited & regionBit) == 0) {
              neighbor.tile.visited |= regionBit;
              if (tileIsPassable(neighbor.tile)) {
                scoringRegion.considerationHeap.push(neighbor);
              }
            }
          }
        }
      }
      const getTileValue = valueFunction ? valueFunction : (tile) => {
        switch (tile.terrainType) {
          case TerrainType.Coast:
            return 0.5;
          default:
            return 1;
        }
      };
      landmassTiles.forEach((tile) => {
        tile.visited = 0;
        if (tile.majorPlayerRegionId >= 0) {
          playerRegions[tile.majorPlayerRegionId].totalValue += getTileValue(tile);
        }
      });
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Initial Growth Done");
      console.log(
        `After initial growth, region sizes are: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] and vales are: [${playerRegions.map((region) => region.totalValue).join(", ")}]`
      );
      class Border {
        regionId1 = -1;
        regionId2 = -1;
        count = 1;
        constructor(regionId1, regionId2) {
          [this.regionId1, this.regionId2] = [regionId1, regionId2];
          this.count = 1;
        }
        regionValueDiff() {
          return Math.abs(
            //playerRegions[this.regionId1].finalSet.size - playerRegions[this.regionId2].finalSet.size,
            playerRegions[this.regionId1].totalValue - playerRegions[this.regionId2].totalValue
          );
        }
        isSame(regionId1, regionId2) {
          return this.regionId1 == regionId1 && this.regionId2 == regionId2 || this.regionId2 == regionId1 && this.regionId1 == regionId2;
        }
        getOrderedRegions() {
          return playerRegions[this.regionId1].totalValue < playerRegions[this.regionId2].totalValue ? [this.regionId1, this.regionId2] : [this.regionId2, this.regionId1];
        }
      }
      const borders = [];
      const addBorder = (regionId1, regionId2) => {
        const existingBorder = borders.find(
          (border) => border.isSame(regionId1, regionId2)
        );
        if (existingBorder) {
          ++existingBorder.count;
        } else {
          borders.push(new Border(regionId1, regionId2));
        }
      };
      const getBorderNeighbors = (tile) => {
        const borderNeighbors = [];
        for (const neighbor of this.getNeighbors(tile)) {
          if (neighbor && neighbor.majorPlayerRegionId != -1 && neighbor.majorPlayerRegionId != tile.majorPlayerRegionId) {
            borderNeighbors.push(neighbor);
          }
        }
        return borderNeighbors;
      };
      const isBridgeForRegion = (tile) => {
        const regions = this.getNeighbors(tile).map(
          (n) => n == void 0 || n.majorPlayerRegionId != tile.majorPlayerRegionId ? 0 : 1
        );
        let lastRegionId = regions[0];
        let nonRegionBlobs = 1 - lastRegionId;
        let regionBlobs = lastRegionId;
        for (let i = 1; i < regions.length; ++i) {
          const regionId = regions[i];
          if (lastRegionId == 0 && regionId == 1) ++regionBlobs;
          else if (lastRegionId == 1 && regionId == 0) ++nonRegionBlobs;
          lastRegionId = regionId;
        }
        return nonRegionBlobs > 1 && regionBlobs > 1;
      };
      for (const tile of landmassTiles) {
        if (tile.majorPlayerRegionId == -1) {
          continue;
        }
        const region = playerRegions[tile.majorPlayerRegionId];
        const borderNeighbors = getBorderNeighbors(tile);
        for (const neighbor of borderNeighbors) {
          region.borderSet[neighbor.majorPlayerRegionId].add(tile);
          addBorder(tile.majorPlayerRegionId, neighbor.majorPlayerRegionId);
        }
      }
      const borderSorter = (a, b) => {
        return b.regionValueDiff() - a.regionValueDiff();
      };
      borders.sort(borderSorter);
      if (borders.length === 0) {
        console.warn(
          "No borders found between player regions, unable to balance the size of player starting areas."
        );
        return;
      }
      let count = 0;
      while (borders[0].regionValueDiff() > 1 && count < 100) {
        ++count;
        let bestScore = -Infinity;
        let bestSteal;
        let bestSource;
        let [smallRegionId, bigRegionId] = borders[0].getOrderedRegions();
        let [smallRegion, bigRegion] = [playerRegions[smallRegionId], playerRegions[bigRegionId]];
        let i = 0;
        let border = borders[i];
        while (bestSteal == void 0 && i < borders.length) {
          border = borders[i];
          ++i;
          bestScore = -Infinity;
          [smallRegionId, bigRegionId] = border.getOrderedRegions();
          [smallRegion, bigRegion] = [playerRegions[smallRegionId], playerRegions[bigRegionId]];
          for (const borderTile of smallRegion.borderSet[bigRegionId]) {
            for (const neighbor of getBorderNeighbors(borderTile)) {
              if (neighbor.majorPlayerRegionId == bigRegionId) {
                const neighborPairTile = getScoredTile(neighbor);
                const neighborValue = getTileValue(neighborPairTile.tile);
                const bigRegionScore = neighborPairTile.scores[bigRegionId] - neighborValue;
                const smallRegionScore = neighborPairTile.scores[smallRegionId] - neighborValue;
                const swapScore = bigRegionScore - smallRegionScore;
                if (swapScore > bestScore && !isBridgeForRegion(neighbor) && // doesn't cut region in two
                borders[0].regionValueDiff() - neighborValue > 0) {
                  bestScore = swapScore;
                  bestSteal = neighbor;
                  bestSource = borderTile;
                }
              }
            }
          }
        }
        if (bestSteal != void 0 && bestSource != void 0) {
          if (detailedLogs) {
            console.log(
              `Stealing (${bestSteal.coord.x}, ${bestSteal.coord.y}) from region ${bestSteal.majorPlayerRegionId} to region ${bestSource.majorPlayerRegionId} with score ${bestScore}`
            );
          }
          border.count -= getBorderNeighbors(bestSteal).length;
          {
            const bestStealValue = getTileValue(bestSteal);
            let count2 = 0;
            for (const borderSet of bigRegion.borderSet) {
              count2 += Number(borderSet.delete(bestSteal));
            }
            if (count2 == 0) throw new Error();
            if (!bigRegion.finalSet.delete(bestSteal)) throw new Error();
            bigRegion.totalValue -= bestStealValue;
            bestSteal.majorPlayerRegionId = smallRegionId;
            count2 = 0;
            for (const neighbor of getBorderNeighbors(bestSteal)) {
              if (neighbor.majorPlayerRegionId != smallRegion.id) {
                smallRegion.borderSet[neighbor.majorPlayerRegionId].add(bestSteal);
                ++count2;
              }
            }
            if (count2 == 0) throw new Error();
            smallRegion.finalSet.add(bestSteal);
            smallRegion.totalValue += bestStealValue;
            const borderNeighbors = getBorderNeighbors(bestSteal);
            for (const neighbor of borderNeighbors) {
              addBorder(smallRegionId, neighbor.majorPlayerRegionId);
              bigRegion.borderSet[smallRegionId].add(neighbor);
            }
          }
          if (getBorderNeighbors(bestSource).length == 0) {
            if (!smallRegion.borderSet[bigRegionId].delete(bestSource)) throw new Error();
          }
          if (border.count == 0) {
            VoronoiUtils.swapAndPop(borders, i - 1);
            borders.sort(borderSorter);
          }
          for (let i2 = 0; i2 < borders.length - 1; ++i2) {
            if (borders[i2].regionValueDiff() < borders[i2 + 1].regionValueDiff()) {
              [borders[i2], borders[i2 + 1]] = [borders[i2 + 1], borders[i2]];
            } else {
              break;
            }
          }
        } else {
          break;
        }
        if (detailedLogs) {
          console.log(`  Region sizes: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] `);
          console.log(`  Region values: [${playerRegions.map((region) => region.totalValue).join(", ")}] `);
          console.log(
            `  Borders: [${borders.map((border2) => "([" + border2.getOrderedRegions()[0] + ", " + border2.getOrderedRegions()[1] + "], diff: " + border2.regionValueDiff() + ", count: " + border2.count + ")").join(", ")}] `
          );
        }
      }
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Region Area Balancing Done");
      for (const region of playerRegions) {
        const inBorderTiles = /* @__PURE__ */ new Set();
        region.finalSet.forEach((tile) => {
          if (getBorderNeighbors(tile).length > 0) inBorderTiles.add(getScoredTile(tile));
        });
        const outBorderTiles = Array.from(
          { length: playerRegions.length },
          () => /* @__PURE__ */ new Set()
        );
        for (const tile of inBorderTiles) {
          for (const neighbor of getBorderNeighbors(tile.tile)) {
            outBorderTiles[neighbor.majorPlayerRegionId].add(getScoredTile(neighbor));
          }
        }
        while (true) {
          const regionPairs = /* @__PURE__ */ new Map();
          for (const inTile2 of inBorderTiles) {
            if (isBridgeForRegion(inTile2.tile)) {
              continue;
            }
            const borderRegions = [];
            for (const neighbor of getBorderNeighbors(inTile2.tile)) {
              if (borderRegions.indexOf(neighbor.majorPlayerRegionId) == -1) {
                borderRegions.push(neighbor.majorPlayerRegionId);
              }
            }
            for (const regionId of borderRegions) {
              let bestTradeScore = 0;
              let bestTradeTile;
              for (const outTile2 of outBorderTiles[regionId]) {
                const inTileValue = getTileValue(inTile2.tile);
                const outTileValue = getTileValue(outTile2.tile);
                const tileValueDiff = inTileValue - outTileValue;
                const scoreBefore = inTile2.scores[region.id] + outTile2.scores[outTile2.tile.majorPlayerRegionId] + tileValueDiff;
                const scoreAfter = inTile2.scores[outTile2.tile.majorPlayerRegionId] + outTile2.scores[region.id] - tileValueDiff;
                const tradeScore = scoreBefore - scoreAfter;
                if (tradeScore > bestTradeScore && !isBridgeForRegion(outTile2.tile)) {
                  bestTradeScore = tradeScore;
                  bestTradeTile = outTile2;
                }
              }
              if (bestTradeTile != void 0) {
                const tradeCandidate = regionPairs.get(regionId);
                if (tradeCandidate == void 0) {
                  regionPairs.set(regionId, {
                    inside: inTile2,
                    outside: bestTradeTile,
                    delta: bestTradeScore
                  });
                } else if (tradeCandidate.delta < bestTradeScore) {
                  tradeCandidate.inside = inTile2;
                  tradeCandidate.outside = bestTradeTile;
                  tradeCandidate.delta = bestTradeScore;
                }
              }
            }
          }
          if (regionPairs.size == 0) {
            break;
          }
          let bestTradeCandidate;
          for (const [_key, value] of regionPairs) {
            if (bestTradeCandidate == void 0 || bestTradeCandidate.delta < value.delta) {
              bestTradeCandidate = value;
            }
          }
          let [inTile, outTile] = [bestTradeCandidate.inside, bestTradeCandidate.outside];
          if (inTile.tile.majorPlayerRegionId == outTile.tile.majorPlayerRegionId) throw new Error("");
          {
            const scoreBefore = inTile.scores[region.id] + outTile.scores[outTile.tile.majorPlayerRegionId];
            const scoreAfter = inTile.scores[outTile.tile.majorPlayerRegionId] + outTile.scores[region.id];
            if (detailedLogs) {
              console.log(
                `Trading (${inTile.tile.coord.x}, ${inTile.tile.coord.y}), region: ${inTile.tile.majorPlayerRegionId} with (${outTile.tile.coord.x}, ${outTile.tile.coord.y}), region: ${outTile.tile.majorPlayerRegionId} to improve total score from ${scoreBefore} to ${scoreAfter} `
              );
            }
          }
          if (!inBorderTiles.delete(inTile)) throw new Error();
          if (!outBorderTiles[outTile.tile.majorPlayerRegionId].delete(outTile)) throw new Error();
          if (!playerRegions[inTile.tile.majorPlayerRegionId].finalSet.delete(inTile.tile)) throw new Error();
          if (!playerRegions[outTile.tile.majorPlayerRegionId].finalSet.delete(outTile.tile))
            throw new Error();
          playerRegions[inTile.tile.majorPlayerRegionId].totalValue -= getTileValue(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].totalValue -= getTileValue(outTile.tile);
          [inTile.tile.majorPlayerRegionId, outTile.tile.majorPlayerRegionId] = [
            outTile.tile.majorPlayerRegionId,
            inTile.tile.majorPlayerRegionId
          ];
          [inTile, outTile] = [outTile, inTile];
          if (inTile.tile.majorPlayerRegionId != region.id) throw new Error("");
          inBorderTiles.add(inTile);
          outBorderTiles[outTile.tile.majorPlayerRegionId].add(outTile);
          playerRegions[inTile.tile.majorPlayerRegionId].finalSet.add(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].finalSet.add(outTile.tile);
          playerRegions[inTile.tile.majorPlayerRegionId].totalValue += getTileValue(inTile.tile);
          playerRegions[outTile.tile.majorPlayerRegionId].totalValue += getTileValue(outTile.tile);
          for (const neighbor of this.getNeighbors(inTile.tile)) {
            if (neighbor && getBorderNeighbors(neighbor).length == 0) {
              inBorderTiles.delete(getScoredTile(neighbor));
            }
          }
          for (const neighbor of this.getNeighbors(outTile.tile)) {
            if (neighbor && getBorderNeighbors(neighbor).length == 0) {
              outBorderTiles[neighbor.majorPlayerRegionId].delete(getScoredTile(neighbor));
            }
          }
        }
      }
      this.m_tiles.forEach((row) => row.forEach((tile) => tile.visited = 0));
      VoronoiUtils.performanceMarker("createMajorPlayerAreas - Region Optimizing Done");
      console.log(
        `"Finished creating major player regions for landmass ${landmass.id}, region sizes are: [${playerRegions.map((region) => region.finalSet.size).join(", ")}] and vales are: [${playerRegions.map((region) => region.totalValue).join(", ")}]`
      );
    }
  }
  floodFill(initialTile, considerCallback) {
    initialTile.visited = 1;
    const considerationList = [initialTile];
    const returnList = [];
    while (considerationList.length > 0) {
      const tile = considerationList.pop();
      returnList.push(tile);
      const neighbors = this.getNeighbors(tile);
      for (const neighbor of neighbors) {
        if (neighbor && !neighbor.visited) {
          neighbor.visited = 1;
          const result = considerCallback(neighbor);
          switch (result) {
            case 0 /* Include */:
              considerationList.push(neighbor);
              break;
            case 2 /* Halt */:
              return returnList;
          }
        }
      }
    }
    return returnList;
  }
  clearVisited() {
    for (const row of this.m_tiles) {
      for (const tile of row) {
        tile.visited = 0;
      }
    }
  }
  getTiles() {
    return this.m_tiles;
  }
}

export { HexTile, VoronoiHex };
//# sourceMappingURL=voronoi-hex.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-plate.js">
class VoronoiPlate {
  m_center = { x: 0, y: 0 };
  m_direction = { x: 0, y: 0 };
  m_rotation = 0;
}

export { VoronoiPlate };
//# sourceMappingURL=voronoi-plate.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-region.js">
import { RandomImpl } from './random-pcg-32.js';
import { VoronoiUtils } from './voronoi-utils.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

class IdScorePair {
  id = 0;
  score = 0;
}
class VoronoiRegion {
  name = "";
  id = 0;
  type = 0;
  maxArea = 0;
  playerAreas = 0;
  color = { x: 0, y: 0, z: 0 };
  seedLocation = { x: 0, y: 0 };
  considerationList = [];
  scoringContext;
  colorString = "";
  quadTree;
  constructor(name, id, type, maxArea, playerAreas, color) {
    this.name = name;
    this.id = id;
    this.type = type;
    this.maxArea = maxArea;
    this.playerAreas = playerAreas;
    this.color = color;
    const r = Math.floor(color.x * 255);
    const g = Math.floor(color.y * 255);
    const b = Math.floor(color.z * 255);
    this.colorString = "rgb(" + r + " ," + g + ", " + b + ")";
  }
  prepareGrowth(regionCells, regions, rules, worldDims, plateRegions) {
    this.scoringContext = {
      cells: regionCells,
      region: this,
      regions,
      plateRegions,
      m_worldDims: { x: worldDims.x, y: worldDims.y },
      totalArea: 0,
      cellCount: 0,
      rules
    };
    for (const rule of Object.values(rules)) {
      rule.prepare();
    }
    regionCells.forEach((cell) => {
      cell.regionConsiderationBits = 0n;
    });
    this.quadTree = void 0;
  }
  growStep() {
    let newCellIndex = 0;
    const regionCells = this.scoringContext.cells;
    for (let i = 0; i < this.considerationList.length; ) {
      const cell = regionCells[this.considerationList[i].id];
      if (this.isCellClaimed(cell)) {
        VoronoiUtils.swapAndPop(this.considerationList, i);
        continue;
      }
      if (this.considerationList[i].score > this.considerationList[newCellIndex].score) {
        newCellIndex = i;
      }
      ++i;
    }
    if (this.considerationList.length == 0 || this.considerationList[newCellIndex].score < 0) {
      return false;
    }
    const newCellId = this.considerationList[newCellIndex].id;
    VoronoiUtils.swapAndPop(this.considerationList, newCellIndex);
    const newCell = regionCells[newCellId];
    this.setRegionIdForCell(newCell, this.id, this.scoringContext);
    this.scoringContext.totalArea += newCell.area;
    this.scoringContext.cellCount++;
    if (this.quadTree) {
      this.quadTree.insert(newCell);
    }
    this.scoringContext.rules.forEach((rule) => rule.notifySelectedCell(newCell, this.scoringContext));
    for (const neighborId of newCell.cell.getNeighborIds()) {
      const neighbor = regionCells[neighborId];
      if (this.isCellClaimed(neighbor)) {
        continue;
      }
      const score = this.scoreCell(neighbor, this.scoringContext);
      if (neighbor.regionConsiderationBits & BigInt(1 << this.id)) {
        const index = this.considerationList.findIndex((value) => value.id === neighborId);
        this.considerationList[index].score = score;
      } else {
        this.considerationList.push({ id: neighborId, score });
      }
    }
    return this.considerationList.length > 0 && this.scoringContext.totalArea < this.maxArea;
  }
  logStats() {
    console.log(
      "Region " + this.id + " total area: " + this.scoringContext?.totalArea + ", cell count: " + this.scoringContext?.cellCount
    );
  }
  getColorString() {
    return this.colorString;
  }
  scoreCell(regionCell, scoringContext) {
    let score = 0;
    for (const rule of Object.values(scoringContext.rules)) {
      if (rule.isActive) {
        score += rule.score(regionCell, scoringContext) * rule.weight;
      }
    }
    return score;
  }
  scoreSingleCell(regionCell) {
    return this.scoreCell(regionCell, this.scoringContext);
  }
  SetQuadTree(quadtree) {
    this.quadTree = quadtree;
  }
}
class LandmassRegion extends VoronoiRegion {
  setRegionIdForCell(cell, id, scoringContext) {
    cell.landmassId = id;
    cell.landmassOrder = scoringContext.cellCount;
  }
  getRegionIdForCell(cell) {
    return cell.landmassId;
  }
  isCellClaimed(cell) {
    return cell.landmassId != 0;
  }
}
class PlateRegion extends VoronoiRegion {
  m_movement = { x: 0, y: 0 };
  m_rotation = 0;
  constructor(name, id, type, maxArea, color) {
    super(name, id, type, maxArea, 0, color);
    const dir = RandomImpl.fRand("Plate Movement Direction") * Math.PI * 2;
    const movementSpeed = RandomImpl.fRand("Plate Movement Speed");
    this.m_movement.x = Math.cos(dir) * movementSpeed;
    this.m_movement.y = Math.sin(dir) * movementSpeed;
    this.m_rotation = RandomImpl.fRand("Plate Rotation") * 2 - 1;
  }
  setRegionIdForCell(cell, id, scoringContext) {
    cell.plateId = id;
    cell.plateOrder = scoringContext.cellCount;
  }
  getRegionIdForCell(cell) {
    return cell.plateId;
  }
  isCellClaimed(cell) {
    return cell.plateId != -1;
  }
}

export { LandmassRegion, PlateRegion, VoronoiRegion };
//# sourceMappingURL=voronoi-region.js.map
</file>

<file path="mod/maps/base-standard/scripts/voronoi-utils.js">
import { Voronoi } from '../../core/scripts/external/TypeScript-Voronoi-master/src/voronoi.js';
import { RandomImpl } from './random-pcg-32.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/rbtree.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/vertex.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/edge.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/cell.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/diagram.js';
import '../../core/scripts/external/TypeScript-Voronoi-master/src/halfedge.js';

var MapSize = /* @__PURE__ */ ((MapSize2) => {
  MapSize2[MapSize2["Tiny"] = 0] = "Tiny";
  MapSize2[MapSize2["Small"] = 1] = "Small";
  MapSize2[MapSize2["Standard"] = 2] = "Standard";
  MapSize2[MapSize2["Large"] = 3] = "Large";
  MapSize2[MapSize2["Huge"] = 4] = "Huge";
  return MapSize2;
})(MapSize || {});
const MapDims = {
  [0 /* Tiny */]: { x: 60, y: 38 },
  [1 /* Small */]: { x: 74, y: 46 },
  [2 /* Standard */]: { x: 84, y: 54 },
  [3 /* Large */]: { x: 96, y: 60 },
  [4 /* Huge */]: { x: 106, y: 66 }
};
var RegionType = /* @__PURE__ */ ((RegionType2) => {
  RegionType2[RegionType2["None"] = 0] = "None";
  RegionType2[RegionType2["Ocean"] = 1] = "Ocean";
  RegionType2[RegionType2["Landmass"] = 2] = "Landmass";
  RegionType2[RegionType2["Island"] = 3] = "Island";
  RegionType2[RegionType2["CoastalIsland"] = 4] = "CoastalIsland";
  RegionType2[RegionType2["_Length"] = 5] = "_Length";
  return RegionType2;
})(RegionType || {});
var TerrainType = /* @__PURE__ */ ((TerrainType2) => {
  TerrainType2[TerrainType2["Unknown"] = 0] = "Unknown";
  TerrainType2[TerrainType2["Ocean"] = 1] = "Ocean";
  TerrainType2[TerrainType2["Coast"] = 2] = "Coast";
  TerrainType2[TerrainType2["Flat"] = 3] = "Flat";
  TerrainType2[TerrainType2["Rough"] = 4] = "Rough";
  TerrainType2[TerrainType2["Mountainous"] = 5] = "Mountainous";
  TerrainType2[TerrainType2["Volcano"] = 6] = "Volcano";
  TerrainType2[TerrainType2["NavRiver"] = 7] = "NavRiver";
  TerrainType2[TerrainType2["_Length"] = 8] = "_Length";
  return TerrainType2;
})(TerrainType || {});
var BiomeType = /* @__PURE__ */ ((BiomeType2) => {
  BiomeType2[BiomeType2["Unknown"] = 0] = "Unknown";
  BiomeType2[BiomeType2["Ocean"] = 1] = "Ocean";
  BiomeType2[BiomeType2["Desert"] = 2] = "Desert";
  BiomeType2[BiomeType2["Grassland"] = 3] = "Grassland";
  BiomeType2[BiomeType2["Plains"] = 4] = "Plains";
  BiomeType2[BiomeType2["Tropical"] = 5] = "Tropical";
  BiomeType2[BiomeType2["Tundra"] = 6] = "Tundra";
  BiomeType2[BiomeType2["_Length"] = 7] = "_Length";
  return BiomeType2;
})(BiomeType || {});
var DetailsType = /* @__PURE__ */ ((DetailsType2) => {
  DetailsType2[DetailsType2["None"] = 0] = "None";
  DetailsType2[DetailsType2["MinorRiver"] = 1] = "MinorRiver";
  DetailsType2[DetailsType2["Wet"] = 2] = "Wet";
  DetailsType2[DetailsType2["Vegetated"] = 3] = "Vegetated";
  DetailsType2[DetailsType2["Floodplain"] = 4] = "Floodplain";
  DetailsType2[DetailsType2["Snow"] = 5] = "Snow";
  DetailsType2[DetailsType2["_Length"] = 6] = "_Length";
  return DetailsType2;
})(DetailsType || {});
class RegionCell {
  id = 0;
  cell;
  area = 0;
  landmassId = 0;
  landmassOrder = 0;
  plateId = -1;
  plateOrder = 0;
  elevation = 0;
  terrainType = 0 /* Unknown */;
  biomeType = 0 /* Unknown */;
  detailsType = 0 /* None */;
  regionConsiderationBits = 0n;
  // helps avoid a set lookup when on a region's consideration heap during processing.
  ruleConsideration = false;
  // used by individual rules. Rule should clear back to false after each use.
  currentScore = 0;
  // can hold a current score temporarily, but should be zeroed out between operations.
  constructor(cell, id, area) {
    this.cell = cell;
    this.id = id;
    this.area = area;
  }
  reset() {
    this.landmassId = 0;
    this.landmassOrder = 0;
    this.plateId = -1;
    this.plateOrder = 0;
    this.elevation = 0;
    this.terrainType = 0 /* Unknown */;
    this.biomeType = 0 /* Unknown */;
    this.detailsType = 0 /* None */;
  }
}
const RegionCellPosGetter = (cell) => {
  return { x: cell.cell.site.x, y: cell.cell.site.y };
};
class PlateBoundary {
  pos = { x: 0, y: 0 };
  normal = { x: 0, y: 0 };
  plateSubduction = 0;
  plateSliding = 0;
  id1 = 0;
  id2 = 0;
}
const PlateBoundaryPosGetter = (data) => {
  return { x: data.pos.x, y: data.pos.y };
};
var VoronoiUtils;
((VoronoiUtils2) => {
  function voronoiCentroid(cell) {
    const site = { x: 0, y: 0, id: 0 };
    for (const halfedge of cell.halfedges) {
      site.x += halfedge.getStartpoint().x;
      site.y += halfedge.getStartpoint().y;
    }
    site.x /= cell.halfedges.length;
    site.y /= cell.halfedges.length;
    return site;
  }
  VoronoiUtils2.voronoiCentroid = voronoiCentroid;
  function lloydRelaxation(cells, strength) {
    return cells.map((cell) => {
      const centerSite = voronoiCentroid(cell);
      const newX = cell.site.x + strength * (centerSite.x - cell.site.x);
      const newY = cell.site.y + strength * (centerSite.y - cell.site.y);
      return {
        id: 0,
        x: newX,
        y: newY
      };
    });
  }
  VoronoiUtils2.lloydRelaxation = lloydRelaxation;
  function computeVoronoi(sites, bbox, relaxationSteps) {
    const voronoi = new Voronoi();
    let diagram = voronoi.compute(sites, bbox);
    for (let index = 0; index < relaxationSteps; index++) {
      sites = lloydRelaxation(diagram.cells, 1);
      voronoi.toRecycle = diagram;
      diagram = voronoi.compute(sites, bbox);
    }
    return diagram;
  }
  VoronoiUtils2.computeVoronoi = computeVoronoi;
  function createRandomSites(count, maxX, maxY) {
    return Array.from({ length: count }, () => ({
      id: 0,
      x: RandomImpl.fRand("Voronoi Site X") * maxX,
      y: RandomImpl.fRand("Voronoi Site Y") * maxY
    }));
  }
  VoronoiUtils2.createRandomSites = createRandomSites;
  function dot(dir1, dir2) {
    return dir1.x * dir2.x + dir1.y * dir2.y;
  }
  VoronoiUtils2.dot = dot;
  function crossZ(dir1, dir2) {
    return dir1.x * dir2.y - dir1.y * dir2.x;
  }
  VoronoiUtils2.crossZ = crossZ;
  function lerp(a, b, t) {
    return a + t * (b - a);
  }
  VoronoiUtils2.lerp = lerp;
  function normalize(v) {
    const len = Math.sqrt(v.x * v.x + v.y * v.y);
    return { x: v.x / len, y: v.y / len };
  }
  VoronoiUtils2.normalize = normalize;
  function iLerp(a, b, t) {
    return (t - a) / (b - a);
  }
  VoronoiUtils2.iLerp = iLerp;
  function clamp(a, min, max) {
    const lowerClamp = Math.max(a, min);
    return Math.min(lowerClamp, max);
  }
  VoronoiUtils2.clamp = clamp;
  function pointInsideCell(cell, point) {
    for (const halfEdge of cell.halfedges) {
      const ept1 = halfEdge.getStartpoint();
      const ept2 = halfEdge.getEndpoint();
      const edgeDir = { x: ept2.x - ept1.x, y: ept2.y - ept1.y };
      const ptDir = { x: point.x - ept1.x, y: point.y - ept1.y };
      if (crossZ(edgeDir, ptDir) > 0) {
        return false;
      }
    }
    return true;
  }
  VoronoiUtils2.pointInsideCell = pointInsideCell;
  function calculateCellArea(cell) {
    let area = 0;
    for (const halfedge of cell.halfedges) {
      const pt1 = halfedge.getStartpoint();
      const pt2 = halfedge.getEndpoint();
      area += pt1.x * pt2.y - pt2.x * pt1.y;
    }
    return area * -0.5;
  }
  VoronoiUtils2.calculateCellArea = calculateCellArea;
  function sqDistance(pt1, pt2) {
    const xDiff = pt1.x - pt2.x;
    const yDiff = pt1.y - pt2.y;
    return xDiff * xDiff + yDiff * yDiff;
  }
  VoronoiUtils2.sqDistance = sqDistance;
  function sqDistanceBetweenSites(site1, site2) {
    return sqDistance({ x: site1.x, y: site1.y }, { x: site2.x, y: site2.y });
  }
  VoronoiUtils2.sqDistanceBetweenSites = sqDistanceBetweenSites;
  function distanceBetweenSites(site1, site2) {
    return Math.sqrt(sqDistance({ x: site1.x, y: site1.y }, { x: site2.x, y: site2.y }));
  }
  VoronoiUtils2.distanceBetweenSites = distanceBetweenSites;
  function defaultEnumRecord(e) {
    const obj = {};
    for (const k of Object.values(e)) {
      if (typeof k === "number") obj[k] = {};
    }
    return obj;
  }
  VoronoiUtils2.defaultEnumRecord = defaultEnumRecord;
  function shuffle(arr, count = arr.length) {
    for (let i = 0; i < count; ++i) {
      const idx = RandomImpl.getRandomNumber(arr.length - i, "Shuffle Idx") + i;
      [arr[i], arr[idx]] = [arr[idx], arr[i]];
    }
  }
  VoronoiUtils2.shuffle = shuffle;
  let RegionCellFilterResult;
  ((RegionCellFilterResult2) => {
    RegionCellFilterResult2[RegionCellFilterResult2["Continue"] = 0] = "Continue";
    RegionCellFilterResult2[RegionCellFilterResult2["HaltSuccess"] = 1] = "HaltSuccess";
    RegionCellFilterResult2[RegionCellFilterResult2["HaltFail"] = 2] = "HaltFail";
  })(RegionCellFilterResult = VoronoiUtils2.RegionCellFilterResult || (VoronoiUtils2.RegionCellFilterResult = {}));
  function regionCellAreaFilter(cell, regionCells, maxDistance, filterCallback) {
    const consideringList = [cell.id];
    cell.ruleConsideration = true;
    let filterResult = 0 /* Continue */;
    for (let i = 0; i < consideringList.length; ++i) {
      const considerCell = regionCells[consideringList[i]];
      filterResult = filterCallback(considerCell);
      if (filterResult != 0 /* Continue */) {
        break;
      }
      const neighborIds = considerCell.cell.getNeighborIds();
      for (const neighborId of neighborIds) {
        const neighbor = regionCells[neighborId];
        if (!neighbor.ruleConsideration && VoronoiUtils2.distanceBetweenSites(cell.cell.site, neighbor.cell.site) < maxDistance) {
          neighbor.ruleConsideration = true;
          consideringList.push(neighborId);
        }
      }
    }
    consideringList.forEach((cellId) => regionCells[cellId].ruleConsideration = false);
    return filterResult;
  }
  VoronoiUtils2.regionCellAreaFilter = regionCellAreaFilter;
  function deepMerge(a, b) {
    for (const key in b) {
      if (b[key] && typeof b[key] === "object" && !Array.isArray(b[key]) && typeof a[key] === "object" && a[key] !== null) {
        deepMerge(a[key], b[key]);
      } else if (Array.isArray(a[key]) && Array.isArray(b[key])) {
        const aArr = a[key];
        const bArr = b[key];
        if (aArr.length < bArr.length && "_defaultChild" in a) {
          while (aArr.length < bArr.length) {
            aArr.push(clone(a["_defaultChild"]));
          }
        }
        aArr.length = bArr.length;
        for (let i = 0; i < bArr.length; ++i) {
          deepMerge(aArr[i], bArr[i]);
        }
      } else if (key in a) {
        a[key] = b[key];
      } else {
        console.log("Warning: key " + key + " not in merged object.");
      }
    }
  }
  VoronoiUtils2.deepMerge = deepMerge;
  async function loadTextFromPath(url) {
    if (typeof fetch == "function") {
      try {
        const response = await fetch(url, { cache: "no-cache" });
        if (!response.ok) {
          console.error(`Failed to load ${url}: ${response.statusText}`);
          return null;
        }
        return await response.text();
      } catch (err) {
        console.error(`Error loading ${url}`, err);
        return null;
      }
    } else {
      console.error("Environment does not support fetch().");
      return null;
    }
  }
  VoronoiUtils2.loadTextFromPath = loadTextFromPath;
  async function loadJsonFromPath(url) {
    const text = await loadTextFromPath(url);
    if (text) {
      return JSON.parse(text);
    }
    return null;
  }
  VoronoiUtils2.loadJsonFromPath = loadJsonFromPath;
  async function loadJsFromPath(url) {
    const text = await loadTextFromPath(url);
    if (text) {
      const match = text.match(/export\s+default\s+({[\s\S]*});?\s*$/);
      if (!match) throw new Error("Could not find export default object");
      return JSON.parse(match[1]);
    }
    return null;
  }
  VoronoiUtils2.loadJsFromPath = loadJsFromPath;
  function loadSettingsFromJson(json, map) {
    const configObject = typeof json === "string" ? JSON.parse(json) : json;
    VoronoiUtils2.deepMerge(map.getSettings(), configObject.mapConfig);
    const generator = map.getBuilder().getGenerator();
    generator.resetToDefault();
    VoronoiUtils2.deepMerge(generator.getSettings(), configObject.generatorConfig);
    const rules = generator.getRules();
    for (const [groupKey, groupValue] of Object.entries(configObject.rulesConfig)) {
      const rulesGroup = rules[groupKey];
      for (const [ruleKey, ruleValue] of Object.entries(groupValue)) {
        const ruleKeyParts = ruleKey.split(".");
        for (const rule of rulesGroup) {
          if (rule.name === ruleKeyParts[0]) {
            if (ruleKeyParts[1] === "weight") {
              rule.weight = ruleValue;
            } else {
              rule.configValues[ruleKeyParts[1]] = ruleValue;
            }
            break;
          }
        }
      }
    }
  }
  VoronoiUtils2.loadSettingsFromJson = loadSettingsFromJson;
  function loadSettingsFromJs(jsText, map) {
    const match = jsText.match(/export\s+default\s+({[\s\S]*});?\s*$/);
    if (!match) throw new Error("Could not find export default object");
    return loadSettingsFromJson(match[1], map);
  }
  VoronoiUtils2.loadSettingsFromJs = loadSettingsFromJs;
  function clone(obj) {
    if (typeof structuredClone === "function") {
      return structuredClone(obj);
    } else {
      return JSON.parse(JSON.stringify(obj));
    }
  }
  VoronoiUtils2.clone = clone;
  function getRoundedString(value, precision) {
    return String(parseFloat(value.toFixed(precision)));
  }
  VoronoiUtils2.getRoundedString = getRoundedString;
  function swapAndPop(arr, indexToRemove) {
    arr[indexToRemove] = arr[arr.length - 1];
    arr.pop();
  }
  VoronoiUtils2.swapAndPop = swapAndPop;
  function performanceMarker(label) {
    if (typeof BuildInfo === "undefined") {
      performance.mark(label);
    } else {
      console.log(label);
    }
  }
  VoronoiUtils2.performanceMarker = performanceMarker;
})(VoronoiUtils || (VoronoiUtils = {}));

export { BiomeType, DetailsType, MapDims, MapSize, PlateBoundary, PlateBoundaryPosGetter, RegionCell, RegionCellPosGetter, RegionType, TerrainType, VoronoiUtils };
//# sourceMappingURL=voronoi-utils.js.map
</file>

<file path="mod/maps/base-standard/base-standard.modinfo">
<?xml version="1.0" encoding="utf-8"?>
<Mod id="base-standard" version="1"
    xmlns="ModInfo">
    <Properties>
        <Name>Base Game</Name>
        <Description>This module contains almost everything necessary for the base game.</Description>
        <Authors>LOC_AUTHORS_FIRAXIS</Authors>
        <ShowInBrowser>0</ShowInBrowser>
        <Package>BaseGame</Package>
        <PackageSortIndex>1</PackageSortIndex>
    </Properties>
    <Dependencies></Dependencies>
    <References>
        <Mod id="core" title="LOC_MODULE_CORE_NAME" />
    </References>
    <ActionCriteria>
        <Criteria id="always">
            <AlwaysMet />
        </Criteria>
        <Criteria id="standard-games">
            <RuleSetInUse>RULESET_STANDARD</RuleSetInUse>
        </Criteria>
    </ActionCriteria>
    <ActionGroups>
        <ActionGroup id="base-game-main" scope="game" criteria="always">
            <Actions>
                <ImportFiles>
                    <Item>ui/loading/root-loading.html</Item>
                    <Item>ui/root-game.html</Item>
                    <Item>ui/unit-flags/unit-info.js</Item>
                </ImportFiles>
                <UIScripts>
                    <Item>ui/action/panel-action.js</Item>
                    <Item>ui/advanced-start/model-advanced-start.js</Item>
                    <Item>ui/advanced-start/screen-advanced-start.js</Item>
                    <Item>
                        ui/age-progression-warning-mini-banner/panel-age-progression-warning-mini-banner.js</Item>
                    <Item>ui/age-progression-warning-popup/panel-age-progression-warning-popup.js</Item>
                    <Item>ui/age-scores/model-age-scores.js</Item>
                    <Item>ui/age-scores/panel-age-scores.js</Item>
                    <Item>ui/age-rankings/model-age-rankings.js</Item>
                    <Item>ui/age-rankings/panel-age-rankings.js</Item>
                    <Item>ui/age-summary/model-age-summary-hub.js</Item>
                    <Item>ui/age-transition-banner/age-transition-banner.js</Item>
                    <Item>ui/army-panel/army-panel.js</Item>
                    <Item>ui/unit-rename/unit-rename.js</Item>
                    <Item>ui/attribute-trees/screen-attribute-trees.js</Item>
                    <Item>ui/attribute-trees/attribute-card.js</Item>
                    <Item>ui/attribute-trees/attribute-small-card.js</Item>
                    <Item>ui/befriend-independent-details/screen-befriend-independent-details.js</Item>
                    <Item>ui/benchmark/screen-benchmark.js</Item>
                    <Item>ui/build-queue/model-build-queue.js</Item>
                    <Item>ui/build-queue/panel-build-queue.js</Item>
                    <Item>ui/building-placement/building-placement-manager.js</Item>
                    <Item>ui/cinematic/screen-cinematic-placard.js</Item>
                    <Item>ui/city-banners/city-banners.js</Item>
                    <Item>ui/city-details/panel-city-details.js</Item>
                    <Item>ui/city-hud-model/model-city-hud.js</Item>
                    <Item>ui/city-selection/city-selection.js</Item>
                    <Item>ui/city-state-bonus-chooser/screen-city-state-bonus-chooser.js</Item>
                    <Item>ui/city-trade/screen-city-trade.js</Item>
                    <Item>ui/civilopedia/screen-civilopedia.js</Item>
                    <Item>ui/civilopedia/civilopedia-sidebar-panels.js</Item>
                    <Item>ui/chooser-item/chooser-item.js</Item>
                    <Item>ui/constructible-details/constructible-details.js</Item>
                    <Item>ui/tree-chooser-item/tree-chooser-item.js</Item>
                    <Item>ui/culture-tree-chooser/screen-culture-tree-chooser.js</Item>
                    <Item>ui/crisis-meter/crisis-meter.js</Item>
                    <Item>ui/diplo-ribbon/panel-diplo-ribbon.js</Item>
                    <Item>ui/diplo-ribbon/panel-yield-banner.js</Item>
                    <Item>ui/diplomacy-action-details/screen-diplomacy-action-details.js</Item>
                    <Item>ui/diplomacy-actions/panel-diplomacy-actions.js</Item>
					<Item>ui/diplomacy-actions/panel-other-diplomacy.js</Item>
					<Item>ui/diplomacy-actions/panel-player-diplomacy.js</Item>
                    <Item>ui/diplomacy-call-to-arms/screen-diplomacy-call-to-arms.js</Item>
                    <Item>ui/diplomacy-hub/panel-diplomacy-hub.js</Item>
                    <Item>ui/diplomacy-peace-deal/panel-diplomacy-peace-deal.js</Item>
                    <Item>ui/diplomacy-project-reaction/panel-diplomacy-project-reaction.js</Item>
                    <Item>ui/diplomacy-actions/screen-diplomacy-target-select.js</Item>
                    <Item>ui/diplomacy/diplomacy-events.js</Item>
                    <Item>ui/diplomacy/diplomacy-manager.js</Item>
                    <Item>ui/district/district-health-manager.js</Item>
                    <Item>ui/district/district-health.js</Item>
                    <Item>ui/end-result-graphs/panel-end-result-graphs.js</Item>
                    <Item>ui/endgame/model-endgame.js</Item>
                    <Item>ui/endgame/screen-endgame.js</Item>
                    <Item>ui/espionage-details/screen-espionage-details.js</Item>
                    <Item>ui/victory-progress/screen-victory-progress.js</Item>
                    <Item>ui/victory-progress/screen-victory-achieved.js</Item>
                    <Item>ui/victory-progress/panel-advisor-victory.js</Item>
                    <Item>ui/city-capture-chooser/panel-city-capture-chooser.js</Item>
                    <Item>ui/general-chooser/screen-general-chooser.js</Item>
                    <Item>ui/celebration-chooser/panel-celebration-chooser.js</Item>
                    <Item>ui/great-works/model-great-works.js</Item>
                    <Item>ui/great-works/screen-great-works.js</Item>
                    <Item>ui/panel-belief-picker/panel-belief-picker.js</Item>
                    <Item>ui/belief-picker-chooser-item/belief-picker-chooser-item.js</Item>
                    <Item>ui/panel-religion-picker/panel-religion-picker.js</Item>
                    <Item>ui/culture-tree/screen-culture-tree.js</Item>
                    <Item>ui/end-results/end-results.js</Item>
                    <Item>ui/pantheon-chooser/panel-religion-chooser.js</Item>
                    <Item>ui/settler-legend/panel-settler-legend.js</Item>
                    <Item>ui/tech-tree-chooser/screen-tech-tree-chooser.js</Item>
                    <Item>ui/trade-route-chooser/trade-route-banner.js</Item>
                    <Item>ui/trade-route-chooser/trade-route-chooser.js</Item>
                    <Item>ui/trade-route-chooser/trade-routes-model.js</Item>
                    <Item>ui/trade-route-chooser/trade-route-tooltip.js</Item>
                    <Item>ui/interface-modes/interface-mode-advanced-start.js</Item>
                    <Item>ui/interface-modes/interface-mode-acquire-tile.js</Item>
                    <Item>ui/interface-modes/interface-mode-add-to-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-aerial-recon.js</Item>
                    <Item>ui/interface-modes/interface-mode-air-attack.js</Item>
                    <Item>ui/interface-modes/interface-mode-naval-attack.js</Item>
                    <Item>ui/interface-modes/interface-mode-army-overrun.js</Item>
                    <Item>ui/interface-modes/interface-mode-bonus-placement.js</Item>
                    <Item>ui/interface-modes/interface-mode-call-to-arms.js</Item>
                    <Item>ui/interface-modes/interface-mode-cargo-drop.js</Item>
                    <Item>ui/interface-modes/interface-mode-chat.js</Item>
                    <Item>ui/interface-modes/interface-mode-choose-plot.js</Item>
                    <Item>ui/interface-modes/interface-mode-cinematic.js</Item>
                    <Item>ui/interface-modes/interface-mode-city-production.js</Item>
                    <Item>ui/interface-modes/interface-mode-city-purchase.js</Item>
                    <Item>ui/interface-modes/interface-mode-connect-with-road.js</Item>
                    <Item>ui/interface-modes/interface-mode-construct-in-range.js</Item>
                    <Item>ui/interface-modes/interface-mode-commander-reinforcement.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-land-melee.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-land-ranged.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-sea-melee.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-sea-ranged.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-air-to-land.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-air-to-air.js</Item>
                    <Item>ui/interface-modes/interface-mode-focused-attack-air-bomb.js</Item>
                    <Item>ui/interface-modes/interface-mode-found-city-adjacent-plot.js</Item>
                    <Item>ui/interface-modes/interface-mode-default.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplo-claim-plot.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplomacy-dialog.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplomacy-hub.js</Item>
                    <Item>ui/interface-modes/interface-mode-diplomacy-project-reaction.js</Item>
                    <Item>ui/interface-modes/interface-mode-establish-base.js</Item>
                    <Item>ui/interface-modes/interface-mode-move-by-rail.js</Item>
                    <Item>ui/interface-modes/interface-mode-move-to.js</Item>
                    <Item>ui/interface-modes/interface-mode-pause-menu.js</Item>
                    <Item>ui/interface-modes/interface-mode-place-building.js</Item>
                    <Item>ui/interface-modes/interface-mode-peace-deal.js</Item>
                    <Item>ui/interface-modes/interface-mode-radial-selection.js</Item>
                    <Item>ui/interface-modes/interface-mode-ranged-attack.js</Item>
                    <Item>ui/interface-modes/interface-mode-rebase.js</Item>
                    <Item>ui/interface-modes/interface-mode-reinforce-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-remove-from-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-resource-allocation.js</Item>
                    <Item>ui/interface-modes/interface-mode-screenshot.js</Item>
                    <Item>ui/interface-modes/interface-mode-tutorial-start.js</Item>
                    <Item>ui/interface-modes/interface-mode-unit-air-drop.js</Item>
                    <Item>ui/interface-modes/interface-mode-unit-promotion.js</Item>
                    <Item>ui/interface-modes/interface-mode-unit-selected.js</Item>
                    <Item>ui/interface-modes/interface-mode-unpack-army.js</Item>
                    <Item>ui/interface-modes/interface-mode-wmd-strike.js</Item>
                    <Item>ui/interface-modes/interface-mode-teleport-to-city.js</Item>
                    <Item>ui/interface-modes/interface-mode-coastal-raid.js</Item>
                    <Item>ui/interface-modes/interface-mode-pillage-land.js</Item>
                    <Item>ui/interface-modes/interface-mode-pillage-route.js</Item>
                    <Item>ui/interface-modes/interface-mode-grant-second-wind.js</Item>
                    <Item>ui/interface-modes/interface-mode-commander-attack.js</Item>
                    <Item>ui/legend-progress/legend-progress.js</Item>
                    <Item>ui/legends-report/screen-legends-report.js</Item>
                    <Item>ui/legends-manager/legends-manager.js</Item>
                    <Item>ui/lenses/panel-continents.js</Item>
                    <Item>ui/lenses/layer/appeal-layer.js</Item>
                    <Item>ui/lenses/layer/building-placement-layer.js</Item>
                    <Item>ui/lenses/layer/city-borders-layer.js</Item>
                    <Item>ui/lenses/layer/city-growth-improvements-layer.js</Item>
                    <Item>ui/lenses/layer/culture-borders-layer.js</Item>
                    <Item>ui/lenses/layer/hexgrid-layer.js</Item>
                    <Item>ui/lenses/layer/random-events-layer.js</Item>
                    <Item>ui/lenses/layer/operation-target-layer.js</Item>
                    <Item>ui/lenses/layer/resource-layer.js</Item>
                    <Item>ui/lenses/layer/settlement-recommendations-layer.js</Item>
                    <Item>ui/lenses/layer/trade-layer.js</Item>
                    <Item>ui/lenses/layer/worker-yields-layer.js</Item>
                    <Item>ui/lenses/layer/yields-layer.js</Item>
                    <Item>ui/lenses/layer/continent-layer.js</Item>
                    <Item>ui/lenses/lens/acquire-tile-lens.js</Item>
                    <Item>ui/lenses/lens/building-placement-lens.js</Item>
                    <Item>ui/lenses/lens/cinematic-lens.js</Item>
                    <Item>ui/lenses/lens/city-lens.js</Item>
                    <Item>ui/lenses/lens/default-lens.js</Item>
                    <Item>ui/lenses/lens/diplomacy-lens.js</Item>
                    <Item>ui/lenses/lens/founder-lens.js</Item>
                    <Item>ui/lenses/lens/settler-lens.js</Item>
                    <Item>ui/lenses/lens/trade-lens.js</Item>
                    <Item>ui/lenses/lens/continent-lens.js</Item>
                    <Item>ui/live-notice/live-notice.js</Item>
                    <Item>ui/mini-map/panel-mini-map.js</Item>
                    <Item>ui/mp-ingame-mgr/mp-ingame-mgr.js</Item>
                    <Item>ui/narrative-event/graphic-narrative-event.js</Item>
                    <Item>ui/narrative-event/screen-narrative-event.js</Item>
                    <Item>ui/notification-connection-status/notification-connection-status.js</Item>
                    <Item>ui/notification-train/model-notification-train.js</Item>
                    <Item>ui/notification-train/notification-handlers.js</Item>
                    <Item>ui/notification-train/panel-notification-train.js</Item>
                    <Item>ui/notification-train-mobile/panel-notification-mobile-opener.js</Item>
                    <Item>ui/notification-train-mobile/panel-notification-train-mobile.js</Item>
                    <Item>ui/pantheon-chooser/screen-pantheon-chooser.js</Item>
                    <Item>ui/pantheon-complete/panel-pantheon-complete.js</Item>
                    <Item>ui/pantheon-chooser-item/pantheon-chooser-item.js</Item>
                    <Item>ui/pause-event-rules/screen-pause-event-rules.js</Item>
                    <Item>ui-next/screens/pause-menu/pause-menu-bootstrap.js</Item>
                    <Item>ui/place-building/model-place-building.js</Item>
                    <Item>ui/place-building/panel-place-building.js</Item>
                    <Item>ui/place-building/model-place-building-v2.js</Item>
                    <Item>ui/place-building/panel-place-building-v2.js</Item>
                    <Item>ui/place-population/model-place-population.js</Item>
                    <Item>ui/place-population/panel-place-population.js</Item>
                    <Item>ui/placement-city-banner/placement-city-banner.js</Item>
					<Item>ui/player-yields-report/player-yields-report-screen.js</Item>
					<Item>ui/plot-icon/plot-icon-random-event.js</Item>
                    <Item>ui/plot-icon/plot-icon-resource.js</Item>
                    <Item>ui/plot-icon/plot-icon-suggested-settlement.js</Item>
                    <Item>ui/plot-icon/plot-icon-archeology.js</Item>
                    <Item>ui/plot-workers/plot-workers-manager.js</Item>
                    <Item>ui/popup-sequencer/popup-sequencer.js</Item>
                    <Item>ui/production-chooser/panel-production-chooser.js</Item>
                    <Item>ui/production-chooser/panel-production-tooltips.js</Item>
                    <Item>ui/quest-tracker/narrative-quest-manager.js</Item>
                    <Item>ui/quest-tracker/quest-item.js</Item>
                    <Item>ui/quest-tracker/quest-list.js</Item>
                    <Item>ui/quest-tracker/quest-tracker.js</Item>
                    <Item>ui/quick-save-indicator/quick-save-indicator.js</Item>
                    <Item>ui/save-indicator/save-indicator.js</Item>
                    <Item>ui/small-narrative-event/small-narrative-event.js</Item>
                    <Item>ui/resource-allocation/screen-resource-allocation.js</Item>
                    <Item>ui/sub-system-dock/panel-sub-system-dock.js</Item>
                    <Item>ui/system-bar/panel-system-bar.js</Item>
                    <Item>ui/system-bar/panel-system-button.js</Item>
                    <Item>ui/tech-civic-complete/screen-tech-civic-complete.js</Item>
                    <Item>ui/tech-tree-chooser/screen-tech-tree-chooser.js</Item>
                    <Item>ui/tech-tree/screen-tech-tree.js</Item>
                    <Item>ui/tree-grid/tree-card.js</Item>
                    <Item>ui/tree-grid/tree-line.js</Item>
                    <Item>ui/tree-grid/tree-detail.js</Item>
                    <Item>ui/tooltips/plot-tooltip.js</Item>
                    <Item>ui/tooltips/relationship-tooltip.js</Item>
                    <Item>ui/tooltips/tech-civic-tooltip.js</Item>
                    <Item>ui/tooltips/advanced-start-tooltip.js</Item>
                    <Item>ui/tooltips/settlement-recommendation-tooltip.js</Item>
                    <Item>ui/tooltips/random-event-tooltip.js</Item>
                    <Item>ui/tooltips/archeology-tooltip.js</Item>
                    <Item>ui/tooltips/peace-deal-tooltip.js</Item>
                    <Item>ui/policies/screen-policies.js</Item>
                    <Item>ui/policies/policy-chooser-item.js</Item>
                    <Item>ui/screen-government-picker/screen-government-picker.js</Item>
                    <Item module="false">ui/tuner-input/tuner-input.js</Item>
                    <Item>ui/turn-icon/turn-icon.js</Item>
                    <Item>ui/tutorial/tutorial-callout.js</Item>
                    <Item>ui/tutorial/tutorial-dialog-page.js</Item>
                    <Item>ui/tutorial/tutorial-dialog.js</Item>
                    <Item>ui/tutorial/tutorial-inspector.js</Item>
                    <Item>ui/tutorial/tutorial-manager.js</Item>
                    <Item>ui/tutorial/tutorial-item.js</Item>
                    <Item>ui/tutorial/tutorial-quest-panel.js</Item>
                    <Item>ui/unit-actions/unit-actions.js</Item>
                    <Item>ui/unit-combat-preview/panel-unit-combat-preview.js</Item>
                    <Item>ui/unit-flags/army-commander-flags.js</Item>
                    <Item>ui/unit-flags/unit-flag-manager.js</Item>
                    <Item>ui/unit-flags/unit-flags-independent-powers.js</Item>
                    <Item>ui/unit-flags/unit-flags.js</Item>
                    <Item>ui/unit-interact/unit-action-handlers.js</Item>
                    <Item>ui/unit-promotion/panel-unit-promotion.js</Item>
                    <Item>ui/unit-selection/unit-selection.js</Item>
                    <Item>ui/unlocks/screen-unlocks.js</Item>
                    <Item>ui/unlocks/screen-reward-unlocked.js</Item>
                    <Item>ui/unlocks/model-unlocks.js</Item>
                    <Item>ui/unlocks/unlocks-manager.js</Item>
                    <Item>ui/unlocks/panel-player-rewards.js</Item>
                    <Item>ui/victory-points/model-victory-points.js</Item>
                    <Item>ui/victory-points/panel-victory-points.js</Item>
                    <Item>ui/views/view-advanced-start.js</Item>
                    <Item>ui/views/view-bonus-placement.js</Item>
                    <Item>ui/views/view-cinematic.js</Item>
                    <Item>ui/views/view-city.js</Item>
                    <Item>ui/views/view-diplomacy.js</Item>
                    <Item>ui/views/view-pause-menu.js</Item>
                    <Item>ui/views/view-placement.js</Item>
                    <Item>ui/views/view-screenshot.js</Item>
                    <Item>ui/views/view-resource-allocation.js</Item>
                    <Item>ui/views/view-unit-promotion.js</Item>
                    <Item>ui/views/view-unit.js</Item>
                    <Item>ui/views/view-reinforcement.js</Item>
                    <Item>ui/views/view-world.js</Item>
                    <Item>ui/watch-out/watch-out-manager.js</Item>
                    <Item>ui/watch-out/screen-watch-out.js</Item>
                    <Item>ui/world-anchor-text/world-anchor-text-manager.js</Item>
                    <Item>ui/world-anchor-text/world-anchor-text.js</Item>
                    <Item>ui/world-input/world-input.js</Item>
                    <Item>ui/world-vfx/world-vfx.js</Item>
                    <Item>ui/yield-bar/model-yield-bar.js</Item>
                    <Item>ui/yield-bar/yield-bar.js</Item>
                    <Item>ui/yield-bar-base/yield-bar-base.js</Item>
                </UIScripts>
                <UpdateDatabase>
                    <Item>data/gameplay.xml</Item>
                    <Item>data/advanced-start-gameeffects.xml</Item>
                    <Item>data/advisory.xml</Item>
                    <Item>data/age-transition-gameeffects.xml</Item>
                    <Item>data/ages.xml</Item>
                    <Item>data/army-names.xml</Item>
                    <Item>data/attributes-gameeffects.xml</Item>
                    <Item>data/attributes.xml</Item>
                    <Item>data/AI_Base.xml</Item>
					<Item>data/AI_Base_Naval.xml</Item>
                    <Item>data/Barbarians.xml</Item>
                    <Item>data/behaviortrees.xml</Item>
                    <Item>data/calendar.xml</Item>
                    <Item>data/capabilities.xml</Item>
                    <Item>data/city-commands.xml</Item>
                    <Item>data/city-properties.xml</Item>
                    <Item>data/civilizations-gameeffects.xml</Item>
                    <Item>data/civilizations.xml</Item>
                    <Item>data/civilopedia.xml</Item>
                    <Item>data/civilopedia-ages.xml</Item>
                    <Item>data/civilopedia-concepts.xml</Item>
                    <Item>data/common-property-types.xml</Item>
                    <Item>data/core-types.xml</Item>
                    <Item>data/constructibles.xml</Item>
                    <Item>data/definition-property-types.xml</Item>
                    <Item>data/difficulties.xml</Item>
                    <Item>data/diplomacy-actions.xml</Item>
                    <Item>data/diplomacy-deal-items.xml</Item>
                    <Item>data/diplomacy-deal-item-agreements.xml</Item>
                    <Item>data/diplomacy-gameeffects.xml</Item>
                    <Item>data/diplomacy-statements.xml</Item>
                    <Item>data/discovery-stories-gameeffects.xml</Item>
                    <Item>data/discovery-stories.xml</Item>
                    <Item>data/districts.xml</Item>
                    <Item>data/game-speeds.xml</Item>
                    <Item>data/gameplay-systems.xml</Item>
                    <Item>data/gossip.xml</Item>
                    <Item>data/governments.xml</Item>
                    <Item>data/happiness-identity.xml</Item>
                    <Item>data/happiness-identity-gameeffects.xml</Item>
                    <Item>data/Independents.xml</Item>
                    <Item>data/interface-modes.xml</Item>
                    <Item>data/leaders.xml</Item>
                    <Item>data/leaders-gameeffects.xml</Item>
                    <Item>data/legacy-path-gameeffects.xml</Item>
                    <Item>data/loading-info.xml</Item>
                    <Item>data/maps.xml</Item>
                    <Item>data/movies.xml</Item>
                    <Item>data/plot-effects.xml</Item>
                    <Item>data/mementos.xml</Item>
                    <Item>data/mementos-gameeffects.xml</Item>
                    <Item>data/metaprogression.xml</Item>
                    <Item>data/metaprogression-gameeffects.xml</Item>
                    <Item>data/modifiers.xml</Item>
                    <Item>data/named-places.xml</Item>
                    <Item>data/narrative-sifting.xml</Item>
                    <Item>data/narrative-crises-stories-gameeffects.xml</Item>
                    <Item>data/narrative-crises-stories.xml</Item>
                    <Item>data/narrative-stories-gameeffects.xml</Item>
                    <Item>data/narrative-stories.xml</Item>
                    <Item>data/narrative-stories-common.xml</Item>
                    <Item>data/narrative-stories-common-gameeffects.xml</Item>
                    <Item>data/narrative-tags.xml</Item>
                    <Item>data/notification.xml</Item>
                    <Item>data/player-properties.xml</Item>
                    <Item>data/progression-trees-common-gameeffects.xml</Item>
                    <Item>data/progression-trees-common.xml</Item>
                    <Item>data/projects.xml</Item>
                    <Item>data/projects-gameeffects.xml</Item>
                    <Item>data/pseudoyields.xml</Item>
                    <Item>data/racetowonders-terrain.xml</Item>
                    <Item>data/racetowonders-terrain-gameeffects.xml</Item>
                    <Item>data/marvelous-mountains-terrain.xml</Item>
                    <Item>data/marvelous-mountains-terrain-gameeffects.xml</Item>
                    <Item>data/resources.xml</Item>
                    <Item>data/resources-v2.xml</Item>
                    <Item>data/random-events.xml</Item>
                    <Item>data/religion.xml</Item>
                    <Item>data/routes.xml</Item>
                    <Item>data/terrain.xml</Item>
                    <Item>data/terrain-gameeffects.xml</Item>
                    <Item>data/traditions.xml</Item>
                    <Item>data/traditions-gameeffects.xml</Item>
                    <Item>data/unit-commands.xml</Item>
                    <Item>data/unit-movement.xml</Item>
                    <Item>data/unit-operations.xml</Item>
                    <Item>data/unit-properties.xml</Item>
                    <Item>data/unit-promotions-gameeffects.xml</Item>
                    <Item>data/unit-promotions.xml</Item>
                    <Item>data/units-gameeffects.xml</Item>
                    <Item>data/units.xml</Item>
                    <Item>data/unlocks.xml</Item>
                    <Item>data/victories.xml</Item>
                    <Item>data/wars.xml</Item>
                </UpdateDatabase>
                <UpdateColors>
                    <Item>data/colors/playercolors.xml</Item>
                    <Item>data/colors/playerstandardcolors.xml</Item>
                </UpdateColors>
                <UpdateIcons>
                    <Item>data/icons/advisor-icons.xml</Item>
                    <Item>data/icons/attribute-icons.xml</Item>
                    <Item>data/icons/chat-icons.xml</Item>
                    <Item>data/icons/city-icons.xml</Item>
                    <Item>data/icons/building-icons.xml</Item>
                    <Item>data/icons/card-icons.xml</Item>
                    <Item>data/icons/diplomacy-icons.xml</Item>
                    <Item>data/icons/civilization-icons.xml</Item>
                    <Item>data/icons/emoji-icons.xml</Item>
                    <Item>data/icons/improvement-icons.xml</Item>
                    <Item>data/icons/leader-icons.xml</Item>
                    <Item>data/icons/legacy-path-icons.xml</Item>
                    <Item>data/icons/misc-icons.xml</Item>
                    <Item>data/icons/modifier-icons.xml</Item>
                    <Item>data/icons/narrative-icons.xml</Item>
                    <Item>data/icons/notification-icons.xml</Item>
                    <Item>data/icons/project-icons.xml</Item>
                    <Item>data/icons/promotion-icons.xml</Item>
                    <Item>data/icons/radial-icons.xml</Item>
                    <Item>data/icons/random-event-icons.xml</Item>
                    <Item>data/icons/relationship-icons.xml</Item>
                    <Item>data/icons/resource-icons.xml</Item>
                    <Item>data/icons/resource-icons-v2.xml</Item>
                    <Item>data/icons/trade-icons.xml</Item>
                    <Item>data/icons/tradition-icons.xml</Item>
                    <Item>data/icons/unit-icons.xml</Item>
                    <Item>data/icons/wonder-icons.xml</Item>
                    <Item>data/icons/victory-icons.xml</Item>
                    <Item>data/icons/yield-icons.xml</Item>
                    <Item>data/icons/tutorial-icons.xml</Item>
                    <Item>data/icons/rewards-icons.xml</Item>
                    <Item>data/icons/platform-icons.xml</Item>
                </UpdateIcons>
                <UpdateText>
                    <Item>text/en_us/ShellText.xml</Item>
                    <Item>text/en_us/ConfigText.xml</Item>
                    <Item>text/en_us/ActionPanelText.xml</Item>
                    <Item>text/en_us/AdvancedOptionText.xml</Item>
                    <Item>text/en_us/AdvancedStartText.xml</Item>
                    <Item>text/en_us/AdvisorText.xml</Item>
                    <Item>text/en_us/AgeTransitionText.xml</Item>
                    <Item>text/en_us/ArmyNamesText.xml</Item>
                    <Item>text/en_us/AttributesText.xml</Item>
                    <Item>text/en_us/BannerText.xml</Item>
                    <Item>text/en_us/CalendarText.xml</Item>
                    <Item>text/en_us/CityCommandsText.xml</Item>
                    <Item>text/en_us/CivilizationText.xml</Item>
                    <Item>text/en_us/CivilopediaText.xml</Item>
                    <Item>text/en_us/Civilopedia_Ages_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Concepts_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Constructibles_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Features_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Resources_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Terrain_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Leaders_Text.xml</Item>
                    <Item>text/en_us/Civilopedia_Units_Text.xml</Item>
                    <Item>text/en_us/CombatPreviewText.xml</Item>
                    <Item>text/en_us/CommonText.xml</Item>
                    <Item>text/en_us/ConstructibleText.xml</Item>
                    <Item>text/en_us/CultureText.xml</Item>
                    <Item>text/en_us/DiplomacyText.xml</Item>
                    <Item>text/en_us/DiplomacyStatementText.xml</Item>
                    <Item>text/en_us/EffectText.xml</Item>
                    <Item>text/en_us/EraVictoryText.xml</Item>
                    <Item>text/en_us/GameplaySystemsText.xml</Item>
                    <Item>text/en_us/InGameText.xml</Item>
                    <Item>text/en_us/InterfaceModeText.xml</Item>
                    <Item>text/en_us/LeaderDialog_Augustus.xml</Item>
                    <Item>text/en_us/LeaderDialog_BenjaminFranklin.xml</Item>
                    <Item>text/en_us/LeaderDialog_Catherine.xml</Item>
                    <Item>text/en_us/LeaderDialog_Isabella.xml</Item>
                    <Item>text/en_us/LeaderDialog_Lafayette.xml</Item>
                    <Item>text/en_us/LeaderDialog_Amina.xml</Item>
                    <Item>text/en_us/LeaderDialog_Ashoka.xml</Item>
                    <Item>text/en_us/LeaderDialog_Charlemagne.xml</Item>
                    <Item>text/en_us/LeaderDialog_Confucius.xml</Item>
                    <Item>text/en_us/LeaderDialog_FriedrichII.xml</Item>
                    <Item>text/en_us/LeaderDialog_HarrietTubman.xml</Item>
                    <Item>text/en_us/LeaderDialog_Hatshepsut.xml</Item>
                    <Item>text/en_us/LeaderDialog_Himiko.xml</Item>
                    <Item>text/en_us/LeaderDialog_IbnBattuta.xml</Item>
                    <Item>text/en_us/LeaderDialog_Machiavelli.xml</Item>
                    <Item>text/en_us/LeaderDialog_Pachacuti.xml</Item>
                    <Item>text/en_us/LeaderDialog_Rizal.xml</Item>
                    <Item>text/en_us/LeaderDialog_TrungTrac.xml</Item>
                    <Item>text/en_us/LeaderDialog_Xerxes.xml</Item>
                    <Item>text/en_us/LeaderText.xml</Item>
                    <Item>text/en_us/LoadingText.xml</Item>
                    <Item>text/en_us/MapText.xml</Item>
                    <Item>text/en_us/MementoText.xml</Item>
                    <Item>text/en_us/UnlockableRewardsText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.generated.xml</Item>
                    <Item>text/en_us/NamedPlacesText.xml</Item>
                    <Item>text/en_us/NarrativeCrisesStoriesText.xml</Item>
                    <Item>text/en_us/NarrativeStoriesText.xml</Item>
                    <Item>text/en_us/NarrativeStoriesTextCommon.xml</Item>
                    <Item>text/en_us/NaturalWonderQuoteText.xml</Item>
                    <Item>text/en_us/NotificationText.xml</Item>
                    <Item>text/en_us/PauseMenuText.xml</Item>
                    <Item>text/en_us/PlayerOperationsText.xml</Item>
                    <Item>text/en_us/PlotTooltipText.xml</Item>
                    <Item>text/en_us/ProductionChooserText.xml</Item>
                    <Item>text/en_us/ProjectsText.xml</Item>
                    <Item>text/en_us/QuestTrackerText.xml</Item>
                    <Item>text/en_us/RandomEventsText.xml</Item>
                    <Item>text/en_us/ResourcesText.xml</Item>
                    <Item>text/en_us/SettlementRecommendationText.xml</Item>
                    <Item>text/en_us/SubSystemDockText.xml</Item>
                    <Item>text/en_us/SystemMessageText.xml</Item>
                    <Item>text/en_us/TerrainText.xml</Item>
                    <Item>text/en_us/TraditionsText.xml</Item>
                    <Item>text/en_us/TreasuryText.xml</Item>
                    <Item>text/en_us/TutorialText.xml</Item>
                    <Item>text/en_us/UIText.xml</Item>
                    <Item>text/en_us/UnitCommandsText.xml</Item>
                    <Item>text/en_us/UnitOperationsText.xml</Item>
                    <Item>text/en_us/UnitPromotionsText.xml</Item>
                    <Item>text/en_us/UnitText.xml</Item>
                    <Item>text/en_us/UnlockText.xml</Item>
                    <Item>text/en_us/VictoryProgressText.xml</Item>
                    <Item>text/en_us/VictoriesText.xml</Item>
                    <Item>text/en_us/WarNamesText.xml</Item>
                    <Item>text/en_us/WorkersText.xml</Item>
                    <Item>text/en_us/YieldsText.xml</Item>

                    <!-- Items below were generated via our loc tool. -->
                    <Item locale="de_DE">l10n/de_DE_Text.xml</Item>
                    <Item locale="es_ES">l10n/es_ES_Text.xml</Item>
                    <Item locale="fr_FR">l10n/fr_FR_Text.xml</Item>
                    <Item locale="it_IT">l10n/it_IT_Text.xml</Item>
                    <Item locale="ja_JP">l10n/ja_JP_Text.xml</Item>
                    <Item locale="ko_KR">l10n/ko_KR_Text.xml</Item>
                    <Item locale="pl_PL">l10n/pl_PL_Text.xml</Item>
                    <Item locale="pt_BR">l10n/pt_BR_Text.xml</Item>
                    <Item locale="ru_RU">l10n/ru_RU_Text.xml</Item>
                    <Item locale="zh_Hans_CN">l10n/zh_Hans_CN_Text.xml</Item>
                    <Item locale="zh_Hant_HK">l10n/zh_Hant_HK_Text.xml</Item>

                    <!-- These text-override entries must happen *after* translations. -->
                    <Item platform="Switch">text/en_us/ShellText_Premium_Services_NX.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_Premium_Services_NX.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_AdditionalContent_Console.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_RestrictedContent.xml</Item>

                    <Item ecosystem="game-center">
                        text/en_us/AttributesText_LegendUnlocks_AppleArcade.xml</Item>
                    <Item ecosystem="game-center">text/en_us/AdvancedOptionText_LegendPathsWarning_AppleArcade.xml</Item>
                </UpdateText>
                <UpdateArt>
                    <!-- Asset Packages that the mod depends on -->
                    <Item>Civ7</Item>
                    <Item>boot-shell</Item>
                </UpdateArt>
                <UIShortcuts>
                    <Item>ui/root-game.html</Item>
                </UIShortcuts>
                <UpdateVisualRemaps>
                    <Item>data/visual-remaps.xml</Item>
                </UpdateVisualRemaps>

                <ImportFiles locale="de_DE">
                    <Item>l10n/de_DE/intro.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_amina.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/de_DE/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/de_DE/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="es_ES">
                    <Item>l10n/es_ES/intro.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_amina.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/es_ES/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/es_ES/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="fr_FR">
                    <Item>l10n/fr_FR/intro.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_amina.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/fr_FR/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/fr_FR/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="it_IT">
                    <Item>l10n/it_IT/intro.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_amina.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/it_IT/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/it_IT/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="ja_JP">
                    <Item>l10n/ja_JP/intro.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_amina.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/ja_JP/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/ja_JP/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="ko_KR">
                    <Item>l10n/ko_KR/intro.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_amina.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/ko_KR/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/ko_KR/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="pl_PL">
                    <Item>l10n/pl_PL/intro.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_amina.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/pl_PL/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/pl_PL/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="pt_BR">
                    <Item>l10n/pt_BR/intro.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_amina.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/pt_BR/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/pt_BR/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="ru_RU">
                    <Item>l10n/ru_RU/intro.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_amina.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/ru_RU/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/ru_RU/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="zh_Hans_CN">
                    <Item>l10n/zh_Hans_CN/intro.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_amina.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/zh_Hans_CN/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>

                <ImportFiles locale="zh_Hant_HK">
                    <Item>l10n/zh_Hant_HK/intro.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_amina.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_ashoka_defeat.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_ashoka.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_augustus.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_benjaminfranklin.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_catherine_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_catherine.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_charlemagne.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_confucius.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_friedrich.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_harriettubman_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_harriettubman.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_hatshepsut.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_himiko.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_ibnbattuta.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_isabella.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_joserizal_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_joserizal.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_lafayette_alt.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_lafayette.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_machiavelli.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_napoleon.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_pachacuti.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_trungtrac.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_leader_xerxes.vtt</Item>
                    <Item>l10n/zh_Hant_HK/wilco_victory_generic_domination.vtt</Item>
                </ImportFiles>
            </Actions>
        </ActionGroup>
        <ActionGroup id="base-game-shell" scope="shell" criteria="always">
            <Actions>
                <ImportFiles>
                    <Item>ui/loading/root-loading.html</Item>
                </ImportFiles>
                <UIScripts>
                    <Item>ui/live-notice/live-notice.js</Item>
                </UIScripts>
                <UpdateArt>
                    <Item>boot-shell</Item>
                </UpdateArt>
                <UpdateDatabase>
                    <Item>config/config.xml</Item>
                    <Item>config/hall-of-fame.xml</Item>
                    <Item>config/metaprogression.xml</Item>
                    <Item>config/unlockableRewards.xml</Item>
                </UpdateDatabase>
                <UpdateColors>
                    <Item>data/colors/playercolors.xml</Item>
                    <Item>data/colors/playerstandardcolors.xml</Item>
                </UpdateColors>
                <UpdateIcons>
                    <Item>data/icons/attribute-icons.xml</Item>
                    <Item>data/icons/chat-icons.xml</Item>
                    <Item>data/icons/building-icons.xml</Item>
                    <Item>data/icons/city-icons.xml</Item>
                    <Item>data/icons/civilization-icons.xml</Item>
                    <Item>data/icons/emoji-icons.xml</Item>
                    <Item>data/icons/improvement-icons.xml</Item>
                    <Item>data/icons/leader-icons.xml</Item>
                    <Item>data/icons/legacy-path-icons.xml</Item>
                    <Item>data/icons/misc-icons.xml</Item>
                    <Item>data/icons/modifier-icons.xml</Item>
                    <Item>data/icons/narrative-icons.xml</Item>
                    <Item>data/icons/notification-icons.xml</Item>
                    <Item>data/icons/project-icons.xml</Item>
                    <Item>data/icons/radial-icons.xml</Item>
                    <Item>data/icons/relationship-icons.xml</Item>
                    <Item>data/icons/resource-icons.xml</Item>
                    <Item>data/icons/resource-icons-v2.xml</Item>
                    <Item>data/icons/tutorial-icons.xml</Item>
                    <Item>data/icons/unit-icons.xml</Item>
                    <Item>data/icons/yield-icons.xml</Item>
                    <Item>data/icons/platform-icons.xml</Item>
                </UpdateIcons>
                <UpdateText>
                    <Item>text/en_us/CivilizationText.xml</Item>
                    <Item>text/en_us/LeaderText.xml</Item>
                    <Item>text/en_us/LoadingText.xml</Item>
                    <Item>text/en_us/ShellText.xml</Item>
                    <Item>text/en_us/SystemMessageText.xml</Item>
                    <Item>text/en_us/AdvancedOptionText.xml</Item>
                    <Item>text/en_us/ConfigText.xml</Item>
                    <Item>text/en_us/HallOfFameText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.xml</Item>
                    <Item>text/en_us/MetaprogressionText.generated.xml</Item>
                    <Item>text/en_us/MementoText.xml</Item>
                    <Item>text/en_us/UnlockableRewardsText.xml</Item>
                    <Item>text/en_us/UIText.xml</Item>
                    <Item>text/en_us/UnlockText.xml</Item>
                    <Item>text/en_us/NarrativeCrisesStoriesText.xml</Item>
                    <Item>text/en_us/LeaderDialog_BenjaminFranklin.xml</Item>
                    <Item>text/en_us/LeaderDialog_Augustus.xml</Item>
                    <Item>text/en_us/LeaderDialog_Catherine.xml</Item>
                    <Item>text/en_us/LeaderDialog_Isabella.xml</Item>
                    <Item>text/en_us/LeaderDialog_Lafayette.xml</Item>
                    <Item>text/en_us/LeaderDialog_Amina.xml</Item>
                    <Item>text/en_us/LeaderDialog_Ashoka.xml</Item>
                    <Item>text/en_us/LeaderDialog_Charlemagne.xml</Item>
                    <Item>text/en_us/LeaderDialog_Confucius.xml</Item>
                    <Item>text/en_us/LeaderDialog_FriedrichII.xml</Item>
                    <Item>text/en_us/LeaderDialog_HarrietTubman.xml</Item>
                    <Item>text/en_us/LeaderDialog_Hatshepsut.xml</Item>
                    <Item>text/en_us/LeaderDialog_Himiko.xml</Item>
                    <Item>text/en_us/LeaderDialog_IbnBattuta.xml</Item>
                    <Item>text/en_us/LeaderDialog_Machiavelli.xml</Item>
                    <Item>text/en_us/LeaderDialog_Pachacuti.xml</Item>
                    <Item>text/en_us/LeaderDialog_Rizal.xml</Item>
                    <Item>text/en_us/LeaderDialog_TrungTrac.xml</Item>
                    <Item>text/en_us/LeaderDialog_Xerxes.xml</Item>
					<Item>text/en_us/VictoriesText.xml</Item>
					<!-- Items below were generated via our loc tool. -->
                    <Item locale="de_DE">l10n/de_DE_Text.xml</Item>
                    <Item locale="es_ES">l10n/es_ES_Text.xml</Item>
                    <Item locale="fr_FR">l10n/fr_FR_Text.xml</Item>
                    <Item locale="it_IT">l10n/it_IT_Text.xml</Item>
                    <Item locale="ja_JP">l10n/ja_JP_Text.xml</Item>
                    <Item locale="ko_KR">l10n/ko_KR_Text.xml</Item>
                    <Item locale="pl_PL">l10n/pl_PL_Text.xml</Item>
                    <Item locale="pt_BR">l10n/pt_BR_Text.xml</Item>
                    <Item locale="ru_RU">l10n/ru_RU_Text.xml</Item>
                    <Item locale="zh_Hans_CN">l10n/zh_Hans_CN_Text.xml</Item>
                    <Item locale="zh_Hant_HK">l10n/zh_Hant_HK_Text.xml</Item>

					<!-- These text-override entries must happen *after* translations. -->
                    <Item platform="Switch">text/en_us/ShellText_Premium_Services_NX.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_Premium_Services_NX.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_AdditionalContent_Console.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_AdditionalContent_Console.xml</Item>

                    <Item platform="Switch">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="Ounce">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS4">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="PS5">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxOne">text/en_us/ShellText_RestrictedContent.xml</Item>
                    <Item platform="XboxScarlett">text/en_us/ShellText_RestrictedContent.xml</Item>

                    <Item ecosystem="game-center">
                        text/en_us/AttributesText_LegendUnlocks_AppleArcade.xml</Item>
                    <Item ecosystem="game-center">text/en_us/AdvancedOptionText_LegendPathsWarning_AppleArcade.xml</Item>
                </UpdateText>

                <ImportFiles>
                    <Item locale="de_DE">l10n/de_DE/intro.vtt</Item>
                    <Item locale="es_ES">l10n/es_ES/intro.vtt</Item>
                    <Item locale="fr_FR">l10n/fr_FR/intro.vtt</Item>
                    <Item locale="it_IT">l10n/it_IT/intro.vtt</Item>
                    <Item locale="ja_JP">l10n/ja_JP/intro.vtt</Item>
                    <Item locale="ko_KR">l10n/ko_KR/intro.vtt</Item>
                    <Item locale="pl_PL">l10n/pl_PL/intro.vtt</Item>
                    <Item locale="pt_BR">l10n/pt_BR/intro.vtt</Item>
                    <Item locale="ru_RU">l10n/ru_RU/intro.vtt</Item>
                    <Item locale="zh_Hans_CN">l10n/zh_Hans_CN/intro.vtt</Item>
                    <Item locale="zh_Hant_HK">l10n/zh_Hant_HK/intro.vtt</Item>
                </ImportFiles>

                <UIShortcuts>
                    <Item>ui/loading/root-loading.html</Item>
                </UIShortcuts>
                <!-- Load Visual Remaps in the shell too, so they can be adjusted. -->
                <UpdateVisualRemaps>
                    <Item>data/visual-remaps.xml</Item>
                </UpdateVisualRemaps>
            </Actions>
        </ActionGroup>
    </ActionGroups>
    <LocalizedText></LocalizedText>
</Mod>
</file>

<file path="mod/maps/bootstrap/defaults/base.js">
// @ts-nocheck
/**
 * Base defaults for Epic Diverse Huge map configs.
 *
 * Purpose
 * - Single, explicit source for baseline defaults that all consumers compose from.
 * - These values form the canonical defaults (no other hidden defaults elsewhere).
 *
 * Notes
 * - Keep objects frozen to discourage mutation and encourage override/merge patterns.
 * - Arrays are provided as plain arrays; resolver will treat arrays as replace-by-default.
 */
// @ts-check
const CLIMATE_BASELINE_DEFAULT = Object.freeze({
    blend: Object.freeze({
        baseWeight: 0.6,
        bandWeight: 0.4,
    }),
    bands: Object.freeze({
        deg0to10: 120,
        deg10to20: 104,
        deg20to35: 75,
        deg35to55: 70,
        deg55to70: 60,
        deg70plus: 45,
    }),
    orographic: Object.freeze({
        hi1Threshold: 350,
        hi1Bonus: 8,
        hi2Threshold: 600,
        hi2Bonus: 7,
    }),
    coastal: Object.freeze({
        coastalLandBonus: 24,
        shallowAdjBonus: 16,
    }),
    noise: Object.freeze({
        baseSpanSmall: 3,
        spanLargeScaleFactor: 1.0,
    }),
});
const CLIMATE_REFINE_DEFAULT = Object.freeze({
    waterGradient: Object.freeze({
        radius: 5,
        perRingBonus: 5,
        lowlandBonus: 3,
    }),
    orographic: Object.freeze({
        steps: 4,
        reductionBase: 8,
        reductionPerStep: 6,
    }),
    riverCorridor: Object.freeze({
        lowlandAdjacencyBonus: 14,
        highlandAdjacencyBonus: 5,
    }),
    lowBasin: Object.freeze({
        radius: 3,
        delta: 6,
    }),
});
const CLIMATE_SWATCHES_DEFAULT = Object.freeze({
    maxPerMap: 7,
    forceAtLeastOne: true,
    sizeScaling: Object.freeze({
        widthMulSqrt: 0.3,
        lengthMulSqrt: 0.4,
    }),
    types: Object.freeze({
        macroDesertBelt: Object.freeze({
            weight: 8,
            latitudeCenterDeg: 20,
            halfWidthDeg: 12,
            drynessDelta: 28,
            bleedRadius: 3,
        }),
        equatorialRainbelt: Object.freeze({
            weight: 3,
            latitudeCenterDeg: 0,
            halfWidthDeg: 10,
            wetnessDelta: 24,
            bleedRadius: 3,
        }),
        rainforestArchipelago: Object.freeze({
            weight: 7,
            islandBias: 2,
            reefBias: 1,
            wetnessDelta: 18,
            bleedRadius: 3,
        }),
        mountainForests: Object.freeze({
            weight: 2,
            coupleToOrogeny: true,
            windwardBonus: 6,
            leePenalty: 2,
            bleedRadius: 3,
        }),
        greatPlains: Object.freeze({
            weight: 5,
            latitudeCenterDeg: 45,
            halfWidthDeg: 8,
            dryDelta: 12,
            lowlandMaxElevation: 300,
            bleedRadius: 4,
        }),
    }),
});

const LANDMASS_DEFAULT = Object.freeze({
    baseWaterPercent: 64,
    waterThumbOnScale: -4,
    jitterAmpFracBase: 0.03,
    jitterAmpFracScale: 0.015,
    curveAmpFrac: 0.05,
    // Core-first: interiors lead; boundaries get a light assist only.
    boundaryBias: 0.25,
    // Soft backstop: minimum share of land in the high-closeness band.
    boundaryShareTarget: 0.15,
    tectonics: Object.freeze({
        interiorNoiseWeight: 0.3, // 0..1 blend weight for plate-interior noise
        fractalGrain: 4, // coarser grain keeps tectonic blobs thick
        boundaryArcWeight: 0.8, // convergent arc multiplier; 1.0 = parity with closeness
        boundaryArcNoiseWeight: 0.5, // raggedness for arcs (0 = straight, 1 = noisy)
    }),
    geometry: Object.freeze({
        post: Object.freeze({
            expandTiles: 0,
            expandWestTiles: 0,
            expandEastTiles: 0,
        }),
    }),
});

const FOUNDATION_SEED_DEFAULT = Object.freeze({
    mode: "engine",
    fixed: null,
    offset: 0,
    offsets: Object.freeze({
        plates: 0,
        dynamics: 0,
        surface: 0,
        diagnostics: 0,
    }),
    manifestHash: null,
});

const FOUNDATION_PLATES_DEFAULT = Object.freeze({
    seedMode: "engine",
    count: 8,
    axisAngles: Object.freeze([15, -20, 35]),
    convergenceMix: 0.6,
    relaxationSteps: 5,
    seedJitter: 3,
    interiorSmooth: 3,
    plateRotationMultiple: 5,
    seedOffset: 0,
});

const FOUNDATION_WIND_DEFAULT = Object.freeze({
    jetStreaks: 5,
    jetStrength: 1.75,
    variance: 0.6,
    coriolisZonalScale: 1.0,
});

const FOUNDATION_CURRENTS_DEFAULT = Object.freeze({
    basinGyreCountMax: 2,
    westernBoundaryBias: 1.1,
    currentStrength: 4.0,
});

const FOUNDATION_MANTLE_DEFAULT = Object.freeze({
    bumps: 7,
    amplitude: 0.75,
    scale: 0.4,
});

const FOUNDATION_DIRECTIONALITY_DEFAULT = Object.freeze({
    cohesion: 0.45,
    primaryAxes: Object.freeze({
        plateAxisDeg: 0,
        windBiasDeg: 260,
        currentBiasDeg: -5,
    }),
    interplay: Object.freeze({
        windsFollowPlates: 0.55,
        currentsFollowWinds: 0.7,
        riftsFollowPlates: 0.75,
        orogenyOpposesRifts: 0.55,
    }),
    hemispheres: Object.freeze({
        southernFlip: true,
        equatorBandDeg: 18,
        monsoonBias: 0.6,
    }),
    variability: Object.freeze({
        angleJitterDeg: 15,
        magnitudeVariance: 0.45,
        seedOffset: 0,
    }),
});

const FOUNDATION_OCEAN_SEPARATION_DEFAULT = Object.freeze({
    enabled: false,
    bandPairs: Object.freeze([
        [0, 1],
        [1, 2],
    ]),
    baseSeparationTiles: 2,
    boundaryClosenessMultiplier: 1.0,
    maxPerRowDelta: 3,
    respectSeaLanes: true,
    minChannelWidth: 4,
    edgeWest: Object.freeze({
        enabled: false,
        baseTiles: 0,
        boundaryClosenessMultiplier: 1.0,
        maxPerRowDelta: 2,
    }),
    edgeEast: Object.freeze({
        enabled: false,
        baseTiles: 0,
        boundaryClosenessMultiplier: 1.0,
        maxPerRowDelta: 2,
    }),
});

const FOUNDATION_POLICY_DEFAULT = Object.freeze({
    windInfluence: 1.0,
    currentHumidityBias: 0.4,
    boundaryFjordBias: 0.3,
    shelfReefBias: 0.2,
    oceanSeparation: FOUNDATION_OCEAN_SEPARATION_DEFAULT,
});

const FOUNDATION_SURFACE_DEFAULT = Object.freeze({
    landmass: LANDMASS_DEFAULT,
    oceanSeparation: FOUNDATION_OCEAN_SEPARATION_DEFAULT,
    overrides: Object.freeze({}),
});

const FOUNDATION_DYNAMICS_DEFAULT = Object.freeze({
    wind: FOUNDATION_WIND_DEFAULT,
    currents: FOUNDATION_CURRENTS_DEFAULT,
    mantle: FOUNDATION_MANTLE_DEFAULT,
    directionality: FOUNDATION_DIRECTIONALITY_DEFAULT,
});

const FOUNDATION_DIAGNOSTICS_DEFAULT = Object.freeze({
    logSeed: false,
    logPlates: false,
    logDynamics: false,
    logSurface: false,
});

const FOUNDATION_DEFAULT = Object.freeze({
    seed: FOUNDATION_SEED_DEFAULT,
    plates: FOUNDATION_PLATES_DEFAULT,
    dynamics: FOUNDATION_DYNAMICS_DEFAULT,
    surface: FOUNDATION_SURFACE_DEFAULT,
    policy: FOUNDATION_POLICY_DEFAULT,
    diagnostics: FOUNDATION_DIAGNOSTICS_DEFAULT,
});

export const BASE_CONFIG = /** @type {import('../map_config.types.js').MapConfig} */ Object.freeze({
    // --- Master Feature Toggles ---
    // Enable or disable major Climate Story systems. Set to false to skip a layer entirely.
    toggles: Object.freeze({
        STORY_ENABLE_HOTSPOTS: false,
        STORY_ENABLE_RIFTS: false,
        STORY_ENABLE_OROGENY: false,
        STORY_ENABLE_SWATCHES: false,
        STORY_ENABLE_PALEO: false,
        STORY_ENABLE_CORRIDORS: false,
    }),
    // --- Climate aggregates (baseline + refinement + swatches) ---
    climate: Object.freeze({
        baseline: CLIMATE_BASELINE_DEFAULT,
        refine: CLIMATE_REFINE_DEFAULT,
        swatches: CLIMATE_SWATCHES_DEFAULT,
    }),
    // --- Stage Manifest ---
    // Canonical execution order and dependency graph for generator stages.
    stageManifest: Object.freeze({
        order: Object.freeze([
            "foundation",
            "landmassPlates",
            "coastlines",
            "storySeed",
            "storyHotspots",
            "storyRifts",
            "storyOrogeny",
            "storyPaleo",
            "storyCorridorsPre",
            "islands",
            "mountains",
            "volcanoes",
            "lakes",
            "climateBaseline",
            "storySwatches",
            "rivers",
            "storyCorridorsPost",
            "climateRefine",
            "biomes",
            "features",
            "placement",
        ]),
        stages: Object.freeze({
            foundation: Object.freeze({
                enabled: true,
                provides: Object.freeze([
                    "foundationContext",
                    "plates",
                    "wind",
                    "currents",
                    "mantle",
                    "directionality",
                ]),
            }),
            landmassPlates: Object.freeze({
                enabled: true,
                requires: Object.freeze(["foundation"]),
                provides: Object.freeze(["continents", "plateWindows", "heightfield"]),
            }),
            coastlines: Object.freeze({
                enabled: true,
                requires: Object.freeze(["landmassPlates"]),
                provides: Object.freeze(["expandedCoasts", "heightfield"]),
            }),
            storySeed: Object.freeze({
                enabled: true,
                requires: Object.freeze(["coastlines"]),
                provides: Object.freeze(["storyTags", "marginTags"]),
            }),
            storyHotspots: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed", "foundation"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_HOTSPOTS"]),
            }),
            storyRifts: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed", "foundation"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_RIFTS"]),
            }),
            storyOrogeny: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed", "foundation"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_OROGENY"]),
            }),
            storyPaleo: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_PALEO"]),
            }),
            storyCorridorsPre: Object.freeze({
                enabled: false,
                requires: Object.freeze(["storySeed"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_CORRIDORS"]),
            }),
            islands: Object.freeze({
                enabled: true,
                requires: Object.freeze(["storySeed"]),
                provides: Object.freeze(["heightfield"]),
            }),
            mountains: Object.freeze({
                enabled: true,
                requires: Object.freeze(["landmassPlates"]),
                provides: Object.freeze(["mountainHeights", "hillHeights", "heightfield"]),
            }),
            volcanoes: Object.freeze({
                enabled: true,
                requires: Object.freeze(["mountains"]),
                provides: Object.freeze(["volcanoes", "heightfield"]),
            }),
            lakes: Object.freeze({
                enabled: true,
                requires: Object.freeze(["mountains"]),
                provides: Object.freeze(["heightfield"]),
            }),
            climateBaseline: Object.freeze({
                enabled: true,
                requires: Object.freeze(["mountains"]),
                provides: Object.freeze(["rainfallBaseline", "climateField"]),
            }),
            storySwatches: Object.freeze({
                enabled: false,
                requires: Object.freeze(["climateBaseline", "storySeed"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_SWATCHES"]),
            }),
            rivers: Object.freeze({
                enabled: true,
                requires: Object.freeze(["climateBaseline"]),
                provides: Object.freeze(["rivers"]),
            }),
            storyCorridorsPost: Object.freeze({
                enabled: false,
                requires: Object.freeze(["rivers", "storyCorridorsPre"]),
                legacyToggles: Object.freeze(["STORY_ENABLE_CORRIDORS"]),
            }),
            climateRefine: Object.freeze({
                enabled: true,
                requires: Object.freeze(["climateBaseline", "rivers"]),
                provides: Object.freeze(["rainfallRefined", "climateField"]),
            }),
            biomes: Object.freeze({
                enabled: true,
                requires: Object.freeze(["climateRefine"]),
                provides: Object.freeze(["biomes"]),
            }),
            features: Object.freeze({
                enabled: true,
                requires: Object.freeze(["biomes"]),
                provides: Object.freeze(["features"]),
            }),
            placement: Object.freeze({
                enabled: true,
                requires: Object.freeze(["features"]),
                provides: Object.freeze(["starts", "resources", "discoveries"]),
            }),
        }),
    }),
    // --- World Foundation (seed + physics controls) ---
    foundation: FOUNDATION_DEFAULT,
    // --- Climate Story Tunables ---
    // Detailed parameters for each narrative motif.
    story: Object.freeze({
        // Deep-ocean hotspot trails (aligned island chains)
        hotspot: Object.freeze({
            maxTrails: 12, // total trails on a Huge map
            steps: 15, // polyline steps per trail
            stepLen: 2, // tiles advanced per step
            minDistFromLand: 5, // keep trails away from coasts
            minTrailSeparation: 12, // avoid parallel clutter between trails
            paradiseBias: 2, // 2:1 paradise:volcanic selection weight
            volcanicBias: 1,
            volcanicPeakChance: 0.7, // chance a volcanic center "peeks" as land
        }),
        // Continental rift lines (linear inland lakes/shoulders)
        rift: Object.freeze({
            maxRiftsPerMap: 3,
            lineSteps: 18,
            stepLen: 2,
            shoulderWidth: 1,
        }),
        // Orogeny belts (windward/lee amplification along mountain chains)
        orogeny: Object.freeze({
            beltMaxPerContinent: 2,
            beltMinLength: 30,
            radius: 2,
            windwardBoost: 5,
            leeDrynessAmplifier: 1.2,
        }),
        // "Black swan" climate swatches (guaranteed N1 macro zone)
        swatches: CLIMATE_SWATCHES_DEFAULT,
        // PaleoHydrology (deltas, oxbows, fossil channels)
        paleo: Object.freeze({
            maxDeltas: 4,
            deltaFanRadius: 1,
            deltaMarshChance: 0.35,
            maxOxbows: 6,
            oxbowElevationMax: 580,
            maxFossilChannels: 12,
            fossilChannelLengthTiles: 12,
            fossilChannelStep: 2,
            fossilChannelHumidity: 6,
            fossilChannelMinDistanceFromCurrentRivers: 4,
            minDistanceFromStarts: 7,
            sizeScaling: Object.freeze({
                lengthMulSqrt: 0.7,
            }),
            elevationCarving: Object.freeze({
                enableCanyonRim: true,
                rimWidth: 4,
                canyonDryBonus: 3,
                bluffWetReduction: 0,
            }),
        }),
    }),
    // --- Microclimate & Feature Adjustments ---
    // Small deltas applied by refinement passes.
    microclimate: Object.freeze({
        rainfall: Object.freeze({
            riftBoost: 8,
            riftRadius: 2,
            paradiseDelta: 6,
            volcanicDelta: 8,
        }),
        features: Object.freeze({
            paradiseReefChance: 23, // % chance
            volcanicForestChance: 27, // % chance
            volcanicTaigaChance: 25, // % chance
        }),
    }),
    // --- Strategic Corridors (sea lanes, island-hop, land, river chains) ---
    corridors: Object.freeze({
        sea: Object.freeze({
            maxLanes: 3,
            minLengthFrac: 0.7,
            scanStride: 6,
            avoidRadius: 2,
            // Scoring and spacing controls
            preferDiagonals: true,
            laneSpacing: 6,
            minChannelWidth: 3,
        }),
        islandHop: Object.freeze({
            useHotspots: true,
            maxArcs: 2,
        }),
        land: Object.freeze({
            useRiftShoulders: true,
            maxCorridors: 5,
            minRunLength: 24,
            spacing: 11,
        }),
        river: Object.freeze({
            maxChains: 2,
            maxSteps: 80,
            preferLowlandBelow: 300,
            coastSeedRadius: 2,
            minTiles: 24,
            mustEndNearCoast: true,
        }),
        // Per-consumer policy strengths and behaviors
        policy: Object.freeze({
            sea: Object.freeze({
                // 'hard' = never edit on lanes; 'soft' = reduce chance instead of skip
                protection: "hard",
                // When protection is 'soft', multiply coast edit probabilities by this factor (0..1)
                softChanceMultiplier: 0.5,
            }),
            land: Object.freeze({
                // 0..1; scales grassland bias strength on land-open corridors
                biomesBiasStrength: 0.6,
            }),
            river: Object.freeze({
                // 0..1; scales grassland bias strength on river-chain corridors
                biomesBiasStrength: 0.5,
            }),
        }),
        // Corridor kinds and styles (probabilities are gentle multipliers; consumers must validate)
        kinds: Object.freeze({
            sea: Object.freeze({
                styles: Object.freeze({
                    ocean: Object.freeze({
                        edge: Object.freeze({
                            cliffsChance: 0.15,
                            fjordChance: 0.1,
                        }),
                        features: Object.freeze({
                            reefBias: 0.1,
                        }),
                    }),
                    coastal: Object.freeze({
                        edge: Object.freeze({
                            cliffsChance: 0.25,
                            bayCarveMultiplier: 1.15,
                        }),
                        features: Object.freeze({
                            reefBias: 0.2,
                        }),
                    }),
                }),
            }),
            islandHop: Object.freeze({
                styles: Object.freeze({
                    archipelago: Object.freeze({
                        features: Object.freeze({
                            reefBias: 0.5,
                        }),
                        edge: Object.freeze({
                            shelfReefMultiplier: 1.25,
                        }),
                    }),
                }),
            }),
            land: Object.freeze({
                styles: Object.freeze({
                    desertBelt: Object.freeze({
                        biomes: Object.freeze({
                            desert: 0.7,
                            plains: 0.25,
                            grassland: 0.1,
                            tundra: 0.05,
                        }),
                        edge: Object.freeze({
                            mountainRimChance: 0.4,
                            forestRimChance: 0.1,
                        }),
                    }),
                    plainsBelt: Object.freeze({
                        biomes: Object.freeze({
                            plains: 0.55,
                            grassland: 0.3,
                            desert: 0.1,
                            tundra: 0.05,
                        }),
                        edge: Object.freeze({
                            forestRimChance: 0.1,
                            hillRimChance: 0.08,
                        }),
                    }),
                    grasslandBelt: Object.freeze({
                        biomes: Object.freeze({
                            grassland: 0.6,
                            plains: 0.25,
                            tropical: 0.1,
                            tundra: 0.05,
                        }),
                        edge: Object.freeze({
                            forestRimChance: 0.15,
                            hillRimChance: 0.05,
                        }),
                    }),
                    canyon: Object.freeze({
                        biomes: Object.freeze({
                            desert: 0.45,
                            plains: 0.3,
                            grassland: 0.15,
                            tundra: 0.1,
                        }),
                        edge: Object.freeze({
                            cliffChance: 0.6,
                            mountainRimChance: 0.12,
                        }),
                    }),
                    plateau: Object.freeze({
                        biomes: Object.freeze({
                            plains: 0.4,
                            grassland: 0.35,
                            desert: 0.15,
                            tundra: 0.1,
                        }),
                        edge: Object.freeze({
                            escarpmentChance: 0.71,
                            mountainRimChance: 0.08,
                        }),
                    }),
                    flatMtn: Object.freeze({
                        biomes: Object.freeze({
                            grassland: 0.35,
                            plains: 0.3,
                            tundra: 0.2,
                            desert: 0.15,
                        }),
                        edge: Object.freeze({
                            mountainRimChance: 0.6,
                            forestRimChance: 0.3,
                        }),
                    }),
                }),
            }),
            river: Object.freeze({
                styles: Object.freeze({
                    riverChain: Object.freeze({
                        biomes: Object.freeze({
                            grassland: 0.6,
                            plains: 0.25,
                            tropical: 0.15,
                        }),
                        features: Object.freeze({
                            floodplainBias: 0.1,
                            forestBias: 0.1,
                        }),
                        edge: Object.freeze({
                            forestRimChance: 0.15,
                        }),
                    }),
                }),
            }),
        }),
    }),
    // --- Landmass (base land/ocean and shaping) ---
    landmass: LANDMASS_DEFAULT,
    // --- Coastlines (rugged coasts; lane-safe) ---
    coastlines: Object.freeze({
        bay: Object.freeze({
            noiseGateAdd: 0,
            rollDenActive: 4,
            rollDenDefault: 5,
        }),
        fjord: Object.freeze({
            baseDenom: 12,
            activeBonus: 1,
            passiveBonus: 2,
        }),
        minSeaLaneWidth: 4,
        plateBias: Object.freeze({
            threshold: 0.45,
            power: 1.25,
            convergent: 1.0,
            transform: 0.4,
            divergent: -0.6,
            interior: 0,
            bayWeight: 0.35,
            bayNoiseBonus: 1.0,
            fjordWeight: 0.8,
        }),
    }),
    // --- Margins (active/passive tagging) ---
    margins: Object.freeze({
        activeFraction: 0.25,
        passiveFraction: 0.25,
        minSegmentLength: 12,
    }),
    // --- Islands (offshore clusters; hotspot bias) ---
    islands: Object.freeze({
        fractalThresholdPercent: 90,
        baseIslandDenNearActive: 5,
        baseIslandDenElse: 7,
        hotspotSeedDenom: 2,
        clusterMax: 3,
        minDistFromLandRadius: 2,
    }),
    // --- Climate Baseline (banded blend + local bonuses) ---
    // --- Mountains & Hills (WorldModel-driven, physics-threshold system) ---
    mountains: Object.freeze({
        // Physics-threshold controls (mountains only where physics justifies)
        tectonicIntensity: 1.0,      // Base intensity (1.0 = standard tectonics)
        mountainThreshold: 0.45,     // Score must exceed this for mountains
        hillThreshold: 0.25,         // Score must exceed this for hills
        // Physics weights
        upliftWeight: 0.6,
        fractalWeight: 0.4,
        riftDepth: 0.25,
        boundaryWeight: 0.85,
        boundaryExponent: 1.3,
        interiorPenaltyWeight: 0.18,
        convergenceBonus: 0.65,
        transformPenalty: 0.25,
        riftPenalty: 0.65,
        hillBoundaryWeight: 0.4,
        hillRiftBonus: 0.45,
        hillConvergentFoothill: 0.22,
        hillInteriorFalloff: 0.2,
        hillUpliftWeight: 0.3,
    }),
    volcanoes: Object.freeze({
        enabled: true,
        baseDensity: 1 / 170,
        minSpacing: 3,
        boundaryThreshold: 0.35,
        boundaryWeight: 1.2,
        convergentMultiplier: 2.4,
        transformMultiplier: 1.1,
        divergentMultiplier: 0.35,
        hotspotWeight: 0.12,
        shieldPenalty: 0.6,
        randomJitter: 0.08,
        minVolcanoes: 5,
        maxVolcanoes: 40,
    }),
    // --- Biomes (nudges) ---
    biomes: Object.freeze({
        tundra: Object.freeze({
            latMin: 70,
            elevMin: 850,
            rainMax: 90,
        }),
        tropicalCoast: Object.freeze({
            latMax: 18,
            rainMin: 105,
        }),
        riverValleyGrassland: Object.freeze({
            latMax: 50,
            rainMin: 75,
        }),
        riftShoulder: Object.freeze({
            grasslandLatMax: 50,
            grasslandRainMin: 75,
            tropicalLatMax: 18,
            tropicalRainMin: 100,
        }),
    }),
    // --- Features density tweaks (validated) ---
    featuresDensity: Object.freeze({
        rainforestExtraChance: 75,
        forestExtraChance: 20,
        taigaExtraChance: 35,
        shelfReefMultiplier: 0.6,
    }),
    // --- Placement ---
    placement: Object.freeze({
        wondersPlusOne: true,
        floodplains: Object.freeze({
            minLength: 4,
            maxLength: 10,
        }),
    }),
    // --- Dev logger defaults (ON for development) ---
    // These feed the resolved config; dev.js will be aligned to read from them.
    dev: Object.freeze({
        enabled: true,
        logTiming: true,
        logStoryTags: true,
        rainfallHistogram: true,
        LOG_FOUNDATION_SUMMARY: true,
        LOG_FOUNDATION_ASCII: true,
        LOG_FOUNDATION_SEED: true,
        LOG_FOUNDATION_PLATES: true,
        LOG_BOUNDARY_METRICS: true,
        LOG_LANDMASS_ASCII: true,
        LOG_LANDMASS_WINDOWS: true,
        LOG_RELIEF_ASCII: true,
        LOG_MOUNTAINS: true,
    }),
});
export default BASE_CONFIG;
</file>

<file path="mod/maps/bootstrap/presets/classic.js">
// @ts-nocheck
/**
 * Classic preset  baseline threeband layout with vanillalike oceans.
 *
 * Purpose
 * - Provide a named, conservative baseline preset suitable as a starting point
 *   for variants. This preset is intentionally minimal and close to defaults.
 *
 * Usage (example)
 *   import { CLASSIC_PRESET } from "./config/presets/classic.js";
 *   setConfig({
 *     ...CLASSIC_PRESET,
 *     // Optional overrides...
 *   });
 */
// @ts-check
export const CLASSIC_PRESET = Object.freeze({
    stageConfig: Object.freeze({
        foundation: true,
        landmassPlates: true,
    }),
    // Keep all major systems enabled by default
    toggles: Object.freeze({
        STORY_ENABLE_HOTSPOTS: true,
        STORY_ENABLE_RIFTS: true,
        STORY_ENABLE_OROGENY: true,
        STORY_ENABLE_SWATCHES: true,
        STORY_ENABLE_PALEO: true,
        STORY_ENABLE_CORRIDORS: true,
    }),
    // Dev logger defaults (quiet; entries/presets may override for debugging)
    dev: Object.freeze({
        enabled: false,
        logTiming: false,
        logStoryTags: false,
        rainfallHistogram: false,
    }),
});
export default CLASSIC_PRESET;
</file>

<file path="mod/maps/bootstrap/presets/temperate.js">
// @ts-nocheck
/**
 * Temperate preset  gentle, tradewind world with classic threeband layout.
 *
 * Purpose
 * - Provide a concise, conservative preset to compose with defaults and/or
 *   per-entry overrides. This is a partial config (no exhaustive fields).
 *
 * Usage (example)
 *   import { TEMPERATE_PRESET } from "./config/presets/temperate.js";
 *   setConfig({
 *     ...TEMPERATE_PRESET,
 *     // Optional overrides...
 *   });
 */
// @ts-check
export const TEMPERATE_PRESET = Object.freeze({
    stageConfig: Object.freeze({
        foundation: true,
        landmassPlates: true,
    }),
    // Keep all major systems enabled (gentle, cohesive world)
    toggles: Object.freeze({
        STORY_ENABLE_HOTSPOTS: true,
        STORY_ENABLE_RIFTS: true,
        STORY_ENABLE_OROGENY: true,
        STORY_ENABLE_SWATCHES: true,
        STORY_ENABLE_PALEO: true,
        STORY_ENABLE_CORRIDORS: true,
    }),
    // Lightweight Earth Forces with moderated global cohesion
    foundation: Object.freeze({
        dynamics: Object.freeze({
            directionality: Object.freeze({
                cohesion: 0.6,
                hemispheres: Object.freeze({
                    // Slight seasonal/hemispheric asymmetry
                    monsoonBias: 0.25,
                }),
            }),
        }),
    }),
    // Dev logger defaults (quiet; entries may override during debugging)
    dev: Object.freeze({
        enabled: false,
        logTiming: false,
        logStoryTags: false,
        rainfallHistogram: false,
    }),
});
export default TEMPERATE_PRESET;
</file>

<file path="mod/maps/bootstrap/climate-tunables.js">
/**
 * Climate-focused tunable surface. Thin wrapper over the unified tunables module
 * so climate layers can import a concise bundle without re-export noise.
 */
export {
    rebind,
    CLIMATE_TUNABLES,
    CLIMATE,
    CLIMATE_CFG,
    CLIMATE_DRIVERS,
    MOISTURE_ADJUSTMENTS,
    STORY_TUNABLES,
} from "./tunables.js";
</file>

<file path="mod/maps/bootstrap/dev.js">
// @ts-nocheck
/**
 * Developer logging configuration and helpers (disabled by default).
 *
 * Purpose
 * - Centralize all dev-only flags and utilities so verbose logs can be enabled
 *   temporarily without touching generation logic.
 * - Keep all helpers no-op when disabled to avoid perf impact or noisy output.
 *
 * Usage (example)
 *   import { DEV, devLog, devLogIf, timeSection, logStoryTagsSummary, logRainfallHistogram } from "./config/dev.js";
 *
 *   // Enable locally for a debugging session:
 *   // DEV.ENABLED = true; DEV.LOG_TIMING = true; DEV.LOG_STORY_TAGS = true;
 *
 *   devLog("Hello from dev logs");
 *   devLogIf("LOG_STORY_TAGS", "Story tags will be summarized later");
 *
 *   timeSection("Layer: addIslandChains", () => {
 *     addIslandChains(width, height);
 *   });
 *
 *   logStoryTagsSummary(StoryTags);
 *   logRainfallHistogram(width, height, 12);
 */
/**
 * Master toggles (all false by default).
 * Flip selectively during development sessions; keep off for release builds.
 */
import * as globals from "/base-standard/maps/map-globals.js";
import { dumpTerrain, dumpRainfall, dumpBiomes, dumpContinents } from "/base-standard/maps/map-debug-helpers.js";
import { DEV_LOG_CFG as __DEV_CFG__, FOUNDATION_DIAGNOSTICS as __FOUNDATION_DIAGNOSTICS__ } from "./resolved.js";
export const DEV = {
    ENABLED: false, // Master switch  must be true for any dev logging
    LOG_TIMING: false, // Log per-section timings (timeSection / timeStart/timeEnd)
    LOG_STORY_TAGS: false, // Log StoryTags summary counts
    RAINFALL_HISTOGRAM: false, // Log a coarse rainfall histogram (non-water tiles only)
    LOG_RAINFALL_SUMMARY: false, // Log rainfall min/max/avg statistics
    LOG_CORRIDOR_ASCII: false, // Print a coarse ASCII overlay of corridor tags (downsampled)
    LOG_FOUNDATION_SUMMARY: false, // Print compact Foundation summary when available
    LOG_FOUNDATION_ASCII: false, // ASCII visualization of plate boundaries & terrain mix
    LOG_LANDMASS_ASCII: false, // ASCII snapshot of land vs. ocean bands/continents
    LOG_LANDMASS_WINDOWS: false, // Log landmass window bounding boxes/areas
    LOG_RELIEF_ASCII: false, // ASCII visualization of major relief (mountains/hills/volcanoes)
    LOG_RAINFALL_ASCII: false, // ASCII heatmap buckets for rainfall bands
    LOG_BIOME_ASCII: false, // ASCII biome classification overlay
    LOG_BIOME_SUMMARY: false, // Log biome tile counts
    LOG_SWATCHES: false, // Log climate swatch usage/results
    LOG_MOUNTAINS: false, // Detailed mountain placement summaries
    LOG_VOLCANOES: false, // Detailed volcano placement summaries
    LOG_BOUNDARY_METRICS: false, // Quantitative summary of plate boundary coverage
    FOUNDATION_HISTOGRAMS: false, // Print histograms for rift/uplift (optionally near tags)
    LAYER_COUNTS: false, // Reserved for layer-specific counters (if used by callers)
    LOG_FOUNDATION_SEED: false,
    LOG_FOUNDATION_PLATES: false,
    LOG_FOUNDATION_DYNAMICS: false,
    LOG_FOUNDATION_SURFACE: false,
};
/**
 * Internal: guard that checks if a specific flag is enabled (and master is on).
 * @param {keyof typeof DEV} flag
 * @returns {boolean}
 */
/**
 * Initialize DEV flags from resolved.DEV_LOG_CFG() at module import time.
 * Entries/presets can override dev logging per run.
 */
try {
    const __cfg = typeof __DEV_CFG__ === "function" ? __DEV_CFG__() : null;
    if (__cfg && typeof __cfg === "object") {
        if ("enabled" in __cfg)
            DEV.ENABLED = !!__cfg.enabled;
        if ("logTiming" in __cfg)
            DEV.LOG_TIMING = !!__cfg.logTiming;
        if ("logStoryTags" in __cfg)
            DEV.LOG_STORY_TAGS = !!__cfg.logStoryTags;
        if ("rainfallHistogram" in __cfg)
            DEV.RAINFALL_HISTOGRAM = !!__cfg.rainfallHistogram;
        if ("LOG_RAINFALL_SUMMARY" in __cfg)
            DEV.LOG_RAINFALL_SUMMARY = !!__cfg.LOG_RAINFALL_SUMMARY;
        if ("LOG_CORRIDOR_ASCII" in __cfg)
            DEV.LOG_CORRIDOR_ASCII = !!__cfg.LOG_CORRIDOR_ASCII;
        if ("LOG_FOUNDATION_SUMMARY" in __cfg)
            DEV.LOG_FOUNDATION_SUMMARY = !!__cfg.LOG_FOUNDATION_SUMMARY;
        else if ("LOG_WORLDMODEL_SUMMARY" in __cfg)
            DEV.LOG_FOUNDATION_SUMMARY = !!__cfg.LOG_WORLDMODEL_SUMMARY;
        if ("LOG_FOUNDATION_ASCII" in __cfg)
            DEV.LOG_FOUNDATION_ASCII = !!__cfg.LOG_FOUNDATION_ASCII;
        else if ("LOG_WORLDMODEL_ASCII" in __cfg)
            DEV.LOG_FOUNDATION_ASCII = !!__cfg.LOG_WORLDMODEL_ASCII;
        if ("LOG_LANDMASS_ASCII" in __cfg)
            DEV.LOG_LANDMASS_ASCII = !!__cfg.LOG_LANDMASS_ASCII;
        if ("LOG_LANDMASS_WINDOWS" in __cfg)
            DEV.LOG_LANDMASS_WINDOWS = !!__cfg.LOG_LANDMASS_WINDOWS;
        if ("LOG_RELIEF_ASCII" in __cfg)
            DEV.LOG_RELIEF_ASCII = !!__cfg.LOG_RELIEF_ASCII;
        if ("LOG_RAINFALL_ASCII" in __cfg)
            DEV.LOG_RAINFALL_ASCII = !!__cfg.LOG_RAINFALL_ASCII;
        if ("LOG_BIOME_ASCII" in __cfg)
            DEV.LOG_BIOME_ASCII = !!__cfg.LOG_BIOME_ASCII;
        if ("LOG_BIOME_SUMMARY" in __cfg)
            DEV.LOG_BIOME_SUMMARY = !!__cfg.LOG_BIOME_SUMMARY;
        if ("LOG_SWATCHES" in __cfg)
            DEV.LOG_SWATCHES = !!__cfg.LOG_SWATCHES;
        if ("LOG_BOUNDARY_METRICS" in __cfg)
            DEV.LOG_BOUNDARY_METRICS = !!__cfg.LOG_BOUNDARY_METRICS;
        if ("LOG_MOUNTAINS" in __cfg)
            DEV.LOG_MOUNTAINS = !!__cfg.LOG_MOUNTAINS;
        if ("LOG_VOLCANOES" in __cfg)
            DEV.LOG_VOLCANOES = !!__cfg.LOG_VOLCANOES;
        if ("FOUNDATION_HISTOGRAMS" in __cfg)
            DEV.FOUNDATION_HISTOGRAMS = !!__cfg.FOUNDATION_HISTOGRAMS;
        else if ("WORLDMODEL_HISTOGRAMS" in __cfg)
            DEV.FOUNDATION_HISTOGRAMS = !!__cfg.WORLDMODEL_HISTOGRAMS;
        if ("LOG_FOUNDATION_SEED" in __cfg)
            DEV.LOG_FOUNDATION_SEED = !!__cfg.LOG_FOUNDATION_SEED;
        if ("LOG_FOUNDATION_PLATES" in __cfg)
            DEV.LOG_FOUNDATION_PLATES = !!__cfg.LOG_FOUNDATION_PLATES;
        if ("LOG_FOUNDATION_DYNAMICS" in __cfg)
            DEV.LOG_FOUNDATION_DYNAMICS = !!__cfg.LOG_FOUNDATION_DYNAMICS;
        if ("LOG_FOUNDATION_SURFACE" in __cfg)
            DEV.LOG_FOUNDATION_SURFACE = !!__cfg.LOG_FOUNDATION_SURFACE;
    }
}
catch (_) {
    /* no-op */
}

applyFoundationDiagnostics();

function isOn(flag) {
    return !!(DEV && DEV.ENABLED && DEV[flag]);
}

function applyFoundationDiagnostics() {
    let diag = null;
    try {
        diag = typeof __FOUNDATION_DIAGNOSTICS__ === "function" ? __FOUNDATION_DIAGNOSTICS__() : null;
    }
    catch (_) {
        diag = null;
    }
    if (!diag || typeof diag !== "object")
        return;
    const { logSeed, logPlates, logDynamics, logSurface } = diag;
    if (logSeed || logPlates || logDynamics || logSurface)
        DEV.ENABLED = true;
    if (logSeed) {
        DEV.LOG_FOUNDATION_SEED = true;
    }
    if (logPlates) {
        DEV.LOG_FOUNDATION_PLATES = true;
        DEV.LOG_FOUNDATION_SUMMARY = true;
        DEV.LOG_FOUNDATION_ASCII = true;
        DEV.LOG_BOUNDARY_METRICS = true;
    }
    if (logDynamics) {
        DEV.LOG_FOUNDATION_DYNAMICS = true;
        DEV.FOUNDATION_HISTOGRAMS = true;
    }
    if (logSurface) {
        DEV.LOG_FOUNDATION_SURFACE = true;
        DEV.LOG_LANDMASS_ASCII = true;
        DEV.LOG_LANDMASS_WINDOWS = true;
    }
}
/**
 * Safe console.log wrapper (no-op if disabled).
 * @param  {...any} args
 */
export function devLog(...args) {
    if (!DEV.ENABLED)
        return;
    try {
        console.log("[DEV]", ...args);
    }
    catch (_) {
        /* swallow */
    }
}
/**
 * Conditional console.log wrapper for a specific flag under the master switch.
 * @param {keyof typeof DEV} flag
 * @param  {...any} args
 */
export function devLogIf(flag, ...args) {
    if (!isOn(flag))
        return;
    try {
        console.log(`[DEV][${String(flag)}]`, ...args);
    }
    catch (_) {
        /* swallow */
    }
}
/**
 * Time a synchronous section and log duration (no-op if LOG_TIMING disabled).
 * @template T
 * @param {string} label
 * @param {() => T} fn
 * @returns {T}
 */
export function timeSection(label, fn) {
    if (!isOn("LOG_TIMING"))
        return fn();
    const t0 = nowMs();
    try {
        return fn();
    }
    finally {
        const dt = nowMs() - t0;
        safeLog(`[DEV][time] ${label}: ${fmtMs(dt)}`);
    }
}
/**
 * Start a timing span; returns a token to pass to timeEnd.
 * No-op (returns null) if LOG_TIMING disabled.
 * @param {string} label
 * @returns {{label:string,t0:number}|null}
 */
export function timeStart(label) {
    if (!isOn("LOG_TIMING"))
        return null;
    return { label, t0: nowMs() };
}
/**
 * End a timing span started by timeStart.
 * Safe to call with null (no-op).
 * @param {{label:string,t0:number}|null} token
 */
export function timeEnd(token) {
    if (!token)
        return;
    const dt = nowMs() - token.t0;
    safeLog(`[DEV][time] ${token.label}: ${fmtMs(dt)}`);
}
/**
 * Log a compact summary of StoryTags (sizes of known sets).
 * Safe if StoryTags is missing or partially defined.
 * No-op if LOG_STORY_TAGS disabled.
 * @param {{hotspot?:Set<string>,hotspotParadise?:Set<string>,hotspotVolcanic?:Set<string>,riftLine?:Set<string>,riftShoulder?:Set<string>,activeMargin?:Set<string>,passiveShelf?:Set<string>}} StoryTags
 * @param {{belts?:Set<string>,windward?:Set<string>,lee?:Set<string>}} [OrogenyCache]
 */
export function logStoryTagsSummary(StoryTags, OrogenyCache) {
    if (!isOn("LOG_STORY_TAGS"))
        return;
    if (!StoryTags || typeof StoryTags !== "object") {
        safeLog("[DEV][story] StoryTags not available");
        return;
    }
    const counts = {
        hotspot: sizeOf(StoryTags.hotspot),
        hotspotParadise: sizeOf(StoryTags.hotspotParadise),
        hotspotVolcanic: sizeOf(StoryTags.hotspotVolcanic),
        riftLine: sizeOf(StoryTags.riftLine),
        riftShoulder: sizeOf(StoryTags.riftShoulder),
        activeMargin: sizeOf(StoryTags.activeMargin),
        passiveShelf: sizeOf(StoryTags.passiveShelf),
        corridorSeaLane: sizeOf(StoryTags.corridorSeaLane),
        corridorIslandHop: sizeOf(StoryTags.corridorIslandHop),
        corridorLandOpen: sizeOf(StoryTags.corridorLandOpen),
        corridorRiverChain: sizeOf(StoryTags.corridorRiverChain),
    };
    safeLog("[DEV][story] tags:", counts);
    if (OrogenyCache && typeof OrogenyCache === "object") {
        const oroCounts = {
            belts: sizeOf(OrogenyCache.belts),
            windward: sizeOf(OrogenyCache.windward),
            lee: sizeOf(OrogenyCache.lee),
        };
        if (oroCounts.belts > 0) {
            safeLog("[DEV][story] orogeny:", oroCounts);
        }
    }
    // Optional ASCII corridor overlay (downsampled)
    if (isOn("LOG_CORRIDOR_ASCII")) {
        logCorridorAsciiOverlay();
    }
}
/**
 * Build and log a rainfall histogram over non-water tiles (coarse bins).
 * Depends on GameplayMap (provided by the game engine at runtime).
 * No-op if RAINFALL_HISTOGRAM disabled or GameplayMap is unavailable.
 * @param {number} width
 * @param {number} height
 * @param {number} [bins=10]
 */
export function logRainfallHistogram(width, height, bins = 10) {
    if (!isOn("RAINFALL_HISTOGRAM"))
        return;
    try {
        if (typeof GameplayMap?.getRainfall !== "function" ||
            typeof GameplayMap?.isWater !== "function") {
            safeLog("[DEV][rain] GameplayMap API unavailable; skipping histogram.");
            return;
        }
        const counts = new Array(Math.max(1, Math.min(100, bins))).fill(0);
        let samples = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (GameplayMap.isWater(x, y))
                    continue;
                const r = clampTo(GameplayMap.getRainfall(x, y), 0, 200);
                const idx = Math.min(counts.length - 1, Math.floor((r / 201) * counts.length));
                counts[idx]++;
                samples++;
            }
        }
        if (samples === 0) {
            safeLog("[DEV][rain] No land samples for histogram.");
            return;
        }
        const pct = counts.map((c) => ((c / samples) * 100).toFixed(1) + "%");
        safeLog("[DEV][rain] histogram (bins=", counts.length, "):", pct);
    }
    catch (err) {
        safeLog("[DEV][rain] histogram error:", err);
    }
}

export function logRainfallStats(label = "rainfall", width, height) {
    if (!isOn("LOG_RAINFALL_SUMMARY"))
        return;
    try {
        const w = Number.isFinite(width) ? width : GameplayMap?.getGridWidth?.();
        const h = Number.isFinite(height) ? height : GameplayMap?.getGridHeight?.();
        if (!w || !h) {
            safeLog(`[DEV][rain] stats ${label}: No map bounds.`);
            return;
        }
        if (typeof GameplayMap?.getRainfall !== "function" || typeof GameplayMap?.isWater !== "function") {
            safeLog(`[DEV][rain] stats ${label}: GameplayMap API unavailable.`);
            return;
        }
        let min = Infinity;
        let max = -Infinity;
        let sum = 0;
        let landTiles = 0;
        const buckets = { arid: 0, semiArid: 0, temperate: 0, wet: 0, lush: 0 };
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (GameplayMap.isWater(x, y))
                    continue;
                const value = GameplayMap.getRainfall(x, y) ?? 0;
                landTiles++;
                if (value < min)
                    min = value;
                if (value > max)
                    max = value;
                sum += value;
                if (value < 25)
                    buckets.arid++;
                else if (value < 60)
                    buckets.semiArid++;
                else if (value < 95)
                    buckets.temperate++;
                else if (value < 130)
                    buckets.wet++;
                else
                    buckets.lush++;
            }
        }
        if (landTiles === 0) {
            safeLog(`[DEV][rain] stats ${label}: No land tiles.`);
            return;
        }
        const avg = sum / landTiles;
        safeLog(`[DEV][rain] stats ${label}:`, {
            landTiles,
            min,
            max,
            avg: Number(avg.toFixed(2)),
            buckets,
        });
    }
    catch (err) {
        safeLog(`[DEV][rain] stats ${label} error:`, err);
    }
}

export function logBiomeSummary(label = "biomes", width, height) {
    if (!isOn("LOG_BIOME_SUMMARY"))
        return;
    try {
        const w = Number.isFinite(width) ? width : GameplayMap?.getGridWidth?.();
        const h = Number.isFinite(height) ? height : GameplayMap?.getGridHeight?.();
        if (!w || !h) {
            safeLog(`[DEV][biome] summary ${label}: No map bounds.`);
            return;
        }
        if (typeof GameplayMap?.getBiomeType !== "function") {
            safeLog(`[DEV][biome] summary ${label}: GameplayMap.getBiomeType unavailable.`);
            return;
        }
        const counts = new Map();
        let landTiles = 0;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (GameplayMap.isWater?.(x, y))
                    continue;
                landTiles++;
                const id = GameplayMap.getBiomeType(x, y) ?? -1;
                counts.set(id, (counts.get(id) ?? 0) + 1);
            }
        }
        const summary = Array.from(counts.entries())
            .map(([id, count]) => ({
            id,
            name: resolveBiomeName(id),
            count,
            share: landTiles > 0 ? Number(((count / landTiles) * 100).toFixed(2)) : 0,
        }))
            .sort((a, b) => b.count - a.count);
        safeLog(`[DEV][biome] summary ${label}:`, {
            landTiles,
            summary,
        });
    }
    catch (err) {
        safeLog(`[DEV][biome] summary ${label} error:`, err);
    }
}

function resolveBiomeName(id) {
    try {
        if (id == null || id < 0)
            return null;
        const entry = GameInfo?.Biomes?.[id];
        if (entry?.Name)
            return entry.Name;
    }
    catch {
        /* ignore */
    }
    return null;
}

/**
 * Log foundation seed configuration and (optional) captured plate seed snapshot.
 * @param {any} seedConfig
 * @param {any} plateSeed
 * @param {{skipConfig?:boolean}} [options]
 */
export function logFoundationSeed(seedConfig, plateSeed, options = {}) {
    if (!isOn("LOG_FOUNDATION_SEED"))
        return;
    const { skipConfig = false } = options || {};
    try {
        if (!skipConfig) {
            safeLog("[Foundation] seed config:", summarizeFoundationSeedConfig(seedConfig));
        }
        if (plateSeed && typeof plateSeed === "object") {
            safeLog("[Foundation] plate seed snapshot:", summarizePlateSeed(plateSeed));
        }
    }
    catch (err) {
        safeLog("[Foundation] seed log error:", err);
    }
}

/**
 * Log configured plate generation parameters.
 * @param {any} platesConfig
 */
export function logFoundationPlates(platesConfig) {
    if (!isOn("LOG_FOUNDATION_PLATES"))
        return;
    try {
        safeLog("[Foundation] plates config:", summarizeFoundationPlates(platesConfig));
    }
    catch (err) {
        safeLog("[Foundation] plates log error:", err);
    }
}

/**
 * Log wind/currents/mantle/directionality drivers.
 * @param {any} dynamicsConfig
 */
export function logFoundationDynamics(dynamicsConfig) {
    if (!isOn("LOG_FOUNDATION_DYNAMICS"))
        return;
    try {
        safeLog("[Foundation] dynamics config:", summarizeFoundationDynamics(dynamicsConfig));
    }
    catch (err) {
        safeLog("[Foundation] dynamics log error:", err);
    }
}

/**
 * Log surface targets (landmass + ocean separation).
 * @param {any} surfaceConfig
 */
export function logFoundationSurface(surfaceConfig) {
    if (!isOn("LOG_FOUNDATION_SURFACE"))
        return;
    try {
        safeLog("[Foundation] surface config:", summarizeFoundationSurface(surfaceConfig));
    }
    catch (err) {
        safeLog("[Foundation] surface log error:", err);
    }
}
/**
 * Foundation summary: plates and boundary type counts (compact).
 * Accepts a WorldModel-like object (so callers can pass the singleton).
 * No-op if LOG_FOUNDATION_SUMMARY disabled.
 * @param {{isEnabled?:()=>boolean,plateId?:Int16Array,boundaryType?:Uint8Array,boundaryCloseness?:Uint8Array,upliftPotential?:Uint8Array, riftPotential?:Uint8Array}} WorldModel
 */
export function logFoundationSummary(WorldModel) {
    if (!isOn("LOG_FOUNDATION_SUMMARY"))
        return;
    try {
        const enabled = !!WorldModel &&
            typeof WorldModel.isEnabled === "function" &&
            !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        const size = Math.max(0, width * height) | 0;
        const plateId = WorldModel.plateId;
        const bType = WorldModel.boundaryType;
        const bClose = WorldModel.boundaryCloseness;
        const uplift = WorldModel.upliftPotential;
        const rift = WorldModel.riftPotential;
        if (!plateId || !bType || !bClose) {
            safeLog("[DEV][foundation] Missing core fields; skipping summary.");
            return;
        }
        const plates = new Set();
        const btCounts = [0, 0, 0, 0]; // none, convergent, divergent, transform
        let boundaryTiles = 0;
        const n = Math.min(size, plateId.length, bType.length, bClose.length);
        for (let i = 0; i < n; i++) {
            plates.add(plateId[i]);
            const bt = bType[i] | 0;
            if (bt >= 0 && bt < btCounts.length)
                btCounts[bt]++;
            if ((bClose[i] | 0) > 32)
                boundaryTiles++;
        }
        function avgByte(arr) {
            if (!arr || !arr.length)
                return 0;
            const m = Math.min(arr.length, size || arr.length);
            let s = 0;
            for (let i = 0; i < m; i++)
                s += arr[i] | 0;
            return Math.round(s / Math.max(1, m));
        }
        // Row sampling to spot directional bias quickly.
        const rowSamples = [];
        const rowsToSample = [0, Math.floor(height * 0.25), Math.floor(height * 0.5), Math.floor(height * 0.75), height - 1].filter((y, idx, arr) => y >= 0 && y < height && arr.indexOf(y) === idx);
        for (const y of rowsToSample) {
            let clos = 0, ups = 0, landClos = 0, landUps = 0, landCount = 0;
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const c = bClose[i] | 0;
                const u = uplift ? uplift[i] | 0 : 0;
                const isLand = GameplayMap?.isWater ? !GameplayMap.isWater(x, y) : true;
                clos += c;
                ups += u;
                if (isLand) {
                    landCount++;
                    landClos += c;
                    landUps += u;
                }
            }
            rowSamples.push({
                row: y,
                closAvg: Math.round(clos / Math.max(1, width)),
                upliftAvg: uplift ? Math.round(ups / Math.max(1, width)) : null,
                landCount,
                landClosAvg: landCount ? Math.round(landClos / landCount) : null,
                landUpliftAvg: landCount && uplift ? Math.round(landUps / landCount) : null,
            });
        }
        const summary = {
            width,
            height,
            plates: plates.size,
            boundaryTiles,
            boundaryTypes: {
                none: btCounts[0] | 0,
                convergent: btCounts[1] | 0,
                divergent: btCounts[2] | 0,
                transform: btCounts[3] | 0,
            },
            upliftAvg: uplift ? avgByte(uplift) : null,
            riftAvg: rift ? avgByte(rift) : null,
            rowSamples,
        };
        safeLog(`[DEV][foundation] summary: ${JSON.stringify(summary)}`);
    }
    catch (err) {
        safeLog("[DEV][foundation] summary error:", err);
    }
}
/**
 * Foundation histograms for uplift/rift potentials. Optionally restrict samples
 * to tiles included in provided tag sets (Orogeny belts or Rift lines).
 * No-op if FOUNDATION_HISTOGRAMS disabled.
 * @param {{isEnabled?:()=>boolean,upliftPotential?:Uint8Array, riftPotential?:Uint8Array}} WorldModel
 * @param {{riftSet?:Set<string>, beltSet?:Set<string>, bins?:number}} [opts]
 */
export function logFoundationHistograms(WorldModel, opts = {}) {
    if (!isOn("FOUNDATION_HISTOGRAMS"))
        return;
    try {
        const enabled = !!WorldModel &&
            typeof WorldModel.isEnabled === "function" &&
            !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] hist: WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        const size = Math.max(0, width * height) | 0;
        const uplift = WorldModel.upliftPotential;
        const rift = WorldModel.riftPotential;
        if (!uplift || !rift) {
            safeLog("[DEV][foundation] hist: Missing fields (uplift/rift).");
            return;
        }
        const bins = Math.max(5, Math.min(50, opts.bins | 0 || 10));
        const histAll = (arr) => {
            const h = new Array(bins).fill(0);
            const n = Math.min(arr.length, size || arr.length);
            let samples = 0;
            for (let i = 0; i < n; i++) {
                const v = arr[i] | 0; // 0..255
                const bi = Math.min(bins - 1, Math.floor((v / 256) * bins));
                h[bi]++;
                samples++;
            }
            return { h, samples };
        };
        const histMasked = (arr, maskSet) => {
            if (!maskSet || !(maskSet instanceof Set) || maskSet.size === 0)
                return null;
            const h = new Array(bins).fill(0);
            let samples = 0;
            // Scan grid once; test membership by tile key
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const key = `${x},${y}`;
                    if (!maskSet.has(key))
                        continue;
                    const i = y * width + x;
                    const v = arr[i] | 0;
                    const bi = Math.min(bins - 1, Math.floor((v / 256) * bins));
                    h[bi]++;
                    samples++;
                }
            }
            return { h, samples };
        };
        const pct = (h, total) => h.map((c) => ((c / Math.max(1, total)) * 100).toFixed(1) + "%");
        const aU = histAll(uplift);
        const aR = histAll(rift);
        safeLog("[DEV][foundation] uplift (all) hist:", pct(aU.h, aU.samples));
        safeLog("[DEV][foundation] rift   (all) hist:", pct(aR.h, aR.samples));
        // Optional masked histograms near tags
        const mUrift = histMasked(uplift, opts.riftSet);
        const mRrift = histMasked(rift, opts.riftSet);
        if (mUrift && mRrift) {
            safeLog("[DEV][foundation] uplift (near riftLine) hist:", pct(mUrift.h, mUrift.samples));
            safeLog("[DEV][foundation] rift   (near riftLine) hist:", pct(mRrift.h, mRrift.samples));
        }
        const mUbelts = histMasked(uplift, opts.beltSet);
        const mRbelts = histMasked(rift, opts.beltSet);
        if (mUbelts && mRbelts) {
            safeLog("[DEV][foundation] uplift (near orogeny belts) hist:", pct(mUbelts.h, mUbelts.samples));
            safeLog("[DEV][foundation] rift   (near orogeny belts) hist:", pct(mRbelts.h, mRbelts.samples));
        }
    }
    catch (err) {
        safeLog("[DEV][foundation] hist error:", err);
    }
}
const ASCII_GRID_LAYOUT = {
    basePadding: {
        left: " ",
        right: " ",
    },
    overlayPadding: {
        left: " ",
        right: " ",
    },
};
const ASCII_FOUNDATION_CHARS = {
    base: {
        water: "~",
        land: ".",
    },
    overlay: {
        convergent: "^",
        divergent: "_",
        transform: "#",
        boundary: " ",
    },
};
const ASCII_CORRIDOR_CHARS = {
    base: {
        water: "~",
        land: ".",
    },
    overlays: {
        seaLane: "S",
        islandHop: "I",
        riverChain: "R",
        landOpen: "L",
    },
};
export const ASCII_DISPLAY = {
    grid: ASCII_GRID_LAYOUT,
    foundation: ASCII_FOUNDATION_CHARS,
    corridor: ASCII_CORRIDOR_CHARS,
};
/**
 * ASCII snapshot of terrain with optional plate-boundary overlay.
 * Prints a base map (water/mountains/hills/volcanoes) and a second map where
 * boundary tiles are annotated with their type (C=convergent, R=rift/divergent,
 * T=transform, +=boundary/no type).
 * @param {{isEnabled?:()=>boolean,boundaryCloseness?:Uint8Array,boundaryType?:Uint8Array}} WorldModel
 * @param {{step?:number,boundaryThreshold?:number}} [opts]
 */
export function logFoundationAscii(WorldModel, opts = {}) {
    if (!isOn("LOG_FOUNDATION_ASCII"))
        return;
    try {
        const enabled = !!WorldModel &&
            typeof WorldModel.isEnabled === "function" &&
            !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] ascii: WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog("[DEV][foundation] ascii: No map bounds; skipping overlay.");
            return;
        }
        const boundaryCloseness = WorldModel.boundaryCloseness;
        const boundaryType = WorldModel.boundaryType;
        if (!boundaryCloseness || !boundaryType) {
            safeLog("[DEV][foundation] ascii: Missing boundary data.");
            return;
        }
        const size = width * height;
        const boundaryLen = Math.min(size, boundaryCloseness.length, boundaryType.length);
        if (!boundaryLen) {
            safeLog("[DEV][foundation] ascii: Boundary arrays empty.");
            return;
        }
        const sampleStep = computeAsciiSampleStep(width, height, opts.step);
        const thresholdRatio = typeof opts.boundaryThreshold === "number"
            ? Math.max(0, Math.min(1, opts.boundaryThreshold))
            : 0.65;
        const closenessCutoff = Math.round(thresholdRatio * 255);
        const asciiChars = ASCII_DISPLAY.foundation;
        const baseWater = asciiChars.base.water;
        const baseLand = asciiChars.base.land;
        const overlays = asciiChars.overlay;
        const rows = renderAsciiGrid(width, height, sampleStep, (x, y) => {
            const idx = y * width + x;
            const close = idx < boundaryLen ? boundaryCloseness[idx] | 0 : 0;
            const isBoundary = close >= closenessCutoff;
            const base = GameplayMap?.isWater?.(x, y) ? baseWater : baseLand;
            if (!isBoundary)
                return { base };
            const bType = boundaryType[idx] | 0;
            const overlay = bType === 1
                ? overlays.convergent
                : bType === 2
                    ? overlays.divergent
                    : bType === 3
                        ? overlays.transform
                        : overlays.boundary;
            return { base, overlay };
        });
        safeLog(`[DEV][foundation] ascii plates (step=${sampleStep}): base ${legendBasePair(baseWater)} ocean, ${legendBasePair(baseLand)} land; overlays ${overlays.convergent} convergent, ${overlays.divergent} divergent, ${overlays.transform} transform, ${overlays.boundary} boundary/unknown`);
        rows.forEach((row) => safeLog(row));
    }
    catch (err) {
        safeLog("[DEV][foundation] ascii error:", err);
    }
}

export function logLandmassAscii(label = "landmass", opts = {}) {
    if (!isOn("LOG_LANDMASS_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][landmass] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][landmass] dump ${label}: delegating to base-standard dumpContinents()`);
        dumpContinents(width, height);
    }
    catch (err) {
        safeLog(`[DEV][landmass] dump ${label} error:`, err);
    }
}

export function logTerrainReliefAscii(label = "relief") {
    if (!isOn("LOG_RELIEF_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][relief] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][relief] dump ${label}: delegating to base-standard dumpTerrain()`);
        dumpTerrain(width, height);
    }
    catch (err) {
        safeLog(`[DEV][relief] dump ${label} error:`, err);
    }
}

export function logRainfallAscii(label = "rainfall") {
    if (!isOn("LOG_RAINFALL_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][rain] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][rain] dump ${label}: delegating to base-standard dumpRainfall()`);
        dumpRainfall(width, height);
    }
    catch (err) {
        safeLog(`[DEV][rain] dump ${label} error:`, err);
    }
}

export function logBiomeAscii(label = "biomes") {
    if (!isOn("LOG_BIOME_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog(`[DEV][biome] dump ${label}: No map bounds.`);
            return;
        }
        safeLog(`[DEV][biome] dump ${label}: delegating to base-standard dumpBiomes()`);
        dumpBiomes(width, height);
    }
    catch (err) {
        safeLog(`[DEV][biome] dump ${label} error:`, err);
    }
}
/**
 * Quantitative boundary diagnostics (coverage, closeness bands, terrain overlays).
 * @param {{isEnabled?:()=>boolean,boundaryType?:Uint8Array,boundaryCloseness?:Uint8Array}} WorldModel
 * @param {{bins?:number,thresholds?:number[],stage?:string}} [opts]
 */
export function logBoundaryMetrics(WorldModel, opts = {}) {
    if (!isOn("LOG_BOUNDARY_METRICS"))
        return;
    try {
        const enabled = !!WorldModel && typeof WorldModel.isEnabled === "function" && !!WorldModel.isEnabled();
        if (!enabled) {
            safeLog("[DEV][foundation] metrics: WorldModel disabled or unavailable.");
            return;
        }
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog("[DEV][foundation] metrics: No map bounds.");
            return;
        }
        const boundaryType = WorldModel.boundaryType;
        const boundaryCloseness = WorldModel.boundaryCloseness;
        if (!boundaryType || !boundaryCloseness) {
            safeLog("[DEV][foundation] metrics: Missing boundary arrays.");
            return;
        }
        const bins = Math.max(3, Math.min(40, Number.isFinite(opts.bins) ? Math.trunc(opts.bins) : 10));
        const thresholds = Array.isArray(opts.thresholds) && opts.thresholds.length
            ? opts.thresholds.map((t) => Math.max(0, Math.min(1, Number(t)))).sort((a, b) => a - b)
            : [0.35, 0.6];
        const stage = opts.stage ? ` (${String(opts.stage)})` : "";

        const hist = new Array(bins).fill(0);
        const counts = [0, 0, 0, 0];
        const thresholdHits = thresholds.map(() => 0);
        const mountainByType = [0, 0, 0, 0];
        const hillByType = [0, 0, 0, 0];
        const volcanoByType = [0, 0, 0, 0];
        const mountainByBand = thresholds.map(() => 0);
        const hillByBand = thresholds.map(() => 0);
        const volcanoByBand = thresholds.map(() => 0);

        let mountains = 0;
        let hills = 0;
        let volcanoes = 0;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const closeness = (boundaryCloseness[i] | 0) / 255;
                const bType = boundaryType[i] | 0;
                if (bType >= 0 && bType < counts.length)
                    counts[bType]++;
                const bin = Math.min(bins - 1, Math.floor(closeness * bins));
                hist[bin]++;
                thresholds.forEach((t, idx) => {
                    if (closeness >= t)
                        thresholdHits[idx]++;
                });

                const isMountain = !!GameplayMap.isMountain?.(x, y);
                const terrainType = GameplayMap.getTerrainType?.(x, y) ?? -1;
                const featureType = GameplayMap.getFeatureType?.(x, y) ?? -1;

                if (isMountain) {
                    mountains++;
                    if (bType >= 0 && bType < mountainByType.length)
                        mountainByType[bType]++;
                    thresholds.forEach((t, idx) => {
                        if (closeness >= t)
                            mountainByBand[idx]++;
                    });
                } else if (terrainType === globals.g_HillTerrain) {
                    hills++;
                    if (bType >= 0 && bType < hillByType.length)
                        hillByType[bType]++;
                    thresholds.forEach((t, idx) => {
                        if (closeness >= t)
                            hillByBand[idx]++;
                    });
                }
                if (featureType === globals.g_VolcanoFeature) {
                    volcanoes++;
                    if (bType >= 0 && bType < volcanoByType.length)
                        volcanoByType[bType]++;
                    thresholds.forEach((t, idx) => {
                        if (closeness >= t)
                            volcanoByBand[idx]++;
                    });
                }
            }
        }

        const totalTiles = Math.min(boundaryType.length, boundaryCloseness.length, width * height);
        const pct = (value, total) => total > 0 ? ((value / total) * 100).toFixed(1) + "%" : "0%";

        safeLog(`[DEV][foundation] metrics${stage}: counts ${JSON.stringify({
            totalTiles,
            none: counts[0],
            convergent: counts[1],
            divergent: counts[2],
            transform: counts[3],
        })}`);
        safeLog(`[DEV][foundation] metrics: share ${JSON.stringify({
            convergent: pct(counts[1], totalTiles),
            divergent: pct(counts[2], totalTiles),
            transform: pct(counts[3], totalTiles),
        })}`);
        safeLog(`[DEV][foundation] metrics: closeness histogram ${JSON.stringify(hist.map((count, idx) => ({ bin: idx, count })))}`);
        thresholds.forEach((t, idx) => {
            safeLog(`[DEV][foundation] metrics: closeness >= ${t.toFixed(2)} ${JSON.stringify({
                tiles: thresholdHits[idx],
                share: pct(thresholdHits[idx], totalTiles),
            })}`);
        });
        safeLog(`[DEV][foundation] metrics: mountains ${JSON.stringify({
            total: mountains,
            none: mountainByType[0],
            convergent: mountainByType[1],
            divergent: mountainByType[2],
            transform: mountainByType[3],
        })}`);
        safeLog(`[DEV][foundation] metrics: hills ${JSON.stringify({
            total: hills,
            none: hillByType[0],
            convergent: hillByType[1],
            divergent: hillByType[2],
            transform: hillByType[3],
        })}`);
        safeLog(`[DEV][foundation] metrics: volcanoes ${JSON.stringify({
            total: volcanoes,
            none: volcanoByType[0],
            convergent: volcanoByType[1],
            divergent: volcanoByType[2],
            transform: volcanoByType[3],
        })}`);
        thresholds.forEach((t, idx) => {
            safeLog(`[DEV][foundation] metrics: >=${t.toFixed(2)} overlays ${JSON.stringify({
                mountains: mountainByBand[idx],
                hills: hillByBand[idx],
                volcanoes: volcanoByBand[idx],
            })}`);
        });
    }
    catch (err) {
        safeLog("[DEV][foundation] metrics error:", err);
    }
}
/**
 * Log a coarse ASCII overlay of corridor tags (downsampled).
 * Legend:
 * Legend:
 *  - S: corridorSeaLane (protected open water)
 *  - I: corridorIslandHop (hotspot arcs over water)
 *  - R: corridorRiverChain (river-adjacent land)
 *  - L: corridorLandOpen (open land lanes)
 *  - ~: water (no corridor)
 *  - .: land (no corridor)
 * The overlay samples every `step` tiles to keep output compact on Huge maps.
 * @param {number} [step=8] sampling stride in tiles
 */
export function logCorridorAsciiOverlay(step = 8) {
    if (!isOn("LOG_CORRIDOR_ASCII"))
        return;
    try {
        const width = GameplayMap?.getGridWidth?.() ?? 0;
        const height = GameplayMap?.getGridHeight?.() ?? 0;
        if (!width || !height) {
            safeLog("[DEV][corridor] No map bounds; skipping ASCII overlay.");
            return;
        }
        const s = computeAsciiSampleStep(width, height, step);
        const asciiChars = ASCII_DISPLAY.corridor;
        const baseWater = asciiChars.base.water;
        const baseLand = asciiChars.base.land;
        const overlayChars = asciiChars.overlays;
        safeLog(`[DEV][corridor] ASCII overlay (step=${s}): base ${legendBasePair(baseWater)} ocean, ${legendBasePair(baseLand)} land; overlays ${overlayChars.seaLane} sea-lane, ${overlayChars.islandHop} island-hop, ${overlayChars.landOpen} land-open, ${overlayChars.riverChain} river-chain`);
        const rows = renderAsciiGrid(width, height, s, (x, y) => {
            const base = GameplayMap?.isWater?.(x, y) ? baseWater : baseLand;
            const key = `${x},${y}`;
            const overlays = [
                StoryTags?.corridorSeaLane?.has?.(key) ? overlayChars.seaLane : null,
                StoryTags?.corridorIslandHop?.has?.(key) ? overlayChars.islandHop : null,
                StoryTags?.corridorRiverChain?.has?.(key) ? overlayChars.riverChain : null,
                StoryTags?.corridorLandOpen?.has?.(key) ? overlayChars.landOpen : null,
            ].filter(Boolean);
            const overlay = overlays.length ? overlays[0] : null;
            return overlay ? { base, overlay } : { base };
        });
        rows.forEach((row) => safeLog(row));
    }
    catch (err) {
        safeLog("[DEV][corridor] ASCII overlay error:", err);
    }
}

function computeAsciiSampleStep(width, height, requested) {
    if (Number.isFinite(requested))
        return Math.max(1, Math.trunc(requested));
    const targetCols = 72;
    const targetRows = 48;
    const stepX = width > targetCols ? Math.floor(width / targetCols) : 1;
    const stepY = height > targetRows ? Math.floor(height / targetRows) : 1;
    const step = Math.max(1, Math.min(stepX || 1, stepY || 1));
    return step;
}

function renderAsciiGrid(width, height, sampleStep, cellFn) {
    const step = Math.max(1, sampleStep | 0);
    const rows = [];
    for (let y = 0; y < height; y += step) {
        let row = "";
        for (let x = 0; x < width; x += step) {
            const cell = cellFn(x, y) || {};
            row += asciiCell(cell.base, cell.overlay);
        }
        rows.push(row);
    }
    return rows;
}

function asciiCell(base, overlay) {
    const baseChar = typeof base === "string" && base.length ? base[0] : ".";
    const center = typeof overlay === "string" && overlay.length ? overlay[0] : baseChar;
    const grid = ASCII_DISPLAY.grid ?? {};
    const padding = (overlay ? grid.overlayPadding : grid.basePadding) || grid.basePadding || { left: "", right: "" };
    const left = padding.left ?? "";
    const right = padding.right ?? left;
    return `${left}${center}${right}`;
}

function legendBasePair(baseChar) {
    const c = typeof baseChar === "string" && baseChar.length ? baseChar[0] : ".";
    const grid = ASCII_DISPLAY.grid ?? {};
    const padding = grid.basePadding || { left: "", right: "" };
    const left = padding.left ?? "";
    const right = padding.right ?? left;
    return `${left}${c}${right}`;
}

function summarizeFoundationSeedConfig(cfg) {
    const seedCfg = typeof cfg === "object" && cfg ? cfg : {};
    const summary = {
        mode: seedCfg.mode ?? "engine",
        fixed: seedCfg.fixed ?? null,
        offset: seedCfg.offset ?? 0,
        manifestHash: seedCfg.manifestHash ?? null,
    };
    if (seedCfg.offsets && typeof seedCfg.offsets === "object") {
        const offsets = {};
        for (const key of Object.keys(seedCfg.offsets)) {
            const value = seedCfg.offsets[key];
            if (value != null)
                offsets[key] = value;
        }
        if (Object.keys(offsets).length > 0)
            summary.offsets = offsets;
    }
    return summary;
}

function summarizePlateSeed(plateSeed) {
    if (!plateSeed || typeof plateSeed !== "object")
        return { available: false };
    const summary = { available: true };
    const width = plateSeed.width ?? plateSeed.mapWidth;
    const height = plateSeed.height ?? plateSeed.mapHeight;
    if (width != null)
        summary.width = width;
    if (height != null)
        summary.height = height;
    const sites = Array.isArray(plateSeed.sites)
        ? plateSeed.sites
        : Array.isArray(plateSeed.siteCoords)
            ? plateSeed.siteCoords
            : null;
    if (sites)
        summary.siteCount = sites.length;
    if (plateSeed.seed != null)
        summary.seed = plateSeed.seed;
    if (plateSeed.seedOffset != null)
        summary.seedOffset = plateSeed.seedOffset;
    if (plateSeed.timestamp != null)
        summary.timestamp = plateSeed.timestamp;
    const rngState = plateSeed.rngState ?? plateSeed.randomState ?? null;
    if (rngState)
        summary.rngState = summarizeRngState(rngState);
    return summary;
}

function summarizeFoundationPlates(cfg) {
    if (!cfg || typeof cfg !== "object")
        return {};
    const summary = pickFields(cfg, [
        "seedMode",
        "count",
        "convergenceMix",
        "relaxationSteps",
        "seedJitter",
        "interiorSmooth",
        "plateRotationMultiple",
        "seedOffset",
    ]) || {};
    if (Array.isArray(cfg.axisAngles) && cfg.axisAngles.length)
        summary.axisAngles = cfg.axisAngles.slice(0, 3);
    return summary;
}

function summarizeFoundationDynamics(cfg) {
    if (!cfg || typeof cfg !== "object")
        return {};
    const wind = pickFields(cfg.wind, ["jetStreaks", "jetStrength", "variance", "coriolisZonalScale"]);
    const currents = pickFields(cfg.currents, ["basinGyreCountMax", "westernBoundaryBias", "currentStrength"]);
    const mantle = pickFields(cfg.mantle, ["bumps", "amplitude", "scale"]);
    const directionality = summarizeDirectionality(cfg.directionality);
    const out = {};
    if (wind)
        out.wind = wind;
    if (currents)
        out.currents = currents;
    if (mantle)
        out.mantle = mantle;
    if (directionality)
        out.directionality = directionality;
    return out;
}

function summarizeDirectionality(cfg) {
    if (!cfg || typeof cfg !== "object")
        return null;
    const out = {};
    if (cfg.cohesion != null)
        out.cohesion = cfg.cohesion;
    const primaryAxes = pickFields(cfg.primaryAxes, ["plateAxisDeg", "windBiasDeg", "currentBiasDeg"]);
    if (primaryAxes)
        out.primaryAxes = primaryAxes;
    const interplay = pickFields(cfg.interplay, [
        "windsFollowPlates",
        "currentsFollowWinds",
        "riftsFollowPlates",
        "orogenyOpposesRifts",
    ]);
    if (interplay)
        out.interplay = interplay;
    const hemispheres = pickFields(cfg.hemispheres, ["southernFlip", "equatorBandDeg", "monsoonBias"]);
    if (hemispheres)
        out.hemispheres = hemispheres;
    const variability = pickFields(cfg.variability, ["angleJitterDeg", "magnitudeVariance", "seedOffset"]);
    if (variability)
        out.variability = variability;
    return Object.keys(out).length ? out : null;
}

function summarizeFoundationSurface(cfg) {
    if (!cfg || typeof cfg !== "object")
        return {};
    const out = {};
    const landmass = pickFields(cfg.landmass, [
        "baseWaterPercent",
        "waterThumbOnScale",
        "jitterAmpFracBase",
        "jitterAmpFracScale",
        "curveAmpFrac",
    ]);
    if (landmass) {
        const post = pickFields(cfg.landmass?.geometry?.post, [
            "expandTiles",
            "expandWestTiles",
            "expandEastTiles",
            "clampWestMin",
            "clampEastMax",
            "minWidthTiles",
            "overrideSouth",
            "overrideNorth",
        ]);
        if (post)
            landmass.geometryPost = post;
        out.landmass = landmass;
    }
    const oceanSeparation = summarizeOceanSeparation(cfg.oceanSeparation);
    if (oceanSeparation)
        out.oceanSeparation = oceanSeparation;
    if (cfg.overrides && typeof cfg.overrides === "object") {
        const overrideKeys = Object.keys(cfg.overrides);
        if (overrideKeys.length)
            out.overrides = { count: overrideKeys.length };
    }
    return out;
}

function summarizeOceanSeparation(cfg) {
    if (!cfg || typeof cfg !== "object")
        return null;
    const out = pickFields(cfg, [
        "enabled",
        "baseSeparationTiles",
        "boundaryClosenessMultiplier",
        "maxPerRowDelta",
        "respectSeaLanes",
        "minChannelWidth",
    ]) || {};
    if (Array.isArray(cfg.bandPairs))
        out.bandPairs = cfg.bandPairs.length;
    if (cfg.edgeWest && cfg.edgeWest.enabled)
        out.edgeWest = pickFields(cfg.edgeWest, ["baseTiles", "boundaryClosenessMultiplier", "maxPerRowDelta"]);
    if (cfg.edgeEast && cfg.edgeEast.enabled)
        out.edgeEast = pickFields(cfg.edgeEast, ["baseTiles", "boundaryClosenessMultiplier", "maxPerRowDelta"]);
    return Object.keys(out).length ? out : null;
}

function summarizeRngState(state) {
    if (!state || typeof state !== "object")
        return state ?? null;
    const keys = Object.keys(state);
    if (!keys.length)
        return {};
    const summary = {};
    const limit = 4;
    for (let i = 0; i < Math.min(limit, keys.length); i++) {
        const key = keys[i];
        summary[key] = state[key];
    }
    if (keys.length > limit)
        summary.truncatedKeys = keys.length - limit;
    return summary;
}

function pickFields(src, fields) {
    if (!src || typeof src !== "object")
        return null;
    const out = {};
    for (const key of fields) {
        if (Object.prototype.hasOwnProperty.call(src, key) && src[key] != null) {
            out[key] = src[key];
        }
    }
    return Object.keys(out).length ? out : null;
}

/* ----------------------- internal helpers ----------------------- */
function safeLog(...args) {
    try {
        console.log(...args);
    }
    catch (_) {
        /* no-op */
    }
}
function nowMs() {
    try {
        // Prefer high-resolution timer when available
        // @ts-ignore
        if (typeof performance !== "undefined" &&
            typeof performance.now === "function")
            return performance.now();
    }
    catch (_) {
        /* ignore */
    }
    return Date.now();
}
function fmtMs(ms) {
    // Format as e.g. "12.34 ms"
    const n = typeof ms === "number" ? ms : Number(ms) || 0;
    return `${n.toFixed(2)} ms`;
}
function sizeOf(setLike) {
    if (!setLike)
        return 0;
    if (typeof setLike.size === "number")
        return setLike.size;
    try {
        return Array.isArray(setLike) ? setLike.length : 0;
    }
    catch {
        return 0;
    }
}
function clampTo(v, lo, hi) {
    if (v < lo)
        return lo;
    if (v > hi)
        return hi;
    return v;
}
export default {
    DEV,
    devLog,
    devLogIf,
    timeSection,
    timeStart,
    timeEnd,
    logStoryTagsSummary,
    logRainfallHistogram,
    logRainfallStats,
    logFoundationSummary,
    logFoundationHistograms,
    logFoundationAscii,
    logBoundaryMetrics,
    logBiomeSummary,
    ASCII_DISPLAY,
};
</file>

<file path="mod/maps/bootstrap/entry.js">
// @ts-check
/**
 * Entry Bootstrap Helper
 *
 * Purpose
 * - Minimize boilerplate in map entry files.
 * - Compose configuration from named presets and inline overrides, then
 *   set the active runtime config. Entries must import the orchestrator separately.
 *
 * Usage (in a map entry file):
 *   import { bootstrap } from "./config/entry.js";
 *   bootstrap({
 *     presets: ["classic", "temperate"], // optional, ordered
 *     overrides: {
 *       // any partial config to override the resolved result
 *       foundation: { world: { enabled: true } },
 *       // ...
 *     }
 *   });
 *
 * Notes
 * - This helper is intentionally simple and synchronous for game VM compatibility.
 * - Presets are applied by name via resolved.js; arrays replace, objects deep-merge.
 * - This helper does not import the orchestrator; keep the explicit import in the entry.
 */

/** @typedef {import('./map_config.types.js').MapConfig} MapConfig */

import { setConfig } from "./runtime.js";
/**
 * Deep merge utility (objects by key, arrays replaced, primitives overwritten).
 * Returns a new object; never mutates inputs.
 * @param {any} base
 * @param {any} src
 * @returns {any}
 */
function deepMerge(base, src) {
    const isObj = (v) => v != null &&
        typeof v === "object" &&
        (Object.getPrototypeOf(v) === Object.prototype ||
            Object.getPrototypeOf(v) === null);
    if (!isObj(base) || Array.isArray(src)) {
        return clone(src);
    }
    if (!isObj(src)) {
        return clone(src);
    }
    /** @type {Record<string, any>} */
    const out = {};
    for (const k of Object.keys(base))
        out[k] = clone(base[k]);
    for (const k of Object.keys(src)) {
        const b = out[k];
        const s = src[k];
        out[k] = isObj(b) && isObj(s) ? deepMerge(b, s) : clone(s);
    }
    return out;
}
/**
 * Shallow clone helper (new containers for arrays/objects).
 * @param {any} v
 * @returns {any}
 */
function clone(v) {
    if (Array.isArray(v))
        return v.slice();
    const isObj = v != null &&
        typeof v === "object" &&
        (Object.getPrototypeOf(v) === Object.prototype ||
            Object.getPrototypeOf(v) === null);
    if (isObj) {
        const o = {};
        for (const k of Object.keys(v))
            o[k] = v[k];
        return o;
    }
    return v;
}
/**
 * Compose a per-entry configuration object from presets and overrides,
 * and set it as the active runtime config.
 *
 * @param {object} [options]
 * @param {ReadonlyArray<string>} [options.presets] - Ordered list of preset names understood by resolved.js
 * @param {Partial<MapConfig>} [options.overrides] - Inline overrides applied last (highest precedence)
 * @param {Record<string, boolean>} [options.stageConfig] - Stage metadata indicating which stages provide config overrides
 */
export function bootstrap(options = {}) {
    const presets = Array.isArray(options.presets) &&
        options.presets.length > 0
        ? options.presets.filter((n) => typeof n === "string")
        : undefined;
    const overrides = options && typeof options === "object" && options.overrides
        ? clone(options.overrides)
        : undefined;
    const stageConfig = options && typeof options === "object" && options.stageConfig
        ? clone(options.stageConfig)
        : undefined;
    const cfg = {};
    if (presets)
        cfg.presets = presets;
    if (stageConfig)
        cfg.stageConfig = stageConfig;
    if (overrides) {
        // If both presets and overrides exist, ensure overrides apply last (highest precedence)
        Object.assign(cfg, deepMerge(cfg, overrides));
    }
    // Store runtime config for this map entry (entries must import orchestrator separately)
    setConfig(cfg);
}
export default { bootstrap };
</file>

<file path="mod/maps/bootstrap/foundation-tunables.js">
/**
 * Foundation/world settings tunable surface. Keeps imports focused on the
 * world-building primitives that layers commonly consume.
 */
export {
    rebind,
    FOUNDATION_TUNABLES,
    FOUNDATION,
    FOUNDATION_CFG,
    FOUNDATION_SEED,
    FOUNDATION_PLATES,
    FOUNDATION_DYNAMICS,
    FOUNDATION_SURFACE,
    FOUNDATION_POLICY,
    FOUNDATION_DIAGNOSTICS,
    FOUNDATION_DIRECTIONALITY,
    FOUNDATION_OCEAN_SEPARATION,
} from "./tunables.js";
</file>

<file path="mod/maps/bootstrap/map_config.types.js">
// @ts-nocheck
/**
 * JSDoc type definitions for Epic Diverse Huge Map Generator config.
 *
 * This file provides runtime-available type hints for IDE autocomplete.
 * For full TypeScript definitions, see map_config.d.ts (development only).
 * For validation schema, see map_config.schema.json
 *
 * Usage in map_config.js (JS with editor typings):
 *
 * @example
 * // @ts-check
 * // @type {import('./map_config.types.js').MapConfig}
 * export const MAP_CONFIG = Object.freeze({
 *   toggles: { STORY_ENABLE_HOTSPOTS: true },
 *   story: {},
 *   microclimate: {}
 * });
 */

/**
 * Master configuration object controlling all map generation layers.
 *
 * Generation pipeline: Foundation (plates/winds)  Landmass  Climate  Biomes  Features
 *
 * @typedef {Object} MapConfig
 * @property {Toggles} toggles - Enable/disable major systems (hotspots, rifts, orogeny, swatches, corridors)
 * @property {Story} story - Narrative elements creating distinctive terrain features (volcanic trails, rift valleys, mountain rain shadows)
 * @property {Microclimate} microclimate - Fine-tuned rainfall and feature bonuses near story elements (rift lines, hotspot centers)
 * @property {Climate} [climate] - Aggregated climate configuration (baseline/refine/swatches)
 * @property {Corridors} [corridors] - Protected travel routes (sea lanes, island chains, land corridors, river valleys) that remain unobstructed
 * @property {Landmass} [landmass] - Continental layout: water percentage, band geometry, curvature/jitter, plate-driven vs preset modes
 * @property {Coastlines} [coastlines] - Coast ruggedization: bay/fjord probabilities, active vs passive margin effects
 * @property {Margins} [margins] - Tectonic margin types: convergent (mountains, subduction) vs divergent (rifts, spreading)
 * @property {Islands} [islands] - Offshore island generation: fractal thresholds, hotspot biasing, cluster distribution
 * @property {Mountains} [mountains] - Mountain and hill placement weights: WorldModel uplift, boundary biasing, foothill distribution
 * @property {Volcanoes} [volcanoes] - Volcano placement controls: convergent arc bias, hotspot allowance, spacing
 * @property {Biomes} [biomes] - Biome assignment rules: tundra limits, tropical coast preferences, river grasslands, rift shoulders
 * @property {FeaturesDensity} [featuresDensity] - Feature density: rainforest, forest, taiga prevalence, coral reef placement
 * @property {Placement} [placement] - Final placement: natural wonder counts, floodplain river lengths
 * @property {DevLogging} [dev] - Debug logging: timing stats, story tag counts, rainfall distribution histograms
 * @property {FoundationConfig} [foundation] - Unified world foundation configuration (seed, plates, dynamics, surface, policy)
 * @property {StageManifest} [stageManifest] - Pipeline manifest describing stage order, enablement, and inter-stage dependencies
 * @property {StageConfigProviders} [stageConfig] - Metadata indicating which stages a preset or entry supplies configuration for
 */

/**
 * Known stage identifiers for the bootstrap manifest.
 *
 * Stage names mirror the major passes in map_orchestrator.js; use them to
 * express dependencies. Adding a new stage requires updating this union.
 *
* @typedef {"foundation" | "landmassPlates" | "coastlines" | "storySeed" | "storyHotspots" | "storyRifts" | "storyOrogeny" | "storyPaleo" | "storyCorridorsPre" | "islands" | "mountains" | "volcanoes" | "lakes" | "climateBaseline" | "storySwatches" | "rivers" | "storyCorridorsPost" | "climateRefine" | "biomes" | "features" | "placement"} StageName
 */

/**
 * Stage descriptor containing enablement and dependency metadata.
 *
 * @typedef {Object} StageDescriptor
 * @property {boolean} [enabled] - Explicit enable/disable flag (defaults to true when omitted)
 * @property {ReadonlyArray<StageName>} [requires] - Hard prerequisites that must execute (and remain enabled) first
 * @property {ReadonlyArray<StageName>} [provides] - Data surfaces emitted by the stage (documentation only)
 * @property {ReadonlyArray<string>} [legacyToggles] - Legacy toggle keys mirrored from the new manifest state
 * @property {string} [blockedBy] - Resolved reason for automatic disablement (populated by resolver diagnostics)
 */

/**
 * Stage manifest describing execution order and dependency graph for the generator.
 *
 * @typedef {Object} StageManifest
 * @property {ReadonlyArray<StageName>} order - Ordered list of stages to execute (duplicates removed during normalization)
 * @property {Record<StageName, StageDescriptor>} stages - Descriptor metadata keyed by stage identifier
 */

/**
 * Stage configuration providers metadata (used for diagnostics).
 * Keys are stage identifiers and values indicate whether overrides target that stage.
 *
 * @typedef {Object.<StageName, boolean>} StageConfigProviders
 */

/**
 * Plate tensors emitted by the foundation stage.
 *
 * @typedef {Object} FoundationPlateFields
 * @property {Int16Array} id - Plate identifier per tile
 * @property {Uint8Array} boundaryCloseness - Distance-to-boundary metric (0 = on boundary)
 * @property {Uint8Array} boundaryType - Encoded boundary type (convergent/divergent/transform)
 * @property {Uint8Array} tectonicStress - Aggregate stress magnitude per tile
 * @property {Uint8Array} upliftPotential - Mountain uplift weighting per tile
 * @property {Uint8Array} riftPotential - Rift weighting per tile
 * @property {Uint8Array} shieldStability - Continental interior stability per tile
 * @property {Int8Array} movementU - Horizontal plate motion component
 * @property {Int8Array} movementV - Vertical plate motion component
 * @property {Int8Array} rotation - Plate rotation scalar
 */

/**
 * Atmospheric and oceanic tensors emitted by the foundation stage.
 *
 * @typedef {Object} FoundationDynamicsFields
 * @property {Int8Array} windU - Zonal wind component per tile
 * @property {Int8Array} windV - Meridional wind component per tile
 * @property {Int8Array} currentU - Zonal ocean current component per tile
 * @property {Int8Array} currentV - Meridional ocean current component per tile
 * @property {Uint8Array} pressure - Mantle pressure field per tile
 */

/**
 * Diagnostics payload bundled with the foundation context.
 *
 * @typedef {Object} FoundationDiagnosticsFields
 * @property {any|null} boundaryTree - Spatial index for boundary queries
 */

/**
 * Immutable runtime snapshot emitted by the `foundation` stage.
 *
 * @typedef {Object} FoundationContext
 * @property {{ width: number, height: number, size: number }} dimensions - Map dimensions baked into the tensors
 * @property {Readonly<any>|null} plateSeed - Captured Voronoi seed bundle used for deterministic replay
 * @property {FoundationPlateFields} plates - Plate/boundary tensors shared across stages
 * @property {FoundationDynamicsFields} dynamics - Wind, current, and mantle pressure tensors
 * @property {FoundationDiagnosticsFields} diagnostics - Supplemental diagnostics (kd-tree, metadata)
 * @property {{
 *   seed: FoundationSeedConfig,
 *   plates: FoundationPlatesConfig,
 *   dynamics: FoundationDynamicsConfig,
 *   surface: FoundationSurfaceConfig,
 *   policy: FoundationPolicyConfig,
 *   diagnostics: FoundationDiagnosticsConfig,
 * }} config - Normalized configuration snapshot associated with the tensors
 */

/**
 * Feature toggles for major narrative and simulation systems.
 *
 * @typedef {Object} Toggles
 * @property {boolean} STORY_ENABLE_HOTSPOTS - Volcanic island chains (like Hawaii) formed as plates move over mantle plumes
 * @property {boolean} STORY_ENABLE_RIFTS - Continental rift valleys (like East African Rift) with humid shoulders and grassland bias
 * @property {boolean} STORY_ENABLE_OROGENY - Mountain rain shadows: wet windward slopes, dry leeward deserts (orographic effect)
 * @property {boolean} STORY_ENABLE_SWATCHES - Guaranteed macro-climate zones (e.g., Sahara-like desert belt, Congo/Amazon rainbelt)
 * @property {boolean} STORY_ENABLE_PALEO - Ancient river features: fossil channels in deserts, oxbow lakes, delta wetlands
 * @property {boolean} STORY_ENABLE_CORRIDORS - Protected routes for strategic gameplay (sea lanes, island chains, river valleys)
 */

/**
 * Story (motif) tunables
 * @typedef {Object} Story
 * @property {Hotspot} [hotspot] - Deep-ocean hotspot trails (aligned chains far from coasts)
 * @property {Rift} [rift] - Continental rift lines (linear basins with narrow shoulder bands)
 * @property {Orogeny} [orogeny] - Orogeny belts (derive windward/lee flanks; apply small wet/dry deltas)
 * @property {Swatches} [swatches] - "Black swan" macro climate swatches (paint one guaranteed macro zone)
 * @property {PaleoHydrology} [paleo] - Paleo-hydrology overlays (humidity hints; optional canyon rim contrast)
 */

/**
 * Deep-ocean hotspot trails (volcanic island chains).
 *
 * Simulates stationary mantle plumes creating linear archipelagos as tectonic plates drift overhead.
 * Think Hawaiian Islands: older islands to the northwest, active volcano in the southeast.
 *
 * @typedef {Object} Hotspot
 * @property {number} [maxTrails] - Maximum trails per map; fewer = more isolated chains (typically 2-5)
 * @property {number} [steps] - Chain length in steps; higher = longer trails like Hawaii (typically 8-15)
 * @property {number} [stepLen] - Spacing between islands in tiles (typically 3-6)
 * @property {number} [minDistFromLand] - Keep trails in deep ocean, away from continents in tiles (typically 15+)
 * @property {number} [minTrailSeparation] - Minimum distance between different chains in tiles (typically 25+)
 * @property {number} [paradiseBias] - Weight for tropical paradise centers (lush, high humidity, reefs)
 * @property {number} [volcanicBias] - Weight for volcanic centers (active, dramatic terrain, geothermal)
 * @property {number} [volcanicPeakChance] - Probability volcanic centers become land vs staying underwater (0..1, typically 0.3-0.7)
 */

/**
 * Continental rift lines (tectonic valleys where plates pull apart).
 *
 * Creates linear depressions like the East African Rift Valley or the Rio Grande Rift.
 * Rift shoulders receive extra humidity and grassland bias, while the valley floor may be drier.
 *
 * @typedef {Object} Rift
 * @property {number} [maxRiftsPerMap] - Maximum rifts on the map; 1-2 typical, 3+ creates heavily fractured continents
 * @property {number} [lineSteps] - Length of rift in steps; higher = longer valleys (typically 15-30)
 * @property {number} [stepLen] - Distance per step in tiles; controls rift straightness (typically 2-4)
 * @property {number} [shoulderWidth] - Width of elevated shoulders on each side receiving humidity bonus (typically 2-5 tiles)
 */

/**
 * Orogeny belts (mountain-building zones with rain shadow effects).
 *
 * Orographic effect: mountains force air upward, causing rainfall on the windward (upwind) side.
 * Air descends on the leeward (downwind) side, creating rain shadows (deserts).
 * Example: Sierra Nevada (wet west, dry east), Himalayas (wet south, dry Gobi Desert north).
 *
 * @typedef {Object} Orogeny
 * @property {number} [beltMaxPerContinent] - Maximum mountain belts per continent (typically 1-3)
 * @property {number} [beltMinLength] - Minimum tiles for a mountain range to qualify (typically 10-20)
 * @property {number} [radius] - Distance from mountains to apply rain shadow effect (typically 3-8 tiles)
 * @property {number} [windwardBoost] - Extra rainfall on upwind side in rainfall units (typically 10-30, max 200)
 * @property {number} [leeDrynessAmplifier] - Drying multiplier for downwind side; 1.5 = 50% drier (typically 1.2-2.0)
 */

/**
 * Macro climate swatches (guaranteed major climate features).
 *
 * Each map gets ONE guaranteed macro-climate zone to create distinctive character.
 * These override normal patterns to ensure interesting gameplay variety.
 *
 * @typedef {Object} Swatches
 * @property {number} [maxPerMap] - Maximum swatches per map; typically 1 to avoid competing features
 * @property {boolean} [forceAtLeastOne] - Guarantee at least one swatch is applied (recommended: true)
 * @property {Object} [sizeScaling] - Scale swatch dimensions with map size
 * @property {number} [sizeScaling.widthMulSqrt] - Width scaling for larger maps (typically 1.0-1.5)
 * @property {number} [sizeScaling.lengthMulSqrt] - Length scaling for larger maps (typically 1.0-1.5)
 * @property {Object} [types] - Available swatch types and their weights
 * @property {SwatchType} [types.macroDesertBelt] - Sahara/Kalahari-like subtropical desert band at ~20-30 latitude
 * @property {SwatchType} [types.equatorialRainbelt] - Congo/Amazon-like equatorial rainforest belt with high humidity
 * @property {SwatchType} [types.rainforestArchipelago] - Southeast Asia-style tropical island rainforests with coral reefs
 * @property {SwatchType} [types.mountainForests] - Alpine/Himalayan-style wet forests on windward mountain slopes
 * @property {SwatchType} [types.greatPlains] - Central Asia/American Great Plains-style continental grasslands/steppes
 */

/**
 * Individual swatch type configuration (fields vary by swatch kind).
 *
 * Each swatch type has different parameters depending on whether it's a latitude band
 * (desert belt, rainbelt), geographic feature (archipelago), or terrain type (plains, mountains).
 *
 * @typedef {Object} SwatchType
 * @property {number} [weight] - Lottery weight for selection; higher = more likely to be chosen (typically 1-10)
 * @property {number} [latitudeCenterDeg] - Center latitude for banded swatches; e.g., 25 for subtropical deserts (degrees)
 * @property {number} [halfWidthDeg] - Band half-width from center; wider = more spread (typically 5-15 degrees)
 * @property {number} [wetnessDelta] - Rainfall increase within swatch zone (typically 20-50 units for rainbelts)
 * @property {number} [drynessDelta] - Rainfall decrease within swatch zone (typically -20 to -40 units for desert belts)
 * @property {number} [dryDelta] - Alternative dryness parameter used by some swatches (units)
 * @property {number} [lowlandMaxElevation] - Elevation ceiling for "lowland" designation; plains swatches ignore highlands (typically 30-50)
 * @property {number} [islandBias] - Strength multiplier near coasts/islands for archipelago swatches (typically 1.0-2.5)
 * @property {number} [reefBias] - Coral reef probability multiplier in warm shallows (typically 1.0-2.0)
 * @property {boolean} [coupleToOrogeny] - Link to mountain rain shadow system for coherent wind patterns
 * @property {number} [windwardBonus] - Extra rainfall on windward mountain slopes (typically 10-25 units)
 * @property {number} [leePenalty] - Rainfall reduction on leeward mountain slopes (typically 5-15 units)
 * @property {number} [bleedRadius] - Edge softening distance for gradual transitions (typically 5-12 tiles)
 */

/**
 * Paleo-hydrology overlays (ancient water features that no longer flow).
 *
 * Adds traces of past hydrological activity: dried riverbeds in deserts, oxbow lakes from ancient
 * meanders, wetland deltas. These features add historical depth and subtle humidity/resource bonuses.
 * Think: Australian dry lakes, Saharan wadis, abandoned Mississippi oxbows.
 *
 * @typedef {Object} PaleoHydrology
 * @property {number} [maxDeltas] - Maximum river deltas to create (wetland fans at river mouths; typically 2-5)
 * @property {number} [deltaFanRadius] - Size of delta wetland spread inland from river mouth (typically 3-6 tiles)
 * @property {number} [deltaMarshChance] - Probability delta tiles become marshland (0..1, typically 0.4-0.7)
 * @property {number} [maxOxbows] - Maximum oxbow lakes (isolated crescent lakes from old meanders; typically 3-8)
 * @property {number} [oxbowElevationMax] - Only create oxbows in lowlands below this elevation (typically 30-50)
 * @property {number} [maxFossilChannels] - Maximum fossil riverbeds (dry channels in deserts; typically 2-6)
 * @property {number} [fossilChannelLengthTiles] - Length of each fossil channel before scaling (typically 15-30 tiles)
 * @property {number} [fossilChannelStep] - Spacing between channel points; lower = more sinuous (typically 2-4)
 * @property {number} [fossilChannelHumidity] - Small humidity bonus along dry channels (typically 5-15 units)
 * @property {number} [fossilChannelMinDistanceFromCurrentRivers] - Keep fossil channels away from active rivers (typically 10+ tiles)
 * @property {number} [minDistanceFromStarts] - Keep paleo features away from player starts for fairness (typically 15+ tiles)
 * @property {Object} [sizeScaling] - Size-aware scaling for fossil channel length (unitless scalar based on sqrt(area))
 * @property {number} [sizeScaling.lengthMulSqrt] - Length multiplier based on sqrt(map area) (scalar)
 * @property {Object} [elevationCarving] - Optional canyon rim contrast (very subtle)
 * @property {boolean} [elevationCarving.enableCanyonRim] - Whether to apply slight dryness on canyon floor and dampen rims
 * @property {number} [elevationCarving.rimWidth] - Rim width around fossil centerline (tiles)
 * @property {number} [elevationCarving.canyonDryBonus] - Extra dryness on canyon floor (rainfall units)
 * @property {number} [elevationCarving.bluffWetReduction] - Optional wetness reduction on bluffs (rainfall units)
 */

/**
 * Microclimate adjustments near story elements (localized bonuses).
 *
 * Applies targeted rainfall and feature bonuses around narrative features like rifts and hotspots.
 * These create distinctive local environments: lush rift valleys, tropical paradise islands,
 * forested volcanic slopes. Subtle but noticeable effects that reward exploration.
 *
 * @typedef {Object} Microclimate
 * @property {Object} [rainfall] - Localized rainfall adjustments
 * @property {number} [rainfall.riftBoost] - Humidity bonus along rift valley shoulders (typically 15-30 units)
 * @property {number} [rainfall.riftRadius] - Distance from rift centerline to apply boost (typically 2-5 tiles)
 * @property {number} [rainfall.paradiseDelta] - Humidity bonus near tropical paradise hotspots (typically 10-20 units)
 * @property {number} [rainfall.volcanicDelta] - Humidity bonus near volcanic hotspots from geothermal moisture (typically 8-15 units)
 * @property {Object} [features] - Localized feature bonuses
 * @property {number} [features.paradiseReefChance] - Extra coral reef probability near paradise islands (percent 0..100, typically 30-60%)
 * @property {number} [features.volcanicForestChance] - Extra forest near volcanic slopes in warm climates (percent 0..100, typically 25-50%)
 * @property {number} [features.volcanicTaigaChance] - Extra coniferous forest near volcanoes in cold climates (percent 0..100, typically 20-40%)
 */

/**
 * Landmass shaping (continental size, shape, and curvature).
 *
 * Controls the land/water ratio and how continents are shaped via fractal noise, jitter, and curvature.
 * Water percentage: 60-65% = Earth-like, 70-75% = archipelago world, 50-55% = Pangaea-like.
 *
 * @typedef {Object} Landmass
 * @property {number} [baseWaterPercent] - Target water coverage; 65 = Earth-like, 75 = island world (percent 0..100, typically 55-75)
 * @property {number} [waterThumbOnScale] - Water adjustment on larger maps; negative = less water (typically -5 to +5)
 * @property {number} [jitterAmpFracBase] - Base coastline waviness as fraction of width; higher = more irregular (typically 0.02-0.08)
 * @property {number} [jitterAmpFracScale] - Extra jitter on larger maps (typically 0.01-0.04)
 * @property {number} [curveAmpFrac] - Continental bowing/curvature; higher = more crescent-shaped landmasses (typically 0.1-0.3)
 * @property {number} [boundaryBias] - Mild closeness assist for boundary tiles (0..1, typically 0.2-0.3); higher values hug boundaries more
 * @property {number} [boundaryShareTarget] - Soft backstop: desired share of land inside the high-closeness band (0..1, typically ~0.15)
 * @property {LandmassTectonics} [tectonics] - Tectonic noise and arc weighting controls
 * @property {LandmassGeometry} [geometry] - Post-processing adjustments applied after plate-driven layout
 */

/**
 * Tectonic knobs for landmass scoring.
 *
 * `interiorNoiseWeight` blends coarse fractal noise into plate interiors so continents have thick/thin spots.
 * `boundaryArcWeight` controls uplift along convergent boundaries; lower = fewer boundary arcs, higher = stronger arcs.
 * `boundaryArcNoiseWeight` roughens arcs to avoid perfect straight lines.
 *
 * @typedef {Object} LandmassTectonics
 * @property {number} [interiorNoiseWeight] - 0..1 weight for plate-interior fractal noise (default ~0.3)
 * @property {number} [fractalGrain] - Grain for the tectonic fractal; higher = finer noise (default 4)
 * @property {number} [boundaryArcWeight] - Multiplier for convergent arc score (0..2, default ~0.8)
 * @property {number} [boundaryArcNoiseWeight] - 0..1 multiplier for arc raggedness (default ~0.5)
 */

/**
 * Landmass geometry post-processing.
 *
 * Provides fine-grained adjustments applied after the plate-driven landmask is computed.
 *
 * @typedef {Object} LandmassGeometry
 * @property {LandmassGeometryPost} [post] - Fine-tuning adjustments applied after initial layout
 */

/**
 * Post-processing adjustments for derived landmass windows.
 * Values are applied after either preset bands or plate-derived windows are computed.
 * @typedef {Object} LandmassGeometryPost
 * @property {number} [expandTiles] - Expand each landmass west/east by this many tiles (applied before individual offsets)
 * @property {number} [expandWestTiles] - Additional west-side expansion per landmass (tiles)
 * @property {number} [expandEastTiles] - Additional east-side expansion per landmass (tiles)
 * @property {number} [clampWestMin] - Minimum west boundary allowed (tiles, 0-based)
 * @property {number} [clampEastMax] - Maximum east boundary allowed (tiles, inclusive)
 * @property {number} [overrideSouth] - Override south boundary for all landmasses (tiles)
 * @property {number} [overrideNorth] - Override north boundary for all landmasses (tiles)
 * @property {number} [minWidthTiles] - Ensure each landmass spans at least this many tiles horizontally (tiles)
 */

/**
 * Coastline ruggedization (creates natural, irregular coasts).
 *
 * Transforms smooth generated coastlines into realistic features like bays and fjords.
 * Active margins get more dramatic features (fjords, cliffs), passive margins get gentler ones.
 * Respects strategic corridors to avoid blocking sea lanes.
 *
 * @typedef {Object} Coastlines
 * @property {Object} [bay] - Bay configuration (gentle coastal indentations)
 * @property {number} [bay.noiseGateAdd] - Extra noise threshold on larger maps; higher = fewer/larger bays (typically 0-3)
 * @property {number} [bay.rollDenActive] - Bay frequency on active margins; lower = more bays (typically 8-15)
 * @property {number} [bay.rollDenDefault] - Bay frequency elsewhere; lower = more bays (typically 12-20)
 * @property {Object} [fjord] - Fjord configuration (deep, narrow inlets like Norway/New Zealand)
 * @property {number} [fjord.baseDenom] - Base fjord frequency; lower = more fjords (typically 15-25)
 * @property {number} [fjord.activeBonus] - Extra fjords on active margins (converging plates); subtracts from baseDenom (typically 3-8)
 * @property {number} [fjord.passiveBonus] - Fjords near passive shelves; subtracts from baseDenom (typically 0-2)
 * @property {number} [minSeaLaneWidth] - Minimum channel width to preserve for naval passage (typically 3-6 tiles)
 * @property {CoastlinePlateBias} [plateBias] - Plate-aware weighting for bay/fjord odds based on boundary closeness
 */

/**
 * Plate-aware coastline weighting (optional).
 *
 * Provides continuous control over how plate-boundary closeness and boundary type
 * influence bay and fjord chances. Positive values make denominators smaller
 * (more edits); negative values make them larger (fewer edits).
 *
 * @typedef {Object} CoastlinePlateBias
 * @property {number} [threshold] - Normalized plate-boundary closeness threshold (0..1) where influence starts (default 0.45)
 * @property {number} [power] - Exponent shaping how quickly influence ramps after the threshold (default 1.25)
 * @property {number} [convergent] - Multiplier for convergent boundaries (default 1.0)
 * @property {number} [transform] - Multiplier for transform boundaries (default 0.4)
 * @property {number} [divergent] - Multiplier for divergent boundaries (negative to reduce edits, default -0.6)
 * @property {number} [interior] - Residual influence for interior coasts (default 0)
 * @property {number} [bayWeight] - Strength applied to bay denominators (default 0.35)
 * @property {number} [bayNoiseBonus] - Extra noise gate reduction when bias is positive (default 1.0)
 * @property {number} [fjordWeight] - Strength applied to fjord denominators (default 0.8)
 */

/**
 * Continental margins tagging (tectonic boundary classification).
 *
 * ACTIVE margins: Convergent plate boundaries with subduction, volcanism, mountains, fjords, earthquakes.
 *   Examples: Pacific Ring of Fire (Andes, Japan, Cascades), steep/dramatic coasts.
 *
 * PASSIVE margins: Divergent or stable boundaries with wide continental shelves, gentle slopes, coral reefs.
 *   Examples: US Atlantic coast, most of Africa, broad coastal plains.
 *
 * @typedef {Object} Margins
 * @property {number} [activeFraction] - Fraction of coasts as active margins; higher = more mountainous/volcanic coasts (typically 0.2-0.4)
 * @property {number} [passiveFraction] - Fraction of coasts as passive shelves; higher = more gentle/reef coasts (typically 0.3-0.5)
 * @property {number} [minSegmentLength] - Minimum coastal stretch length to classify as a margin type (typically 8-15 tiles)
 */

/**
 * Island chain placement (offshore archipelagos and volcanic islands).
 *
 * Uses fractal noise to seed islands in appropriate locations. Lower fractal threshold = more islands.
 * Active margins (like Japan, Philippines) get more volcanic islands than passive margins.
 * Hotspot trails automatically bias toward island formation (like Hawaii, Galapagos).
 *
 * @typedef {Object} Islands
 * @property {number} [fractalThresholdPercent] - Noise cutoff for island seeds; higher = fewer islands (typically 75-90 for sparse, 60-75 for moderate)
 * @property {number} [baseIslandDenNearActive] - Island frequency near active margins; lower = more islands (typically 6-12)
 * @property {number} [baseIslandDenElse] - Island frequency elsewhere; lower = more islands (typically 15-30)
 * @property {number} [hotspotSeedDenom] - Island frequency on hotspot trails; lower = more islands (typically 3-8)
 * @property {number} [clusterMax] - Maximum tiles per island cluster; creates small archipelagos (typically 3-8 tiles)
 * @property {number} [minDistFromLandRadius] - Minimum spacing from continents; prevents coastal clutter (typically 4-8 tiles)
 */

/**
 * Strategic corridors (protected travel routes for gameplay).
 *
 * Identifies and preserves key routes that should remain passable and unobstructed.
 * Prevents map generation from accidentally creating chokepoints or blocked passages.
 * Useful for ensuring naval mobility, island hopping chains, and cross-continent land routes.
 *
 * @typedef {Object} Corridors
 * @property {CorridorSea} [sea] - Open-water naval lanes (e.g., trans-oceanic shipping routes)
 * @property {CorridorIslandHop} [islandHop] - Island-hopping chains along hotspot trails (e.g., Polynesian triangle)
 * @property {CorridorLand} [land] - Overland corridors through rift valleys or grassland belts
 * @property {CorridorRiver} [river] - River valley routes connecting coasts through lowlands
 * @property {CorridorPolicy} [policy] - How strictly to enforce corridor protection (hard vs soft blocking)
 * @property {CorridorKinds} [kinds] - Biome and feature preferences within corridor zones
 */

/**
 * Sea lane corridor configuration
 * @typedef {Object} CorridorSea
 * @property {number} [maxLanes] - Max number of sea lanes to tag across the map (count)
 * @property {number} [minLengthFrac] - Minimum fraction of map span a lane must cover to qualify (ratio 0..1)
 * @property {number} [scanStride] - Sampling stride when scanning for lanes (tiles)
 * @property {number} [avoidRadius] - Radius to keep islands away from protected lanes (tiles)
 * @property {boolean} [preferDiagonals] - Whether to consider diagonal lanes in selection/scoring
 * @property {number} [laneSpacing] - Minimum spacing enforced between selected lanes (tiles)
 * @property {number} [minChannelWidth] - Minimum channel width measured orthogonal to the lane (tiles)
 */

/**
 * Island-hop corridor configuration
 * @typedef {Object} CorridorIslandHop
 * @property {boolean} [useHotspots] - Whether to promote hotspot trails into island-hop lanes
 * @property {number} [maxArcs] - Max number of promoted arcs (count)
 */

/**
 * Land corridor configuration
 * @typedef {Object} CorridorLand
 * @property {boolean} [useRiftShoulders] - Whether to derive land corridors from rift shoulders
 * @property {number} [maxCorridors] - Cap on distinct land-open corridors (count)
 * @property {number} [minRunLength] - Minimum contiguous shoulder run length eligible (tiles)
 * @property {number} [spacing] - Minimum spacing enforced between selected land corridor segments (tiles)
 */

/**
 * River corridor configuration
 * @typedef {Object} CorridorRiver
 * @property {number} [maxChains] - Max number of river chain corridors (count)
 * @property {number} [maxSteps] - Max greedy steps while following river-adjacent path (steps; ~tiles)
 * @property {number} [preferLowlandBelow] - Elevation threshold treated as lowland preference (elevation units)
 * @property {number} [coastSeedRadius] - Coast seed radius for initial river-adjacent seed near coast (tiles)
 * @property {number} [minTiles] - Minimum tiles that must be tagged for a chain to qualify (tiles)
 * @property {boolean} [mustEndNearCoast] - Require the chain to end near a coast or river mouth
 */

/**
 * Per-consumer policy strengths and behaviors for corridors
 * @typedef {Object} CorridorPolicy
 * @property {CorridorPolicySea} [sea] - Sea-lane policies (coastline/island interactions)
 * @property {CorridorPolicyLand} [land] - Land-open corridor policies (biome bias strength)
 * @property {CorridorPolicyRiver} [river] - River-chain corridor policies (biome bias strength)
 */

/**
 * Sea-lane policy
 * @typedef {Object} CorridorPolicySea
 * @property {"hard"|"soft"} [protection] - 'hard' = never edit on lanes; 'soft' = reduce chance instead of skip
 * @property {number} [softChanceMultiplier] - When protection is 'soft', multiply coast edit probabilities by this factor (ratio 0..1)
 */

/**
 * Land-open corridor policy
 * @typedef {Object} CorridorPolicyLand
 * @property {number} [biomesBiasStrength] - Scales grassland bias strength on land-open corridors (ratio 0..1)
 */

/**
 * River-chain corridor policy
 * @typedef {Object} CorridorPolicyRiver
 * @property {number} [biomesBiasStrength] - Scales grassland bias strength on river-chain corridors (ratio 0..1)
 */

/**
 * Corridor kinds/styles (open schema with known areas for sea/islandHop/land/river)
 * @typedef {Object} CorridorKinds
 * @property {Object} [sea] - Sea-lane kinds and styles
 * @property {Object.<string, CorridorStyle>} [sea.styles] - Mapping of style-name to style config
 * @property {Object} [islandHop] - Island-hop kinds and styles
 * @property {Object.<string, CorridorStyle>} [islandHop.styles] - Mapping of style-name to style config
 * @property {Object} [land] - Land corridor kinds and styles
 * @property {Object.<string, CorridorStyle>} [land.styles] - Mapping of style-name to style config
 * @property {Object} [river] - River corridor kinds and styles
 * @property {Object.<string, CorridorStyle>} [river.styles] - Mapping of style-name to style config
 */

/**
 * A generic corridor style configuration container
 * @typedef {Object} CorridorStyle
 * @property {Object.<string, number>} [biomes] - Biome mixture biases where values represent weights or fractions for biome tendencies. Values are unitless weights or ratios (0..1 typical). Keys are biome names as consumed by the layer.
 * @property {Object.<string, number>} [features] - Feature biases where numeric values represent probabilities (ratios 0..1) or multipliers (scalars). Example keys (not exhaustive): reefBias (scalar), floodplainBias (scalar), forestBias (scalar).
 * @property {Object.<string, number>} [edge] - Edge-shaping hints where numeric values are probabilities (ratios 0..1) or multipliers (scalars). Example keys (not exhaustive): cliffsChance (ratio), fjordChance (ratio), bayCarveMultiplier (scalar), shelfReefMultiplier (scalar), mountainRimChance (ratio), forestRimChance (ratio), hillRimChance (ratio), cliffChance (ratio), escarpmentChance (ratio).
 */

/**
 * Aggregated climate configuration grouping baseline, refinement, and macro swatch knobs.
 * @typedef {Object} Climate
 * @property {ClimateBaseline} [baseline]
 * @property {ClimateRefine} [refine]
 * @property {Swatches} [swatches]
 */

/**
 * Baseline rainfall and local bonuses.
 *
 * Establishes fundamental rainfall distribution based on latitude (distance from equator).
 * Mimics Earth's climate zones: wet tropics, dry subtropics, temperate mid-latitudes, cold poles.
 *
 * @typedef {Object} ClimateBaseline
 * @property {Object} [blend] - How to mix engine default rainfall with latitude-based targets
 * @property {number} [blend.baseWeight] - Weight for engine's base rainfall (0..1; typically 0.5-0.7)
 * @property {number} [blend.bandWeight] - Weight for latitude band targets (0..1; typically 0.3-0.5)
 * @property {Object} [bands] - Rainfall targets by latitude zone (units 0..200)
 * @property {number} [bands.deg0to10] - Equatorial zone (rainforests, monsoons; typically 110-130)
 * @property {number} [bands.deg10to20] - Tropical zone (wet but variable; typically 90-110)
 * @property {number} [bands.deg20to35] - Subtropical zone (deserts, Mediterranean; typically 60-80)
 * @property {number} [bands.deg35to55] - Temperate zone (moderate rainfall; typically 70-90)
 * @property {number} [bands.deg55to70] - Subpolar zone (cool, moderate moisture; typically 55-70)
 * @property {number} [bands.deg70plus] - Polar zone (cold deserts, ice; typically 40-50)
 * @property {Object} [orographic] - Orographic lift bonuses (mountains force air upward, causing condensation and rain)
 * @property {number} [orographic.hi1Threshold] - Elevation for modest rain increase (hills get some extra moisture)
 * @property {number} [orographic.hi1Bonus] - Rainfall bonus at first threshold in units (typically 5-15)
 * @property {number} [orographic.hi2Threshold] - Elevation for strong rain increase (mountains get significant moisture)
 * @property {number} [orographic.hi2Bonus] - Rainfall bonus at second threshold in units (typically 10-25)
 * @property {Object} [coastal] - Coastal bonuses
 * @property {number} [coastal.coastalLandBonus] - Bonus rainfall on coastal land tiles (rainfall units)
 * @property {number} [coastal.shallowAdjBonus] - Bonus rainfall when adjacent to shallow water (rainfall units)
 * @property {Object} [noise] - Rainfall noise/jitter
 * @property {number} [noise.baseSpanSmall] - Base +/-jitter span used on smaller maps (rainfall units)
 * @property {number} [noise.spanLargeScaleFactor] - Extra jitter span applied on larger maps (unitless scalar applied via sqrt(area))
 */

/**
 * Earthlike refinement parameters (realistic climate adjustments).
 *
 * Adds physically motivated climate effects on top of baseline latitude patterns:
 * - Continental effect: interiors are drier than coasts
 * - Rain shadows: mountains block moisture from reaching leeward areas
 * - River corridors: valleys retain moisture and support greenery
 * - Enclosed basins: low areas trap humidity
 *
 * @typedef {Object} ClimateRefine
 * @property {Object} [waterGradient] - Continental effect (distance from ocean impacts humidity)
 * @property {number} [waterGradient.radius] - How far inland to measure water proximity (typically 8-15 tiles)
 * @property {number} [waterGradient.perRingBonus] - Humidity per tile closer to water; creates coastalinterior gradient (typically 1-3 units/tile)
 * @property {number} [waterGradient.lowlandBonus] - Extra humidity in low-elevation areas near water (typically 5-12 units)
 * @property {Object} [orographic] - Orographic rain shadow simulation (leeward drying effect)
 * @property {number} [orographic.steps] - How far upwind to scan for blocking mountains (typically 4-8 tiles)
 * @property {number} [orographic.reductionBase] - Base rainfall loss in rain shadow (typically 8-20 units)
 * @property {number} [orographic.reductionPerStep] - Extra drying per tile closer to mountain barrier (typically 1-3 units/tile)
 * @property {Object} [riverCorridor] - River valley humidity (water channels transport moisture inland)
 * @property {number} [riverCorridor.lowlandAdjacencyBonus] - Humidity bonus next to rivers in lowlands (typically 8-18 units)
 * @property {number} [riverCorridor.highlandAdjacencyBonus] - Humidity bonus next to rivers in highlands; less than lowlands (typically 3-8 units)
 * @property {Object} [lowBasin] - Enclosed basin humidity retention (valleys trap moisture)
 * @property {number} [lowBasin.radius] - Search radius to detect if a lowland is surrounded by higher ground (typically 3-6 tiles)
 * @property {number} [lowBasin.delta] - Humidity bonus in enclosed lowland basins like oases (typically 10-25 units)
 */

/**
 * Mountain and hill placement tuning (WorldModel-driven orogeny).
 *
 * ARCHITECTURE: Physics-threshold based (not quota based).
 * Mountains appear only where physics score exceeds threshold - no forced quotas.
 * The tectonicIntensity dial scales physics effects to control mountain prevalence.
 *
 * @typedef {Object} Mountains
 * @property {number} [tectonicIntensity] - Scales all tectonic effects (1.0 = standard, higher = more mountains). This is the primary dial for mountain prevalence.
 * @property {number} [mountainThreshold] - Score threshold for mountain placement (0..1, typically 0.4-0.5). Lower = more permissive.
 * @property {number} [hillThreshold] - Score threshold for hill placement (0..1, typically 0.2-0.3). Lower = more hills.
 * @property {number} [upliftWeight] - Weight (0..1) applied to `WorldModel.upliftPotential`; higher = mountains stick to convergent zones
 * @property {number} [fractalWeight] - Weight (0..1) applied to fractal noise; higher = more natural variation in mountain chains
 * @property {number} [riftDepth] - 0..1 depression severity at divergent boundaries (1 = completely flatten divergent zones)
 * @property {number} [boundaryWeight] - Additional mountain weight contributed by plate-boundary closeness (unitless multiplier, typically 0..2)
 * @property {number} [boundaryExponent] - Exponent (>=0.25) shaping how quickly the boundary bonus decays with distance from a plate boundary (1.0 = linear)
 * @property {number} [interiorPenaltyWeight] - Amount subtracted from mountains deep inside plates; nudges belts toward margins (0..1)
 * @property {number} [convergenceBonus] - Extra additive weight for convergent tiles (0..1.5 typical) creating high orogeny ridges
 * @property {number} [transformPenalty] - Multiplier penalty applied along transform boundaries (0..1; 0.3 softens shearing ridges)
 * @property {number} [riftPenalty] - Multiplier penalty applied along divergent boundaries before `riftDepth` carve (0..1.5)
 * @property {number} [hillBoundaryWeight] - Hill weight contributed by plate-boundary closeness (0..1; creates foothill skirts)
 * @property {number} [hillRiftBonus] - Hill bonus for divergent belts (0..1; creates uplifted shoulders beside rifts)
 * @property {number} [hillConvergentFoothill] - Extra foothill weight on convergent tiles (0..0.5 typical)
 * @property {number} [hillInteriorFalloff] - Penalty for hills deep inside plates (0..0.5; higher keeps hills near action)
 * @property {number} [hillUpliftWeight] - Residual uplift contribution to hills (0..1; balances foothills + basins)
 */

/**
 * Volcano placement controls (plate-aware arcs + hotspots).
 *
 * Shapes how many volcanoes spawn, how tightly they track convergent margins,
 * and how much room is left for inland hotspot mechanics.
 *
 * @typedef {Object} Volcanoes
 * @property {boolean} [enabled] - Toggle volcano placement (default true)
 * @property {number} [baseDensity] - Volcanoes per land tile (e.g., 1/170  0.0059)
 * @property {number} [minSpacing] - Minimum Euclidean distance between volcanoes (tiles)
 * @property {number} [boundaryThreshold] - Plate-boundary closeness threshold (0..1) for treating a tile as margin adjacent
 * @property {number} [boundaryWeight] - Base weight applied to tiles within the plate-boundary band (0..3 typical)
 * @property {number} [convergentMultiplier] - Weight multiplier for convergent boundaries (>=0)
 * @property {number} [transformMultiplier] - Weight multiplier for transform boundaries (>=0)
 * @property {number} [divergentMultiplier] - Weight multiplier for divergent boundaries (>=0; usually <1 to discourage)
 * @property {number} [hotspotWeight] - Weight contributed to interior (non-boundary) hotspots (0..1)
 * @property {number} [shieldPenalty] - Penalty applied using shield stability (0..1; higher reduces interior volcanoes)
 * @property {number} [randomJitter] - Random additive jitter added per-tile (0..1) for variety
 * @property {number} [minVolcanoes] - Minimum volcano count target (integer)
 * @property {number} [maxVolcanoes] - Maximum volcano count target (integer; <=0 disables the cap)
 */

/**
 * Biome nudge thresholds (fine-tuning terrain assignment).
 *
 * Adjusts biome distribution to avoid unrealistic patterns and create interesting gameplay zones.
 * Example: prevent excessive tundra in temperate highlands, encourage tropical coasts near equator,
 * add grasslands along rivers and rift valleys for mobility and settlement opportunities.
 *
 * @typedef {Object} Biomes
 * @property {Object} [tundra] - Tundra constraints (prevent over-expansion of frozen terrain)
 * @property {number} [tundra.latMin] - Only allow tundra beyond this latitude; prevents equatorial tundra (typically 45-60)
 * @property {number} [tundra.elevMin] - Minimum elevation for tundra; prevents lowland tundra sprawl (typically 40-60)
 * @property {number} [tundra.rainMax] - Maximum rainfall for tundra; wet cold areas become taiga instead (typically 60-80)
 * @property {Object} [tropicalCoast] - Tropical coast encouragement (lush coastlines near equator)
 * @property {number} [tropicalCoast.latMax] - Latitude limit for tropical coast preference (typically 20-30 degrees)
 * @property {number} [tropicalCoast.rainMin] - Minimum humidity for tropical vegetation (typically 90-110 units)
 * @property {Object} [riverValleyGrassland] - River valley grassland bias (fertile flood plains)
 * @property {number} [riverValleyGrassland.latMax] - Latitude limit for temperate river grasslands (typically 45-60 degrees)
 * @property {number} [riverValleyGrassland.rainMin] - Minimum humidity for lush valley grasslands (typically 65-85 units)
 * @property {Object} [riftShoulder] - Rift shoulder biome preferences (elevated rift margins)
 * @property {number} [riftShoulder.grasslandLatMax] - Latitude limit for grassland on rift shoulders (typically 45-55 degrees)
 * @property {number} [riftShoulder.grasslandRainMin] - Minimum humidity for grassland rift shoulders (typically 60-80 units)
 * @property {number} [riftShoulder.tropicalLatMax] - Latitude limit for tropical rift shoulders (typically 25-35 degrees)
 * @property {number} [riftShoulder.tropicalRainMin] - Minimum humidity for tropical rift vegetation (typically 90-110 units)
 */

/**
 * Feature density controls (vegetation and reef prevalence).
 *
 * Fine-tunes how much forest, jungle, and reef coverage appears on the map.
 * Higher values create denser vegetation and more abundant natural features.
 * Affects visual variety and resource distribution.
 *
 * @typedef {Object} FeaturesDensity
 * @property {number} [rainforestExtraChance] - Bonus jungle/rainforest in wet tropics (percent 0..100, typically 15-40%)
 * @property {number} [forestExtraChance] - Bonus temperate forests in moderate rainfall zones (percent 0..100, typically 20-45%)
 * @property {number} [taigaExtraChance] - Bonus coniferous forests in cold regions (percent 0..100, typically 15-35%)
 * @property {number} [shelfReefMultiplier] - Coral reef density on passive continental shelves (multiplier, typically 0.8-1.5)
 */

/**
 * Late-stage placement (final touches and special features).
 *
 * Controls placement of natural wonders and floodplains along rivers.
 * Applied after all other generation is complete.
 *
 * @typedef {Object} Placement
 * @property {boolean} [wondersPlusOne] - Add one extra natural wonder beyond map size default for more variety
 * @property {Object} [floodplains] - River floodplain generation (fertile lowland strips)
 * @property {number} [floodplains.minLength] - Minimum floodplain segment length along rivers (typically 2-4 tiles)
 * @property {number} [floodplains.maxLength] - Maximum floodplain segment length along rivers (typically 4-8 tiles)
 */

/**
 * Developer logging toggles (keep false for release)
 * @typedef {Object} DevLogging
 * @property {boolean} [enabled] - Master switch for dev logging
 * @property {boolean} [logTiming] - Log per-section timings
 * @property {boolean} [logStoryTags] - Log StoryTags summary counts
 * @property {boolean} [rainfallHistogram] - Log coarse rainfall histogram over land
 */

/**
 * Unified world foundation configuration replacing the legacy `worldModel` + `landmass` split.
 *
 * @typedef {Object} FoundationConfig
 * @property {FoundationSeedConfig} [seed] - Deterministic seed controls shared by plates/dynamics.
 * @property {FoundationPlatesConfig} [plates] - Voronoi plate generation controls.
 * @property {FoundationDynamicsConfig} [dynamics] - Atmospheric/oceanic drivers and mantle pressure.
 * @property {FoundationSurfaceConfig} [surface] - Landmass targets and ocean separation policy.
 * @property {FoundationPolicyConfig} [policy] - Consumer-facing policy multipliers.
 * @property {FoundationDiagnosticsConfig} [diagnostics] - Logging + replay toggles for foundations.
 */

/**
 * Voronoi plate layout controls for the world foundation.
 *
 * @typedef {Object} FoundationPlatesConfig
 * @property {number} [count] - Number of tectonic plates; 8=Pangaea, 15-20=Earth-like, 25+=fragmented (typically 12-18).
 * @property {ReadonlyArray<number>} [axisAngles] - **Deprecated** legacy axis hints retained for compatibility.
 * @property {number} [convergenceMix] - Ratio of convergent vs divergent boundaries (0..1, typically 0.4-0.6).
 * @property {number} [relaxationSteps] - Lloyd relaxation iterations to smooth plate shapes (0=random, 5=balanced, 10+=uniform).
 * @property {number} [seedJitter] - Random offset applied to initial plate seeds in tiles (0-8 typical).
 * @property {number} [interiorSmooth] - Shield interior smoothing steps (iterations).
 * @property {number} [plateRotationMultiple] - Multiplier for plate rotation weighting along boundaries.
 * @property {"engine"|"fixed"} [seedMode] - Use Civ engine seed ("engine") or a fixed seed ("fixed").
 * @property {number} [fixedSeed] - Explicit plate seed used when `seedMode === "fixed"`.
 * @property {number} [seedOffset] - Integer added to the base seed before plate generation for deterministic reruns.
 */

/**
 * Prevailing wind configuration for rainfall/orographic modelling.
 *
 * @typedef {Object} FoundationWindConfig
 * @property {number} [jetStreaks] - Number of jet stream bands influencing storm tracks (typically 2-5).
 * @property {number} [jetStrength] - Jet stream intensity multiplier (typically 0.8-2.0).
 * @property {number} [variance] - Directional variance for winds (0..1, typically 0.2-0.6).
 * @property {number} [coriolisZonalScale] - Coriolis effect strength on zonal (east/west) flow (typically 0.8-1.5).
 */

/**
 * Ocean circulation configuration for humidity and coastal climate effects.
 *
 * @typedef {Object} FoundationCurrentsConfig
 * @property {number} [basinGyreCountMax] - Maximum gyre systems to model (typically 3-6).
 * @property {number} [westernBoundaryBias] - Strength of western boundary currents (unitless multiplier, typically 1.0-2.0).
 * @property {number} [currentStrength] - Overall ocean current strength multiplier (typically 0.8-1.5).
 */

/**
 * Mantle convection hotspot configuration used for uplift potential.
 *
 * @typedef {Object} FoundationMantleConfig
 * @property {number} [bumps] - Number of mantle plume hotspots (typically 3-8).
 * @property {number} [amplitude] - Uplift strength from mantle pressure (typically 0.5-1.5).
 * @property {number} [scale] - Spatial scale of pressure effects (typically 0.8-1.5).
 */

/**
 * Alignment and interplay controls for plates, winds, and currents.
 *
 * @typedef {Object} FoundationDirectionalityConfig
 * @property {number} [cohesion] - Global alignment strength (0..1, typically 0.3-0.7).
 * @property {Object} [primaryAxes] - Preferred axes for each subsystem (degrees, 0=east).
 * @property {number} [primaryAxes.plateAxisDeg] - Primary plate movement direction.
 * @property {number} [primaryAxes.windBiasDeg] - Wind direction bias offset from zonal flow.
 * @property {number} [primaryAxes.currentBiasDeg] - Ocean gyre rotation bias.
 * @property {Object} [interplay] - Cross-system coupling strengths controlling mutual influence.
 * @property {number} [interplay.windsFollowPlates] - Jet streams align with plate motion (0..1).
 * @property {number} [interplay.currentsFollowWinds] - Ocean currents align with winds (0..1).
 * @property {number} [interplay.riftsFollowPlates] - Rift valleys align with divergent plate boundaries (0..1).
 * @property {number} [interplay.orogenyOpposesRifts] - Mountain ranges oppose rift direction (0..1).
 * @property {Object} [hemispheres] - Hemisphere-specific behaviour.
 * @property {boolean} [hemispheres.southernFlip] - Flip directionality in the southern hemisphere (Coriolis realism).
 * @property {number} [hemispheres.equatorBandDeg] - Symmetric latitude band around the equator (degrees).
 * @property {number} [hemispheres.monsoonBias] - Seasonal wind variation strength (0..1).
 * @property {Object} [variability] - Randomness injection to avoid uniform patterns.
 * @property {number} [variability.angleJitterDeg] - Random deviation from preferred axes (degrees).
 * @property {number} [variability.magnitudeVariance] - Strength variation multiplier (0..1).
 * @property {number} [variability.seedOffset] - Seed offset for reproducible variability.
 */

/**
 * Policy multipliers exposed to downstream stages (story overlays, coastlines, etc.).
 *
 * @typedef {Object} FoundationPolicyConfig
 * @property {number} [windInfluence] - Wind impact on rain shadow calculations (multiplier, typically 0.5-1.5).
 * @property {number} [currentHumidityBias] - Coastal humidity bias from currents (multiplier, typically 0.5-1.5).
 * @property {number} [boundaryFjordBias] - Fjord frequency multiplier near convergent boundaries (typically 0.8-2.0).
 * @property {number} [shelfReefBias] - Coral reef density multiplier on passive shelves (typically 0.8-1.5).
 * @property {FoundationOceanSeparationConfig} [oceanSeparation] - Plate-aware ocean separation policy.
 */

/**
 * Plate-aware ocean separation policy controlling continental drift spacing.
 *
 * @typedef {Object} FoundationOceanSeparationConfig
 * @property {boolean} [enabled] - Enable plate-driven separation between continent bands.
 * @property {ReadonlyArray<ReadonlyArray<number>>} [bandPairs] - Pairs of continent indices to separate (e.g., [[0,1],[1,2]]).
 * @property {number} [baseSeparationTiles] - Baseline widening between continents in tiles (typically 2-8).
 * @property {number} [boundaryClosenessMultiplier] - Extra separation near active boundaries (multiplier 0..2).
 * @property {number} [maxPerRowDelta] - Maximum per-latitude variation in separation (tiles, typically 1-3).
 * @property {boolean} [respectSeaLanes] - Preserve strategic corridors when widening oceans.
 * @property {number} [minChannelWidth] - Minimum channel width to maintain for navigation (tiles, typically 4-8).
 * @property {Object} [edgeWest] - Optional overrides for the western map edge.
 * @property {boolean} [edgeWest.enabled] - Enable west-edge override.
 * @property {number} [edgeWest.baseTiles] - Baseline tiles at the west edge.
 * @property {number} [edgeWest.boundaryClosenessMultiplier] - Boundary multiplier at the west edge.
 * @property {number} [edgeWest.maxPerRowDelta] - Maximum per-row delta at the west edge.
 * @property {Object} [edgeEast] - Optional overrides for the eastern map edge.
 * @property {boolean} [edgeEast.enabled] - Enable east-edge override.
 * @property {number} [edgeEast.baseTiles] - Baseline tiles at the east edge.
 * @property {number} [edgeEast.boundaryClosenessMultiplier] - Boundary multiplier at the east edge.
 * @property {number} [edgeEast.maxPerRowDelta] - Maximum per-row delta at the east edge.
 */

/**
 * Deterministic seed configuration for world foundations.
 *
 * @typedef {Object} FoundationSeedConfig
 * @property {"engine"|"fixed"} [mode] - Use Civ engine seed or a fixed value.
 * @property {number} [fixed] - Explicit seed value when `mode === "fixed"`.
 * @property {number} [offset] - Global offset applied before deriving subsystem seeds.
 * @property {Object} [offsets] - Optional per-subsystem offsets (e.g., { plates, dynamics, surface }).
 * @property {number} [manifestHash] - Hash of the resolved manifest for replay diagnostics.
 */

/**
 * Atmospheric, oceanic, and mantle drivers for the foundation tensors.
 *
 * @typedef {Object} FoundationDynamicsConfig
 * @property {FoundationWindConfig} [wind] - Prevailing wind configuration.
 * @property {FoundationCurrentsConfig} [currents] - Ocean circulation settings.
 * @property {FoundationMantleConfig} [mantle] - Mantle pressure hotspot configuration.
 * @property {FoundationDirectionalityConfig} [directionality] - Cross-system alignment controls.
 */

/**
 * Surface targets derived from the world foundation seed.
 *
 * @typedef {Object} FoundationSurfaceConfig
 * @property {Landmass} [landmass] - Landmass targets and geometry preferences.
 * @property {FoundationOceanSeparationConfig} [oceanSeparation] - Plate-aware ocean separation policy.
 * @property {Object<string, any>} [overrides] - Additional surface overrides keyed by stage name.
 */

/**
 * Diagnostics and logging toggles for the foundation pipeline.
 *
 * @typedef {Object} FoundationDiagnosticsConfig
 * @property {boolean} [logSeed] - Emit plate seed + RNG metadata to diagnostics.
 * @property {boolean} [logPlates] - Log plate ASCII/summary output.
 * @property {boolean} [logDynamics] - Log wind/current summaries.
 * @property {boolean} [logSurface] - Log landmass window + separation summaries.
 */

// Export empty object to make this a proper ES module
export {};
</file>

<file path="mod/maps/bootstrap/resolved.js">
// @ts-check
/**
 * Resolved Config Provider
 *
 * Purpose
 * - Build a single, immutable configuration snapshot for the current run by
 *   composing, in order of increasing precedence:
 *     1) Explicit defaults (BASE_CONFIG)
 *     2) Named presets (optional, ordered)
 *     3) Per-entry overrides from runtime (set via setConfig in entry files)
 *
 * Usage
 * - Call refresh() once at the start of generation (e.g., top of generateMap()).
 * - Import and use the getters below to read resolved groups/fields.
 *
 * Notes
 * - Arrays are replaced (not merged); objects are deep-merged by key.
 * - The final snapshot is deeply frozen to prevent accidental mutation.
 * - Control keys (e.g., `presets`) are stripped from the final snapshot.
 */

/**
 * Type definitions for configuration objects (available at runtime).
 * @typedef {import('./map_config.types.js').MapConfig} MapConfig
 * @typedef {import('./map_config.types.js').Toggles} Toggles
 * @typedef {import('./map_config.types.js').Story} Story
 * @typedef {import('./map_config.types.js').Microclimate} Microclimate
 * @typedef {import('./map_config.types.js').Landmass} Landmass
 * @typedef {import('./map_config.types.js').Coastlines} Coastlines
 * @typedef {import('./map_config.types.js').Margins} Margins
 * @typedef {import('./map_config.types.js').Islands} Islands
 * @typedef {import('./map_config.types.js').ClimateBaseline} ClimateBaseline
 * @typedef {import('./map_config.types.js').ClimateRefine} ClimateRefine
 * @typedef {import('./map_config.types.js').Biomes} Biomes
 * @typedef {import('./map_config.types.js').FeaturesDensity} FeaturesDensity
 * @typedef {import('./map_config.types.js').Mountains} Mountains
 * @typedef {import('./map_config.types.js').Volcanoes} Volcanoes
 * @typedef {import('./map_config.types.js').Corridors} Corridors
 * @typedef {import('./map_config.types.js').Placement} Placement
 * @typedef {import('./map_config.types.js').DevLogging} DevLogging
 * @typedef {import('./map_config.types.js').FoundationConfig} FoundationConfig
 * @typedef {import('./map_config.types.js').StageManifest} StageManifest
 * @typedef {import('./map_config.types.js').StageDescriptor} StageDescriptor
 * @typedef {import('./map_config.types.js').StageName} StageName
 */

import { BASE_CONFIG } from "./defaults/base.js";
import { CLASSIC_PRESET } from "./presets/classic.js";
import { TEMPERATE_PRESET } from "./presets/temperate.js";
import { getConfig as getRuntimeConfig } from "./runtime.js";
/* -----------------------------------------------------------------------------
 * Internal state
 * -------------------------------------------------------------------------- */
/** @typedef {Record<string, any>} AnyObject */
/** @type {Record<string, AnyObject>} */
const PRESET_REGISTRY = Object.freeze({
    classic: CLASSIC_PRESET,
    temperate: TEMPERATE_PRESET,
});
/** @type {ReadonlyArray<string>} */
let ACTIVE_PRESETS = Object.freeze([]);
/** @type {Readonly<AnyObject>} */
let SNAPSHOT = BASE_CONFIG;
/** @type {StageManifest} */
const EMPTY_STAGE_MANIFEST = Object.freeze({
    order: Object.freeze([]),
    stages: Object.freeze({}),
});
/* -----------------------------------------------------------------------------
 * Merge and freeze helpers
 * -------------------------------------------------------------------------- */
/**
 * @param {any} v
 * @returns {v is AnyObject}
 */
function isPlainObject(v) {
    return (v != null &&
        typeof v === "object" &&
        (Object.getPrototypeOf(v) === Object.prototype ||
            Object.getPrototypeOf(v) === null));
}
/**
 * Deeply merge two values into a new value.
 * - Objects: merged per-key (recursively).
 * - Arrays: replaced by the source (no concat).
 * - Other types: replaced by the source.
 *
 * @template T
 * @param {T} base
 * @param {any} src
 * @returns {T}
 */
function deepMerge(base, src) {
    // Replace primitives and arrays directly
    if (!isPlainObject(base) || Array.isArray(src)) {
        return clone(src);
    }
    if (!isPlainObject(src)) {
        // If source is not a plain object, replace
        return clone(src);
    }
    /** @type {AnyObject} */
    const out = {};
    // Copy base keys first
    for (const k of Object.keys(base)) {
        out[k] = clone(base[k]);
    }
    // Merge/replace from source
    for (const k of Object.keys(src)) {
        const b = out[k];
        const s = src[k];
        if (isPlainObject(b) && isPlainObject(s)) {
            out[k] = deepMerge(b, s);
        }
        else {
            out[k] = clone(s);
        }
    }
    return /** @type {T} */ (out);
}
/**
 * Clone a value shallowly (objects/arrays produce new containers).
 * @param {any} v
 * @returns {any}
 */
function clone(v) {
    if (Array.isArray(v))
        return v.slice();
    if (isPlainObject(v)) {
        const o = {};
        for (const k of Object.keys(v))
            o[k] = v[k];
        return o;
    }
    return v;
}
/**
 * Deep-freeze an object graph (objects/arrays).
 * Loosened typing for @ts-check to avoid structural complaints in JS.
 * @param {any} v
 * @returns {any}
 */
function deepFreeze(v) {
    if (v == null)
        return v;
    if (typeof Object.isFrozen === "function" && Object.isFrozen(v))
        return v;
    if (Array.isArray(v)) {
        const arr = v.map((item) => deepFreeze(item));
        return Object.freeze(arr);
    }
    if (isPlainObject(v)) {
        /** @type {Record<string, any>} */
        const out = {};
        for (const k of Object.keys(v)) {
            out[k] = deepFreeze(v[k]);
        }
        return Object.freeze(out);
    }
    return v;
}
/**
 * @typedef {Object} StageState
 * @property {boolean} enabled
 * @property {boolean} requested
 * @property {Array<StageName>} requires
 * @property {Array<string>} legacyToggles
 * @property {Array<string>} provides
 * @property {string | undefined} blockedBy
 */
/**
 * @param {any} values
 * @returns {Array<string>}
 */
function normalizeStringArray(values) {
    if (!Array.isArray(values))
        return [];
    /** @type {Array<string>} */
    const out = [];
    const seen = new Set();
    for (const val of values) {
        if (typeof val !== "string")
            continue;
        if (seen.has(val))
            continue;
        seen.add(val);
        out.push(val);
    }
    return out;
}
/**
 * Normalize stage manifest metadata, enforce dependencies, and derive toggle state.
 *
 * @param {any} manifestInput
 * @param {AnyObject} togglesInput
 * @returns {{ manifest: StageManifest, toggles: Record<string, boolean>, warnings: Array<string> }}
 */
function normalizeStageManifest(manifestInput, togglesInput) {
    const manifestObj = isPlainObject(manifestInput) ? manifestInput : {};
    const rawOrder = Array.isArray(manifestObj.order) ? manifestObj.order : [];
    const rawStages = isPlainObject(manifestObj.stages) ? manifestObj.stages : {};
    /** @type {Array<StageName>} */
    const order = [];
    const seen = new Set();
    for (const entry of rawOrder) {
        if (typeof entry !== "string")
            continue;
        if (seen.has(entry))
            continue;
        order.push(entry);
        seen.add(entry);
    }
    for (const key of Object.keys(rawStages)) {
        if (seen.has(key))
            continue;
        order.push(key);
        seen.add(key);
    }
    /** @type {Record<string, StageState>} */
    const states = {};
    const toggles = isPlainObject(togglesInput) ? togglesInput : {};
    const orderIndex = new Map(order.map((name, idx) => [name, idx]));
    for (const name of order) {
        const rawDescriptor = rawStages[name];
        const descriptor = isPlainObject(rawDescriptor) ? rawDescriptor : {};
        const requires = normalizeStringArray(descriptor.requires);
        const provides = normalizeStringArray(descriptor.provides);
        const legacyToggles = normalizeStringArray(descriptor.legacyToggles);
        let enabled = descriptor.enabled !== false;
        let requested = enabled;
        for (const key of legacyToggles) {
            if (Object.prototype.hasOwnProperty.call(toggles, key) &&
                typeof toggles[key] === "boolean") {
                enabled = !!toggles[key];
                requested = !!toggles[key];
            }
        }
        states[name] = {
            enabled,
            requested,
            requires,
            legacyToggles,
            provides,
            blockedBy: undefined,
        };
    }
    for (const name of order) {
        const state = states[name];
        if (!state || !state.enabled)
            continue;
        for (const dep of state.requires) {
            const depState = states[dep];
            if (!depState) {
                if (!state.blockedBy)
                    state.blockedBy = `requires missing stage "${dep}"`;
                state.enabled = false;
                break;
            }
            if (!depState.enabled) {
                if (!state.blockedBy)
                    state.blockedBy = `requires disabled stage "${dep}"`;
                state.enabled = false;
                break;
            }
            const depIdx = orderIndex.get(dep);
            const stageIdx = orderIndex.get(name);
            if (depIdx != null && stageIdx != null && depIdx > stageIdx) {
                if (!state.blockedBy)
                    state.blockedBy = `dependency "${dep}" executes after stage`;
                state.enabled = false;
                break;
            }
        }
    }
    /** @type {Record<string, boolean>} */
    const derivedToggles = {};
    /** @type {Array<string>} */
    const warnings = [];
    /** @type {Record<string, StageDescriptor>} */
    const normalizedStages = {};
    for (const name of order) {
        const state = states[name];
        if (!state)
            continue;
        for (const key of state.legacyToggles) {
            derivedToggles[key] = !!state.enabled;
        }
        if (state.blockedBy && state.requested) {
            warnings.push(`Stage "${name}" disabled: ${state.blockedBy}.`);
        }
        const desc = /** @type {StageDescriptor} */ ({
            enabled: !!state.enabled,
        });
        if (state.requires.length)
            desc.requires = state.requires.slice();
        if (state.provides.length)
            desc.provides = state.provides.slice();
        if (state.legacyToggles.length)
            desc.legacyToggles = state.legacyToggles.slice();
        if (state.blockedBy)
            desc.blockedBy = state.blockedBy;
        normalizedStages[name] = desc;
    }
    return {
        manifest: {
            order: order.slice(),
            stages: normalizedStages,
        },
        toggles: derivedToggles,
        warnings,
    };
}

/**
 * Normalize stage configuration provider metadata from runtime entries.
 * @param {any} input
 * @returns {Record<string, boolean>}
 */
function normalizeStageConfigProviders(input) {
    if (!isPlainObject(input))
        return {};
    /** @type {Record<string, boolean>} */
    const out = {};
    for (const key of Object.keys(input)) {
        if (typeof key !== "string")
            continue;
        const value = input[key];
        if (typeof value === "boolean") {
            if (value)
                out[key] = true;
            continue;
        }
        if (value != null)
            out[key] = true;
    }
    return out;
}

/**
 * Derive warnings when overrides target disabled or missing stages.
 * @param {Record<string, boolean>} providers
 * @param {StageManifest} manifest
 * @returns {Array<string>}
 */
function deriveStageOverrideWarnings(providers, manifest) {
    /** @type {Array<string>} */
    const warnings = [];
    if (!providers)
        return warnings;
    const stages = manifest?.stages || {};
    for (const name of Object.keys(providers)) {
        if (!providers[name])
            continue;
        const desc = stages[name];
        if (!desc) {
            warnings.push(`Stage "${name}" not present in manifest; overrides will not run.`);
            continue;
        }
        if (desc.enabled)
            continue;
        const reason = desc.blockedBy ? ` (${desc.blockedBy})` : "";
        warnings.push(`Stage "${name}" disabled${reason}; overrides for this stage will be ignored.`);
    }
    return warnings;
}

/**
 * Normalize the foundation group and surface landmass metadata.
 * Mutates the supplied merged snapshot and returns any migration warnings.
 * @param {AnyObject} merged
 * @returns {Array<string>}
 */
function normalizeFoundationGroup(merged) {
    /** @type {Array<string>} */
    const warnings = [];
    const foundationInput = isPlainObject(merged.foundation) ? /** @type {AnyObject} */ (merged.foundation) : {};
    const landmassInput = isPlainObject(merged.landmass) ? /** @type {AnyObject} */ (merged.landmass) : {};
    /** @type {AnyObject} */
    const foundationNormalized = deepMerge({}, foundationInput || {});
    if (Object.keys(landmassInput).length > 0) {
        if (isPlainObject(foundationNormalized.surface)) {
            foundationNormalized.surface = deepMerge({ landmass: landmassInput }, foundationNormalized.surface);
        }
        else {
            foundationNormalized.surface = { landmass: landmassInput };
        }
    }
    merged.foundation = foundationNormalized;
    if (merged.worldModel && isPlainObject(merged.worldModel) && Object.keys(merged.worldModel).length > 0) {
        warnings.push("Legacy `worldModel` overrides are no longer supported; migrate overrides to `foundation.*`.");
    }
    if ("worldModel" in merged) {
        delete merged.worldModel;
    }
    return warnings;
}
/* -----------------------------------------------------------------------------
 * Resolution
 * -------------------------------------------------------------------------- */
/**
 * Build a new resolved snapshot by composing:
 *   BASE_CONFIG <- presets[] <- runtimeOverrides
 *
 * Runtime overrides may optionally include { presets: string[] } to select
 * named presets. The 'presets' control key is stripped from the final snapshot.
 *
 * @returns {{ snapshot: Readonly<AnyObject>, activePresetNames: ReadonlyArray<string> }}
 */
function buildSnapshot() {
    // Start from explicit defaults
    let merged = /** @type {AnyObject} */ (deepMerge({}, BASE_CONFIG));
    // Read per-entry overrides
    const rc = /** @type {AnyObject} */ (getRuntimeConfig() || {});
    // Resolve and apply presets (ordered)
    const presetNames = Array.isArray(rc.presets)
        ? rc.presets.filter((n) => typeof n === "string" && !!PRESET_REGISTRY[n])
        : [];
    for (const name of presetNames) {
        const presetObj = PRESET_REGISTRY[name];
        if (presetObj) {
            merged = deepMerge(merged, presetObj);
        }
    }
    const stageConfigProviders = normalizeStageConfigProviders(rc.stageConfig);
    // Strip control keys (e.g., 'presets') from overrides before merge
    /** @type {AnyObject} */
    const overrides = {};
    for (const k of Object.keys(rc)) {
        if (k === "presets" || k === "stageConfig")
            continue;
        overrides[k] = rc[k];
    }
    // Apply per-entry overrides last (highest precedence)
    merged = deepMerge(merged, overrides);
    if (Object.keys(stageConfigProviders).length > 0) {
        merged.stageConfig = stageConfigProviders;
    }
    const togglesBase = isPlainObject(merged.toggles) ? /** @type {AnyObject} */ (merged.toggles) : {};
    const { manifest: normalizedManifest, toggles: manifestToggles, warnings } = normalizeStageManifest(merged.stageManifest, togglesBase);
    const overrideWarnings = deriveStageOverrideWarnings(stageConfigProviders, normalizedManifest);
    merged.stageManifest = normalizedManifest;
    merged.toggles = { ...togglesBase, ...manifestToggles };
    for (const msg of [...warnings, ...overrideWarnings]) {
        try {
            console.warn(`[StageManifest] ${msg}`);
        }
        catch (_) {
            // Ignore console access issues in restrictive runtimes.
        }
    }
    const foundationWarnings = normalizeFoundationGroup(merged);
    for (const msg of foundationWarnings) {
        try {
            console.warn(`[Foundation] ${msg}`);
        }
        catch (_) {
            // Ignore console access issues in restrictive runtimes.
        }
    }
    // Freeze deeply for safety
    const frozen = deepFreeze(merged);
    return {
        snapshot: frozen,
        activePresetNames: Object.freeze(presetNames.slice()),
    };
}
/* -----------------------------------------------------------------------------
 * Public API
 * -------------------------------------------------------------------------- */
/**
 * Rebuild the resolved snapshot for the current run.
 * Should be called at the start of generation (e.g., in generateMap()).
 */
export function refresh() {
    const { snapshot, activePresetNames } = buildSnapshot();
    SNAPSHOT = snapshot;
    ACTIVE_PRESETS = activePresetNames;
}
/**
 * Get the current immutable snapshot (for diagnostics or advanced usage).
 * @returns {Readonly<AnyObject>}
 */
export function getSnapshot() {
    return SNAPSHOT;
}
/**
 * Get the currently active preset names (in application order).
 * @returns {ReadonlyArray<string>}
 */
export function currentActivePresets() {
    return ACTIVE_PRESETS;
}
/**
 * Generic group accessor with safe fallback to empty object.
 * @param {string} groupName
 * @returns {Readonly<AnyObject>}
 */
export function getGroup(groupName) {
    const g = SNAPSHOT && /** @type {AnyObject} */ (SNAPSHOT)[groupName];
    return /** @type {any} */ (isPlainObject(g) ? g : {});
}
/**
 * Retrieve the normalized stage manifest (order + descriptors).
 * @returns {Readonly<StageManifest>}
 */
export function STAGE_MANIFEST() {
    const manifest = SNAPSHOT && /** @type {AnyObject} */ (SNAPSHOT).stageManifest;
    return isPlainObject(manifest)
        ? /** @type {Readonly<StageManifest>} */ (manifest)
        : EMPTY_STAGE_MANIFEST;
}
/**
 * Dot-path getter for convenience (e.g., "foundation.dynamics.wind").
 * Returns undefined if not found.
 * @param {string} path
 * @returns {any}
 */
export function get(path) {
    if (!path || typeof path !== "string")
        return undefined;
    const parts = path.split(".");
    /** @type {any} */
    let cur = SNAPSHOT;
    for (const p of parts) {
        if (cur == null)
            return undefined;
        cur = cur[p];
    }
    return cur;
}
/* ---- Named helpers (common groups; return empty objects if missing) ---- */
/** @returns {Readonly<Toggles>} */
export function TOGGLES() {
    return /** @type {Readonly<Toggles>} */ (getGroup("toggles"));
}
/** @returns {Readonly<Story>} */
export function STORY() {
    return /** @type {Readonly<Story>} */ (getGroup("story"));
}
/** @returns {Readonly<Microclimate>} */
export function MICROCLIMATE() {
    return /** @type {Readonly<Microclimate>} */ (getGroup("microclimate"));
}
/** @returns {Readonly<Landmass>} */
export function LANDMASS_CFG() {
    return /** @type {Readonly<Landmass>} */ (getGroup("landmass"));
}
/** @returns {Readonly<Coastlines>} */
export function COASTLINES_CFG() {
    return /** @type {Readonly<Coastlines>} */ (getGroup("coastlines"));
}
/** @returns {Readonly<Margins>} */
export function MARGINS_CFG() {
    return /** @type {Readonly<Margins>} */ (getGroup("margins"));
}
/** @returns {Readonly<Islands>} */
export function ISLANDS_CFG() {
    return /** @type {Readonly<Islands>} */ (getGroup("islands"));
}
/** @returns {Readonly<any>} */
export function CLIMATE_CFG() {
    return /** @type {Readonly<any>} */ (getGroup("climate"));
}
/** @returns {Readonly<Mountains>} */
export function MOUNTAINS_CFG() {
    return /** @type {Readonly<Mountains>} */ (getGroup("mountains"));
}
/** @returns {Readonly<Volcanoes>} */
export function VOLCANOES_CFG() {
    return /** @type {Readonly<Volcanoes>} */ (getGroup("volcanoes"));
}
/** @returns {Readonly<Biomes>} */
export function BIOMES_CFG() {
    return /** @type {Readonly<Biomes>} */ (getGroup("biomes"));
}
/** @returns {Readonly<FeaturesDensity>} */
export function FEATURES_DENSITY_CFG() {
    return /** @type {Readonly<FeaturesDensity>} */ (getGroup("featuresDensity"));
}
/** @returns {Readonly<Corridors>} */
export function CORRIDORS_CFG() {
    return /** @type {Readonly<Corridors>} */ (getGroup("corridors"));
}
/** @returns {Readonly<Placement>} */
export function PLACEMENT_CFG() {
    return /** @type {Readonly<Placement>} */ (getGroup("placement"));
}
/** @returns {Readonly<DevLogging>} */
export function DEV_LOG_CFG() {
    return /** @type {Readonly<DevLogging>} */ (getGroup("dev"));
}
/** @returns {Readonly<FoundationConfig>} */
export function FOUNDATION_CFG() {
    return /** @type {Readonly<FoundationConfig>} */ (getGroup("foundation"));
}
/* ---- Foundation helpers ---- */
export function FOUNDATION_SEED() {
    return /** @type {any} */ (get("foundation.seed") || {});
}
export function FOUNDATION_PLATES() {
    return /** @type {any} */ (get("foundation.plates") || {});
}
export function FOUNDATION_DYNAMICS() {
    return /** @type {any} */ (get("foundation.dynamics") || {});
}
export function FOUNDATION_SURFACE() {
    return /** @type {any} */ (get("foundation.surface") || {});
}
export function FOUNDATION_POLICY() {
    return /** @type {any} */ (get("foundation.policy") || {});
}
export function FOUNDATION_DIAGNOSTICS() {
    return /** @type {any} */ (get("foundation.diagnostics") || {});
}
export function FOUNDATION_DIRECTIONALITY() {
    return /** @type {any} */ (get("foundation.dynamics.directionality") || {});
}
export function FOUNDATION_OCEAN_SEPARATION() {
    return /** @type {any} */ (get("foundation.surface.oceanSeparation") ||
        get("foundation.policy.oceanSeparation") ||
        {});
}

/* ---- Default export (optional convenience) ---- */
export default {
    refresh,
    getSnapshot,
    currentActivePresets,
    getGroup,
    get,
    STAGE_MANIFEST,
    // Groups
    TOGGLES,
    STORY,
    MICROCLIMATE,
    LANDMASS_CFG,
    COASTLINES_CFG,
    MARGINS_CFG,
    ISLANDS_CFG,
    CLIMATE_CFG,
    BIOMES_CFG,
    FEATURES_DENSITY_CFG,
    CORRIDORS_CFG,
    PLACEMENT_CFG,
    DEV_LOG_CFG,
    FOUNDATION_CFG,
    // Foundation subsets
    FOUNDATION_SEED,
    FOUNDATION_PLATES,
    FOUNDATION_DYNAMICS,
    FOUNDATION_SURFACE,
    FOUNDATION_POLICY,
    FOUNDATION_DIAGNOSTICS,
    FOUNDATION_DIRECTIONALITY,
    FOUNDATION_OCEAN_SEPARATION,
};
</file>

<file path="mod/maps/bootstrap/runtime.js">
// @ts-nocheck
/**
 * Minimal runtime config store for per-map inline configuration.
 *
 * Intent
 * - Each map entry file defines a plain JS object (MAP_CONFIG) inline and calls setConfig(MAP_CONFIG).
 * - The generator/orchestrator imports this module and calls getConfig() at runtime (e.g., inside generateMap()).
 * - No dynamic imports, no registries, no evaluation-time side effects. Dead simple and explicit.
 *
 * Usage (in a map entry file):
 *   import { setConfig } from "./config/runtime.js";
 *   import "./map_orchestrator.js"; // or your generator module that reads getConfig() at runtime
 *
 *   setConfig({
 *     landmass: { /* ... *\/ },
 *     foundation: { /* ... *\/ },
 *     /* other groups ... *\/
 *   });
 *
 * Usage (in the orchestrator/generator):
 *   import { getConfig } from "./config/runtime.js";
 *   function generateMap() {
 *     const cfg = getConfig();
 *     // read cfg.toggles, cfg.landmass, etc., and proceed
 *   }
 */
const GLOBAL_KEY = "__EPIC_MAP_CONFIG__";
/**
 * Store the per-map configuration for this run.
 * Accepts any plain object. Non-objects are coerced to an empty object.
 * The stored object is shallow-frozen to prevent accidental mutation.
 * @param {object} config
 */
export function setConfig(config) {
    const obj = isObject(config) ? config : {};
    const frozen = shallowFreeze(obj);
    try {
        // Use a single well-known global key so all modules can access the same config
        // without import-time coupling or registries.
        globalThis[GLOBAL_KEY] = frozen;
    }
    catch {
        // In restricted environments, fall back to a local static (unlikely in Civ VM).
        __localStore.value = frozen;
    }
}
/**
 * Retrieve the current per-map configuration.
 * Returns an empty frozen object if none was set.
 * @returns {object}
 */
export function getConfig() {
    try {
        const v = globalThis[GLOBAL_KEY];
        return isObject(v) ? v : EMPTY_FROZEN_OBJECT;
    }
    catch {
        return isObject(__localStore.value) ? __localStore.value : EMPTY_FROZEN_OBJECT;
    }
}
/* -----------------------------------------------------------------------------
 * Internal helpers
 * -------------------------------------------------------------------------- */
const EMPTY_FROZEN_OBJECT = Object.freeze({});
/** @type {{ value: object }} */
const __localStore = { value: EMPTY_FROZEN_OBJECT };
/**
 * Shallow-freeze an object (freezes only the first level).
 * @template T extends object
 * @param {T} obj
 * @returns {Readonly<T>}
 */
function shallowFreeze(obj) {
    try {
        return Object.freeze(obj);
    }
    catch {
        return obj;
    }
}
/**
 * @param {any} v
 * @returns {v is object}
 */
function isObject(v) {
    return v != null && typeof v === "object";
}
</file>

<file path="mod/maps/bootstrap/tunables.js">
/**
 * Unified Tunables  Live bindings with runtime rebind()
 *
 * Intent
 * - Provide a single import surface for all generator tunables (toggles and groups)
 *   backed by the resolved config snapshot.
 * - Export live ES module bindings (let variables) so callers see updated values
 *   after a call to rebind().
 *
 * Usage
 *   // Import once anywhere (bindings are live)
 *   import {
 *     rebind,
 *     LANDMASS_CFG,
 *     FOUNDATION_DIRECTIONALITY,
 *     // ...
 *   } from "./config/tunables.js";
 *
 *   // Call rebind() at the start of a generation (or when the active entry changes)
 *   rebind();
 *
 * Notes
 * - rebind() calls resolved.refresh() internally, then updates all exported bindings.
 * - A besteffort initial rebind() is performed at module load for safety.
 * - Arrays and objects returned from the resolver are treated as readonly.
 */
// @ts-check
import {
    refresh as __refreshResolved__,
    // group getters
    TOGGLES as __TOGGLES__,
    STORY as __STORY__,
    MICROCLIMATE as __MICROCLIMATE__,
    LANDMASS_CFG as __LANDMASS__,
    COASTLINES_CFG as __COASTLINES__,
    MARGINS_CFG as __MARGINS__,
    ISLANDS_CFG as __ISLANDS__,
    CLIMATE_CFG as __CLIMATE__,
    MOUNTAINS_CFG as __MOUNTAINS__,
    VOLCANOES_CFG as __VOLCANOES__,
    BIOMES_CFG as __BIOMES__,
    FEATURES_DENSITY_CFG as __FEATURES_DENSITY__,
    CORRIDORS_CFG as __CORRIDORS__,
    PLACEMENT_CFG as __PLACEMENT__,
    DEV_LOG_CFG as __DEV__,
    FOUNDATION_CFG as __FOUNDATION__,
    STAGE_MANIFEST as __STAGE_MANIFEST__,
    // foundation helpers
    FOUNDATION_SEED as __FOUNDATION_SEED__,
    FOUNDATION_PLATES as __FOUNDATION_PLATES__,
    FOUNDATION_DYNAMICS as __FOUNDATION_DYNAMICS__,
    FOUNDATION_SURFACE as __FOUNDATION_SURFACE__,
    FOUNDATION_POLICY as __FOUNDATION_POLICY__,
    FOUNDATION_DIAGNOSTICS as __FOUNDATION_DIAGNOSTICS__,
    FOUNDATION_DIRECTIONALITY as __FOUNDATION_DIR__,
    FOUNDATION_OCEAN_SEPARATION as __FOUNDATION_OSEPARATION__,
} from "./resolved.js";
/**
 * Type definitions for configuration objects (available at runtime).
 * @typedef {import('./map_config.types.js').Landmass} Landmass
 * @typedef {import('./map_config.types.js').LandmassGeometry} LandmassGeometry
 * @typedef {import('./map_config.types.js').Coastlines} CoastlinesCfg
 * @typedef {import('./map_config.types.js').Margins} MarginsCfg
 * @typedef {import('./map_config.types.js').Islands} IslandsCfg
 * @typedef {import('./map_config.types.js').ClimateBaseline} ClimateBaseline
 * @typedef {import('./map_config.types.js').ClimateRefine} ClimateRefine
 * @typedef {import('./map_config.types.js').Mountains} MountainsCfg
 * @typedef {import('./map_config.types.js').Biomes} Biomes
 * @typedef {import('./map_config.types.js').Volcanoes} VolcanoesCfg
 * @typedef {import('./map_config.types.js').FeaturesDensity} FeaturesDensity
 * @typedef {import('./map_config.types.js').Corridors} Corridors
 * @typedef {import('./map_config.types.js').CorridorPolicy} CorridorPolicy
 * @typedef {import('./map_config.types.js').CorridorKinds} CorridorKinds
 * @typedef {import('./map_config.types.js').Placement} Placement
 * @typedef {import('./map_config.types.js').DevLogging} DevLogging
 * @typedef {import('./map_config.types.js').FoundationConfig} FoundationConfig
 * @typedef {import('./map_config.types.js').FoundationSeedConfig} FoundationSeedConfig
 * @typedef {import('./map_config.types.js').FoundationPlatesConfig} FoundationPlatesConfig
 * @typedef {import('./map_config.types.js').FoundationDynamicsConfig} FoundationDynamicsConfig
 * @typedef {import('./map_config.types.js').FoundationDirectionalityConfig} FoundationDirectionalityConfig
 * @typedef {import('./map_config.types.js').FoundationPolicyConfig} FoundationPolicyConfig
 * @typedef {import('./map_config.types.js').FoundationOceanSeparationConfig} FoundationOceanSeparationConfig
 * @typedef {import('./map_config.types.js').FoundationSurfaceConfig} FoundationSurfaceConfig
 * @typedef {import('./map_config.types.js').FoundationDiagnosticsConfig} FoundationDiagnosticsConfig
 * @typedef {import('./map_config.types.js').StageManifest} StageManifest
 * @typedef {import('./map_config.types.js').StageDescriptor} StageDescriptor
 * @typedef {import('./map_config.types.js').StageName} StageName
 */
/**
 * @typedef {Readonly<Partial<Record<string, StageDescriptor>>>} StageDescriptorMap
 * @typedef {Readonly<{
 *   order: ReadonlyArray<string>;
 *   stages: StageDescriptorMap;
 * }>} StageManifestSnapshot
 */
const EMPTY_OBJECT = /** @type {Readonly<any>} */ (Object.freeze({}));
const EMPTY_ARRAY = /** @type {ReadonlyArray<any>} */ (Object.freeze([]));
const EMPTY_STAGE_ORDER = /** @type {ReadonlyArray<string>} */ (Object.freeze([]));
const EMPTY_STAGE_MANIFEST = /** @type {StageManifestSnapshot} */ (Object.freeze({
    order: EMPTY_STAGE_ORDER,
    stages: Object.freeze(
        /** @type {Partial<Record<string, StageDescriptor>>} */ ({})
    ),
}));
const EMPTY_CLIMATE_BASELINE = /** @type {Readonly<ClimateBaseline>} */ (Object.freeze({}));
const EMPTY_CLIMATE_REFINE = /** @type {Readonly<ClimateRefine>} */ (Object.freeze({}));
/* -----------------------------------------------------------------------------
 * Exported live bindings (updated by rebind)
 * -------------------------------------------------------------------------- */
/** @type {StageManifestSnapshot} */
export let STAGE_MANIFEST = EMPTY_STAGE_MANIFEST;
/**
 * Check whether a manifest stage is enabled after dependency evaluation.
 * @param {StageName} stage
 * @returns {boolean}
 */
export function stageEnabled(stage) {
    if (!STAGE_MANIFEST || typeof STAGE_MANIFEST !== "object")
        return false;
    const stages = STAGE_MANIFEST.stages || {};
    const entry = stages && stages[stage];
    return !!(entry && entry.enabled !== false);
}
// Master toggles
export let STORY_ENABLE_HOTSPOTS = true;
export let STORY_ENABLE_RIFTS = true;
export let STORY_ENABLE_OROGENY = true;
export let STORY_ENABLE_SWATCHES = true;
export let STORY_ENABLE_PALEO = true;
export let STORY_ENABLE_CORRIDORS = true;
// Merged story+micro tunables convenience view
export let STORY_TUNABLES = Object.freeze({
    hotspot: Object.freeze({}),
    rift: Object.freeze({}),
    orogeny: Object.freeze({}),
    swatches: Object.freeze({}),
    paleo: Object.freeze({}),
    rainfall: Object.freeze({}),
    features: Object.freeze({}),
});
// Group objects (treat as readonly from callers)
/** @type {Readonly<Landmass>} */
export let LANDMASS_CFG = Object.freeze({});
/** @type {Readonly<LandmassGeometry>} */
export let LANDMASS_GEOMETRY = Object.freeze({});
/** @type {Readonly<CoastlinesCfg>} */
export let COASTLINES_CFG = Object.freeze({});
/** @type {Readonly<MarginsCfg>} */
export let MARGINS_CFG = Object.freeze({});
/** @type {Readonly<IslandsCfg>} */
export let ISLANDS_CFG = Object.freeze({});
/** @type {Readonly<any>} */
export let CLIMATE_CFG = Object.freeze({});
/**
 * Shared climate primitives exposed to layers and narrative overlays.
 *
 * climate.drivers  canonical baseline/refinement parameter blocks.
 * climate.moistureAdjustments  targeted adjustments used by layers and overlays.
 */
export let CLIMATE = Object.freeze({
    drivers: Object.freeze({
        baseline: Object.freeze({}),
        refine: Object.freeze({}),
    }),
    moistureAdjustments: Object.freeze({
        baseline: Object.freeze({}),
        refine: Object.freeze({}),
        story: Object.freeze({}),
        micro: Object.freeze({}),
    }),
});
export let CLIMATE_DRIVERS = CLIMATE.drivers;
export let MOISTURE_ADJUSTMENTS = CLIMATE.moistureAdjustments;
/** @type {Readonly<FoundationConfig>} */
export let FOUNDATION_CFG = Object.freeze({});
/**
 * Consolidated view of the world foundation configuration (seed, plates, dynamics, surface, policy).
 */
export let FOUNDATION = Object.freeze({
    core: Object.freeze({}),
    seed: Object.freeze({}),
    plates: Object.freeze({}),
    dynamics: Object.freeze({}),
    surface: Object.freeze({}),
    policy: Object.freeze({}),
    diagnostics: Object.freeze({}),
});
/** @type {Readonly<FoundationSeedConfig>} */
export let FOUNDATION_SEED = Object.freeze({});
/** @type {Readonly<FoundationPlatesConfig>} */
export let FOUNDATION_PLATES = Object.freeze({});
/** @type {Readonly<FoundationDynamicsConfig>} */
export let FOUNDATION_DYNAMICS = Object.freeze({});
/** @type {Readonly<FoundationSurfaceConfig>} */
export let FOUNDATION_SURFACE = Object.freeze({});
/** @type {Readonly<FoundationPolicyConfig>} */
export let FOUNDATION_POLICY = Object.freeze({});
/** @type {Readonly<FoundationDiagnosticsConfig>} */
export let FOUNDATION_DIAGNOSTICS = Object.freeze({});
/** @type {Readonly<FoundationDirectionalityConfig>} */
export let FOUNDATION_DIRECTIONALITY = Object.freeze({});
/** @type {Readonly<FoundationOceanSeparationConfig>} */
export let FOUNDATION_OCEAN_SEPARATION = Object.freeze({});
/** @type {Readonly<MountainsCfg>} */
export let MOUNTAINS_CFG = Object.freeze({});
/** @type {Readonly<VolcanoesCfg>} */
export let VOLCANOES_CFG = Object.freeze({});
/** @type {Readonly<Biomes>} */
export let BIOMES_CFG = Object.freeze({});
/** @type {Readonly<FeaturesDensity>} */
export let FEATURES_DENSITY_CFG = Object.freeze({});
/** @type {Readonly<Corridors>} */
export let CORRIDORS_CFG = Object.freeze({});
/** @type {Readonly<Placement>} */
export let PLACEMENT_CFG = Object.freeze({});
/** @type {Readonly<DevLogging>} */
export let DEV_LOG_CFG = Object.freeze({});
// Corridor sub-groups
/** @type {Readonly<CorridorPolicy>} */
export let CORRIDOR_POLICY = Object.freeze({});
/** @type {Readonly<CorridorKinds>} */
export let CORRIDOR_KINDS = Object.freeze({});
/* -----------------------------------------------------------------------------
 * Namespaced views (lightweight import helpers)
 * -------------------------------------------------------------------------- */
/**
 * Focused accessor bundle for climate-related tunables.
 * Uses getters so consumers always see the most recent rebind() snapshot.
 */
export const CLIMATE_TUNABLES = Object.freeze({
    get config() {
        return CLIMATE_CFG;
    },
    get snapshot() {
        return CLIMATE;
    },
    get drivers() {
        return CLIMATE_DRIVERS;
    },
    get moistureAdjustments() {
        return MOISTURE_ADJUSTMENTS;
    },
});
/**
 * Focused accessor bundle for foundation/world settings.
 */
export const FOUNDATION_TUNABLES = Object.freeze({
    get config() {
        return FOUNDATION_CFG;
    },
    get snapshot() {
        return FOUNDATION;
    },
    get seed() {
        return FOUNDATION_SEED;
    },
    get plates() {
        return FOUNDATION_PLATES;
    },
    get dynamics() {
        return FOUNDATION_DYNAMICS;
    },
    get surface() {
        return FOUNDATION_SURFACE;
    },
    get policy() {
        return FOUNDATION_POLICY;
    },
    get diagnostics() {
        return FOUNDATION_DIAGNOSTICS;
    },
    get directionality() {
        return FOUNDATION_DIRECTIONALITY;
    },
    get oceanSeparation() {
        return FOUNDATION_OCEAN_SEPARATION;
    },
});
/* -----------------------------------------------------------------------------
 * Rebind implementation
 * -------------------------------------------------------------------------- */
/**
 * Refresh the resolved snapshot then update all exported bindings.
 * Call this at the start of a generation (or whenever the active entry changes).
 */
export function rebind() {
    // 1) Resolve the current snapshot from defaults + presets + per-entry overrides
    __refreshResolved__();
    STAGE_MANIFEST = coerceStageManifest(__STAGE_MANIFEST__());
    const manifestToggleMap = deriveManifestToggleMap(STAGE_MANIFEST);
    const resolvedToggleSnapshot = /** @type {Readonly<Record<string, unknown>>} */ (safeObj(__TOGGLES__()));
    /**
     * Resolve a toggle key using manifest overrides, then runtime toggles.
     * @param {string} key
     * @param {boolean} fallback
     * @returns {boolean}
     */
    const toggleValue = (key, fallback) => {
        if (Object.prototype.hasOwnProperty.call(manifestToggleMap, key))
            return manifestToggleMap[key];
        const raw = resolvedToggleSnapshot[key];
        return typeof raw === "boolean" ? raw : fallback;
    };
    // 2) Toggles
    STORY_ENABLE_HOTSPOTS = toggleValue("STORY_ENABLE_HOTSPOTS", true);
    STORY_ENABLE_RIFTS = toggleValue("STORY_ENABLE_RIFTS", true);
    STORY_ENABLE_OROGENY = toggleValue("STORY_ENABLE_OROGENY", true);
    STORY_ENABLE_SWATCHES = toggleValue("STORY_ENABLE_SWATCHES", true);
    STORY_ENABLE_PALEO = toggleValue("STORY_ENABLE_PALEO", true);
    STORY_ENABLE_CORRIDORS = toggleValue("STORY_ENABLE_CORRIDORS", true);
    // 3) Story+Micro merged convenience
    const S = safeObj(__STORY__());
    const M = safeObj(__MICROCLIMATE__());
    STORY_TUNABLES = Object.freeze({
        hotspot: safeObj(S.hotspot),
        rift: safeObj(S.rift),
        orogeny: safeObj(S.orogeny),
        swatches: safeObj(S.swatches),
        paleo: safeObj(S.paleo),
        rainfall: safeObj(M.rainfall),
        features: safeObj(M.features),
    });
    // 4) Groups
    LANDMASS_CFG = safeObj(__LANDMASS__());
    LANDMASS_GEOMETRY = safeObj(LANDMASS_CFG.geometry);
    COASTLINES_CFG = safeObj(__COASTLINES__());
    MARGINS_CFG = safeObj(__MARGINS__());
    ISLANDS_CFG = safeObj(__ISLANDS__());
    CLIMATE_CFG = safeObj(__CLIMATE__());
    const climateBaselineRaw = safeObj(CLIMATE_CFG.baseline, EMPTY_CLIMATE_BASELINE);
    const climateRefineRaw = safeObj(CLIMATE_CFG.refine, EMPTY_CLIMATE_REFINE);
    const climateSwatches = safeObj(CLIMATE_CFG.swatches);
    const climateBaseline = Object.keys(climateBaselineRaw).length > 0 ? climateBaselineRaw : EMPTY_CLIMATE_BASELINE;
    const climateRefine = Object.keys(climateRefineRaw).length > 0 ? climateRefineRaw : EMPTY_CLIMATE_REFINE;
    MOUNTAINS_CFG = safeObj(__MOUNTAINS__());
    VOLCANOES_CFG = safeObj(__VOLCANOES__());
    BIOMES_CFG = safeObj(__BIOMES__());
    FEATURES_DENSITY_CFG = safeObj(__FEATURES_DENSITY__());
    CORRIDORS_CFG = safeObj(__CORRIDORS__());
    PLACEMENT_CFG = safeObj(__PLACEMENT__());
    DEV_LOG_CFG = safeObj(__DEV__());
    // 5) Foundation config (new unified world settings)
    FOUNDATION_CFG = safeObj(__FOUNDATION__());
    FOUNDATION_SEED = safeObj(__FOUNDATION_SEED__());
    FOUNDATION_PLATES = safeObj(__FOUNDATION_PLATES__());
    FOUNDATION_DYNAMICS = safeObj(__FOUNDATION_DYNAMICS__());
    const foundationDirResolved = safeObj(__FOUNDATION_DIR__());
    const foundationSurfaceRaw = safeObj(__FOUNDATION_SURFACE__());
    FOUNDATION_SURFACE = foundationSurfaceRaw;
    const foundationPolicyRaw = safeObj(__FOUNDATION_POLICY__());
    FOUNDATION_POLICY = foundationPolicyRaw;
    FOUNDATION_DIAGNOSTICS = safeObj(__FOUNDATION_DIAGNOSTICS__());
    const foundationDirectionalityFromDynamics = safeObj(FOUNDATION_DYNAMICS.directionality);
    FOUNDATION_DIRECTIONALITY =
        Object.keys(foundationDirectionalityFromDynamics).length > 0
            ? foundationDirectionalityFromDynamics
            : foundationDirResolved;
    const foundationSurfaceOcean = safeObj(foundationSurfaceRaw.oceanSeparation);
    const foundationPolicyOcean = safeObj(foundationPolicyRaw.oceanSeparation);
    const foundationOceanResolved = safeObj(__FOUNDATION_OSEPARATION__());
    FOUNDATION_OCEAN_SEPARATION =
        Object.keys(foundationSurfaceOcean).length > 0
            ? foundationSurfaceOcean
            : Object.keys(foundationPolicyOcean).length > 0
                ? foundationPolicyOcean
                : foundationOceanResolved;
    FOUNDATION = Object.freeze({
        core: FOUNDATION_CFG,
        seed: FOUNDATION_SEED,
        plates: FOUNDATION_PLATES,
        dynamics: FOUNDATION_DYNAMICS,
        surface: FOUNDATION_SURFACE,
        policy: FOUNDATION_POLICY,
        diagnostics: FOUNDATION_DIAGNOSTICS,
    });
    // Corridor sub-groups
    CORRIDOR_POLICY = safeObj(CORRIDORS_CFG.policy);
    CORRIDOR_KINDS = safeObj(CORRIDORS_CFG.kinds);
    // 7) Climate primitives (drivers + shared adjustments)
    const baselineDrivers = Object.freeze({
        bands: safeObj(climateBaseline.bands),
        blend: safeObj(climateBaseline.blend),
    });
    const refineDrivers = Object.freeze({
        waterGradient: safeObj(climateRefine.waterGradient),
        orographic: safeObj(climateRefine.orographic),
        riverCorridor: safeObj(climateRefine.riverCorridor),
        lowBasin: safeObj(climateRefine.lowBasin),
        pressure: safeObj(climateRefine.pressure),
    });
    const storyMoisture = Object.freeze({
        swatches: Object.keys(climateSwatches).length > 0 ? climateSwatches : safeObj(S.swatches),
        paleo: safeObj(S.paleo),
        rainfall: safeObj(M.rainfall),
        orogeny: safeObj(S.orogeny),
    });
    const baselineMoisture = Object.freeze({
        orographic: safeObj(climateBaseline.orographic),
        coastal: safeObj(climateBaseline.coastal),
        noise: safeObj(climateBaseline.noise),
        bands: baselineDrivers.bands,
        blend: baselineDrivers.blend,
    });
    const refineMoisture = Object.freeze({
        waterGradient: refineDrivers.waterGradient,
        orographic: refineDrivers.orographic,
        riverCorridor: refineDrivers.riverCorridor,
        lowBasin: refineDrivers.lowBasin,
        pressure: refineDrivers.pressure,
    });
    const microMoisture = Object.freeze({
        rainfall: safeObj(M.rainfall),
        features: safeObj(M.features),
    });
    CLIMATE = Object.freeze({
        drivers: Object.freeze({
            baseline: Object.freeze({
                ...baselineDrivers,
                orographic: baselineMoisture.orographic,
                coastal: baselineMoisture.coastal,
                noise: baselineMoisture.noise,
            }),
            refine: Object.freeze({
                ...refineDrivers,
            }),
        }),
        moistureAdjustments: Object.freeze({
            baseline: baselineMoisture,
            refine: refineMoisture,
            story: storyMoisture,
            micro: microMoisture,
        }),
    });
    CLIMATE_DRIVERS = CLIMATE.drivers;
    MOISTURE_ADJUSTMENTS = CLIMATE.moistureAdjustments;
}
/* -----------------------------------------------------------------------------
 * Helpers
 * -------------------------------------------------------------------------- */
/**
 * Normalize a resolver-provided manifest into a frozen snapshot with safe defaults.
 * @param {Readonly<StageManifest> | StageManifestSnapshot | null | undefined} manifest
 * @returns {StageManifestSnapshot}
 */
function coerceStageManifest(manifest) {
    if (!manifest || typeof manifest !== "object")
        return EMPTY_STAGE_MANIFEST;
    const rawOrder = Array.isArray(manifest.order) ? manifest.order : EMPTY_ARRAY;
    /** @type {Array<string>} */
    const order = [];
    for (const entry of rawOrder) {
        if (typeof entry === "string")
            order.push(entry);
    }
    const rawStages = manifest.stages && typeof manifest.stages === "object"
        ? /** @type {Record<string, any>} */ (manifest.stages)
        : {};
    /** @type {Partial<Record<string, StageDescriptor>>} */
    const normalizedStages = {};
    for (const name of Object.keys(rawStages)) {
        const descriptor = rawStages[name];
        if (!descriptor || typeof descriptor !== "object")
            continue;
        normalizedStages[name] = /** @type {StageDescriptor} */ (Object.isFrozen(descriptor)
            ? descriptor
            : Object.freeze({ ...descriptor }));
    }
    if (!order.length && !Object.keys(normalizedStages).length) {
        return EMPTY_STAGE_MANIFEST;
    }
    return /** @type {StageManifestSnapshot} */ (Object.freeze({
        order: /** @type {ReadonlyArray<string>} */ (Object.freeze(order)),
        stages: Object.freeze(normalizedStages),
    }));
}
/**
 * Build a lookup of legacy toggle keys derived from the stage manifest.
 * @param {StageManifestSnapshot} manifest
 * @returns {Record<string, boolean>}
 */
function deriveManifestToggleMap(manifest) {
    /** @type {Record<string, boolean>} */
    const out = {};
    if (!manifest || typeof manifest !== "object")
        return out;
    const stages = manifest?.stages
        ? /** @type {Partial<Record<string, StageDescriptor>>} */ (manifest.stages)
        : {};
    const order = manifest?.order && manifest.order.length > 0
        ? Array.from(manifest.order)
        : Object.keys(stages);
    for (const name of order) {
        const stage = stages && stages[name];
        if (!stage)
            continue;
        const toggles = Array.isArray(stage.legacyToggles) ? stage.legacyToggles : [];
        for (const key of toggles) {
            if (typeof key !== "string")
                continue;
            out[key] = stage.enabled !== false;
        }
    }
    for (const name of Object.keys(stages)) {
        const stage = stages[name];
        if (!stage)
            continue;
        const toggles = Array.isArray(stage.legacyToggles) ? stage.legacyToggles : [];
        for (const key of toggles) {
            if (typeof key !== "string" || Object.prototype.hasOwnProperty.call(out, key))
                continue;
            out[key] = stage.enabled !== false;
        }
    }
    return out;
}
/**
 * Ensure we always return a frozen object of the expected shape for TS consumers.
 * Falls back to an empty frozen object when input is null/undefined or not an object.
 * @template {object | ReadonlyArray<any>} T
 * @param {T | null | undefined} value
 * @param {Readonly<T>} [fallback]
 * @returns {Readonly<T>}
 */
function safeObj(value, fallback) {
    if (!value || typeof value !== "object") {
        if (fallback)
            return fallback;
        return /** @type {Readonly<T>} */ (EMPTY_OBJECT);
    }
    if (Object.isFrozen(value))
        return /** @type {Readonly<T>} */ (value);
    if (Array.isArray(value)) {
        const clone = value.slice();
        return /** @type {Readonly<T>} */ (/** @type {unknown} */ (Object.freeze(clone)));
    }
    return /** @type {Readonly<T>} */ (Object.freeze({ ...value }));
}
/* -----------------------------------------------------------------------------
 * Module-load bootstrap
 * -------------------------------------------------------------------------- */
// Perform an initial bind so imports have sane values even if callers forget to rebind().
// Callers should still rebind() at the start of each GenerateMap to ensure the
// snapshot reflects the active entrys presets and overrides.
try {
    rebind();
}
catch {
    // Keep imports resilient even if resolution fails very early in a cold VM.
    // Bindings already hold conservative defaults above.
}
export default {
    rebind,
    // expose current group snapshots (optional convenience mirror)
    get LANDMASS() {
        return LANDMASS_CFG;
    },
    get CORRIDORS() {
        return CORRIDORS_CFG;
    },
    get FOUNDATION() {
        return FOUNDATION;
    },
    get CLIMATE() {
        return CLIMATE;
    },
};
</file>

<file path="mod/maps/core/adapters.js">
/**
 * Engine Adapter  CivEngineAdapter
 *
 * Purpose:
 * - CivEngineAdapter: production adapter using Civ7 engine APIs (GameplayMap, TerrainBuilder, etc.)
 *
 * All passes should interact with the map ONLY via this adapter, never directly.
 */

import { idx } from "./types.js";

/**
 * CivEngineAdapter  production implementation using Civ7 engine APIs
 *
 * Wraps all GameplayMap, TerrainBuilder, FeatureTypes, and other engine calls.
 * This is the adapter used during actual map generation in the game.
 *
 * @implements {import('./types.js').EngineAdapter}
 */
export class CivEngineAdapter {
  /**
   * @param {number} width
   * @param {number} height
   */
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  // ==================== TERRAIN READS ====================

  /**
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isWater(x, y) {
    return GameplayMap.isWater(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {boolean}
   */
  isMountain(x, y) {
    if (typeof GameplayMap.isMountain === "function") {
      return GameplayMap.isMountain(x, y);
    }
    // Fallback: check elevation >= 500
    return GameplayMap.getElevation(x, y) >= 500;
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} radius
   * @returns {boolean}
   */
  isAdjacentToRivers(x, y, radius) {
    return GameplayMap.isAdjacentToRivers(x, y, radius);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getElevation(x, y) {
    return GameplayMap.getElevation(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getTerrainType(x, y) {
    return GameplayMap.getTerrainType(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getRainfall(x, y) {
    return GameplayMap.getRainfall(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getTemperature(x, y) {
    return GameplayMap.getTemperature(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getLatitude(x, y) {
    return GameplayMap.getPlotLatitude(x, y);
  }

  // ==================== TERRAIN WRITES ====================

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} terrainTypeId
   */
  setTerrainType(x, y, terrainTypeId) {
    TerrainBuilder.setTerrainType(x, y, terrainTypeId);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} rainfall
   */
  setRainfall(x, y, rainfall) {
    TerrainBuilder.setRainfall(x, y, rainfall);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} elevation
   */
  setElevation(x, y, elevation) {
    // Note: Engine may not expose direct elevation setter; use with caution
    if (typeof TerrainBuilder.setElevation === "function") {
      TerrainBuilder.setElevation(x, y, elevation);
    }
  }

  // ==================== FEATURE READS/WRITES ====================

  /**
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getFeatureType(x, y) {
    return GameplayMap.getFeatureType(x, y);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {{Feature: number, Direction: number, Elevation: number}} featureData
   */
  setFeatureType(x, y, featureData) {
    TerrainBuilder.setFeatureType(x, y, featureData);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @param {number} featureTypeId
   * @returns {boolean}
   */
  canHaveFeature(x, y, featureTypeId) {
    return TerrainBuilder.canHaveFeature(x, y, featureTypeId);
  }

  // ==================== RANDOM NUMBER GENERATION ====================

  /**
   * @param {number} max
   * @param {string} label
   * @returns {number}
   */
  getRandomNumber(max, label) {
    return TerrainBuilder.getRandomNumber(max, label);
  }

  // ==================== UTILITIES ====================

  validateAndFixTerrain() {
    TerrainBuilder.validateAndFixTerrain();
  }

  recalculateAreas() {
    AreaBuilder.recalculateAreas();
  }

  /**
   * @param {number} fractalId
   * @param {number} width
   * @param {number} height
   * @param {number} grain
   * @param {number} flags
   */
  createFractal(fractalId, width, height, grain, flags) {
    FractalBuilder.create(fractalId, width, height, grain, flags);
  }

  /**
   * @param {number} fractalId
   * @param {number} x
   * @param {number} y
   * @returns {number}
   */
  getFractalHeight(fractalId, x, y) {
    return FractalBuilder.getHeight(fractalId, x, y);
  }

  // ==================== BIOME/CONTINENTS ====================

  stampContinents() {
    TerrainBuilder.stampContinents();
  }

  buildElevation() {
    TerrainBuilder.buildElevation();
  }

  /**
   * @param {number} minLength
   * @param {number} maxLength
   * @param {number} navigableTerrain
   */
  modelRivers(minLength, maxLength, navigableTerrain) {
    TerrainBuilder.modelRivers(minLength, maxLength, navigableTerrain);
  }

  defineNamedRivers() {
    TerrainBuilder.defineNamedRivers();
  }

  storeWaterData() {
    TerrainBuilder.storeWaterData();
  }
}
</file>

<file path="mod/maps/core/plot_tags.js">
import * as globals from "/base-standard/maps/map-globals.js";

/**
 * Maintain plot tagging (land/water + east/west) independently of Civ7 updates.
 * The base-standard map-utilities no longer ships addPlotTags, so we keep a stable copy here.
 *
 * @param {number} iHeight
 * @param {number} iWidth
 * @param {number} iEastContinentLeftCol - column separating west/east landmasses
 */
export function addPlotTags(iHeight, iWidth, iEastContinentLeftCol) {
  for (let iY = 0; iY < iHeight; iY++) {
    for (let iX = 0; iX < iWidth; iX++) {
      TerrainBuilder.setPlotTag(iX, iY, PlotTags.PLOT_TAG_NONE);
      const terrain = GameplayMap.getTerrainType(iX, iY);
      const isLand = terrain != globals.g_OceanTerrain && terrain != globals.g_CoastTerrain;
      if (isLand) {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_LANDMASS);
        if (iX >= iEastContinentLeftCol) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_LANDMASS);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_LANDMASS);
        }
      } else {
        TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WATER);
        if (iX >= iEastContinentLeftCol - 1) {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_EAST_WATER);
        } else {
          TerrainBuilder.addPlotTag(iX, iY, PlotTags.PLOT_TAG_WEST_WATER);
        }
      }
    }
  }
}
</file>

<file path="mod/maps/core/types.js">
/**
 * Core Types  MapContext, EngineAdapter, and data contracts
 *
 * Purpose:
 * - Define the seam between pure logic and engine coupling
 * - MapContext holds all data dependencies for passes (fields, worldModel, rng, config)
 * - EngineAdapter abstracts read/write operations (enables testing, replay, diffing)
 *
 * Invariants:
 * - Passes should ONLY access engine APIs via the adapter
 * - RNG calls should go through ctx.rng() for deterministic replay
 * - Context is immutable reference (but fields are mutable for performance)
 */

/**
 * @typedef {Object} MapDimensions
 * @property {number} width - Map width in tiles
 * @property {number} height - Map height in tiles
 */

/**
 * @typedef {Object} MapFields
 * @property {Uint8Array|null} rainfall - Rainfall per tile (0..200)
 * @property {Int16Array|null} elevation - Elevation per tile
 * @property {Uint8Array|null} temperature - Temperature per tile (0..255)
 * @property {Uint8Array|null} biomeId - Biome type ID per tile
 * @property {Int16Array|null} featureType - Feature type ID per tile
 * @property {Uint8Array|null} terrainType - Terrain type ID per tile
 */

/**
 * Primary morphology staging buffer.
 *
 * These arrays capture the heightfield (terrain + elevation) before it is
 * flushed back to the engine so plates/coastlines/mountains operate on a
 * consistent in-memory surface.
 *
 * @typedef {Object} HeightfieldBuffer
 * @property {Int16Array} elevation - Elevation values staged for morphology
 * @property {Uint8Array} terrain - Terrain type IDs staged for morphology
 * @property {Uint8Array} landMask - Binary land/water mask derived from the heightfield (1 = land)
 */

/**
 * Staged climate buffer for rainfall and humidity fields. Mirrors the heightfield
 * staging approach so climate passes can operate without mutating GameplayMap
 * directly.
 *
 * @typedef {Object} ClimateFieldBuffer
 * @property {Uint8Array} rainfall - Rainfall values staged for climate passes (0..200)
 * @property {Uint8Array} humidity - Relative humidity or derived moisture metrics (0..255)
 */

/**
 * Collection of reusable buffers shared across generation stages.
 * Additional staging arrays (shore masks, coast metrics, etc.) can be added in
 * later phases.
 *
 * @typedef {Object} MapBuffers
 * @property {HeightfieldBuffer} heightfield - Canonical heightfield staging buffers
 * @property {ClimateFieldBuffer} climate - Staged rainfall/humidity buffers for climate + narrative
 * @property {Map<string, Uint8Array>} scratchMasks - Named scratch masks reused across stages
 */

/**
 * Immutable snapshot describing a sparse narrative overlay.
 * Overlays capture derived storytelling metadata (margins, corridors, etc.)
 * produced during generation so downstream stages can consume consistent
 * products without rerunning expensive passes.
 *
 * @typedef {Object} StoryOverlaySnapshot
 * @property {string} key - Overlay registry key (e.g., "margins")
 * @property {string} kind - Overlay kind identifier
 * @property {number} version - Schema version for the overlay payload
 * @property {number} width - Map width in tiles
 * @property {number} height - Map height in tiles
 * @property {ReadonlyArray<string>} [active] - Active tile identifiers ("x,y" form) when applicable
 * @property {ReadonlyArray<string>} [passive] - Passive tile identifiers ("x,y" form) when applicable
 * @property {Readonly<Record<string, any>>} summary - Overlay summary metadata (counts, thresholds, etc.)
 */

/**
 * Registry of immutable story overlays published during generation.
 * Keys map to overlay snapshots (see StoryOverlaySnapshot).
 *
 * @typedef {Map<string, StoryOverlaySnapshot>} StoryOverlayRegistry
 */

/**
 * Snapshot of the configuration objects that informed the current foundation run.
 * Mirrors come from the resolved tunables so downstream consumers can reason
 * about the knobs that produced the published tensors.
 *
 * @typedef {Object} FoundationConfigSnapshot
 * @property {Readonly<any>} seed
 * @property {Readonly<any>} plates
 * @property {Readonly<any>} dynamics
 * @property {Readonly<any>} surface
 * @property {Readonly<any>} policy
 * @property {Readonly<any>} diagnostics
 */

/**
 * Plate-centric tensors emitted by the WorldModel. All arrays share the map
 * dimensions (width  height) and are treated as read-only snapshots.
 *
 * @typedef {Object} FoundationPlateFields
 * @property {Int16Array} id
 * @property {Uint8Array} boundaryCloseness
 * @property {Uint8Array} boundaryType
 * @property {Uint8Array} tectonicStress
 * @property {Uint8Array} upliftPotential
 * @property {Uint8Array} riftPotential
 * @property {Uint8Array} shieldStability
 * @property {Int8Array} movementU
 * @property {Int8Array} movementV
 * @property {Int8Array} rotation
 */

/**
 * Atmospheric and oceanic tensors emitted by the WorldModel.
 *
 * @typedef {Object} FoundationDynamicsFields
 * @property {Int8Array} windU
 * @property {Int8Array} windV
 * @property {Int8Array} currentU
 * @property {Int8Array} currentV
 * @property {Uint8Array} pressure
 */

/**
 * Diagnostics payload accompanying the foundation tensors.
 *
 * @typedef {Object} FoundationDiagnosticsFields
 * @property {any|null} boundaryTree
 */

/**
 * Immutable data product emitted by the foundation stage.
 * Downstream stages rely on this object instead of touching WorldModel directly.
 *
 * @typedef {Object} FoundationContext
 * @property {{ width: number, height: number, size: number }} dimensions
 * @property {Readonly<any>|null} plateSeed
 * @property {FoundationPlateFields} plates
 * @property {FoundationDynamicsFields} dynamics
 * @property {FoundationDiagnosticsFields} diagnostics
 * @property {FoundationConfigSnapshot} config
 */

const EMPTY_FROZEN_OBJECT = Object.freeze({});

/**
 * @typedef {Object} RNGState
 * @property {Map<string, number>} callCounts - Tracks RNG calls per label for determinism
 * @property {number|null} seed - Optional seed for replay
 */

/**
 * @typedef {Object} GenerationMetrics
 * @property {Map<string, number>} timings - Pass execution times (ms)
 * @property {Map<string, any>} histograms - Field histograms for validation
 * @property {Array<string>} warnings - Validation warnings
 */

/**
 * MapContext  unified data container passed through the generation pipeline
 *
 * All passes receive a MapContext and may:
 * - Read fields (rainfall, elevation, worldModel data)
 * - Write fields (via adapter)
 * - Call rng() for deterministic randomness
 * - Log metrics
 *
 * @typedef {Object} MapContext
 * @property {MapDimensions} dimensions - Map size
 * @property {MapFields} fields - Typed arrays for terrain data
 * @property {import('../world/model.js').WorldModel|null} worldModel - Physics/tectonics model (attached after init)
 * @property {RNGState} rng - RNG state tracker
 * @property {any} config - Resolved configuration object
 * @property {GenerationMetrics} metrics - Performance and validation metrics
 * @property {EngineAdapter} adapter - Abstraction layer for engine operations
 * @property {FoundationContext|null} foundation - Shared world foundations (immutable data product)
 * @property {MapBuffers} buffers - Shared staging buffers
 * @property {StoryOverlayRegistry} overlays - Published story overlays keyed by overlay id
 */

/**
 * EngineAdapter  abstraction for all engine/surface interactions
 *
 * All terrain/feature reads and writes MUST go through this interface.
 * Two implementations:
 * - CivEngineAdapter: uses GameplayMap, TerrainBuilder, etc. (production)
 *
 * @interface
 * @typedef {Object} EngineAdapter
 *
 * === TERRAIN READS ===
 * @property {(x: number, y: number) => boolean} isWater - Check if tile is water
 * @property {(x: number, y: number) => boolean} isMountain - Check if tile is mountain
 * @property {(x: number, y: number, radius: number) => boolean} isAdjacentToRivers - Check if tile is near rivers
 * @property {(x: number, y: number) => number} getElevation - Get tile elevation
 * @property {(x: number, y: number) => number} getTerrainType - Get terrain type ID
 * @property {(x: number, y: number) => number} getRainfall - Get rainfall (0..200)
 * @property {(x: number, y: number) => number} getTemperature - Get temperature
 * @property {(x: number, y: number) => number} getLatitude - Get latitude in degrees
 *
 * === TERRAIN WRITES ===
 * @property {(x: number, y: number, terrainTypeId: number) => void} setTerrainType - Set terrain type
 * @property {(x: number, y: number, rainfall: number) => void} setRainfall - Set rainfall (0..200)
 * @property {(x: number, y: number, elevation: number) => void} setElevation - Set elevation
 *
 * === FEATURE READS/WRITES ===
 * @property {(x: number, y: number) => number} getFeatureType - Get feature type ID
 * @property {(x: number, y: number, featureData: {Feature: number, Direction: number, Elevation: number}) => void} setFeatureType - Set feature
 * @property {(x: number, y: number, featureTypeId: number) => boolean} canHaveFeature - Validate feature placement
 *
 * === RANDOM NUMBER GENERATION ===
 * @property {(max: number, label: string) => number} getRandomNumber - Seeded RNG (0..max-1)
 *
 * === UTILITIES ===
 * @property {() => void} validateAndFixTerrain - Run engine validation pass
 * @property {() => void} recalculateAreas - Rebuild continent/area data
 * @property {(fractalId: number, width: number, height: number, grain: number, flags: number) => void} createFractal - Initialize fractal
 * @property {(fractalId: number, x: number, y: number) => number} getFractalHeight - Sample fractal value
 */

/**
 * Create a new MapContext with default/empty fields.
 *
 * @param {MapDimensions} dimensions
 * @param {EngineAdapter} adapter
 * @param {any} config
 * @returns {MapContext}
 */
export function createMapContext(dimensions, adapter, config) {
  const { width, height } = dimensions;
  const size = width * height;

  const heightfield = {
    elevation: new Int16Array(size),
    terrain: new Uint8Array(size),
    landMask: new Uint8Array(size),
  };

  const rainfall = new Uint8Array(size);
  const climate = {
    rainfall,
    humidity: new Uint8Array(size),
  };

  return {
    dimensions,
    fields: {
      rainfall,
      elevation: new Int16Array(size),
      temperature: new Uint8Array(size),
      biomeId: new Uint8Array(size),
      featureType: new Int16Array(size),
      terrainType: new Uint8Array(size),
    },
    worldModel: null, // Initialized later if enabled
    rng: {
      callCounts: new Map(),
      seed: null,
    },
    config,
    metrics: {
      timings: new Map(),
      histograms: new Map(),
      warnings: [],
    },
    adapter,
    foundation: null,
    buffers: {
      heightfield,
      climate,
      scratchMasks: new Map(),
    },
    overlays: new Map(),
  };
}

/**
 * Deterministic RNG helper for MapContext.
 * Tracks call counts per label for debugging and replay.
 *
 * @param {MapContext} ctx
 * @param {string} label - Unique label for this RNG call site
 * @param {number} max - Return value in [0, max)
 * @returns {number}
 */
export function ctxRandom(ctx, label, max) {
  const count = ctx.rng.callCounts.get(label) || 0;
  ctx.rng.callCounts.set(label, count + 1);

  // Delegate to adapter (which may use seed or engine RNG)
  return ctx.adapter.getRandomNumber(max, `${label}_${count}`);
}

/**
 * Utility: Get linear index from (x, y) coordinates.
 *
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @returns {number}
 */
export function idx(x, y, width) {
  return y * width + x;
}

/**
 * Utility: Check if coordinates are in bounds.
 *
 * @param {number} x
 * @param {number} y
 * @param {MapDimensions} dimensions
 * @returns {boolean}
 */
export function inBounds(x, y, dimensions) {
  return x >= 0 && x < dimensions.width && y >= 0 && y < dimensions.height;
}

/**
 * Write staged heightfield values (terrain/elevation/landMask) and mirror the
 * change to the engine adapter when provided.
 *
 * @param {MapContext} ctx
 * @param {number} x
 * @param {number} y
 * @param {{ terrain?: number, elevation?: number, isLand?: boolean }} options
 */
export function writeHeightfield(ctx, x, y, options) {
  if (!ctx || !options) return;
  const { width } = ctx.dimensions;
  const idxValue = y * width + x;
  const hf = ctx.buffers?.heightfield;

  if (hf) {
    if (typeof options.terrain === "number") {
      hf.terrain[idxValue] = options.terrain & 0xff;
    }
    if (typeof options.elevation === "number") {
      hf.elevation[idxValue] = options.elevation | 0;
    }
    if (typeof options.isLand === "boolean") {
      hf.landMask[idxValue] = options.isLand ? 1 : 0;
    }
  }

  if (typeof options.terrain === "number" && ctx.adapter?.setTerrainType) {
    ctx.adapter.setTerrainType(x, y, options.terrain);
  }

  if (typeof options.elevation === "number" && ctx.adapter?.setElevation) {
    ctx.adapter.setElevation(x, y, options.elevation);
  }
}

/**
 * Write staged climate values (rainfall/humidity) and mirror the
 * change to the engine adapter when provided.
 *
 * @param {MapContext} ctx
 * @param {number} x
 * @param {number} y
 * @param {{ rainfall?: number, humidity?: number }} options
 */
export function writeClimateField(ctx, x, y, options) {
  if (!ctx || !options) return;
  const { width } = ctx.dimensions;
  const idxValue = y * width + x;
  const climate = ctx.buffers?.climate;

  if (climate) {
    if (typeof options.rainfall === "number") {
      const rf = Math.max(0, Math.min(200, options.rainfall)) | 0;
      climate.rainfall[idxValue] = rf & 0xff;
      if (ctx.fields?.rainfall) {
        ctx.fields.rainfall[idxValue] = rf & 0xff;
      }
    }
    if (typeof options.humidity === "number") {
      const hum = Math.max(0, Math.min(255, options.humidity)) | 0;
      climate.humidity[idxValue] = hum & 0xff;
    }
  }

  if (typeof options.rainfall === "number" && ctx.adapter?.setRainfall) {
    ctx.adapter.setRainfall(x, y, Math.max(0, Math.min(200, options.rainfall)) | 0);
  }
}

function freezeConfigSnapshot(value) {
  if (!value || typeof value !== "object") return EMPTY_FROZEN_OBJECT;
  try {
    return Object.freeze(value);
  } catch {
    return value;
  }
}

function ensureTensor(name, tensor, size) {
  if (!tensor || typeof tensor.length !== "number") {
    throw new Error(`[FoundationContext] Missing ${name} tensor.`);
  }
  if (tensor.length !== size) {
    throw new Error(
      `[FoundationContext] ${name} tensor length mismatch (expected ${size}, received ${tensor.length}).`
    );
  }
  return tensor;
}

/**
 * Create an immutable FoundationContext snapshot from the active WorldModel.
 *
 * @param {import('../world/model.js').WorldModel} worldModel
 * @param {{ dimensions: MapDimensions, config?: Partial<FoundationConfigSnapshot> }} options
 * @returns {FoundationContext}
 */
export function createFoundationContext(worldModel, options) {
  if (!worldModel || typeof worldModel.isEnabled !== "function" || !worldModel.isEnabled()) {
    throw new Error("[FoundationContext] WorldModel is not initialized or disabled.");
  }
  if (!options || !options.dimensions) {
    throw new Error("[FoundationContext] Map dimensions are required to build the context.");
  }
  const width = options.dimensions.width | 0;
  const height = options.dimensions.height | 0;
  const size = Math.max(0, width * height) | 0;
  if (size <= 0) {
    throw new Error("[FoundationContext] Invalid map dimensions.");
  }

  const plateId = ensureTensor("plateId", worldModel.plateId, size);
  const boundaryCloseness = ensureTensor("boundaryCloseness", worldModel.boundaryCloseness, size);
  const boundaryType = ensureTensor("boundaryType", worldModel.boundaryType, size);
  const tectonicStress = ensureTensor("tectonicStress", worldModel.tectonicStress, size);
  const upliftPotential = ensureTensor("upliftPotential", worldModel.upliftPotential, size);
  const riftPotential = ensureTensor("riftPotential", worldModel.riftPotential, size);
  const shieldStability = ensureTensor("shieldStability", worldModel.shieldStability, size);
  const plateMovementU = ensureTensor("plateMovementU", worldModel.plateMovementU, size);
  const plateMovementV = ensureTensor("plateMovementV", worldModel.plateMovementV, size);
  const plateRotation = ensureTensor("plateRotation", worldModel.plateRotation, size);
  const windU = ensureTensor("windU", worldModel.windU, size);
  const windV = ensureTensor("windV", worldModel.windV, size);
  const currentU = ensureTensor("currentU", worldModel.currentU, size);
  const currentV = ensureTensor("currentV", worldModel.currentV, size);
  const pressure = ensureTensor("pressure", worldModel.pressure, size);

  const configInput = options.config || {};
  const configSnapshot = {
    seed: freezeConfigSnapshot(configInput.seed),
    plates: freezeConfigSnapshot(configInput.plates),
    dynamics: freezeConfigSnapshot(configInput.dynamics),
    surface: freezeConfigSnapshot(configInput.surface),
    policy: freezeConfigSnapshot(configInput.policy),
    diagnostics: freezeConfigSnapshot(configInput.diagnostics),
  };

  return Object.freeze({
    dimensions: Object.freeze({ width, height, size }),
    plateSeed: worldModel.plateSeed || null,
    plates: Object.freeze({
      id: plateId,
      boundaryCloseness,
      boundaryType,
      tectonicStress,
      upliftPotential,
      riftPotential,
      shieldStability,
      movementU: plateMovementU,
      movementV: plateMovementV,
      rotation: plateRotation,
    }),
    dynamics: Object.freeze({ windU, windV, currentU, currentV, pressure }),
    diagnostics: Object.freeze({ boundaryTree: worldModel.boundaryTree || null }),
    config: Object.freeze(configSnapshot),
  });
}

/**
 * Check whether the provided MapContext already carries a FoundationContext.
 *
 * @param {MapContext} ctx
 * @returns {ctx is MapContext & { foundation: FoundationContext }}
 */
export function hasFoundationContext(ctx) {
  return !!(ctx && ctx.foundation && typeof ctx.foundation === "object");
}

/**
 * Assert that a FoundationContext exists on the provided MapContext.
 * Throws when absent so stages fail loudly instead of running with stale data.
 *
 * @param {MapContext} ctx
 * @param {string} [stage]
 * @returns {FoundationContext}
 */
export function assertFoundationContext(ctx, stage) {
  if (hasFoundationContext(ctx)) {
    return /** @type {FoundationContext} */ (ctx.foundation);
  }
  const message = stage
    ? `[StageManifest] Stage "${stage}" requires FoundationContext but it is unavailable.`
    : "[StageManifest] Required FoundationContext is unavailable.";
  console.error(message);
  throw new Error(message);
}

/**
 * Convenience helper to fill an entire buffer with a value (used for resets).
 *
 * @param {TypedArray} buffer
 * @param {number} value
 */
export function fillBuffer(buffer, value) {
  if (!buffer || typeof buffer.fill !== "function") return;
  buffer.fill(value);
}

/**
 * Synchronize the staged heightfield buffers from the current engine surface.
 * Useful after invoking legacy generators (lakes, rivers) that mutate the
 * gameplay surface directly.
 *
 * @param {MapContext} ctx
 */
export function syncHeightfield(ctx) {
  if (!ctx || !ctx.adapter) return;
  const hf = ctx.buffers?.heightfield;
  if (!hf) return;
  const { width, height } = ctx.dimensions;
  const hasElevation = typeof ctx.adapter.getElevation === "function";
  const hasWaterCheck = typeof ctx.adapter.isWater === "function";
  const hasTerrainGetter = typeof ctx.adapter.getTerrainType === "function";

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idxValue = y * width + x;
      if (hasTerrainGetter) {
        const terrain = ctx.adapter.getTerrainType(x, y);
        if (terrain != null) {
          hf.terrain[idxValue] = terrain & 0xff;
        }
      }
      if (hasElevation) {
        const elevation = ctx.adapter.getElevation(x, y);
        if (Number.isFinite(elevation)) {
          hf.elevation[idxValue] = elevation | 0;
        }
      }
      if (hasWaterCheck) {
        hf.landMask[idxValue] = ctx.adapter.isWater(x, y) ? 0 : 1;
      }
    }
  }
}

/**
 * Synchronize the staged climate buffers from the current engine surface.
 * Useful after invoking legacy generators (rivers, swatches) that mutate the
 * gameplay surface directly.
 *
 * @param {MapContext} ctx
 */
export function syncClimateField(ctx) {
  if (!ctx || !ctx.adapter) return;
  const climate = ctx.buffers?.climate;
  if (!climate) return;
  const { width, height } = ctx.dimensions;
  const hasRainfall = typeof ctx.adapter.getRainfall === "function";

  if (!hasRainfall) return;

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idxValue = y * width + x;
      const rf = ctx.adapter.getRainfall(x, y);
      if (Number.isFinite(rf)) {
        const rfClamped = Math.max(0, Math.min(200, rf)) | 0;
        climate.rainfall[idxValue] = rfClamped & 0xff;
        if (ctx.fields?.rainfall) {
          ctx.fields.rainfall[idxValue] = rfClamped & 0xff;
        }
      }
    }
  }
}

export default {
  createMapContext,
  ctxRandom,
  idx,
  inBounds,
  writeHeightfield,
  writeClimateField,
  createFoundationContext,
  hasFoundationContext,
  assertFoundationContext,
  fillBuffer,
  syncHeightfield,
  syncClimateField,
};
</file>

<file path="mod/maps/core/utils.js">
// @ts-nocheck
/**
 * Core utilities for the Epic Diverse Huge map generator.
 * These helpers centralize common operations so layers can share consistent logic.
 *
 * Exports:
 *  - clamp(v, min, max)
 *  - inBounds(x, y)
 *  - storyKey(x, y)
 *  - isAdjacentToLand(x, y, radius)
 *  - getFeatureTypeIndex(name)
 */
/**
 * Clamp a number between min and max (inclusive).
 * @param {number} v
 * @param {number} [min=0]
 * @param {number} [max=200]
 * @returns {number}
 */
export function clamp(v, min = 0, max = 200) {
    if (v < min)
        return min;
    if (v > max)
        return max;
    return v;
}
/**
 * Check if coordinates are within the current map bounds.
 * @param {number} x
 * @param {number} y
 * @returns {boolean}
 */
export function inBounds(x, y) {
    // GameplayMap is provided by the game engine at runtime.
    const width = GameplayMap && typeof GameplayMap.getGridWidth === "function" ? GameplayMap.getGridWidth() : 0;
    const height = GameplayMap && typeof GameplayMap.getGridHeight === "function" ? GameplayMap.getGridHeight() : 0;
    return x >= 0 && x < width && y >= 0 && y < height;
}
/**
 * Produce a stable string key for a tile coordinate.
 * @param {number} x
 * @param {number} y
 * @returns {string}
 */
export function storyKey(x, y) {
    return `${x},${y}`;
}
/**
 * Determine whether any tile within a Chebyshev radius of (x, y) is land.
 * Radius of 1 checks 8-neighborhood; larger radii expand the search square.
 * @param {number} x
 * @param {number} y
 * @param {number} [radius=1]
 * @returns {boolean}
 */
export function isAdjacentToLand(x, y, radius = 1) {
    if (radius <= 0)
        return false;
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            if (dx === 0 && dy === 0)
                continue;
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                if (!GameplayMap.isWater(nx, ny)) {
                    return true;
                }
            }
        }
    }
    return false;
}
/**
 * Resolve a feature type index from its ruleset name using engine lookups.
 * Returns -1 if the feature is not found (caller should then skip placement).
 * @param {string} name
 * @returns {number}
 */
export function getFeatureTypeIndex(name) {
    if (!name || !GameInfo || !GameInfo.Features || typeof GameInfo.Features.lookup !== "function") {
        return -1;
    }
    const def = GameInfo.Features.lookup(name);
    if (def && typeof def.$index === "number") {
        return def.$index;
    }
    return -1;
}
</file>

<file path="mod/maps/layers/biomes.js">
// @ts-nocheck
/**
 * Biomes Layer  designateEnhancedBiomes
 *
 * Purpose
 * - Start with base-standard biome assignment, then apply light, climate-aware
 *   nudges for playability and realism.
 * - Includes a narrow preference along rift shoulders to suggest fertile
 *   corridor edges without overriding vanilla eligibility rules.
 *
 * Behavior
 * - Base biomes: delegated to engine (vanilla-compatible).
 * - Tundra restraint: only at very high latitude or extreme elevation when dry.
 * - Tropical encouragement: wet, warm coasts near the equator.
 * - River-valley playability: temperate/warm river-adjacent tiles trend grassland.
 * - Rift shoulder bias: temperate/warm shoulder tiles prefer grassland when moist.
 *
 * Invariants
 * - Does not bypass engine constraints beyond setting biome types.
 * - Keeps adjustments modest; does not interfere with feature validation rules.
 * - O(width  height) with simple local checks.
 */
import { designateBiomes as baseDesignateBiomes } from "/base-standard/maps/feature-biome-generator.js";
import * as globals from "/base-standard/maps/map-globals.js";
import { StoryTags } from "../story/tags.js";
import { STORY_ENABLE_RIFTS, BIOMES_CFG, CORRIDOR_POLICY, } from "../bootstrap/tunables.js";
/**
 * Enhanced biome designation with gentle, readable nudges.
 * @param {number} iWidth
 * @param {number} iHeight
 */
export function designateEnhancedBiomes(iWidth, iHeight) {
    console.log("Creating enhanced biome diversity (climate-aware)...");
    // Start with vanilla-consistent biomes
    baseDesignateBiomes(iWidth, iHeight);
    // Apply small, climate-aware preferences
    const _bcfg = BIOMES_CFG || {};
    const _tundra = _bcfg.tundra || {};
    const TUNDRA_LAT_MIN = Number.isFinite(_tundra.latMin)
        ? _tundra.latMin
        : 70;
    const TUNDRA_ELEV_MIN = Number.isFinite(_tundra.elevMin)
        ? _tundra.elevMin
        : 850;
    const TUNDRA_RAIN_MAX = Number.isFinite(_tundra.rainMax)
        ? _tundra.rainMax
        : 90;
    const _tcoast = _bcfg.tropicalCoast || {};
    const TCOAST_LAT_MAX = Number.isFinite(_tcoast.latMax)
        ? _tcoast.latMax
        : 18;
    const TCOAST_RAIN_MIN = Number.isFinite(_tcoast.rainMin)
        ? _tcoast.rainMin
        : 105;
    const _rv = _bcfg.riverValleyGrassland || {};
    const RV_LAT_MAX = Number.isFinite(_rv.latMax) ? _rv.latMax : 50;
    const RV_RAIN_MIN = Number.isFinite(_rv.rainMin) ? _rv.rainMin : 75;
    const _rs = _bcfg.riftShoulder || {};
    const RS_GRASS_LAT_MAX = Number.isFinite(_rs.grasslandLatMax)
        ? _rs.grasslandLatMax
        : 50;
    const RS_GRASS_RAIN_MIN = Number.isFinite(_rs.grasslandRainMin)
        ? _rs.grasslandRainMin
        : 75;
    const RS_TROP_LAT_MAX = Number.isFinite(_rs.tropicalLatMax)
        ? _rs.tropicalLatMax
        : 18;
    const RS_TROP_RAIN_MIN = Number.isFinite(_rs.tropicalRainMin)
        ? _rs.tropicalRainMin
        : 100;
    const LAND_BIAS_STRENGTH = Math.max(0, Math.min(1, CORRIDOR_POLICY?.land?.biomesBiasStrength ?? 0.6));
    const RIVER_BIAS_STRENGTH = Math.max(0, Math.min(1, CORRIDOR_POLICY?.river?.biomesBiasStrength ?? 0.5));
    for (let y = 0; y < iHeight; y++) {
        for (let x = 0; x < iWidth; x++) {
            if (GameplayMap.isWater(x, y))
                continue;
            const lat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            const elevation = GameplayMap.getElevation(x, y);
            const rainfall = GameplayMap.getRainfall(x, y);
            // Tundra restraint: require very high lat or extreme elevation and dryness
            if ((lat > TUNDRA_LAT_MIN || elevation > TUNDRA_ELEV_MIN) &&
                rainfall < TUNDRA_RAIN_MAX) {
                TerrainBuilder.setBiomeType(x, y, globals.g_TundraBiome);
                continue; // lock this decision; skip other nudges
            }
            // Wet, warm coasts near the equator tend tropical
            if (lat < TCOAST_LAT_MAX &&
                GameplayMap.isCoastalLand(x, y) &&
                rainfall > TCOAST_RAIN_MIN) {
                TerrainBuilder.setBiomeType(x, y, globals.g_TropicalBiome);
            }
            // Temperate/warm river valleys prefer grassland for playability
            if (GameplayMap.isAdjacentToRivers(x, y, 1) &&
                rainfall > RV_RAIN_MIN &&
                lat < RV_LAT_MAX) {
                TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
            }
            // Strategic Corridors: land-open corridor tiles gently bias to grassland (policy-scaled)
            if (StoryTags.corridorLandOpen &&
                StoryTags.corridorLandOpen.has(`${x},${y}`)) {
                if (rainfall > 80 &&
                    lat < 55 &&
                    TerrainBuilder.getRandomNumber(100, "Corridor Land-Open Biome") < Math.round(LAND_BIAS_STRENGTH * 100)) {
                    TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
                }
            }
            // Strategic Corridors: river-chain tiles gently bias to grassland (policy-scaled)
            if (StoryTags.corridorRiverChain &&
                StoryTags.corridorRiverChain.has(`${x},${y}`)) {
                if (rainfall > 75 &&
                    lat < 55 &&
                    TerrainBuilder.getRandomNumber(100, "Corridor River-Chain Biome") < Math.round(RIVER_BIAS_STRENGTH * 100)) {
                    TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
                }
            }
            // Edge hints near land/river corridors: light vegetation/mountain rim cues (biome-only)
            // Applies to tiles adjacent to a land-open or river-chain corridor, not the corridor tile itself
            {
                if (!(StoryTags.corridorLandOpen?.has?.(`${x},${y}`) ||
                    StoryTags.corridorRiverChain?.has?.(`${x},${y}`))) {
                    let edgeAttr = null;
                    for (let ddy = -1; ddy <= 1 && !edgeAttr; ddy++) {
                        for (let ddx = -1; ddx <= 1; ddx++) {
                            if (ddx === 0 && ddy === 0)
                                continue;
                            const nx = x + ddx;
                            const ny = y + ddy;
                            const nk = `${nx},${ny}`;
                            if (!StoryTags)
                                continue;
                            if (StoryTags.corridorLandOpen?.has?.(nk) ||
                                StoryTags.corridorRiverChain?.has?.(nk)) {
                                const attr = StoryTags.corridorAttributes?.get?.(nk);
                                if (attr && attr.edge)
                                    edgeAttr = attr;
                            }
                        }
                    }
                    if (edgeAttr && edgeAttr.edge) {
                        const edgeCfg = edgeAttr.edge;
                        // Forest rim: bias toward forest-friendly biomes (grassland/tropical) when moist
                        const forestRimChance = Math.max(0, Math.min(1, edgeCfg.forestRimChance ?? 0));
                        if (forestRimChance > 0 &&
                            rainfall > 90 &&
                            TerrainBuilder.getRandomNumber(100, "Corr Forest Rim") < Math.round(forestRimChance * 100)) {
                            const target = lat < 22 && rainfall > 110
                                ? globals.g_TropicalBiome
                                : globals.g_GrasslandBiome;
                            TerrainBuilder.setBiomeType(x, y, target);
                        }
                        // Hill/mountain rim: suggest drier, relief-friendly biomes (plains/tundra in cold/high)
                        const hillRimChance = Math.max(0, Math.min(1, edgeCfg.hillRimChance ?? 0));
                        const mountainRimChance = Math.max(0, Math.min(1, edgeCfg.mountainRimChance ?? 0));
                        const escarpmentChance = Math.max(0, Math.min(1, edgeCfg.escarpmentChance ?? 0));
                        const reliefChance = Math.max(0, Math.min(1, hillRimChance +
                            mountainRimChance +
                            escarpmentChance));
                        if (reliefChance > 0 &&
                            TerrainBuilder.getRandomNumber(100, "Corr Relief Rim") < Math.round(reliefChance * 100)) {
                            // Prefer tundra when very cold/high, else plains (playable with hills)
                            const elev = GameplayMap.getElevation(x, y);
                            const target = (lat > 62 || elev > 800) && rainfall < 95
                                ? globals.g_TundraBiome
                                : globals.g_PlainsBiome;
                            TerrainBuilder.setBiomeType(x, y, target);
                        }
                    }
                }
            }
            // Strategic Corridors: kind/style biome bias (very gentle; policy-scaled)
            {
                const cKey = `${x},${y}`;
                const attr = StoryTags.corridorAttributes?.get?.(cKey);
                const cKind = attr?.kind || (StoryTags.corridorKind && StoryTags.corridorKind.get(cKey));
                const biomesCfg = attr?.biomes;
                if ((cKind === "land" || cKind === "river") && biomesCfg) {
                    const strength = cKind === "land"
                        ? LAND_BIAS_STRENGTH
                        : RIVER_BIAS_STRENGTH;
                    if (strength > 0 &&
                        TerrainBuilder.getRandomNumber(100, "Corridor Kind Bias") < Math.round(strength * 100)) {
                        const entries = Object.keys(biomesCfg);
                        let totalW = 0;
                        for (const k of entries)
                            totalW += Math.max(0, biomesCfg[k] || 0);
                        if (totalW > 0) {
                            let roll = TerrainBuilder.getRandomNumber(totalW, "Corridor Kind Pick");
                            let chosen = entries[0];
                            for (const k of entries) {
                                const w = Math.max(0, biomesCfg[k] || 0);
                                if (roll < w) {
                                    chosen = k;
                                    break;
                                }
                                roll -= w;
                            }
                            let target = null;
                            if (chosen === "desert")
                                target = globals.g_DesertBiome;
                            else if (chosen === "plains")
                                target = globals.g_PlainsBiome;
                            else if (chosen === "grassland")
                                target = globals.g_GrasslandBiome;
                            else if (chosen === "tropical")
                                target = globals.g_TropicalBiome;
                            else if (chosen === "tundra")
                                target = globals.g_TundraBiome;
                            else if (chosen === "snow")
                                target = globals.g_SnowBiome;
                            if (target != null) {
                                // Light sanity gates to avoid extreme mismatches
                                let ok = true;
                                if (target === globals.g_DesertBiome &&
                                    rainfall > 110)
                                    ok = false;
                                if (target === globals.g_TropicalBiome &&
                                    !(lat < 25 && rainfall > 95))
                                    ok = false;
                                if (target === globals.g_TundraBiome &&
                                    !(lat > 60 || elevation > 800))
                                    ok = false;
                                if (target === globals.g_SnowBiome &&
                                    !(lat > 70 || elevation > 900))
                                    ok = false;
                                if (ok) {
                                    TerrainBuilder.setBiomeType(x, y, target);
                                }
                            }
                        }
                    }
                }
            }
            // Climate Story: rift shoulder preference (narrow, moisture-aware)
            if (STORY_ENABLE_RIFTS && StoryTags.riftShoulder.size > 0) {
                const key = `${x},${y}`;
                if (StoryTags.riftShoulder.has(key)) {
                    // Temperate/warm shoulders: prefer grassland when sufficiently moist
                    if (lat < RS_GRASS_LAT_MAX &&
                        rainfall > RS_GRASS_RAIN_MIN) {
                        TerrainBuilder.setBiomeType(x, y, globals.g_GrasslandBiome);
                    }
                    else if (lat < RS_TROP_LAT_MAX &&
                        rainfall > RS_TROP_RAIN_MIN) {
                        // In very warm & wet shoulders, allow tropical bias (still gentle)
                        TerrainBuilder.setBiomeType(x, y, globals.g_TropicalBiome);
                    }
                }
            }
        }
    }
}
export default designateEnhancedBiomes;
</file>

<file path="mod/maps/layers/climate-engine.js">
// @ts-nocheck
/**
 * Climate Engine  centralizes rainfall staging passes so the orchestrator and
 * narrative overlays operate against a single shared module.
 */
import { buildRainfallMap } from "/base-standard/maps/elevation-terrain-generator.js";
import { clamp, inBounds } from "../core/utils.js";
import { CLIMATE_DRIVERS, MOISTURE_ADJUSTMENTS, STORY_TUNABLES, STORY_ENABLE_OROGENY, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { ctxRandom, writeClimateField, syncClimateField } from "../core/types.js";
import { WorldModel } from "../world/model.js";
import { StoryTags } from "../story/tags.js";

/**
 * Resolve an engine adapter for rainfall operations. Falls back to GameplayMap
 * when no MapContext adapter is available.
 * @param {import('../core/types.js').MapContext|null} ctx
 */
function resolveAdapter(ctx) {
    if (ctx && ctx.adapter) {
        return ctx.adapter;
    }
    return {
        isWater: (x, y) => GameplayMap.isWater(x, y),
        isMountain: (x, y) => (GameplayMap.isMountain ? GameplayMap.isMountain(x, y) : GameplayMap.getElevation(x, y) >= 500),
        isCoastalLand: (x, y) => (GameplayMap.isCoastalLand ? GameplayMap.isCoastalLand(x, y) : false),
        isAdjacentToShallowWater: (x, y) => (GameplayMap.isAdjacentToShallowWater ? GameplayMap.isAdjacentToShallowWater(x, y) : false),
        isAdjacentToRivers: (x, y, radius) => GameplayMap.isAdjacentToRivers(x, y, radius),
        getRainfall: (x, y) => GameplayMap.getRainfall(x, y),
        setRainfall: (x, y, rf) => TerrainBuilder.setRainfall(x, y, rf),
        getElevation: (x, y) => GameplayMap.getElevation(x, y),
        getLatitude: (x, y) => GameplayMap.getPlotLatitude(x, y),
        getRandomNumber: (max, label) => TerrainBuilder.getRandomNumber(max, label),
    };
}

/**
 * Create shared IO helpers for rainfall passes.
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 */
function createClimateRuntime(width, height, ctx) {
    const adapter = resolveAdapter(ctx);
    const rainfallBuf = ctx?.buffers?.climate?.rainfall || null;
    const idx = (x, y) => y * width + x;
    const readRainfall = (x, y) => {
        if (ctx && rainfallBuf) {
            return rainfallBuf[idx(x, y)] | 0;
        }
        return adapter.getRainfall(x, y);
    };
    const writeRainfall = (x, y, rainfall) => {
        const clamped = clamp(rainfall, 0, 200);
        if (ctx) {
            writeClimateField(ctx, x, y, { rainfall: clamped });
        }
        else {
            adapter.setRainfall(x, y, clamped);
        }
    };
    const rand = (max, label) => {
        if (ctx) {
            return ctxRandom(ctx, label || "ClimateRand", max);
        }
        return adapter.getRandomNumber(max, label || "ClimateRand");
    };
    return {
        adapter,
        readRainfall,
        writeRainfall,
        rand,
        idx,
    };
}

/**
 * Baseline rainfall generation (latitude bands + coastal/orographic modifiers).
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 */
export function applyClimateBaseline(width, height, ctx = null) {
    console.log("Building enhanced rainfall patterns...");
    buildRainfallMap(width, height);
    if (ctx) {
        syncClimateField(ctx);
    }
    const runtime = createClimateRuntime(width, height, ctx);
    const { adapter, readRainfall, writeRainfall, rand } = runtime;
    const BASE_AREA = 10000;
    const sqrt = Math.min(2.0, Math.max(0.6, Math.sqrt(Math.max(1, width * height) / BASE_AREA)));
    const equatorPlus = Math.round(12 * (sqrt - 1));
    const drivers = CLIMATE_DRIVERS?.baseline || {};
    const adjustments = MOISTURE_ADJUSTMENTS?.baseline || {};
    const bands = drivers.bands || {};
    const blend = drivers.blend || {};
    const orographic = adjustments.orographic || {};
    const coastalCfg = adjustments.coastal || {};
    const noiseCfg = adjustments.noise || {};
    const noiseBase = Number.isFinite(noiseCfg?.baseSpanSmall) ? noiseCfg.baseSpanSmall : 3;
    const noiseSpan = sqrt > 1
        ? noiseBase + Math.round(Number.isFinite(noiseCfg?.spanLargeScaleFactor) ? noiseCfg.spanLargeScaleFactor : 1)
        : noiseBase;
    const isCoastalLand = (x, y) => {
        if (adapter.isCoastalLand)
            return adapter.isCoastalLand(x, y);
        if (typeof GameplayMap?.isCoastalLand === "function")
            return GameplayMap.isCoastalLand(x, y);
        if (adapter.isWater(x, y))
            return false;
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0)
                    continue;
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                    continue;
                if (adapter.isWater(nx, ny))
                    return true;
            }
        }
        return false;
    };
    const isAdjacentToShallowWater = (x, y) => {
        if (adapter.isAdjacentToShallowWater)
            return adapter.isAdjacentToShallowWater(x, y);
        if (typeof GameplayMap?.isAdjacentToShallowWater === "function")
            return GameplayMap.isAdjacentToShallowWater(x, y);
        return false;
    };
    const rollNoise = () => rand(noiseSpan * 2 + 1, "RainNoise") - noiseSpan;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (adapter.isWater(x, y))
                continue;
            const base = readRainfall(x, y);
            const elevation = adapter.getElevation(x, y);
            const lat = Math.abs(adapter.getLatitude(x, y));
            const b0 = Number.isFinite(bands.deg0to10) ? bands.deg0to10 : 120;
            const b1 = Number.isFinite(bands.deg10to20) ? bands.deg10to20 : 104;
            const b2 = Number.isFinite(bands.deg20to35) ? bands.deg20to35 : 75;
            const b3 = Number.isFinite(bands.deg35to55) ? bands.deg35to55 : 70;
            const b4 = Number.isFinite(bands.deg55to70) ? bands.deg55to70 : 60;
            const b5 = Number.isFinite(bands.deg70plus) ? bands.deg70plus : 45;
            let bandRain = 0;
            if (lat < 10)
                bandRain = b0 + equatorPlus;
            else if (lat < 20)
                bandRain = b1 + Math.floor(equatorPlus * 0.6);
            else if (lat < 35)
                bandRain = b2;
            else if (lat < 55)
                bandRain = b3;
            else if (lat < 70)
                bandRain = b4;
            else
                bandRain = b5;
            const baseW = Number.isFinite(blend?.baseWeight) ? blend.baseWeight : 0.6;
            const bandW = Number.isFinite(blend?.bandWeight) ? blend.bandWeight : 0.4;
            let currentRainfall = Math.round(base * baseW + bandRain * bandW);
            const hi1T = Number.isFinite(orographic?.hi1Threshold) ? orographic.hi1Threshold : 350;
            const hi1B = Number.isFinite(orographic?.hi1Bonus) ? orographic.hi1Bonus : 8;
            const hi2T = Number.isFinite(orographic?.hi2Threshold) ? orographic.hi2Threshold : 600;
            const hi2B = Number.isFinite(orographic?.hi2Bonus) ? orographic.hi2Bonus : 7;
            if (elevation > hi1T)
                currentRainfall += hi1B;
            if (elevation > hi2T)
                currentRainfall += hi2B;
            const coastalBonus = Number.isFinite(coastalCfg.coastalLandBonus) ? coastalCfg.coastalLandBonus : 24;
            const shallowBonus = Number.isFinite(coastalCfg.shallowAdjBonus) ? coastalCfg.shallowAdjBonus : 16;
            if (isCoastalLand(x, y))
                currentRainfall += coastalBonus;
            if (isAdjacentToShallowWater(x, y))
                currentRainfall += shallowBonus;
            currentRainfall += rollNoise();
            writeRainfall(x, y, currentRainfall);
        }
    }
}

/**
 * Apply macro climate swatches to the rainfall field.
 * Returns a lightweight summary that callers can extend.
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 * @param {{ orogenyCache?: any }} [options]
 */
export function applyClimateSwatches(width, height, ctx = null, options = {}) {
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    const cfg = storyMoisture.swatches;
    if (!cfg)
        return { applied: false, kind: "missing-config" };
    const area = Math.max(1, width * height);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    if (ctx) {
        syncClimateField(ctx);
    }
    const runtime = createClimateRuntime(width, height, ctx);
    const { adapter, readRainfall, writeRainfall, rand, idx } = runtime;
    const orogenyCache = options?.orogenyCache || {};
    const clamp200 = (v) => clamp(v, 0, 200);
    const inLocalBounds = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
    const isWater = (x, y) => adapter.isWater(x, y);
    const getElevation = (x, y) => adapter.getElevation(x, y);
    const signedLatitudeAt = (y) => adapter.getLatitude(0, y);
    const isCoastalLand = (x, y) => {
        if (adapter.isCoastalLand)
            return adapter.isCoastalLand(x, y);
        if (typeof GameplayMap?.isCoastalLand === "function")
            return GameplayMap.isCoastalLand(x, y);
        if (isWater(x, y))
            return false;
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0)
                    continue;
                const nx = x + dx;
                const ny = y + dy;
                if (!inLocalBounds(nx, ny))
                    continue;
                if (isWater(nx, ny))
                    return true;
            }
        }
        return false;
    };
    const isAdjacentToShallowWater = (x, y) => {
        if (adapter.isAdjacentToShallowWater)
            return adapter.isAdjacentToShallowWater(x, y);
        if (typeof GameplayMap?.isAdjacentToShallowWater === "function")
            return GameplayMap.isAdjacentToShallowWater(x, y);
        return false;
    };
    const types = cfg.types || {};
    let entries = Object.keys(types).map((key) => ({
        key,
        w: Math.max(0, types[key].weight | 0),
    }));
    try {
        const DIR = FOUNDATION_DIRECTIONALITY || {};
        const COH = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
        if (COH > 0) {
            const windDeg = (DIR?.primaryAxes?.windBiasDeg ?? 0) | 0;
            const plateDeg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
            const wRad = (windDeg * Math.PI) / 180;
            const pRad = (plateDeg * Math.PI) / 180;
            const alignZonal = Math.abs(Math.cos(wRad));
            const alignPlate = Math.abs(Math.cos(pRad));
            entries = entries.map((entry) => {
                let mul = 1;
                if (entry.key === "macroDesertBelt") {
                    mul *= 1 + 0.4 * COH * alignZonal;
                }
                else if (entry.key === "equatorialRainbelt") {
                    mul *= 1 + 0.25 * COH * alignZonal;
                }
                else if (entry.key === "mountainForests") {
                    mul *= 1 + 0.2 * COH * alignPlate;
                }
                else if (entry.key === "greatPlains") {
                    mul *= 1 + 0.2 * COH * alignZonal;
                }
                return { key: entry.key, w: Math.max(0, Math.round(entry.w * mul)) };
            });
        }
    }
    catch (_err) {
        /* keep default weights on any error */
    }
    const totalW = entries.reduce((sum, entry) => sum + entry.w, 0) || 1;
    let roll = rand(totalW, "SwatchType");
    let chosenKey = entries[0]?.key || "macroDesertBelt";
    for (const entry of entries) {
        if (roll < entry.w) {
            chosenKey = entry.key;
            break;
        }
        roll -= entry.w;
    }
    const kind = chosenKey;
    const t = types[kind] || {};
    const widthMul = 1 + (cfg.sizeScaling?.widthMulSqrt || 0) * (sqrtScale - 1);
    const latBandCenter = () => t.latitudeCenterDeg ?? 0;
    const halfWidthDeg = () => Math.max(4, Math.round((t.halfWidthDeg ?? 10) * widthMul));
    const falloff = (value, radius) => Math.max(0, 1 - value / Math.max(1, radius));
    let applied = 0;
    for (let y = 0; y < height; y++) {
        const latDegAbs = Math.abs(signedLatitudeAt(y));
        for (let x = 0; x < width; x++) {
            if (isWater(x, y))
                continue;
            let rf = readRainfall(x, y);
            const elev = getElevation(x, y);
            let tileAdjusted = false;
            if (kind === "macroDesertBelt") {
                const center = latBandCenter();
                const hw = halfWidthDeg();
                const f = falloff(Math.abs(latDegAbs - center), hw);
                if (f > 0) {
                    const base = t.drynessDelta ?? 28;
                    const lowlandBonus = elev < 250 ? 4 : 0;
                    const delta = Math.round((base + lowlandBonus) * f);
                    rf = clamp200(rf - delta);
                    applied++;
                    tileAdjusted = true;
                }
            }
            else if (kind === "equatorialRainbelt") {
                const center = latBandCenter();
                const hw = halfWidthDeg();
                const f = falloff(Math.abs(latDegAbs - center), hw);
                if (f > 0) {
                    const base = t.wetnessDelta ?? 24;
                    let coastBoost = 0;
                    if (isCoastalLand(x, y))
                        coastBoost += 6;
                    if (isAdjacentToShallowWater(x, y))
                        coastBoost += 4;
                    const delta = Math.round((base + coastBoost) * f);
                    rf = clamp200(rf + delta);
                    applied++;
                    tileAdjusted = true;
                }
            }
            else if (kind === "rainforestArchipelago") {
                const fTropics = latDegAbs < 23 ? 1 : latDegAbs < 30 ? 0.5 : 0;
                if (fTropics > 0) {
                    let islandy = 0;
                    if (isCoastalLand(x, y))
                        islandy += 1;
                    if (isAdjacentToShallowWater(x, y))
                        islandy += 0.5;
                    if (islandy > 0) {
                        const base = t.wetnessDelta ?? 18;
                        const delta = Math.round(base * fTropics * islandy);
                        rf = clamp200(rf + delta);
                        applied++;
                        tileAdjusted = true;
                    }
                }
            }
            else if (kind === "mountainForests") {
                const windward = !!orogenyCache?.windward?.has?.(`${x},${y}`);
                const lee = !!orogenyCache?.lee?.has?.(`${x},${y}`);
                if (windward) {
                    const base = t.windwardBonus ?? 6;
                    const delta = base + (elev < 300 ? 2 : 0);
                    rf = clamp200(rf + delta);
                    applied++;
                    tileAdjusted = true;
                }
                else if (lee) {
                    const base = t.leePenalty ?? 2;
                    rf = clamp200(rf - base);
                    applied++;
                    tileAdjusted = true;
                }
            }
            else if (kind === "greatPlains") {
                const center = t.latitudeCenterDeg ?? 45;
                const hw = Math.max(6, Math.round((t.halfWidthDeg ?? 8) * widthMul));
                const f = falloff(Math.abs(latDegAbs - center), hw);
                if (f > 0 && elev <= (t.lowlandMaxElevation ?? 300)) {
                    const dry = t.dryDelta ?? 12;
                    const delta = Math.round(dry * f);
                    rf = clamp200(rf - delta);
                    applied++;
                    tileAdjusted = true;
                }
            }
            if (tileAdjusted) {
                writeRainfall(x, y, rf);
            }
        }
    }
    try {
        const DIR = FOUNDATION_DIRECTIONALITY || {};
        const monsoonBias = Math.max(0, Math.min(1, DIR?.hemispheres?.monsoonBias ?? 0));
        const COH = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
        const eqBand = Math.max(0, (DIR?.hemispheres?.equatorBandDeg ?? 12) | 0);
        if (monsoonBias > 0 && COH > 0 && WorldModel?.isEnabled?.() && WorldModel.windU && WorldModel.windV) {
            const baseDelta = Math.max(1, Math.round(3 * COH * monsoonBias));
            for (let y = 0; y < height; y++) {
                const latSigned = signedLatitudeAt(y);
                const absLat = Math.abs(latSigned);
                if (absLat > eqBand + 18)
                    continue;
                for (let x = 0; x < width; x++) {
                    if (isWater(x, y))
                        continue;
                    if (!isCoastalLand(x, y) && !isAdjacentToShallowWater(x, y))
                        continue;
                    const i = idx(x, y);
                    const u = WorldModel.windU[i] | 0;
                    const v = WorldModel.windV[i] | 0;
                    let ux = 0, vy = 0;
                    if (Math.abs(u) >= Math.abs(v)) {
                        ux = u === 0 ? 0 : u > 0 ? 1 : -1;
                        vy = 0;
                    }
                    else {
                        ux = 0;
                        vy = v === 0 ? 0 : v > 0 ? 1 : -1;
                    }
                    const dnX = x - ux;
                    const dnY = y - vy;
                    if (!inLocalBounds(dnX, dnY))
                        continue;
                    let rf = readRainfall(x, y);
                    let baseDeltaAdj = baseDelta;
                    if (absLat <= eqBand)
                        baseDeltaAdj += 2;
                    if (isWater(dnX, dnY))
                        baseDeltaAdj += 2;
                    rf = clamp(rf + baseDeltaAdj, 0, 200);
                    writeRainfall(x, y, rf);
                    const upX = x + ux;
                    const upY = y + vy;
                    if (inLocalBounds(upX, upY) && isWater(dnX, dnY)) {
                        const rf0 = readRainfall(x, y);
                        const rf1 = Math.max(0, Math.min(200, rf0 - 1));
                        writeRainfall(x, y, rf1);
                    }
                }
            }
        }
    }
    catch (_err) {
        /* keep resilient */
    }
    return { applied: applied > 0, kind, tiles: applied };
}

/**
 * Earthlike rainfall refinements (post-rivers).
 * @param {number} width
 * @param {number} height
 * @param {import('../core/types.js').MapContext|null} ctx
 * @param {{ orogenyCache?: any }} [options]
 */
export function refineClimateEarthlike(width, height, ctx = null, options = {}) {
    const runtime = createClimateRuntime(width, height, ctx);
    const { adapter, readRainfall, writeRainfall } = runtime;
    const worldModel = ctx && ctx.worldModel ? ctx.worldModel : WorldModel;
    const refineAdjust = MOISTURE_ADJUSTMENTS?.refine || {};
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    const storyRain = storyMoisture.rainfall || {};
    const orogenyCache = options?.orogenyCache || null;
    console.log(`[Climate Refinement] Using ${ctx ? "MapContext adapter" : "direct engine calls"}`);
    // Pass A: coastal and lake humidity gradient
    {
        const waterGradient = refineAdjust.waterGradient || {};
        const maxR = (waterGradient?.radius ?? 5) | 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (adapter.isWater(x, y))
                    continue;
                let rf = readRainfall(x, y);
                const dist = distanceToNearestWater(x, y, maxR, adapter, width, height);
                if (dist >= 0) {
                    const elev = adapter.getElevation(x, y);
                    let bonus = Math.max(0, maxR - dist) * (waterGradient?.perRingBonus ?? 5);
                    if (elev < 150)
                        bonus += waterGradient?.lowlandBonus ?? 3;
                    rf += bonus;
                    writeRainfall(x, y, rf);
                }
            }
        }
    }
    // Pass B: orographic rain shadows with wind model
    {
        const orographic = refineAdjust.orographic || {};
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (adapter.isWater(x, y))
                    continue;
                const baseSteps = (orographic?.steps ?? 4) | 0;
                let steps = baseSteps;
                try {
                    const DIR = FOUNDATION_DIRECTIONALITY || {};
                    const coh = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                    const windC = Math.max(0, Math.min(1, DIR?.interplay?.windsFollowPlates ?? 0));
                    const extra = Math.round(coh * windC);
                    steps = Math.max(1, baseSteps + extra);
                }
                catch (_) {
                    steps = baseSteps;
                }
                let barrier = 0;
                if (worldModel?.isEnabled?.() && worldModel.windU && worldModel.windV) {
                    barrier = hasUpwindBarrierWM(x, y, steps, adapter, width, height, worldModel);
                }
                else {
                    const lat = Math.abs(adapter.getLatitude(x, y));
                    const dx = lat < 30 || lat >= 60 ? -1 : 1;
                    const dy = 0;
                    barrier = hasUpwindBarrier(x, y, dx, dy, steps, adapter, width, height);
                }
                if (barrier) {
                    const rf = readRainfall(x, y);
                    const reduction = (orographic?.reductionBase ?? 8) + barrier * (orographic?.reductionPerStep ?? 6);
                    writeRainfall(x, y, rf - reduction);
                }
            }
        }
    }
    // Pass C: river corridor greening and basin humidity
    {
        const riverCorridor = refineAdjust.riverCorridor || {};
        const lowBasinCfg = refineAdjust.lowBasin || {};
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (adapter.isWater(x, y))
                    continue;
                let rf = readRainfall(x, y);
                const elev = adapter.getElevation(x, y);
                if (adapter.isAdjacentToRivers(x, y, 1)) {
                    rf += elev < 250
                        ? (riverCorridor?.lowlandAdjacencyBonus ?? 14)
                        : (riverCorridor?.highlandAdjacencyBonus ?? 10);
                }
                let lowBasinClosed = true;
                const basinRadius = lowBasinCfg?.radius ?? 2;
                for (let dy = -basinRadius; dy <= basinRadius && lowBasinClosed; dy++) {
                    for (let dx = -basinRadius; dx <= basinRadius; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (inBounds(nx, ny)) {
                            if (adapter.getElevation(nx, ny) < elev + 20) {
                                lowBasinClosed = false;
                                break;
                            }
                        }
                    }
                }
                if (lowBasinClosed && elev < 200)
                    rf += lowBasinCfg?.delta ?? 6;
                writeRainfall(x, y, rf);
            }
        }
    }
    // Pass D: Rift humidity boost
    {
        const riftR = storyRain?.riftRadius ?? 2;
        const riftBoost = storyRain?.riftBoost ?? 8;
        if (StoryTags.riftLine.size > 0 && riftR > 0 && riftBoost !== 0) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (adapter.isWater(x, y))
                        continue;
                    let nearRift = false;
                    for (let dy = -riftR; dy <= riftR && !nearRift; dy++) {
                        for (let dx = -riftR; dx <= riftR; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (!inBounds(nx, ny))
                                continue;
                            if (StoryTags.riftLine.has(`${nx},${ny}`)) {
                                nearRift = true;
                                break;
                            }
                        }
                    }
                    if (nearRift) {
                        const rf = readRainfall(x, y);
                        const elev = adapter.getElevation(x, y);
                        const penalty = Math.max(0, Math.floor((elev - 200) / 150));
                        const delta = Math.max(0, riftBoost - penalty);
                        writeRainfall(x, y, rf + delta);
                    }
                }
            }
        }
    }
    // Pass E: Orogeny belts (windward/lee)
    {
        if (STORY_ENABLE_OROGENY && typeof orogenyCache === "object") {
            const hasWindward = orogenyCache?.windward?.size > 0;
            const hasLee = orogenyCache?.lee?.size > 0;
            if (hasWindward || hasLee) {
                const windwardBoost = STORY_TUNABLES?.orogeny?.windwardBoost ?? 5;
                const leeAmp = STORY_TUNABLES?.orogeny?.leeDrynessAmplifier ?? 1.2;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (adapter.isWater(x, y))
                            continue;
                        let rf = readRainfall(x, y);
                        const key = `${x},${y}`;
                        if (hasWindward && orogenyCache.windward.has(key)) {
                            rf = clamp(rf + windwardBoost, 0, 200);
                        }
                        if (hasLee && orogenyCache.lee.has(key)) {
                            const baseSubtract = 8;
                            const extra = Math.max(0, Math.round(baseSubtract * (leeAmp - 1)));
                            rf = clamp(rf - (baseSubtract + extra), 0, 200);
                        }
                        writeRainfall(x, y, rf);
                    }
                }
            }
        }
    }
    // Pass F: Hotspot island microclimates
    {
        const paradiseDelta = storyRain?.paradiseDelta ?? 6;
        const volcanicDelta = storyRain?.volcanicDelta ?? 8;
        const radius = 2;
        const hasParadise = StoryTags.hotspotParadise.size > 0;
        const hasVolcanic = StoryTags.hotspotVolcanic.size > 0;
        if (hasParadise || hasVolcanic) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (adapter.isWater(x, y))
                        continue;
                    let nearParadise = false;
                    let nearVolcanic = false;
                    for (let dy = -radius; dy <= radius && (!nearParadise || !nearVolcanic); dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (!inBounds(nx, ny))
                                continue;
                            const key = `${nx},${ny}`;
                            if (!nearParadise && hasParadise && StoryTags.hotspotParadise.has(key))
                                nearParadise = true;
                            if (!nearVolcanic && hasVolcanic && StoryTags.hotspotVolcanic.has(key))
                                nearVolcanic = true;
                            if (nearParadise && nearVolcanic)
                                break;
                        }
                    }
                    if (nearParadise || nearVolcanic) {
                        const rf = readRainfall(x, y);
                        let delta = 0;
                        if (nearParadise)
                            delta += paradiseDelta;
                        if (nearVolcanic)
                            delta += volcanicDelta;
                        writeRainfall(x, y, rf + delta);
                    }
                }
            }
        }
    }
}

/**
 * Distance helper for the refinement pass.
 */
function distanceToNearestWater(x, y, maxR, adapter, width, height) {
    for (let r = 1; r <= maxR; r++) {
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                if (dx === 0 && dy === 0)
                    continue;
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    if (adapter.isWater(nx, ny))
                        return r;
                }
            }
        }
    }
    return -1;
}

/**
 * Upwind barrier utility (legacy helper copied from refinement layer).
 */
function hasUpwindBarrier(x, y, dx, dy, steps, adapter, width, height) {
    for (let s = 1; s <= steps; s++) {
        const nx = x + dx * s;
        const ny = y + dy * s;
        if (nx < 0 || nx >= width || ny < 0 || ny >= height)
            break;
        if (!adapter.isWater(nx, ny)) {
            if (adapter.isMountain && adapter.isMountain(nx, ny))
                return s;
            const elev = adapter.getElevation(nx, ny);
            if (elev >= 500)
                return s;
        }
    }
    return 0;
}

/**
 * Upwind barrier using world model wind vectors.
 */
function hasUpwindBarrierWM(x, y, steps, adapter, width, height, worldModel) {
    const U = worldModel.windU;
    const V = worldModel.windV;
    if (!U || !V)
        return 0;
    let cx = x;
    let cy = y;
    for (let s = 1; s <= steps; s++) {
        const i = cy * width + cx;
        let ux = 0, vy = 0;
        if (i >= 0 && i < U.length) {
            const u = U[i] | 0;
            const v = V[i] | 0;
            if (Math.abs(u) >= Math.abs(v)) {
                ux = u === 0 ? 0 : u > 0 ? 1 : -1;
                vy = 0;
            }
            else {
                ux = 0;
                vy = v === 0 ? 0 : v > 0 ? 1 : -1;
            }
            if (ux === 0 && vy === 0) {
                const lat = Math.abs(adapter.getLatitude(cx, cy));
                ux = lat < 30 || lat >= 60 ? -1 : 1;
                vy = 0;
            }
        }
        else {
            const lat = Math.abs(adapter.getLatitude(cx, cy));
            ux = lat < 30 || lat >= 60 ? -1 : 1;
            vy = 0;
        }
        const nx = cx + ux;
        const ny = cy + vy;
        if (nx < 0 || nx >= width || ny < 0 || ny >= height)
            break;
        if (!adapter.isWater(nx, ny)) {
            if (adapter.isMountain && adapter.isMountain(nx, ny))
                return s;
            const elev = adapter.getElevation(nx, ny);
            if (elev >= 500)
                return s;
        }
        cx = nx;
        cy = ny;
    }
    return 0;
}

export default {
    applyClimateBaseline,
    applyClimateSwatches,
    refineClimateEarthlike,
};
</file>

<file path="mod/maps/layers/coastlines.js">
// @ts-nocheck
/**
 * Coastlines Layer  addRuggedCoasts
 *
 * Light-touch coastal reshaping that carves occasional bays and creates sparse
 * fjord-like peninsulas while preserving open sea lanes. Uses a low-frequency
 * fractal mask and conservative randomness to avoid chokepoint proliferation.
 *
 * Dependencies: engine-provided GameplayMap, TerrainBuilder, FractalBuilder, and globals.
 */
import * as globals from "/base-standard/maps/map-globals.js";
import { isAdjacentToLand } from "../core/utils.js";
import { StoryTags } from "../story/tags.js";
import { COASTLINES_CFG, CORRIDOR_POLICY, } from "../bootstrap/tunables.js";
import { ctxRandom, writeHeightfield } from "../core/types.js";
import { WorldModel } from "../world/model.js";

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

function clamp(v, lo, hi) {
    if (v < lo)
        return lo;
    if (v > hi)
        return hi;
    return v;
}

function computePlateBias(closenessNorm, boundaryType, cfg) {
    if (closenessNorm == null || Number.isNaN(closenessNorm))
        closenessNorm = 0;
    const threshold = cfg.threshold;
    const power = cfg.power;
    let weight = 0;
    if (closenessNorm >= threshold) {
        const span = Math.max(1e-3, 1 - threshold);
        const normalized = clamp((closenessNorm - threshold) / span, 0, 1);
        const ramp = Math.pow(normalized, power);
        let typeMul = 0;
        if (boundaryType === ENUM_BOUNDARY.convergent)
            typeMul = cfg.convergent;
        else if (boundaryType === ENUM_BOUNDARY.transform)
            typeMul = cfg.transform;
        else if (boundaryType === ENUM_BOUNDARY.divergent)
            typeMul = cfg.divergent;
        weight = ramp * typeMul;
    }
    else if (cfg.interior !== 0 && threshold > 0) {
        const normalized = clamp(1 - closenessNorm / threshold, 0, 1);
        weight = Math.pow(normalized, power) * cfg.interior;
    }
    return weight;
}
/**
 * Ruggedize coasts in a sparse, performance-friendly pass.
 * - Occasionally converts coastal land to shallow water (bays).
 * - Occasionally converts adjacent ocean to coast (peninsulas/fjords).
 * - Only operates near current coastlines; does not perform heavy flood fills.
 *
 * Invariants:
 * - Keeps oceans truly open; very low probabilities to avoid chokepoints.
 * - O(width  height) with constant-time local checks.
 *
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {import('../core/types.js').MapContext} [ctx] - Optional MapContext for adapter-based operations
 */
export function addRuggedCoasts(iWidth, iHeight, ctx) {
    // Size-aware modifiers (gentle; keep lanes open)
    const area = Math.max(1, iWidth * iHeight);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    // Use hill fractal as a sparse noise mask to drive rare edits
    FractalBuilder.create(globals.g_HillFractal, iWidth, iHeight, 4, 0);

    // Phase 2: WorldModel plate boundary integration
    const worldModelEnabled = WorldModel.isEnabled();
    const boundaryCloseness = worldModelEnabled ? WorldModel.boundaryCloseness : null;
    const boundaryType = worldModelEnabled ? WorldModel.boundaryType : null;
    // Probability tuning: on larger maps, allow a touch more edits
    const cfg = COASTLINES_CFG || {};
    const cfgBay = (cfg && cfg.bay) || {};
    const cfgFjord = (cfg && cfg.fjord) || {};
    const bayNoiseExtra = (sqrtScale > 1 ? 1 : 0) +
        (Number.isFinite(cfgBay.noiseGateAdd) ? cfgBay.noiseGateAdd : 0);
    const fjordBaseDenom = Math.max(6, (Number.isFinite(cfgFjord.baseDenom) ? cfgFjord.baseDenom : 12) -
        (sqrtScale > 1.3 ? 1 : 0));
    const fjordActiveBonus = Number.isFinite(cfgFjord.activeBonus)
        ? cfgFjord.activeBonus
        : 1;
    const fjordPassiveBonus = Number.isFinite(cfgFjord.passiveBonus)
        ? cfgFjord.passiveBonus
        : 2;
    const bayRollDenActive = Number.isFinite(cfgBay.rollDenActive)
        ? cfgBay.rollDenActive
        : 4;
    const bayRollDenDefault = Number.isFinite(cfgBay.rollDenDefault)
        ? cfgBay.rollDenDefault
        : 5;
    const minSeaLaneWidth = Number.isFinite(cfg.minSeaLaneWidth)
        ? cfg.minSeaLaneWidth
        : 4; // reserved for future shelf/trench guards
    const plateBiasRaw = (cfg && cfg.plateBias) || {};
    const plateBiasCfg = {
        threshold: clamp(Number.isFinite(plateBiasRaw.threshold) ? plateBiasRaw.threshold : 0.45, 0, 1),
        power: Math.max(0.1, Number.isFinite(plateBiasRaw.power) ? plateBiasRaw.power : 1.25),
        convergent: Number.isFinite(plateBiasRaw.convergent) ? plateBiasRaw.convergent : 1.0,
        transform: Number.isFinite(plateBiasRaw.transform) ? plateBiasRaw.transform : 0.4,
        divergent: Number.isFinite(plateBiasRaw.divergent) ? plateBiasRaw.divergent : -0.6,
        interior: Number.isFinite(plateBiasRaw.interior) ? plateBiasRaw.interior : 0,
        bayWeight: Math.max(0, Number.isFinite(plateBiasRaw.bayWeight) ? plateBiasRaw.bayWeight : 0.35),
        bayNoiseBonus: Math.max(0, Number.isFinite(plateBiasRaw.bayNoiseBonus) ? plateBiasRaw.bayNoiseBonus : 1.0),
        fjordWeight: Math.max(0, Number.isFinite(plateBiasRaw.fjordWeight) ? plateBiasRaw.fjordWeight : 0.8),
    };
    // Sea-lane policy (hard skip vs. soft probability reduction)
    const seaPolicy = (CORRIDOR_POLICY && CORRIDOR_POLICY.sea) || {};
    const SEA_PROTECTION = seaPolicy.protection || "hard";
    const SOFT_MULT = Math.max(0, Math.min(1, seaPolicy.softChanceMultiplier ?? 0.5));

    const applyTerrain = (x, y, terrain, isLand) => {
        if (ctx) {
            writeHeightfield(ctx, x, y, { terrain, isLand });
        }
        else {
            TerrainBuilder.setTerrainType(x, y, terrain);
        }
    };
    for (let y = 1; y < iHeight - 1; y++) {
        for (let x = 1; x < iWidth - 1; x++) {
            // Sea-lane policy: hard skip or soft probability reduction
            const _k = `${x},${y}`;
            const _onSeaLane = StoryTags.corridorSeaLane && StoryTags.corridorSeaLane.has(_k);
            const _softMult = _onSeaLane && SEA_PROTECTION === "soft" ? SOFT_MULT : 1;
            if (_onSeaLane && SEA_PROTECTION === "hard") {
                continue;
            }
            // Carve bays: coastal land -> coast water (very sparse)
            if (GameplayMap.isCoastalLand(x, y)) {
                const h = FractalBuilder.getHeight(globals.g_HillFractal, x, y);

                // Phase 2: Check boundary closeness for enhanced ruggedness
                const i = y * iWidth + x;
                const closenessByte = boundaryCloseness ? boundaryCloseness[i] | 0 : 0;
                const closenessNorm = closenessByte / 255;
                const bType = boundaryType ? boundaryType[i] | 0 : ENUM_BOUNDARY.none;
                const nearBoundary = closenessNorm >= plateBiasCfg.threshold;
                const plateBiasValue = boundaryCloseness
                    ? computePlateBias(closenessNorm, bType, plateBiasCfg)
                    : 0;

                // Margin-aware: slightly stronger bay carving on ACTIVE_MARGIN or near plate boundaries
                const isActive = StoryTags.activeMargin.has(`${x},${y}`) || nearBoundary;
                const noiseGateBonus = plateBiasValue > 0
                    ? Math.round(plateBiasValue * plateBiasCfg.bayNoiseBonus)
                    : 0;
                const noiseGate = 2 + bayNoiseExtra + (isActive ? 1 : 0) + noiseGateBonus;
                const bayRollDen = isActive
                    ? bayRollDenActive
                    : bayRollDenDefault;
                let bayRollDenUsed = _softMult !== 1
                    ? Math.max(1, Math.round(bayRollDen / _softMult))
                    : bayRollDen;
                if (plateBiasCfg.bayWeight > 0 && plateBiasValue !== 0) {
                    const scale = clamp(1 + plateBiasValue * plateBiasCfg.bayWeight, 0.25, 4);
                    bayRollDenUsed = Math.max(1, Math.round(bayRollDenUsed / scale));
                }
                // Corridor edge effect: if near a sea-lane, apply style-based bay carve bias
                const laneAttr = (function () {
                    for (let ddy = -1; ddy <= 1; ddy++) {
                        for (let ddx = -1; ddx <= 1; ddx++) {
                            if (ddx === 0 && ddy === 0)
                                continue;
                            const k = `${x + ddx},${y + ddy}`;
                            if (StoryTags.corridorSeaLane &&
                                StoryTags.corridorSeaLane.has(k)) {
                                return StoryTags.corridorAttributes?.get?.(k) || null;
                            }
                        }
                    }
                    return null;
                })();
                if (laneAttr && laneAttr.edge) {
                    const edgeCfg = laneAttr.edge;
                    const bayMult = Number.isFinite(edgeCfg.bayCarveMultiplier)
                        ? edgeCfg.bayCarveMultiplier
                        : 1;
                    if (bayMult && bayMult !== 1) {
                        bayRollDenUsed = Math.max(1, Math.round(bayRollDenUsed / bayMult));
                    }
                }
                if (h % 97 < noiseGate &&
                    (ctx ? ctxRandom(ctx, "Carve Bay", bayRollDenUsed) : TerrainBuilder.getRandomNumber(bayRollDenUsed, "Carve Bay")) === 0) {
                    applyTerrain(x, y, globals.g_CoastTerrain, false);
                    continue; // Avoid double-touching same tile in this pass
                }
            }
            // Fjord-like peninsulas: turn some adjacent ocean into coast (very sparse)
            if (GameplayMap.isWater(x, y)) {
                // Keep to near-land ocean only; deep ocean remains untouched
                if (isAdjacentToLand(x, y, 1)) {
                    {
                        // Phase 2: Check boundary closeness for enhanced ruggedness
                        const i = y * iWidth + x;
                        const closenessByte = boundaryCloseness ? boundaryCloseness[i] | 0 : 0;
                        const closenessNorm = closenessByte / 255;
                        const bType = boundaryType ? boundaryType[i] | 0 : ENUM_BOUNDARY.none;
                        const nearBoundary = closenessNorm >= plateBiasCfg.threshold;
                        const plateBiasValue = boundaryCloseness
                            ? computePlateBias(closenessNorm, bType, plateBiasCfg)
                            : 0;

                        // Margin-aware: widen shelf near PASSIVE_SHELF, deepen cuts near ACTIVE_MARGIN or plate boundaries
                        let nearActive = nearBoundary, nearPassive = false;
                        for (let ddy = -1; ddy <= 1 && (!nearActive || !nearPassive); ddy++) {
                            for (let ddx = -1; ddx <= 1; ddx++) {
                                if (ddx === 0 && ddy === 0)
                                    continue;
                                const nx = x + ddx, ny = y + ddy;
                                if (nx <= 0 ||
                                    nx >= iWidth - 1 ||
                                    ny <= 0 ||
                                    ny >= iHeight - 1)
                                    continue;
                                const k = `${nx},${ny}`;
                                if (!nearActive &&
                                    StoryTags.activeMargin.has(k))
                                    nearActive = true;
                                if (!nearPassive &&
                                    StoryTags.passiveShelf.has(k))
                                    nearPassive = true;
                            }
                        }
                        const denom = Math.max(4, fjordBaseDenom -
                            (nearPassive ? fjordPassiveBonus : 0) -
                            (nearActive ? fjordActiveBonus : 0));
                        let denomUsed = _softMult !== 1
                            ? Math.max(1, Math.round(denom / _softMult))
                            : denom;
                        if (plateBiasCfg.fjordWeight > 0 && plateBiasValue !== 0) {
                            const fjScale = clamp(1 + plateBiasValue * plateBiasCfg.fjordWeight, 0.2, 5);
                            denomUsed = Math.max(1, Math.round(denomUsed / fjScale));
                        }
                        // Corridor edge effect: if adjacent to a sea-lane tile, increase fjord/coast conversion chance
                        {
                            let edgeCfg = null;
                            for (let my = -1; my <= 1 && !edgeCfg; my++) {
                                for (let mx = -1; mx <= 1; mx++) {
                                    if (mx === 0 && my === 0)
                                        continue;
                                    const kk = `${x + mx},${y + my}`;
                                    if (StoryTags.corridorSeaLane &&
                                        StoryTags.corridorSeaLane.has(kk)) {
                                        const attr = StoryTags.corridorAttributes?.get?.(kk);
                                        edgeCfg = attr && attr.edge ? attr.edge : null;
                                        if (edgeCfg)
                                            break;
                                    }
                                }
                            }
                            if (edgeCfg) {
                                const fj = Number.isFinite(edgeCfg.fjordChance)
                                    ? edgeCfg.fjordChance
                                    : 0;
                                const cliffs = Number.isFinite(edgeCfg.cliffsChance)
                                    ? edgeCfg.cliffsChance
                                    : 0;
                                // Convert combined edge effect into a denom multiplier (cap to avoid aggression)
                                const effect = Math.max(0, Math.min(0.5, fj + cliffs * 0.5));
                                if (effect > 0) {
                                    denomUsed = Math.max(1, Math.round(denomUsed * (1 - effect)));
                                }
                            }
                        }
                        if ((ctx ? ctxRandom(ctx, "Fjord Coast", denomUsed) : TerrainBuilder.getRandomNumber(denomUsed, "Fjord Coast")) === 0) {
                            applyTerrain(x, y, globals.g_CoastTerrain, false);
                        }
                    }
                }
            }
        }
    }
}
export default addRuggedCoasts;
</file>

<file path="mod/maps/layers/features.js">
// @ts-nocheck
/**
 * Features Layer  addDiverseFeatures
 *
 * Purpose
 * - Run base-standard feature generation, then apply small, validated, and
 *   climate-aware embellishments that strengthen the narrative:
 *   - Paradise reefs near hotspot paradise centers
 *   - Volcanic vegetation around volcanic centers (forests in warm/wet, taiga in cold/wet)
 *   - Gentle density tweaks for rainforest/forest/taiga in appropriate biomes
 *
 * Guardrails
 * - Always validate placements via TerrainBuilder.canHaveFeature
 * - Resolve feature indices via lookups; skip if unavailable
 * - Keep probabilities conservative and local; never create chokepoints
 * - O(width  height); small neighborhood scans only
 */
import { addFeatures as baseAddFeatures } from "/base-standard/maps/feature-biome-generator.js";
import * as globals from "/base-standard/maps/map-globals.js";
import { StoryTags } from "../story/tags.js";
import { STORY_ENABLE_HOTSPOTS, STORY_TUNABLES, FEATURES_DENSITY_CFG, } from "../bootstrap/tunables.js";
import { getFeatureTypeIndex, inBounds } from "../core/utils.js";
import { ctxRandom } from "../core/types.js";
/**
 * Add diverse features with conservative, validated tweaks.
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {import('../core/types.js').MapContext} [ctx] - Optional MapContext for adapter-based operations
 */
export function addDiverseFeatures(iWidth, iHeight, ctx) {
    console.log("Adding diverse terrain features...");
    // 1) Base-standard features (vanilla-compatible baseline)
    baseAddFeatures(iWidth, iHeight);
    // 2) Paradise reefs near hotspot paradise centers
    const reefIndex = getFeatureTypeIndex("FEATURE_REEF");
    const paradiseReefChance = STORY_TUNABLES?.features?.paradiseReefChance ?? 18;
    if (STORY_ENABLE_HOTSPOTS &&
        reefIndex !== -1 &&
        StoryTags.hotspotParadise.size > 0 &&
        paradiseReefChance > 0) {
        for (const key of StoryTags.hotspotParadise) {
            const [cx, cy] = key.split(",").map(Number);
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    if (!inBounds(nx, ny))
                        continue;
                    if (!GameplayMap.isWater(nx, ny))
                        continue;
                    if (GameplayMap.getFeatureType(nx, ny) !==
                        FeatureTypes.NO_FEATURE)
                        continue;
                    if ((ctx ? ctxRandom(ctx, "Paradise Reef", 100) : TerrainBuilder.getRandomNumber(100, "Paradise Reef")) <
                        paradiseReefChance) {
                        const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(nx, ny, reefIndex) : TerrainBuilder.canHaveFeature(nx, ny, reefIndex);
                        if (canPlace) {
                            if (ctx && ctx.adapter) {
                                ctx.adapter.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            } else {
                                TerrainBuilder.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            }
                        }
                    }
                }
            }
        }
    }
    // 2b) Reefs along passive shelves (margin-aware, modest chance)
    if (reefIndex !== -1 &&
        StoryTags.passiveShelf &&
        StoryTags.passiveShelf.size > 0) {
        // Keep this lower than paradise reefs to stay subtle.
        const shelfMult = FEATURES_DENSITY_CFG?.shelfReefMultiplier ?? 0.6;
        const shelfReefChance = Math.max(1, Math.min(100, Math.floor((paradiseReefChance || 18) * shelfMult)));
        for (const key of StoryTags.passiveShelf) {
            const [sx, sy] = key.split(",").map(Number);
            // Tight radius; shelves are linear and we don't want clutter.
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = sx + dx;
                    const ny = sy + dy;
                    if (!inBounds(nx, ny))
                        continue;
                    if (!GameplayMap.isWater(nx, ny))
                        continue;
                    if (GameplayMap.getFeatureType(nx, ny) !==
                        FeatureTypes.NO_FEATURE)
                        continue;
                    if ((ctx ? ctxRandom(ctx, "Shelf Reef", 100) : TerrainBuilder.getRandomNumber(100, "Shelf Reef")) <
                        shelfReefChance) {
                        const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(nx, ny, reefIndex) : TerrainBuilder.canHaveFeature(nx, ny, reefIndex);
                        if (canPlace) {
                            if (ctx && ctx.adapter) {
                                ctx.adapter.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            } else {
                                TerrainBuilder.setFeatureType(nx, ny, { Feature: reefIndex, Direction: -1, Elevation: 0 });
                            }
                        }
                    }
                }
            }
        }
    }
    // 3) Per-tile post-pass for gentle density tweaks and volcanic vegetation
    const baseVolcanicForestChance = STORY_TUNABLES?.features?.volcanicForestChance ?? 22;
    const baseVolcanicTaigaChance = STORY_TUNABLES?.features?.volcanicTaigaChance ?? 25;
    // Slight boost to rugged vegetation near volcanic centers (kept conservative)
    const volcanicForestChance = Math.min(100, baseVolcanicForestChance + 6);
    const volcanicTaigaChance = Math.min(100, baseVolcanicTaigaChance + 5);
    const rainforestIdx = getFeatureTypeIndex("FEATURE_RAINFOREST");
    const forestIdx = getFeatureTypeIndex("FEATURE_FOREST");
    const taigaIdx = getFeatureTypeIndex("FEATURE_TAIGA");
    const rainforestExtraChance = FEATURES_DENSITY_CFG?.rainforestExtraChance ?? 55;
    const forestExtraChance = FEATURES_DENSITY_CFG?.forestExtraChance ?? 30;
    const taigaExtraChance = FEATURES_DENSITY_CFG?.taigaExtraChance ?? 35;
    for (let y = 0; y < iHeight; y++) {
        for (let x = 0; x < iWidth; x++) {
            if (GameplayMap.isWater(x, y))
                continue;
            if (GameplayMap.getFeatureType(x, y) !== FeatureTypes.NO_FEATURE)
                continue;
            const biome = GameplayMap.getBiomeType(x, y);
            const elevation = GameplayMap.getElevation(x, y);
            const rainfall = GameplayMap.getRainfall(x, y);
            const plat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            // 3a) Volcanic vegetation near volcanic hotspot centers (radius 1)
            if (STORY_ENABLE_HOTSPOTS && StoryTags.hotspotVolcanic.size > 0) {
                let nearVolcanic = false;
                for (let vdy = -1; vdy <= 1 && !nearVolcanic; vdy++) {
                    for (let vdx = -1; vdx <= 1; vdx++) {
                        if (vdx === 0 && vdy === 0)
                            continue;
                        const vx = x + vdx;
                        const vy = y + vdy;
                        if (!inBounds(vx, vy))
                            continue;
                        if (StoryTags.hotspotVolcanic.has(`${vx},${vy}`)) {
                            nearVolcanic = true;
                            break;
                        }
                    }
                }
                if (nearVolcanic) {
                    // Warm/wet: bias forest on eligible land
                    if (forestIdx !== -1 &&
                        rainfall > 95 &&
                        (biome === globals.g_GrasslandBiome ||
                            biome === globals.g_TropicalBiome)) {
                        if ((ctx ? ctxRandom(ctx, "Volcanic Forest", 100) : TerrainBuilder.getRandomNumber(100, "Volcanic Forest")) < volcanicForestChance) {
                            const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, forestIdx) : TerrainBuilder.canHaveFeature(x, y, forestIdx);
                            if (canPlace) {
                                if (ctx && ctx.adapter) {
                                    ctx.adapter.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                                } else {
                                    TerrainBuilder.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                                }
                                continue; // placed a feature; skip other tweaks on this tile
                            }
                        }
                    }
                    // Cold/wet: bias taiga in suitable tundra pockets
                    if (taigaIdx !== -1 &&
                        plat >= 55 &&
                        biome === globals.g_TundraBiome &&
                        elevation < 400 &&
                        rainfall > 60) {
                        if ((ctx ? ctxRandom(ctx, "Volcanic Taiga", 100) : TerrainBuilder.getRandomNumber(100, "Volcanic Taiga")) < volcanicTaigaChance) {
                            const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, taigaIdx) : TerrainBuilder.canHaveFeature(x, y, taigaIdx);
                            if (canPlace) {
                                if (ctx && ctx.adapter) {
                                    ctx.adapter.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                                } else {
                                    TerrainBuilder.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                                }
                                continue;
                            }
                        }
                    }
                }
            }
            // 3b) Gentle density tweaks (validated)
            // Enhanced jungle in tropical high-rainfall areas
            if (rainforestIdx !== -1 &&
                biome === globals.g_TropicalBiome &&
                rainfall > 130) {
                if ((ctx ? ctxRandom(ctx, "Extra Jungle", 100) : TerrainBuilder.getRandomNumber(100, "Extra Jungle")) <
                    rainforestExtraChance) {
                    const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, rainforestIdx) : TerrainBuilder.canHaveFeature(x, y, rainforestIdx);
                    if (canPlace) {
                        if (ctx && ctx.adapter) {
                            ctx.adapter.setFeatureType(x, y, { Feature: rainforestIdx, Direction: -1, Elevation: 0 });
                        } else {
                            TerrainBuilder.setFeatureType(x, y, { Feature: rainforestIdx, Direction: -1, Elevation: 0 });
                        }
                        continue;
                    }
                }
            }
            // Enhanced forests in temperate grasslands
            if (forestIdx !== -1 &&
                biome === globals.g_GrasslandBiome &&
                rainfall > 100) {
                if ((ctx ? ctxRandom(ctx, "Extra Forest", 100) : TerrainBuilder.getRandomNumber(100, "Extra Forest")) <
                    forestExtraChance) {
                    const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, forestIdx) : TerrainBuilder.canHaveFeature(x, y, forestIdx);
                    if (canPlace) {
                        if (ctx && ctx.adapter) {
                            ctx.adapter.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                        } else {
                            TerrainBuilder.setFeatureType(x, y, { Feature: forestIdx, Direction: -1, Elevation: 0 });
                        }
                        continue;
                    }
                }
            }
            // Taiga in cold areas (low elevation)
            if (taigaIdx !== -1 &&
                biome === globals.g_TundraBiome &&
                elevation < 300) {
                if ((ctx ? ctxRandom(ctx, "Extra Taiga", 100) : TerrainBuilder.getRandomNumber(100, "Extra Taiga")) <
                    taigaExtraChance) {
                    const canPlace = ctx && ctx.adapter ? ctx.adapter.canHaveFeature(x, y, taigaIdx) : TerrainBuilder.canHaveFeature(x, y, taigaIdx);
                    if (canPlace) {
                        if (ctx && ctx.adapter) {
                            ctx.adapter.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                        } else {
                            TerrainBuilder.setFeatureType(x, y, { Feature: taigaIdx, Direction: -1, Elevation: 0 });
                        }
                        continue;
                    }
                }
            }
        }
    }
}
export default addDiverseFeatures;
</file>

<file path="mod/maps/layers/islands.js">
// @ts-nocheck
/**
 * Islands Layer  addIslandChains
 *
 * Seeds tiny offshore island clusters using a sparse fractal mask, with
 * additional alignment/bias along previously tagged hotspot trails to create
 * legible chains. Some hotspot centers are classified as paradise (reeffriendly,
 * lusher), others as volcanic (occasional cone peeking above the sea; tougher
 * vegetation nearby). Feature/biome micro-tweaks occur in other layers; this
 * module only handles terrain placement and StoryTag classification.
 *
 * Guardrails
 * - Preserves open sea lanes by avoiding tiles within a small radius of land.
 * - Keeps clusters tiny (13 tiles; 12 when hotspotbiased).
 * - Leaves heavy validation to feature layers (reefs/vegetation are validated there).
 * - O(width  height) with constant-time local checks.
 */
import * as globals from "/base-standard/maps/map-globals.js";
import { StoryTags } from "../story/tags.js";
import { STORY_TUNABLES, ISLANDS_CFG, CORRIDORS_CFG, } from "../bootstrap/tunables.js";
import { isAdjacentToLand, storyKey } from "../core/utils.js";
import { ctxRandom, writeHeightfield } from "../core/types.js";
/**
 * Place small island clusters in deep water, with hotspot bias.
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {import('../core/types.js').MapContext} [ctx] - Optional MapContext for adapter-based operations
 */
export function addIslandChains(iWidth, iHeight, ctx) {
    // Sparse mask: use mountain fractal as a high-threshold trigger
    FractalBuilder.create(globals.g_HillFractal, iWidth, iHeight, 5, 0);
    const fracPct = (ISLANDS_CFG?.fractalThresholdPercent ?? 90) | 0;
    const threshold = FractalBuilder.getHeightFromPercent(globals.g_HillFractal, Math.max(0, Math.min(100, fracPct)));
    // Tunables for hotspot classification and cone peeking
    const paradiseWeight = (STORY_TUNABLES?.hotspot?.paradiseBias ?? 2) | 0; // default 2
    const volcanicWeight = (STORY_TUNABLES?.hotspot?.volcanicBias ?? 1) | 0; // default 1
    const peakPercent = Math.max(0, Math.min(100, Math.round((STORY_TUNABLES?.hotspot?.volcanicPeakChance ?? 0.33) * 100) + 10));
    const applyTerrain = (tileX, tileY, terrain, isLand) => {
        if (ctx) {
            writeHeightfield(ctx, tileX, tileY, { terrain, isLand });
        }
        else {
            TerrainBuilder.setTerrainType(tileX, tileY, terrain);
        }
    };
    for (let y = 2; y < iHeight - 2; y++) {
        for (let x = 2; x < iWidth - 2; x++) {
            if (!GameplayMap.isWater(x, y))
                continue;
            // Keep islands away from existing land to preserve lanes
            const minDist = (ISLANDS_CFG?.minDistFromLandRadius ?? 2) | 0;
            if (isAdjacentToLand(x, y, Math.max(0, minDist)))
                continue;
            // Respect strategic sea-lane corridors: skip tiles near protected lanes
            const laneRadius = (CORRIDORS_CFG?.sea?.avoidRadius ?? 2) | 0;
            if (laneRadius > 0 &&
                StoryTags.corridorSeaLane &&
                StoryTags.corridorSeaLane.size > 0) {
                let nearSeaLane = false;
                for (let my = -laneRadius; my <= laneRadius && !nearSeaLane; my++) {
                    for (let mx = -laneRadius; mx <= laneRadius; mx++) {
                        const kk = storyKey(x + mx, y + my);
                        if (StoryTags.corridorSeaLane.has(kk)) {
                            nearSeaLane = true;
                            break;
                        }
                    }
                }
                if (nearSeaLane)
                    continue;
            }
            const v = FractalBuilder.getHeight(globals.g_HillFractal, x, y);
            const isHotspot = StoryTags.hotspot.has(storyKey(x, y));
            // Margin context (adjacent coastal segments tagged by margins)
            let nearActive = false;
            let nearPassive = false;
            for (let my = -1; my <= 1 && (!nearActive || !nearPassive); my++) {
                for (let mx = -1; mx <= 1; mx++) {
                    if (mx === 0 && my === 0)
                        continue;
                    const k = storyKey(x + mx, y + my);
                    if (!nearActive &&
                        StoryTags.activeMargin &&
                        StoryTags.activeMargin.has(k))
                        nearActive = true;
                    if (!nearPassive &&
                        StoryTags.passiveShelf &&
                        StoryTags.passiveShelf.has(k))
                        nearPassive = true;
                }
            }
            // Base sparse placement vs. hotspot- and margin-biased placement
            const denActive = (ISLANDS_CFG?.baseIslandDenNearActive ?? 5) | 0;
            const denElse = (ISLANDS_CFG?.baseIslandDenElse ?? 7) | 0;
            const baseIslandDen = nearActive ? denActive : denElse; // slightly more islands along active margins
            const baseAllowed = v > threshold &&
                (ctx ? ctxRandom(ctx, "Island Seed", baseIslandDen) : TerrainBuilder.getRandomNumber(baseIslandDen, "Island Seed")) ===
                    0;
            const hotspotAllowed = isHotspot &&
                (ctx ? ctxRandom(ctx, "Hotspot Island Seed", Math.max(1, (ISLANDS_CFG?.hotspotSeedDenom ?? 2) | 0)) : TerrainBuilder.getRandomNumber(Math.max(1, (ISLANDS_CFG?.hotspotSeedDenom ?? 2) | 0), "Hotspot Island Seed")) === 0;
            if (!(baseAllowed || hotspotAllowed))
                continue;
            // Default to coast water; occasionally let a volcanic center peek as land
            let centerTerrain = globals.g_CoastTerrain;
            let classifyParadise = false;
            if (isHotspot) {
                // Along passive shelves, slightly bias toward "paradise" centers
                const pWeight = paradiseWeight + (nearPassive ? 1 : 0);
                const vWeight = volcanicWeight;
                const bucket = pWeight + vWeight;
                const roll = ctx ? ctxRandom(ctx, "HotspotKind", bucket || 1) : TerrainBuilder.getRandomNumber(bucket || 1, "HotspotKind");
                classifyParadise = roll < pWeight;
                if (!classifyParadise) {
                    // Volcanic: rare cone peeking above sea level
                    if ((ctx ? ctxRandom(ctx, "HotspotPeak", 100) : TerrainBuilder.getRandomNumber(100, "HotspotPeak")) <
                        peakPercent) {
                        centerTerrain = globals.g_FlatTerrain;
                    }
                }
            }
            // Place center tile
            const centerIsLand = centerTerrain !== globals.g_CoastTerrain && centerTerrain !== globals.g_OceanTerrain;
            applyTerrain(x, y, centerTerrain, centerIsLand);
            // Classify center for downstream microclimates/features
            if (isHotspot) {
                if (classifyParadise) {
                    StoryTags.hotspotParadise.add(storyKey(x, y));
                }
                else {
                    StoryTags.hotspotVolcanic.add(storyKey(x, y));
                }
            }
            // Create a tiny cluster around the center (smaller for hotspot-biased)
            const maxCluster = Math.max(1, (ISLANDS_CFG?.clusterMax ?? 3) | 0);
            const count = 1 + (ctx ? ctxRandom(ctx, "Island Size", maxCluster) : TerrainBuilder.getRandomNumber(maxCluster, "Island Size"));
            for (let n = 0; n < count; n++) {
                const dx = (ctx ? ctxRandom(ctx, "dx", 3) : TerrainBuilder.getRandomNumber(3, "dx")) - 1;
                const dy = (ctx ? ctxRandom(ctx, "dy", 3) : TerrainBuilder.getRandomNumber(3, "dy")) - 1;
                const nx = x + dx;
                const ny = y + dy;
                if (nx <= 0 || nx >= iWidth - 1 || ny <= 0 || ny >= iHeight - 1)
                    continue;
                if (!GameplayMap.isWater(nx, ny))
                    continue;
                applyTerrain(nx, ny, globals.g_CoastTerrain, false);
            }
        }
    }
}
export default addIslandChains;
</file>

<file path="mod/maps/layers/landmass_plate.js">
// @ts-nocheck
/**
 * Plate-driven landmass generator
 *
 * Uses Civ VII WorldModel plate fields to carve land and ocean before the
 * remainder of the Swooper pipeline runs. The algorithm ranks tiles by plate
 * interior "stability" (WorldModel.shieldStability) and selects the highest
 * scoring tiles until the configured land/sea ratio is satisfied, while also
 * respecting boundary closeness to preserve coastlines.
 */

import * as globals from "/base-standard/maps/map-globals.js";
import { LANDMASS_CFG } from "../bootstrap/tunables.js";
import { WorldModel } from "../world/model.js";
import { writeHeightfield } from "../core/types.js";

// Default closeness gating for land selection. We keep the full 0255 band so
// that boundary tiles remain eligible; presets can still clamp via geometry.post.
const DEFAULT_CLOSENESS_LIMIT = 255;
const CLOSENESS_STEP_PER_TILE = 8;
const MIN_CLOSENESS_LIMIT = 150;
const MAX_CLOSENESS_LIMIT = 255;

const BOUNDARY_TYPE = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});
// Reserve a dedicated tectonic fractal slot for interior noise and arc raggedness.
// Base-standard maps typically claim 0..2; we keep 3 for Swooper tectonics.
const FRACTAL_TECTONIC_ID = 3;

/**
 * Create landmasses using plate stability metrics.
 *
 * @param {number} width
 * @param {number} height
 * @param {import("../core/types.js").MapContext} [ctx]
 * @param {{ landmassCfg?: any, geometry?: any }} [options]
 * @returns {{ windows: Array<{west:number,east:number,south:number,north:number,continent:number}>, startRegions?: {westContinent?:any,eastContinent?:any}, landMask: Uint8Array }|null}
 */
export function createPlateDrivenLandmasses(width, height, ctx, options = {}) {
    if (!WorldModel || typeof WorldModel.isEnabled !== "function" || !WorldModel.isEnabled()) {
        return null;
    }
    const shield = WorldModel.shieldStability;
    const closeness = WorldModel.boundaryCloseness;
    const boundaryType = WorldModel.boundaryType;
    const plateIds = WorldModel.plateId;
    if (!shield || !closeness || !boundaryType || !plateIds) {
        return null;
    }
    const size = width * height;
    if (shield.length !== size || closeness.length !== size || boundaryType.length !== size || plateIds.length !== size) {
        return null;
    }
    const landmassCfg = options.landmassCfg || LANDMASS_CFG || {};
    // Keep a modest bias toward margins but clamp to a core-first band.
    const boundaryBias = clampInt(
        Number.isFinite(landmassCfg.boundaryBias) ? landmassCfg.boundaryBias : 0.25,
        0,
        0.4
    );
    const boundaryShareTarget = Number.isFinite(landmassCfg.boundaryShareTarget)
        ? Math.max(0, Math.min(1, landmassCfg.boundaryShareTarget))
        : 0.15;
    const tectonicsCfg = landmassCfg.tectonics || {};
    const interiorNoiseWeight = clamp01(tectonicsCfg.interiorNoiseWeight, 0.3);
    const arcWeight = clampRange(tectonicsCfg.boundaryArcWeight, 0.8, 0, 2);
    const arcNoiseWeight = clamp01(tectonicsCfg.boundaryArcNoiseWeight, 0.5);
    const fractalGrain = clampInt(
        Number.isFinite(tectonicsCfg.fractalGrain) ? tectonicsCfg.fractalGrain : 4,
        1,
        32
    );
    const geomCfg = options.geometry || {};
    const postCfg = geomCfg.post || {};

    // Earth-like baseline water coverage with a scalar to nudge wetter/drier worlds.
    const baseWaterPct = clampPct(landmassCfg.baseWaterPercent, 0, 100, 64);
    const waterScalar = clampPct(
        Number.isFinite(landmassCfg.waterScalar) ? landmassCfg.waterScalar * 100 : 100,
        25,
        175,
        100
    ) / 100;
    const waterPct = clampPct(baseWaterPct * waterScalar, 0, 100, baseWaterPct);
    const totalTiles = size || 1;
    const targetLandTiles = Math.max(1, Math.min(totalTiles - 1, Math.round(totalTiles * (1 - waterPct / 100))));

    // Allow high-closeness tiles to become land when scored high.
    const closenessLimit = computeClosenessLimit(postCfg);
    const adapter = ctx?.adapter;
    const useFractal = !!(
        adapter &&
        typeof adapter.createFractal === "function" &&
        typeof adapter.getFractalHeight === "function" &&
        (interiorNoiseWeight > 0 || arcNoiseWeight > 0)
    );
    if (useFractal) {
        adapter.createFractal(FRACTAL_TECTONIC_ID, width, height, fractalGrain, 0);
    }
    const baseInteriorWeight = 1 - interiorNoiseWeight;
    const interiorScore = new Uint16Array(size);
    const arcScore = new Uint16Array(size);
    const landScore = new Uint16Array(size);
    // Debug stats to validate score ranges before thresholding.
    let interiorMin = 255, interiorMax = 0, interiorSum = 0;
    let arcMin = 255, arcMax = 0, arcSum = 0;
    let landMin = 255, landMax = 0, landSum = 0;

    for (let y = 0; y < height; y++) {
        const rowOffset = y * width;
        for (let x = 0; x < width; x++) {
            const idx = rowOffset + x;
            const closenessVal = closeness[idx] | 0;
            const interiorBase = 255 - closenessVal;

            // --- Interior score: plate core + tectonic noise ---
            let noise255 = 128;
            if (useFractal && interiorNoiseWeight > 0) {
                const raw = adapter.getFractalHeight(FRACTAL_TECTONIC_ID, x, y) | 0;
                noise255 = raw >>> 8; // downscale 0..65535  0..255
            }
            const centeredNoise = noise255 - 128; // -128..127
            const noisyInterior = interiorBase * baseInteriorWeight + centeredNoise * interiorNoiseWeight;
            const clampedInterior = noisyInterior < 0 ? 0 : noisyInterior > 255 ? 255 : noisyInterior;
            const interiorVal = clampedInterior & 0xff;
            interiorScore[idx] = interiorVal;
            interiorMin = Math.min(interiorMin, interiorVal);
            interiorMax = Math.max(interiorMax, interiorVal);
            interiorSum += interiorVal;

            // --- Arc score: convergent uplift / island arcs ---
            const bType = boundaryType[idx] | 0;
            const rawArc = closenessVal;
            let arc = rawArc;
            if (bType === BOUNDARY_TYPE.convergent) {
                arc = rawArc * arcWeight;
            }
            else if (bType === BOUNDARY_TYPE.divergent) {
                arc = rawArc * 0.25;
            }
            else {
                arc = rawArc * 0.5;
            }
            if (useFractal && arcNoiseWeight > 0) {
                const raw = adapter.getFractalHeight(FRACTAL_TECTONIC_ID, x, y) | 0;
                const noiseNorm = (raw >>> 8) / 255; // 0..1
                const noiseMix = 0.5 + (noiseNorm - 0.5) * arcNoiseWeight; // ~[0.5, 1.5] scaled by weight
                arc *= noiseMix;
            }
            if (boundaryBias > 0) {
                arc += closenessVal * boundaryBias;
            }
            const clampedArc = arc < 0 ? 0 : arc > 255 ? 255 : arc;
            arcScore[idx] = clampedArc & 0xff;
            arcMin = Math.min(arcMin, arcScore[idx]);
            arcMax = Math.max(arcMax, arcScore[idx]);
            arcSum += arcScore[idx];

            // --- Final land score: core vs boundary uplift ---
            const l = interiorVal >= clampedArc ? interiorVal : clampedArc;
            landScore[idx] = l;
            landMin = Math.min(landMin, l);
            landMax = Math.max(landMax, l);
            landSum += l;
        }
    }

    const computeLandScore = (idx) => landScore[idx] | 0;

    const countTilesAboveTyped = (threshold) => {
        let count = 0;
        for (let i = 0; i < size; i++) {
            const score = computeLandScore(i);
            if (score >= threshold && closeness[i] <= closenessLimit) {
                count++;
            }
        }
        return count;
    };

    // Distribution and sanity logs to avoid zero-land failures.
    const thresholdsProbe = [32, 64, 96, 128, 160, 192, 224];
    const probeCounts = thresholdsProbe.map((t) => ({
        threshold: t,
        count: countTilesAboveTyped(t),
    }));

    console.log(
        "[Landmass][Debug] score ranges",
        JSON.stringify({
            width,
            height,
            targetLandTiles,
            closenessLimit,
            boundaryBias,
            boundaryShareTarget,
            interiorNoiseWeight,
            arcWeight,
            arcNoiseWeight,
            fractalGrain,
            useFractal,
            interior: {
                min: interiorMin,
                max: interiorMax,
                avg: Number((interiorSum / totalTiles).toFixed(2)),
            },
            arc: {
                min: arcMin,
                max: arcMax,
                avg: Number((arcSum / totalTiles).toFixed(2)),
            },
            land: {
                min: landMin,
                max: landMax,
                avg: Number((landSum / totalTiles).toFixed(2)),
            },
            probes: probeCounts,
        })
    );

    // Binary search threshold to hit target land count.
    let low = 0;
    let high = 255;
    let bestThreshold = 128;
    let bestDiff = Number.POSITIVE_INFINITY;
    let bestCount = 0;
    while (low <= high) {
        const mid = (low + high) >> 1;
        const count = countTilesAboveTyped(mid);
        const diff = Math.abs(count - targetLandTiles);
        if (diff < bestDiff || (diff === bestDiff && count > bestCount)) {
            bestDiff = diff;
            bestThreshold = mid;
            bestCount = count;
        }
        if (count > targetLandTiles) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    // Ensure a minimum share of land within the high-closeness band near boundaries.
    const boundaryBand = (closenessArr, idx) => (closenessArr[idx] | 0) >= 90;
    const computeShares = (threshold) => {
        let land = 0, boundaryLand = 0, convergentLand = 0;
        for (let i = 0; i < size; i++) {
            const score = computeLandScore(i);
            const isLand = score >= threshold && closeness[i] <= closenessLimit;
            if (isLand) {
                land++;
                if (boundaryBand(closeness, i)) boundaryLand++;
                if (boundaryType[i] === BOUNDARY_TYPE.convergent) convergentLand++;
            }
        }
        return { land, boundaryLand, convergentLand };
    };

    let { land: landCount, boundaryLand } = computeShares(bestThreshold);
    const minBoundary = Math.round(targetLandTiles * boundaryShareTarget);
    if (boundaryLand < minBoundary) {
        const maxAllowedLand = Math.round(targetLandTiles * 1.03);
        let t = bestThreshold - 5;
        while (t >= 0) {
            const shares = computeShares(t);
            landCount = shares.land;
            boundaryLand = shares.boundaryLand;
            if (boundaryLand >= minBoundary) {
                bestThreshold = t;
                break;
            }
            if (landCount > maxAllowedLand) {
                break;
            }
            t -= 5;
        }
    }

    const landMask = new Uint8Array(size);
    let finalLandTiles = 0;
    let convergentLandCount = 0;
    let divergentOceanCount = 0;
    for (let y = 0; y < height; y++) {
        const rowOffset = y * width;
        for (let x = 0; x < width; x++) {
            const idx = rowOffset + x;
            const score = computeLandScore(idx);
            const isLand = score >= bestThreshold && closeness[idx] <= closenessLimit;
            if (isLand) {
                if (boundaryType[idx] === BOUNDARY_TYPE.convergent) convergentLandCount++;
                landMask[idx] = 1;
                finalLandTiles++;
                if (ctx) {
                    writeHeightfield(ctx, x, y, {
                        terrain: globals.g_FlatTerrain,
                        elevation: 0,
                        isLand: true,
                    });
                }
                else {
                    setTerrain(null, x, y, globals.g_FlatTerrain);
                }
            }
            else {
                if (boundaryType[idx] === BOUNDARY_TYPE.divergent) divergentOceanCount++;
                landMask[idx] = 0;
                if (ctx) {
                    writeHeightfield(ctx, x, y, {
                        terrain: globals.g_OceanTerrain,
                        elevation: -1,
                        isLand: false,
                    });
                }
                else {
                    setTerrain(null, x, y, globals.g_OceanTerrain);
                }
            }
        }
    }

    console.log(
        `[Landmass] Core-vs-boundary scoring: threshold=${bestThreshold}, land=${finalLandTiles}, convergentLand=${convergentLandCount}, divergentOcean=${divergentOceanCount}, boundaryShare=${boundaryLand}/${Math.round(
            targetLandTiles * boundaryShareTarget
        )}`
    );

    // Derive bounding boxes per plate for downstream start placement heuristics.
    const plateStats = new Map();
    for (let idx = 0; idx < size; idx++) {
        if (!landMask[idx])
            continue;
        const plateId = plateIds[idx];
        if (plateId == null || plateId < 0)
            continue;
        const y = Math.floor(idx / width);
        const x = idx - y * width;
        let stat = plateStats.get(plateId);
        if (!stat) {
            stat = {
                plateId,
                count: 0,
                minX: width,
                maxX: -1,
                minY: height,
                maxY: -1,
            };
            plateStats.set(plateId, stat);
        }
        stat.count++;
        if (x < stat.minX)
            stat.minX = x;
        if (x > stat.maxX)
            stat.maxX = x;
        if (y < stat.minY)
            stat.minY = y;
        if (y > stat.maxY)
            stat.maxY = y;
    }

    const minWidth = postCfg.minWidthTiles ? Math.max(1, Math.trunc(postCfg.minWidthTiles)) : 0;
    const polarRows = globals.g_PolarWaterRows ?? 0;

    const windows = Array.from(plateStats.values())
        .filter((s) => s.count > 0 && s.maxX >= s.minX && s.maxY >= s.minY)
        .map((s) => {
        const expand = postCfg.expandTiles ? Math.trunc(postCfg.expandTiles) : 0;
        const expandWest = postCfg.expandWestTiles ? Math.trunc(postCfg.expandWestTiles) : 0;
        const expandEast = postCfg.expandEastTiles ? Math.trunc(postCfg.expandEastTiles) : 0;
        let west = Math.max(0, s.minX - Math.max(0, expand + expandWest));
        let east = Math.min(width - 1, s.maxX + Math.max(0, expand + expandEast));
        if (minWidth > 0) {
            const span = east - west + 1;
            if (span < minWidth) {
                const deficit = minWidth - span;
                const extraWest = Math.floor(deficit / 2);
                const extraEast = deficit - extraWest;
                west = Math.max(0, west - extraWest);
                east = Math.min(width - 1, east + extraEast);
            }
        }
        if (postCfg.clampWestMin != null) {
            west = Math.max(west, Math.max(0, Math.trunc(postCfg.clampWestMin)));
        }
        if (postCfg.clampEastMax != null) {
            east = Math.min(east, Math.min(width - 1, Math.trunc(postCfg.clampEastMax)));
        }
        const verticalPad = Math.max(0, expand);
        const baseSouth = Math.max(polarRows, s.minY - verticalPad);
        const baseNorth = Math.min(height - polarRows, s.maxY + verticalPad);
        const south = postCfg.overrideSouth != null
            ? clampInt(Math.trunc(postCfg.overrideSouth), 0, height - 1)
            : clampInt(baseSouth, 0, height - 1);
        const north = postCfg.overrideNorth != null
            ? clampInt(Math.trunc(postCfg.overrideNorth), 0, height - 1)
            : clampInt(baseNorth, 0, height - 1);
        return {
            plateId: s.plateId,
            west,
            east,
            south,
            north,
            centerX: (west + east) * 0.5,
            count: s.count,
        };
    })
        .sort((a, b) => a.centerX - b.centerX);

    const windowsOut = windows.map((win, index) => ({
        west: win.west,
        east: win.east,
        south: win.south,
        north: win.north,
        continent: index,
    }));

    let startRegions = null;
    if (windowsOut.length >= 2) {
        startRegions = {
            westContinent: Object.assign({}, windowsOut[0]),
            eastContinent: Object.assign({}, windowsOut[windowsOut.length - 1]),
        };
    }

    if (ctx?.buffers?.heightfield?.landMask) {
        ctx.buffers.heightfield.landMask.set(landMask);
    }

    return {
        windows: windowsOut,
        startRegions,
        landMask,
        landTiles: finalLandTiles,
        threshold: bestThreshold,
    };
}

function computeClosenessLimit(postCfg) {
    const expand = postCfg && postCfg.expandTiles ? Math.trunc(postCfg.expandTiles) : 0;
    const limit = DEFAULT_CLOSENESS_LIMIT + expand * CLOSENESS_STEP_PER_TILE;
    return clampInt(limit, MIN_CLOSENESS_LIMIT, MAX_CLOSENESS_LIMIT);
}

function countTilesAbove(shield, closeness, threshold, closenessLimit, boundaryBias = 0) {
    const bias = Math.max(0, boundaryBias);
    let count = 0;
    for (let i = 0; i < shield.length; i++) {
        const score = (shield[i] | 0) + Math.round((closeness[i] | 0) * bias);
        if (score >= threshold && closeness[i] <= closenessLimit) {
            count++;
        }
    }
    return count;
}

function setTerrain(adapter, x, y, terrainType) {
    if (adapter) {
        adapter.setTerrainType(x, y, terrainType);
    }
    else {
        TerrainBuilder.setTerrainType(x, y, terrainType);
    }
}

function clampPct(value, min, max, fallback) {
    if (!Number.isFinite(value))
        return fallback;
    const v = Math.max(min, Math.min(max, value));
    return v;
}

function clampInt(value, min, max) {
    if (!Number.isFinite(value))
        return min;
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

function clamp01(value, fallback = 0) {
    if (!Number.isFinite(value))
        return fallback;
    if (value < 0)
        return 0;
    if (value > 1)
        return 1;
    return value;
}

function clampRange(value, fallback, min, max) {
    if (!Number.isFinite(value))
        return fallback;
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

export default createPlateDrivenLandmasses;
</file>

<file path="mod/maps/layers/landmass_utils.js">
// @ts-nocheck
/* global TerrainBuilder */
/**
 * Shared helpers for landmass generation.
 */

import * as globals from "/base-standard/maps/map-globals.js";
import { FOUNDATION_OCEAN_SEPARATION } from "../bootstrap/tunables.js";
import { WorldModel } from "../world/model.js";
import { writeHeightfield } from "../core/types.js";

/**
 * Apply geometry post-processing adjustments defined in config.
 *
 * @param {Array<{west:number,east:number,south:number,north:number,continent:number}>} windows
 * @param {any} geometry
 * @param {number} width
 * @param {number} height
 */
export function applyLandmassPostAdjustments(windows, geometry, width, height) {
    if (!Array.isArray(windows) || windows.length === 0)
        return windows;
    const post = geometry?.post;
    if (!post || typeof post !== "object")
        return windows;
    const expandAll = Number.isFinite(post.expandTiles) ? Math.trunc(post.expandTiles) : 0;
    const expandWest = Number.isFinite(post.expandWestTiles) ? Math.trunc(post.expandWestTiles) : 0;
    const expandEast = Number.isFinite(post.expandEastTiles) ? Math.trunc(post.expandEastTiles) : 0;
    const clampWest = Number.isFinite(post.clampWestMin) ? Math.max(0, Math.trunc(post.clampWestMin)) : null;
    const clampEast = Number.isFinite(post.clampEastMax) ? Math.min(width - 1, Math.trunc(post.clampEastMax)) : null;
    const overrideSouth = Number.isFinite(post.overrideSouth) ? clampInt(Math.trunc(post.overrideSouth), 0, height - 1) : null;
    const overrideNorth = Number.isFinite(post.overrideNorth) ? clampInt(Math.trunc(post.overrideNorth), 0, height - 1) : null;
    const minWidth = Number.isFinite(post.minWidthTiles) ? Math.max(0, Math.trunc(post.minWidthTiles)) : null;
    let changed = false;
    const adjusted = windows.map((win) => {
        if (!win)
            return win;
        let west = clampInt(win.west | 0, 0, width - 1);
        let east = clampInt(win.east | 0, 0, width - 1);
        let south = clampInt(win.south | 0, 0, height - 1);
        let north = clampInt(win.north | 0, 0, height - 1);
        const expansionWest = expandAll + expandWest;
        const expansionEast = expandAll + expandEast;
        if (expansionWest > 0)
            west = clampInt(west - expansionWest, 0, width - 1);
        if (expansionEast > 0)
            east = clampInt(east + expansionEast, 0, width - 1);
        if (clampWest != null)
            west = Math.max(west, clampWest);
        if (clampEast != null)
            east = Math.min(east, clampEast);
        if (minWidth != null && minWidth > 0) {
            const span = east - west + 1;
            if (span < minWidth) {
                const deficit = minWidth - span;
                const extraWest = Math.floor(deficit / 2);
                const extraEast = deficit - extraWest;
                west = clampInt(west - extraWest, 0, width - 1);
                east = clampInt(east + extraEast, 0, width - 1);
            }
        }
        if (overrideSouth != null)
            south = overrideSouth;
        if (overrideNorth != null)
            north = overrideNorth;
        const mutated = west !== win.west || east !== win.east || south !== win.south || north !== win.north;
        if (mutated)
            changed = true;
        if (!mutated)
            return win;
        return {
            west,
            east,
            south,
            north,
            continent: win.continent,
        };
    });
    return changed ? adjusted : windows;
}

function clampInt(value, min, max) {
    if (value < min)
        return min;
    if (value > max)
        return max;
    return value;
}

/**
 * Apply plate-aware ocean separation to landmasses after generation.
 *
 * Widens or narrows ocean channels based on WorldModel boundary closeness,
 * mutating both the supplied land mask (when available) and returning updated
 * landmass windows for downstream consumers.
 *
 * @param {{
 *   width: number,
 *   height: number,
 *   windows: ReadonlyArray<{west:number,east:number,south:number,north:number,continent?:number}>,
 *   landMask?: Uint8Array | null,
 *   context?: import("../core/types.js").MapContext | null,
 *   adapter?: { setTerrainType?(x:number,y:number,terrain:number):void } | null,
 *   policy?: any,
 *   worldModel?: typeof WorldModel | null,
 * }} params
 * @returns {{ windows: Array<{west:number,east:number,south:number,north:number,continent:number}>, landMask?: Uint8Array }}
 */
export function applyPlateAwareOceanSeparation(params) {
    const width = params?.width | 0;
    const height = params?.height | 0;
    const windows = Array.isArray(params?.windows) ? params.windows : [];
    if (!width || !height || windows.length === 0) {
        return { windows: windows.map((win, idx) => normalizeWindow(win, idx, width, height)) };
    }
    const ctx = params?.context ?? null;
    const adapter = params?.adapter && typeof params.adapter.setTerrainType === "function"
        ? params.adapter
        : null;
    const worldModel = params?.worldModel ?? WorldModel;
    const policy = params?.policy || worldModel?.policy?.oceanSeparation || FOUNDATION_OCEAN_SEPARATION;
    if (!policy || !policy.enabled || !worldModel || typeof worldModel.isEnabled !== "function" || !worldModel.isEnabled()) {
        return {
            windows: windows.map((win, idx) => normalizeWindow(win, idx, width, height)),
            landMask: params?.landMask ?? undefined,
        };
    }
    const closeness = worldModel.boundaryCloseness;
    if (!closeness || closeness.length !== width * height) {
        return {
            windows: windows.map((win, idx) => normalizeWindow(win, idx, width, height)),
            landMask: params?.landMask ?? undefined,
        };
    }
    const landMask = params?.landMask instanceof Uint8Array && params.landMask.length === width * height
        ? params.landMask
        : null;
    const heightfield = ctx?.buffers?.heightfield;
    const bandPairs = Array.isArray(policy.bandPairs) && policy.bandPairs.length
        ? policy.bandPairs
        : [
            [0, 1],
            [1, 2],
        ];
    const baseSeparation = Math.max(0, policy.baseSeparationTiles | 0 || 0);
    const closenessMultiplier = Number.isFinite(policy.boundaryClosenessMultiplier)
        ? policy.boundaryClosenessMultiplier
        : 1.0;
    const maxPerRow = Math.max(0, policy.maxPerRowDelta | 0 || 3);
    const rowStates = windows.map((win, idx) => createRowState(win, idx, width, height));
    const setTerrain = (x, y, terrain, isLand) => {
        if (x < 0 || x >= width || y < 0 || y >= height)
            return;
        const idx = y * width + x;
        if (landMask) {
            landMask[idx] = isLand ? 1 : 0;
        }
        if (ctx) {
            writeHeightfield(ctx, x, y, {
                terrain,
                isLand,
            });
        }
        else if (adapter) {
            adapter.setTerrainType(x, y, terrain);
        }
        else {
            TerrainBuilder.setTerrainType(x, y, terrain);
        }
        if (heightfield && !landMask) {
            heightfield.landMask[idx] = isLand ? 1 : 0;
        }
    };
    const carveOceanFromEast = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let removed = 0;
        let x = state.east[y];
        const limit = state.west[y];
        const rowOffset = y * width;
        while (removed < tiles && x >= limit) {
            const idx = rowOffset + x;
            if (!landMask || landMask[idx]) {
                setTerrain(x, y, globals.g_OceanTerrain, false);
                removed++;
            }
            x--;
        }
        state.east[y] = clampInt(state.east[y] - removed, limit, width - 1);
        return removed;
    };
    const carveOceanFromWest = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let removed = 0;
        let x = state.west[y];
        const limit = state.east[y];
        const rowOffset = y * width;
        while (removed < tiles && x <= limit) {
            const idx = rowOffset + x;
            if (!landMask || landMask[idx]) {
                setTerrain(x, y, globals.g_OceanTerrain, false);
                removed++;
            }
            x++;
        }
        state.west[y] = clampInt(state.west[y] + removed, 0, limit);
        return removed;
    };
    const fillLandFromWest = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let added = 0;
        let x = state.west[y] - 1;
        while (added < tiles && x >= 0) {
            setTerrain(x, y, globals.g_FlatTerrain, true);
            added++;
            x--;
        }
        state.west[y] = clampInt(state.west[y] - added, 0, width - 1);
        return added;
    };
    const fillLandFromEast = (state, y, tiles) => {
        if (!tiles)
            return 0;
        let added = 0;
        let x = state.east[y] + 1;
        while (added < tiles && x < width) {
            setTerrain(x, y, globals.g_FlatTerrain, true);
            added++;
            x++;
        }
        state.east[y] = clampInt(state.east[y] + added, 0, width - 1);
        return added;
    };
    for (const pair of bandPairs) {
        const li = Array.isArray(pair) ? pair[0] | 0 : -1;
        const ri = Array.isArray(pair) ? pair[1] | 0 : -1;
        const left = rowStates[li];
        const right = rowStates[ri];
        if (!left || !right)
            continue;
        const rowStart = Math.max(0, Math.max(left.south, right.south));
        const rowEnd = Math.min(height - 1, Math.min(left.north, right.north));
        for (let y = rowStart; y <= rowEnd; y++) {
            const mid = clampInt(Math.floor((left.east[y] + right.west[y]) / 2), 0, width - 1);
            const clos = closeness[y * width + mid] | 0;
            let sep = baseSeparation;
            if (sep > 0) {
                const weight = clos / 255;
                sep += Math.round(weight * closenessMultiplier * baseSeparation);
            }
            if (sep > maxPerRow)
                sep = maxPerRow;
            if (sep <= 0)
                continue;
            carveOceanFromEast(left, y, sep);
            carveOceanFromWest(right, y, sep);
        }
    }
    const edgeWest = policy.edgeWest || {};
    if (rowStates.length && edgeWest.enabled) {
        const state = rowStates[0];
        const base = edgeWest.baseTiles | 0 || 0;
        const mult = Number.isFinite(edgeWest.boundaryClosenessMultiplier)
            ? edgeWest.boundaryClosenessMultiplier
            : 1.0;
        const cap = Math.max(0, edgeWest.maxPerRowDelta | 0 || 2);
        for (let y = state.south; y <= state.north; y++) {
            const clos = closeness[y * width + 0] | 0;
            let mag = Math.abs(base) + Math.round((clos / 255) * Math.abs(base) * mult);
            if (mag > cap)
                mag = cap;
            if (mag <= 0)
                continue;
            if (base >= 0) {
                carveOceanFromWest(state, y, mag);
            }
            else {
                fillLandFromWest(state, y, mag);
            }
        }
    }
    const edgeEast = policy.edgeEast || {};
    if (rowStates.length && edgeEast.enabled) {
        const state = rowStates[rowStates.length - 1];
        const base = edgeEast.baseTiles | 0 || 0;
        const mult = Number.isFinite(edgeEast.boundaryClosenessMultiplier)
            ? edgeEast.boundaryClosenessMultiplier
            : 1.0;
        const cap = Math.max(0, edgeEast.maxPerRowDelta | 0 || 2);
        for (let y = state.south; y <= state.north; y++) {
            const clos = closeness[y * width + (width - 1)] | 0;
            let mag = Math.abs(base) + Math.round((clos / 255) * Math.abs(base) * mult);
            if (mag > cap)
                mag = cap;
            if (mag <= 0)
                continue;
            if (base >= 0) {
                carveOceanFromEast(state, y, mag);
            }
            else {
                fillLandFromEast(state, y, mag);
            }
        }
    }
    const normalized = rowStates.map((state) => aggregateRowState(state, width, height));
    if (ctx && landMask && ctx.buffers?.heightfield?.landMask) {
        ctx.buffers.heightfield.landMask.set(landMask);
    }
    return {
        windows: normalized,
        landMask: landMask ?? undefined,
    };
}

function createRowState(win, index, width, height) {
    const normalized = normalizeWindow(win, index, width, height);
    const west = new Int16Array(height);
    const east = new Int16Array(height);
    for (let y = 0; y < height; y++) {
        west[y] = normalized.west;
        east[y] = normalized.east;
    }
    return {
        index,
        west,
        east,
        south: normalized.south,
        north: normalized.north,
        continent: normalized.continent,
    };
}

function aggregateRowState(state, width, height) {
    let minWest = width - 1;
    let maxEast = 0;
    const south = clampInt(state.south, 0, height - 1);
    const north = clampInt(state.north, 0, height - 1);
    for (let y = south; y <= north; y++) {
        if (state.west[y] < minWest)
            minWest = state.west[y];
        if (state.east[y] > maxEast)
            maxEast = state.east[y];
    }
    return {
        west: clampInt(minWest, 0, width - 1),
        east: clampInt(maxEast, 0, width - 1),
        south,
        north,
        continent: state.continent,
    };
}

function normalizeWindow(win, index, width, height) {
    if (!win)
        return {
            west: 0,
            east: Math.max(0, width - 1),
            south: 0,
            north: Math.max(0, height - 1),
            continent: index,
        };
    const west = clampInt(win.west | 0, 0, width - 1);
    const east = clampInt(win.east | 0, 0, width - 1);
    const south = clampInt(win.south | 0, 0, height - 1);
    const north = clampInt(win.north | 0, 0, height - 1);
    return {
        west: Math.min(west, east),
        east: Math.max(west, east),
        south: Math.min(south, north),
        north: Math.max(south, north),
        continent: win.continent ?? index,
    };
}
</file>

<file path="mod/maps/layers/mountains.js">
// @ts-nocheck
/**
 * Mountains Layer  Physics-Based Mountain and Rift Placement (Phase 2)
 *
 * Purpose:
 * - Replace random fractal mountain placement with plate-boundary-driven orogenesis
 * - Place mountain chains along convergent boundaries (collision zones)
 * - Create rift valleys and lowlands along divergent boundaries (spreading zones)
 * - Use WorldModel.upliftPotential and tile-precise boundary data for accurate placement
 *
 * Architecture:
 * - Reads WorldModel plate boundary data (Phase 1.5 output)
 * - Uses MapContext + Adapter pattern (Phase 1 foundation)
 * - Blends WorldModel-driven placement with optional fractal noise for variety
 * - Backward compatible: Falls back to base game fractals if WorldModel disabled
 *
 * Usage:
 *   import { layerAddMountainsPhysics } from "./layers/mountains.js";
 *   layerAddMountainsPhysics(ctx, {
 *     tectonicIntensity: 1.2,    // Higher = stronger tectonic effects = more mountains
 *     mountainThreshold: 0.45,   // Score threshold for mountains (lower = more permissive)
 *     hillThreshold: 0.25,       // Score threshold for hills
 *     upliftWeight: 0.75,        // 0..1, how much WorldModel drives placement
 *     fractalWeight: 0.25,       // 0..1, how much random fractal adds variety
 *   });
 */

import { WorldModel } from "../world/model.js";
import { ctxRandom, idx, writeHeightfield } from "../core/types.js";
import { devLogIf } from "../bootstrap/dev.js";
import * as globals from "/base-standard/maps/map-globals.js";

// Baseline Earthlike relief proportions (approximate) expressed as percent of
// land tiles. These act as canonical ratios; configs scale them via a single
// scalar instead of hard-coding absolute mountain/hill quotas per preset.
const BASE_MOUNTAIN_PERCENT = 14; //  mid-point between Civ-style and real-world highlands
const BASE_HILL_PERCENT = 28;     // hills cover roughly twice the mountainous area
const MAX_RELIEF_FRACTION = 0.7;  // safety cap so relief never exceeds ~70% of land

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

/**
 * Add mountains using WorldModel plate boundaries
 *
 * ARCHITECTURE: Physics-threshold based (not quota based)
 * - Mountains appear where physics score > mountainThreshold
 * - No forced quota - if tectonics don't create mountains, there are fewer mountains
 * - tectonicIntensity scales the physics parameters to control mountain prevalence
 * - This ensures mountains ONLY appear where plate tectonics justify them
 *
 * @param {import('../core/types.js').MapContext} ctx - Map context
 * @param {Object} options - Mountain generation options
 * @param {number} [options.tectonicIntensity=1.0] - Scales all tectonic effects (higher = more mountains)
 * @param {number} [options.mountainThreshold=0.45] - Score threshold for mountain placement (0..1)
 * @param {number} [options.hillThreshold=0.25] - Score threshold for hill placement (0..1)
 * @param {number} [options.upliftWeight=0.75] - Weight for WorldModel uplift (0..1)
 * @param {number} [options.fractalWeight=0.25] - Weight for fractal noise (0..1)
 * @param {number} [options.riftDepth=0.3] - Depression strength at rifts (0..1)
 * @param {number} [options.boundaryWeight=0.6] - Additional mountain weight contributed by boundary closeness
 * @param {number} [options.boundaryExponent=1.4] - Exponent applied to boundary closeness shaping belt width
 * @param {number} [options.interiorPenaltyWeight=0.2] - Penalty applied to interior tiles (push mountains toward margins)
 * @param {number} [options.convergenceBonus=0.9] - Added weight for convergent tiles (mountain belts)
 * @param {number} [options.transformPenalty=0.3] - Reduction applied to transform boundaries (flatter ridges)
 * @param {number} [options.riftPenalty=0.75] - Reduction applied to divergent tiles (discourage mountains in rifts)
 * @param {number} [options.hillBoundaryWeight=0.45] - Hill weight contributed by boundary closeness (foothills)
 * @param {number} [options.hillRiftBonus=0.5] - Hill bonus for divergent tiles (rift shoulders)
 * @param {number} [options.hillConvergentFoothill=0.25] - Hill bonus adjacent to convergent belts
 * @param {number} [options.hillInteriorFalloff=0.2] - Penalty for deep-interior tiles (keeps hills near action)
 * @param {number} [options.hillUpliftWeight=0.25] - Residual uplift contribution to hills
 */
export function layerAddMountainsPhysics(ctx, options = {}) {
    const {
        // Global relief scalar  higher values increase both tectonic forcing
        // and the fraction of land promoted to mountains/hills.
        tectonicIntensity = 1.0,
        // Legacy thresholds are still accepted but no longer drive the primary
        // selection; they act only as optional minimum-score floors.
        mountainThreshold = 0.0,
        hillThreshold = 0.0,
        // Physics weights (scaled by tectonicIntensity)
        upliftWeight = 0.75,
        fractalWeight = 0.25,
        riftDepth = 0.3,
        boundaryWeight = 0.6,
        boundaryExponent = 1.4,
        interiorPenaltyWeight = 0.2,
        convergenceBonus = 0.9,
        transformPenalty = 0.3,
        riftPenalty = 0.75,
        hillBoundaryWeight = 0.45,
        hillRiftBonus = 0.5,
        hillConvergentFoothill = 0.25,
        hillInteriorFalloff = 0.2,
        hillUpliftWeight = 0.25,
    } = options;

    // Scale physics parameters by tectonic intensity
    // Higher intensity = stronger boundary effects = more tiles exceed threshold
    const scaledConvergenceBonus = convergenceBonus * tectonicIntensity;
    const scaledBoundaryWeight = boundaryWeight * tectonicIntensity;
    const scaledUpliftWeight = upliftWeight * tectonicIntensity;
    const scaledHillBoundaryWeight = hillBoundaryWeight * tectonicIntensity;
    const scaledHillConvergentFoothill = hillConvergentFoothill * tectonicIntensity;

    const dimensions = ctx?.dimensions || {};
    const width = Number.isFinite(dimensions.width)
        ? dimensions.width
        : GameplayMap?.getGridWidth?.() ?? 0;
    const height = Number.isFinite(dimensions.height)
        ? dimensions.height
        : GameplayMap?.getGridHeight?.() ?? 0;
    const adapter = ctx?.adapter;

    if (!width || !height || !adapter) {
        devLogIf &&
            devLogIf("LOG_MOUNTAINS", "[Mountains] Missing dimensions/adapter; skipping placement", {
                width,
                height,
            hasAdapter: !!adapter,
        });
        return;
    }
    const isWater = createIsWaterTile(ctx, adapter, width, height);
    const terrainWriter = (x, y, terrain) => {
        const isLand = terrain !== globals.g_CoastTerrain && terrain !== globals.g_OceanTerrain;
        if (ctx) {
            writeHeightfield(ctx, x, y, { terrain, isLand });
        }
        else {
            adapter.setTerrainType(x, y, terrain);
        }
    };
    const worldModelEnabled = WorldModel.isEnabled();

    devLogIf &&
        devLogIf("LOG_MOUNTAINS", "[Mountains] Starting physics-based placement", {
            worldModelEnabled,
            upliftWeight,
            fractalWeight,
        });

    // Create fractals for base noise and variety
    const g_MountainFractal = 0;
    const g_HillFractal = 1;
    const grainAmount = 5;
    const iFlags = 0;

    FractalBuilder.create(g_MountainFractal, width, height, grainAmount, iFlags);
    FractalBuilder.create(g_HillFractal, width, height, grainAmount, iFlags);

    // Calculate target tile counts
    let landTiles = 0;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!isWater(x, y)) {
                landTiles++;
            }
        }
    }

    devLogIf &&
        devLogIf("LOG_MOUNTAINS", "[Mountains] Physics-threshold mode", {
            landTiles,
            tectonicIntensity,
            mountainThreshold,
            hillThreshold,
        });

    // Compute placement scores for each tile
    const scores = new Float32Array(width * height);
    const hillScores = new Float32Array(width * height);

    if (worldModelEnabled) {
        // Physics-based placement using WorldModel
        // Pass SCALED parameters - tectonicIntensity affects mountain prevalence
        computePlateBasedScores(ctx, scores, hillScores, {
            upliftWeight: scaledUpliftWeight,
            fractalWeight,
            g_MountainFractal,
            g_HillFractal,
            boundaryWeight: scaledBoundaryWeight,
            boundaryExponent,
            interiorPenaltyWeight,
            convergenceBonus: scaledConvergenceBonus,
            transformPenalty,
            riftPenalty,
            hillBoundaryWeight: scaledHillBoundaryWeight,
            hillRiftBonus,
            hillConvergentFoothill: scaledHillConvergentFoothill,
            hillInteriorFalloff,
            hillUpliftWeight,
        }, isWater);
    } else {
        // Fallback: pure fractal (base game behavior)
        computeFractalOnlyScores(ctx, scores, hillScores, {
            g_MountainFractal,
            g_HillFractal,
        });
    }

    // Apply rift depressions (lower scores at divergent boundaries)
    if (worldModelEnabled && riftDepth > 0) {
        applyRiftDepressions(ctx, scores, hillScores, riftDepth);
    }

    // Relief selection  quota-based with Earthlike proportions.
    //
    // We determine target mountain/hill counts as:
    //   landTiles  BASE_*_PERCENT  tectonicIntensity
    // subject to a global MAX_RELIEF_FRACTION cap. Scores still come from
    // physics; quotas only fix the *ratio* of relief to land.
    const selectionAdapter = {
        isWater,
    };

    let mountainFrac = BASE_MOUNTAIN_PERCENT / 100;
    let hillFrac = BASE_HILL_PERCENT / 100;
    mountainFrac *= tectonicIntensity;
    hillFrac *= tectonicIntensity;

    const totalFrac = mountainFrac + hillFrac;
    if (totalFrac > MAX_RELIEF_FRACTION && totalFrac > 0) {
        const k = MAX_RELIEF_FRACTION / totalFrac;
        mountainFrac *= k;
        hillFrac *= k;
    }

    const targetMountains = Math.max(1, Math.round(landTiles * mountainFrac));
    const targetHills = Math.max(1, Math.round(landTiles * hillFrac));

    const mountainTiles = selectTopScoringTiles(scores, width, height, targetMountains, selectionAdapter);
    const hillTiles = selectTopScoringTiles(hillScores, width, height, targetHills, selectionAdapter, mountainTiles);

    const mountainsPlaced = mountainTiles.size;
    const hillsPlaced = hillTiles.size;
    // Place mountains
    for (const i of mountainTiles) {
        const x = i % width;
        const y = Math.floor(i / width);
        terrainWriter(x, y, globals.g_MountainTerrain);
    }

    // Place hills
    for (const i of hillTiles) {
        const x = i % width;
        const y = Math.floor(i / width);
        terrainWriter(x, y, globals.g_HillTerrain);
    }

    const summary = {
        mode: "physics-quota",
        tectonicIntensity,
        baseMountainPercent: BASE_MOUNTAIN_PERCENT,
        baseHillPercent: BASE_HILL_PERCENT,
        targetMountains,
        targetHills,
        mountainsPlaced,
        hillsPlaced,
        mountainPercent: landTiles > 0 ? ((mountainsPlaced / landTiles) * 100).toFixed(1) + "%" : "0%",
        hillPercent: landTiles > 0 ? ((hillsPlaced / landTiles) * 100).toFixed(1) + "%" : "0%",
        landTiles,
        worldModelEnabled,
    };
    devLogIf && devLogIf("LOG_MOUNTAINS", "[Mountains] placement", JSON.stringify(summary));
}

/**
 * Compute plate-based mountain scores using WorldModel boundaries
 */
function computePlateBasedScores(ctx, scores, hillScores, options, isWaterCheck) {
    // Get dimensions properly from ctx.dimensions (not ctx.width/height which don't exist!)
    const dims = ctx?.dimensions || {};
    const width = Number.isFinite(dims.width) ? dims.width : (GameplayMap?.getGridWidth?.() ?? 0);
    const height = Number.isFinite(dims.height) ? dims.height : (GameplayMap?.getGridHeight?.() ?? 0);
    const {
        upliftWeight,
        fractalWeight,
        g_MountainFractal,
        g_HillFractal,
        boundaryWeight,
        boundaryExponent,
        interiorPenaltyWeight,
        convergenceBonus,
        transformPenalty,
        riftPenalty,
        hillBoundaryWeight,
        hillRiftBonus,
        hillConvergentFoothill,
        hillInteriorFalloff,
        hillUpliftWeight,
    } = options;

    const upliftPotential = WorldModel.upliftPotential;
    const boundaryType = WorldModel.boundaryType;
    const boundaryCloseness = WorldModel.boundaryCloseness;
    const riftPotential = WorldModel.riftPotential;

    if (!upliftPotential || !boundaryType) {
        // Fallback if WorldModel data missing
        devLogIf &&
            devLogIf("LOG_MOUNTAINS", "[Mountains] Falling back to fractal-only scores (missing WorldModel arrays)");
        computeFractalOnlyScores(ctx, scores, hillScores, options);
        return;
    }

    // ========== DEBUG #1: Diagnose Land/Uplift Disconnect ==========
    // (Reuses width/height declared at function start)
    const isWater = typeof isWaterCheck === "function" ? isWaterCheck : (x, y) => GameplayMap?.isWater?.(x, y) ?? false;

    // Collect diagnostic data
    let totalLandTiles = 0;
    let landUpliftSum = 0;
    let landClosenessSum = 0;
    const landByBoundaryType = [0, 0, 0, 0]; // none, convergent, divergent, transform
    const landUpliftBuckets = { under25: 0, under50: 0, under100: 0, over100: 0 };
    const landClosenessBuckets = { under64: 0, under128: 0, under192: 0, over192: 0 };

    // Row-by-row analysis for south bias detection
    const rowStats = [];
    const rowStep = Math.max(1, Math.floor(height / 10));

    for (let y = 0; y < height; y++) {
        let rowLandCount = 0;
        let rowLandUpliftSum = 0;
        let rowLandClosenessSum = 0;

        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const isLand = !isWater(x, y);

            if (isLand) {
                totalLandTiles++;
                const upliftVal = upliftPotential[i] | 0;
                const closenessVal = boundaryCloseness[i] | 0;
                const bType = boundaryType[i] | 0;

                landUpliftSum += upliftVal;
                landClosenessSum += closenessVal;

                if (bType >= 0 && bType < 4) landByBoundaryType[bType]++;

                if (upliftVal < 25) landUpliftBuckets.under25++;
                else if (upliftVal < 50) landUpliftBuckets.under50++;
                else if (upliftVal < 100) landUpliftBuckets.under100++;
                else landUpliftBuckets.over100++;

                if (closenessVal < 64) landClosenessBuckets.under64++;
                else if (closenessVal < 128) landClosenessBuckets.under128++;
                else if (closenessVal < 192) landClosenessBuckets.under192++;
                else landClosenessBuckets.over192++;

                rowLandCount++;
                rowLandUpliftSum += upliftVal;
                rowLandClosenessSum += closenessVal;
            }
        }

        if (y % rowStep === 0 || y === height - 1) {
            rowStats.push({
                row: y,
                landCount: rowLandCount,
                avgUplift: rowLandCount > 0 ? Math.round(rowLandUpliftSum / rowLandCount) : 0,
                avgCloseness: rowLandCount > 0 ? Math.round(rowLandClosenessSum / rowLandCount) : 0,
            });
        }
    }

    devLogIf && devLogIf("LOG_MOUNTAINS", "[DEBUG #1] ========== LAND/UPLIFT DIAGNOSTIC ==========");
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Total land tiles: ${totalLandTiles}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Avg uplift on land: ${totalLandTiles > 0 ? (landUpliftSum / totalLandTiles).toFixed(1) : 0} / 255`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Avg closeness on land: ${totalLandTiles > 0 ? (landClosenessSum / totalLandTiles).toFixed(1) : 0} / 255`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Land by boundary type: none=${landByBoundaryType[0]}, convergent=${landByBoundaryType[1]}, divergent=${landByBoundaryType[2]}, transform=${landByBoundaryType[3]}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Land uplift buckets: <25=${landUpliftBuckets.under25}, 25-50=${landUpliftBuckets.under50}, 50-100=${landUpliftBuckets.under100}, >100=${landUpliftBuckets.over100}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Land closeness buckets: <64=${landClosenessBuckets.under64}, 64-128=${landClosenessBuckets.under128}, 128-192=${landClosenessBuckets.under192}, >192=${landClosenessBuckets.over192}`);
    devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1] Row-by-row (south=0, north=${height-1}):`);
    rowStats.forEach(rs => {
        devLogIf && devLogIf("LOG_MOUNTAINS", `[DEBUG #1]   row ${rs.row}: land=${rs.landCount}, avgUplift=${rs.avgUplift}, avgCloseness=${rs.avgCloseness}`);
    });
    devLogIf && devLogIf("LOG_MOUNTAINS", "[DEBUG #1] ================================================");
    // ========== END DEBUG #1 ==========

    const boundaryGate = 0.20;  // Minimum closeness (0-1) to consider boundary effects
    const falloffExponent = boundaryExponent || 2.5;  // Exponential falloff for concentrated mountain belts

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);

            const uplift = upliftPotential ? upliftPotential[i] / 255 : 0;
            const bType = boundaryType[i];
            const closenessRaw = boundaryCloseness ? boundaryCloseness[i] / 255 : 0;
            const rift = riftPotential ? riftPotential[i] / 255 : 0;

            const fractalMtn = FractalBuilder.getHeight(g_MountainFractal, x, y) / 65535;
            const fractalHill = FractalBuilder.getHeight(g_HillFractal, x, y) / 65535;

            // Base score: uplift potential + fractal variety
            let mountainScore = uplift * upliftWeight + fractalMtn * fractalWeight;

            // Physics-based boundary effects with exponential falloff
            // Mountain building is most intense RIGHT AT the collision zone
            // BUT we modulate by fractal noise to create natural variation:
            // - Peaks where fractal is high
            // - Saddles/valleys where fractal is low
            // - Interruptions in the mountain chain
            if (closenessRaw > boundaryGate) {
                // Normalize to 0-1 above threshold, then apply exponential falloff
                const normalized = (closenessRaw - boundaryGate) / (1 - boundaryGate);
                const intensity = Math.pow(normalized, falloffExponent);

                // General boundary weight (foothills near any boundary)
                // Modulated by fractal to create variable foothill bands
                if (boundaryWeight > 0) {
                    const foothillNoise = 0.5 + fractalMtn * 0.5; // 0.5-1.0 range
                    mountainScore += intensity * boundaryWeight * foothillNoise;
                }

                // Boundary-type-specific modifiers
                if (bType === ENUM_BOUNDARY.convergent) {
                    // CONVERGENT: Strong mountain bonus concentrated at collision zone
                    // Modulated by fractal: creates peaks where noise is high, saddles where low
                    // fractalMtn ranges 0-1, so bonus ranges from 0.3x to 1.0x of full bonus
                    const peakNoise = 0.3 + fractalMtn * 0.7; // Minimum 30% ensures some mountains
                    mountainScore += intensity * convergenceBonus * peakNoise;
                }
                else if (bType === ENUM_BOUNDARY.divergent) {
                    // DIVERGENT: Suppress mountains (rift valleys, not peaks)
                    mountainScore *= Math.max(0, 1 - intensity * riftPenalty);
                }
                else if (bType === ENUM_BOUNDARY.transform) {
                    // TRANSFORM: Moderate suppression (strike-slip faults, linear valleys)
                    mountainScore *= Math.max(0, 1 - intensity * transformPenalty);
                }
            }

            // Interior penalty - push mountains toward plate margins
            if (interiorPenaltyWeight > 0) {
                const interiorPenalty = (1 - closenessRaw) * interiorPenaltyWeight;
                mountainScore = Math.max(0, mountainScore - interiorPenalty);
            }

            scores[i] = Math.max(0, mountainScore);

            // Hill scoring - foothills form around mountain belts with softer falloff
            // Hills use fractalHill for natural variation in foothill extent
            let hillScore = fractalHill * fractalWeight + uplift * hillUpliftWeight;

            if (closenessRaw > boundaryGate) {
                // Normalize and apply softer falloff for hills (sqrt instead of pow 2.5)
                // Hills spread wider than peaks, forming foothill bands
                const normalized = (closenessRaw - boundaryGate) / (1 - boundaryGate);
                const hillIntensity = Math.sqrt(normalized);  // Softer falloff for wider foothill bands

                // Variable foothill width based on fractal noise
                // Some areas have extensive foothills, others transition sharply
                const foothillExtent = 0.4 + fractalHill * 0.6; // 0.4-1.0 range

                if (hillBoundaryWeight > 0) {
                    hillScore += hillIntensity * hillBoundaryWeight * foothillExtent;
                }

                if (bType === ENUM_BOUNDARY.divergent) {
                    // Rift shoulders - hills along divergent boundaries (like East African Rift)
                    // Modulated by fractal for irregular rift shoulder terrain
                    hillScore += hillIntensity * rift * hillRiftBonus * foothillExtent;
                }
                else if (bType === ENUM_BOUNDARY.convergent) {
                    // Foothill bands adjacent to mountain belts
                    // Variable extent creates natural-looking piedmont zones
                    hillScore += hillIntensity * hillConvergentFoothill * foothillExtent;
                }
            }

            // Interior falloff - fewer hills deep in plate interiors
            if (hillInteriorFalloff > 0) {
                hillScore -= (1 - closenessRaw) * hillInteriorFalloff;
            }

            hillScores[i] = Math.max(0, hillScore);
        }
    }
}

/**
 * Select top N scoring tiles, excluding water and optionally excluding a set.
 * Scores remain physics-driven; this helper only fixes the *count* of tiles.
 *
 * @param {Float32Array} scores
 * @param {number} width
 * @param {number} height
 * @param {number} targetCount
 * @param {{ isWater(x:number,y:number):boolean }} adapter
 * @param {Set<number>|null} [excludeSet]
 * @returns {Set<number>}
 */
function selectTopScoringTiles(scores, width, height, targetCount, adapter, excludeSet = null) {
    const candidates = [];

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;

            // Skip water
            if (adapter.isWater(x, y)) continue;

            // Skip excluded tiles
            if (excludeSet && excludeSet.has(i)) continue;

            candidates.push({ index: i, score: scores[i] });
        }
    }

    if (!candidates.length || targetCount <= 0) {
        return new Set();
    }

    // Sort by score descending
    candidates.sort((a, b) => b.score - a.score);

    // Take top N
    const selected = new Set();
    const limit = Math.min(targetCount, candidates.length);
    for (let k = 0; k < limit; k++) {
        selected.add(candidates[k].index);
    }

    return selected;
}

/**
 * Fallback: pure fractal-based scores (base game approach)
 */
function computeFractalOnlyScores(ctx, scores, hillScores, options) {
    // Get dimensions properly from ctx.dimensions
    const dims = ctx?.dimensions || {};
    const width = Number.isFinite(dims.width) ? dims.width : (GameplayMap?.getGridWidth?.() ?? 0);
    const height = Number.isFinite(dims.height) ? dims.height : (GameplayMap?.getGridHeight?.() ?? 0);
    const { g_MountainFractal, g_HillFractal } = options;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);

            scores[i] = FractalBuilder.getHeight(g_MountainFractal, x, y) / 65535;
            hillScores[i] = FractalBuilder.getHeight(g_HillFractal, x, y) / 65535;
        }
    }
}

/**
 * Apply rift depressions (lower mountains/hills at divergent boundaries)
 */
function applyRiftDepressions(ctx, scores, hillScores, riftDepth) {
    // Get dimensions properly from ctx.dimensions
    const dims = ctx?.dimensions || {};
    const width = Number.isFinite(dims.width) ? dims.width : (GameplayMap?.getGridWidth?.() ?? 0);
    const height = Number.isFinite(dims.height) ? dims.height : (GameplayMap?.getGridHeight?.() ?? 0);
    const riftPotential = WorldModel.riftPotential;
    const boundaryType = WorldModel.boundaryType;

    if (!riftPotential || !boundaryType) return;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);
            const rift = riftPotential[i] / 255; // 0..1
            const bType = boundaryType[i];

            // Depress scores at divergent boundaries (rift valleys)
            if (bType === ENUM_BOUNDARY.divergent) {
                const depression = rift * riftDepth;
                scores[i] = Math.max(0, scores[i] - depression);
                hillScores[i] = Math.max(0, hillScores[i] - depression * 0.5);
            }
        }
    }
}

/**
 * Build a water check that prefers the landMask buffer written by landmass generation.
 */
function createIsWaterTile(ctx, adapter, width, height) {
    const landMask = ctx?.buffers?.heightfield?.landMask || null;
    return (x, y) => {
        if (landMask) {
            const idx = y * width + x;
            if (idx >= 0 && idx < landMask.length) {
                return landMask[idx] === 0;
            }
        }
        if (adapter?.isWater) {
            return adapter.isWater(x, y);
        }
        return GameplayMap?.isWater?.(x, y) ?? false;
    };
}

/**
 * Select tiles where score exceeds threshold (physics-driven, no quota)
 *
 * This is the core of the physics-threshold architecture:
 * - Only tiles that genuinely qualify based on tectonic physics get selected
 * - No forcing tiles to meet a quota
 * - Mountain count is determined by geology, not arbitrary percentage
 *
 * @param {Float32Array} scores - Score array for all tiles
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} threshold - Minimum score for selection (0..1)
 * @param {Object} adapter - Adapter with isWater(x,y) method
 * @param {Set} [excludeSet] - Optional set of tile indices to exclude
 * @returns {Set} Set of selected tile indices
 */
function selectTilesAboveThreshold(scores, width, height, threshold, adapter, excludeSet = null) {
    const selected = new Set();

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;

            // Skip water
            if (adapter.isWater(x, y)) continue;

            // Skip excluded tiles
            if (excludeSet && excludeSet.has(i)) continue;

            // Only select if score exceeds threshold
            if (scores[i] > threshold) {
                selected.add(i);
            }
        }
    }

    return selected;
}

/**
 * Backward-compatible wrapper that can be called without ctx
 * Falls back to base game fractal approach
 */
export function addMountainsCompat(width, height) {
    // Create minimal adapter if ctx not available
    const adapter = {
        isWater: (x, y) => GameplayMap.isWater(x, y),
        setTerrainType: (x, y, type) => TerrainBuilder.setTerrainType(x, y, type),
    };

    const ctx = {
        dimensions: { width, height },
        adapter,
        rng: {
            calls: 0,
            sequence: [],
        },
    };

    layerAddMountainsPhysics(ctx, {
        tectonicIntensity: 1.0,  // Standard intensity
        mountainThreshold: 0.45,
        hillThreshold: 0.25,
        upliftWeight: WorldModel.isEnabled() ? 0.75 : 0,
        fractalWeight: WorldModel.isEnabled() ? 0.25 : 1.0,
    });
}

export default layerAddMountainsPhysics;
</file>

<file path="mod/maps/layers/placement.js">
// @ts-nocheck
console.log("[SWOOPER_MOD] Placement layer loading...");
/**
 * Placement Layer  Wonders, Floodplains, Snow, Resources, Starts, Discoveries, Fertility, Advanced Start
 *
 * Purpose
 * - Encapsulate all late-stage placement and finalization passes into a single, reusable function.
 * - Keep behavior compatible with the existing pipeline while enabling clean orchestration.
 *
 * Responsibilities
 * - Natural wonders (+1 vs. map defaults unless overridden)
 * - Floodplains
 * - Snow generation
 * - Resources
 * - Start position assignment (vanilla-compatible)
 * - Discoveries (post-starts to seed exploration)
 * - Fertility recalculation
 * - Advanced start region assignment
 *
 * Usage
 *   import { runPlacement } from "./layers/placement.js";
 *   const startPositions = runPlacement(iWidth, iHeight, {
 *     mapInfo,
 *     wondersPlusOne: true, // default true
 *     floodplains: { minLength: 4, maxLength: 10 },
 *     starts: {
 *       playersLandmass1, playersLandmass2,
 *       westContinent, eastContinent,
 *       startSectorRows, startSectorCols,
 *       startSectors
 *     }
 *   });
 *
 * Notes
 * - All external engine/module calls are wrapped in light defensive try/catch where sensible.
 * - Returns the computed startPositions array for downstream consumers (e.g., discoveries).
 */
import { addNaturalWonders } from "/base-standard/maps/natural-wonder-generator.js";
import { generateResources } from "/base-standard/maps/resource-generator.js";
import { assignAdvancedStartRegions } from "/base-standard/maps/assign-advanced-start-region.js";
import { generateDiscoveries } from "/base-standard/maps/discovery-generator.js";
import { generateSnow } from "/base-standard/maps/snow-generator.js";
import { assignStartPositions } from "/base-standard/maps/assign-starting-plots.js";
import { PLACEMENT_CFG } from "../bootstrap/tunables.js";
/**
 * Compute the number of natural wonders to place.
 * Default behavior mirrors the main script: +1 vs map defaults (but never below default).
 * @param {any} mapInfo
 * @param {boolean} wondersPlusOne
 * @returns {number}
 */
function resolveNaturalWonderCount(mapInfo, wondersPlusOne = true) {
    if (!mapInfo || typeof mapInfo.NumNaturalWonders !== "number") {
        return 1;
    }
    if (wondersPlusOne) {
        return Math.max(mapInfo.NumNaturalWonders + 1, mapInfo.NumNaturalWonders);
    }
    return mapInfo.NumNaturalWonders;
}
/**
 * Run late-stage placement and finalization passes.
 * @param {number} iWidth
 * @param {number} iHeight
 * @param {object} params
 * @param {any} params.mapInfo - GameInfo.Maps row (used to derive defaults).
 * @param {boolean} [params.wondersPlusOne=true] - Whether to add +1 to map default wonders.
 * @param {{minLength:number,maxLength:number}} [params.floodplains] - Floodplains config (defaults: {4, 10}).
 * @param {object} params.starts - Start placement inputs.
 * @param {number} params.starts.playersLandmass1
 * @param {number} params.starts.playersLandmass2
 * @param {{west:number,east:number,south:number,north:number,continent:number}} params.starts.westContinent
 * @param {{west:number,east:number,south:number,north:number,continent:number}} params.starts.eastContinent
 * @param {number} params.starts.startSectorRows
 * @param {number} params.starts.startSectorCols
 * @param {Array<any>} params.starts.startSectors
 * @returns {Array<any>} startPositions
 */
export function runPlacement(iWidth, iHeight, { mapInfo, wondersPlusOne = true, floodplains = { minLength: 4, maxLength: 10 }, starts, } = {}) {
    console.log("[SWOOPER_MOD] === runPlacement() CALLED ===");
    console.log(`[SWOOPER_MOD] Map size: ${iWidth}x${iHeight}`);
    const startPositions = [];
    // 1) Natural Wonders
    try {
        const wonders = resolveNaturalWonderCount(mapInfo, typeof wondersPlusOne === "boolean"
            ? wondersPlusOne
            : PLACEMENT_CFG &&
                typeof PLACEMENT_CFG.wondersPlusOne === "boolean"
                ? PLACEMENT_CFG.wondersPlusOne
                : true);
        addNaturalWonders(iWidth, iHeight, wonders);
    }
    catch (err) {
        console.log("[Placement] addNaturalWonders failed:", err);
    }
    // 2) Floodplains
    try {
        const minLen = floodplains && typeof floodplains.minLength === "number"
            ? floodplains.minLength
            : PLACEMENT_CFG &&
                PLACEMENT_CFG.floodplains &&
                typeof PLACEMENT_CFG.floodplains.minLength === "number"
                ? PLACEMENT_CFG.floodplains.minLength
                : 4;
        const maxLen = floodplains && typeof floodplains.maxLength === "number"
            ? floodplains.maxLength
            : PLACEMENT_CFG &&
                PLACEMENT_CFG.floodplains &&
                typeof PLACEMENT_CFG.floodplains.maxLength === "number"
                ? PLACEMENT_CFG.floodplains.maxLength
                : 10;
        TerrainBuilder.addFloodplains(minLen, maxLen);
    }
    catch (err) {
        console.log("[Placement] addFloodplains failed:", err);
    }
    // 3) Snow (post-water/terrain stabilization)
    try {
        generateSnow(iWidth, iHeight);
    }
    catch (err) {
        console.log("[Placement] generateSnow failed:", err);
    }
    // 4) Resources (after snow)
    try {
        generateResources(iWidth, iHeight);
    }
    catch (err) {
        console.log("[Placement] generateResources failed:", err);
    }
    // 5) Start positions (vanilla-compatible)
    try {
        if (!starts) {
            console.log("[Placement] Start placement skipped (no starts config provided).");
        }
        else {
            const { playersLandmass1, playersLandmass2, westContinent, eastContinent, startSectorRows, startSectorCols, startSectors, } = starts;

            // DIAGNOSTIC LOGGING - Start placement parameters
            const totalPlayers = playersLandmass1 + playersLandmass2;
            console.log(`[START_DEBUG] === Beginning Start Placement ===`);
            console.log(`[START_DEBUG] Players: ${totalPlayers} total (${playersLandmass1} landmass1, ${playersLandmass2} landmass2)`);
            console.log(`[START_DEBUG] Continents: west=${westContinent}, east=${eastContinent}`);
            console.log(`[START_DEBUG] Sectors: ${startSectorRows}x${startSectorCols} grid, ${startSectors.length} sectors chosen`);

            const pos = assignStartPositions(playersLandmass1, playersLandmass2, westContinent, eastContinent, startSectorRows, startSectorCols, startSectors);

            // DIAGNOSTIC LOGGING - Placement results
            const successCount = pos ? pos.filter(p => p !== undefined && p >= 0).length : 0;
            console.log(`[START_DEBUG] Result: ${successCount}/${totalPlayers} civilizations placed successfully`);
            if (successCount < totalPlayers) {
                console.log(`[START_DEBUG] WARNING: ${totalPlayers - successCount} civilizations failed to find valid start locations!`);
            }
            console.log(`[START_DEBUG] === End Start Placement ===`);

            if (Array.isArray(pos)) {
                startPositions.push(...pos);
            }
            if (successCount === totalPlayers) {
                console.log("[Placement] Start positions assigned successfully");
            }
            else {
                console.log(`[Placement] Start positions assignment incomplete: ${totalPlayers - successCount} failures`);
            }
        }
    }
    catch (err) {
        console.log("[Placement] assignStartPositions failed:", err);
    }
    // 6) Discoveries (post-starts to seed exploration)
    try {
        generateDiscoveries(iWidth, iHeight, startPositions);
        console.log("[Placement] Discoveries generated successfully");
    }
    catch (err) {
        console.log("[Placement] generateDiscoveries failed:", err);
    }
    // 7) Fertility + Advanced Start
    try {
        FertilityBuilder.recalculate();
    }
    catch (err) {
        console.log("[Placement] FertilityBuilder.recalculate failed:", err);
    }
    try {
        assignAdvancedStartRegions();
    }
    catch (err) {
        console.log("[Placement] assignAdvancedStartRegions failed:", err);
    }
    return startPositions;
}
export default runPlacement;
</file>

<file path="mod/maps/layers/volcanoes.js">
// @ts-nocheck
/**
 * Volcano Placement  Plate-Aware Wrapper
 *
 * Purpose
 * - Replace the base game's continent-edge heuristic with a WorldModel-driven
 *   placement strategy that favors convergent arcs while still allowing inland
 *   hotspot-style volcanoes when configured.
 * - Exposes tunables through the `volcanoes` config block so presets can adjust
 *   density, spacing, and boundary weighting without touching this layer.
 *
 * Fallback
 * - If the WorldModel is disabled or required fields are unavailable, defer to
 *   the base game's `addVolcanoes()` implementation to preserve vanilla behavior.
 */

import { WorldModel } from "../world/model.js";
import { idx, writeHeightfield } from "../core/types.js";
import { devLogIf } from "../bootstrap/dev.js";
import * as globals from "/base-standard/maps/map-globals.js";
import { addVolcanoes as baseAddVolcanoes, isTooCloseToExistingVolcanoes } from "/base-standard/maps/volcano-generator.js";

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

/**
 * @typedef {import("../core/types.js").MapContext} MapContext
 * @typedef {import("../core/types.js").MapMetrics} MapMetrics
 */

/**
 * Plate-aware volcano placement. Falls back to base game implementation when
 * WorldModel data is unavailable.
 *
 * @param {MapContext} ctx
 * @param {Object} [options]
 */
export function layerAddVolcanoesPlateAware(ctx, options = {}) {
    const {
        enabled = true,
        baseDensity = 1 / 170, // ~1 volcano per 170 land tiles (close to vanilla)
        minSpacing = 3,
        boundaryThreshold = 0.35,
        boundaryWeight = 1.2,
        convergentMultiplier = 2.4,
        transformMultiplier = 1.1,
        divergentMultiplier = 0.35,
        hotspotWeight = 0.12,
        shieldPenalty = 0.6,
        randomJitter = 0.08,
        minVolcanoes = 5,
        maxVolcanoes = 40,
    } = options;

    const dimensions = ctx?.dimensions || {};
    const width = Number.isFinite(dimensions.width)
        ? dimensions.width
        : GameplayMap?.getGridWidth?.() ?? 0;
    const height = Number.isFinite(dimensions.height)
        ? dimensions.height
        : GameplayMap?.getGridHeight?.() ?? 0;
    const adapter = ctx?.adapter;

    if (!width || !height || !adapter) {
        devLogIf &&
            devLogIf("LOG_VOLCANOES", "[Volcanoes] Missing dimensions/adapter; skipping placement", {
                width,
                height,
                hasAdapter: !!adapter,
            });
        return;
    }

    if (!enabled) {
        devLogIf && devLogIf("LOG_VOLCANOES", "[Volcanoes] Disabled via config; skipping placement.");
        return;
    }

    const worldEnabled = WorldModel.isEnabled();
    const boundaryCloseness = WorldModel.boundaryCloseness;
    const boundaryType = WorldModel.boundaryType;
    const shieldStability = WorldModel.shieldStability;

    if (!worldEnabled || !boundaryCloseness || !boundaryType) {
        devLogIf &&
            devLogIf("LOG_VOLCANOES", "[Volcanoes] WorldModel unavailable; falling back to base generator.");
        baseAddVolcanoes(width, height, minSpacing);
        return;
    }

    // Count land tiles for density target
    let landTiles = 0;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (!GameplayMap.isWater(x, y)) landTiles++;
        }
    }

    const rawDesired = Math.round(landTiles * Math.max(0, baseDensity));
    const targetVolcanoes = clamp(Math.max(minVolcanoes | 0, rawDesired), minVolcanoes | 0, maxVolcanoes > 0 ? maxVolcanoes | 0 : rawDesired);

    if (targetVolcanoes <= 0) {
        devLogIf && devLogIf("LOG_STORY_TAGS", "[Volcanoes] Target count <= 0; skipping placement.");
        return;
    }

    const candidates = [];
    const hotspotBase = Math.max(0, hotspotWeight);
    const threshold = Math.max(0, Math.min(1, boundaryThreshold));
    const shieldWeight = Math.max(0, Math.min(1, shieldPenalty));
    const jitter = Math.max(0, randomJitter);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (GameplayMap.isWater(x, y)) continue;
            if (GameplayMap.getFeatureType(x, y) === globals.g_VolcanoFeature) continue;

            const i = idx(x, y, width);
            const closeness = boundaryCloseness[i] / 255;
            const shield = shieldStability ? shieldStability[i] / 255 : 0;
            const bType = boundaryType[i] | 0;

            let weight = 0;
            let boundaryBand = 0;
            if (closeness >= threshold) {
                boundaryBand = (closeness - threshold) / Math.max(1e-3, 1 - threshold);
                const base = boundaryBand * Math.max(0, boundaryWeight);
                let multiplier = 1;
                if (bType === ENUM_BOUNDARY.convergent) multiplier = Math.max(0, convergentMultiplier);
                else if (bType === ENUM_BOUNDARY.transform) multiplier = Math.max(0, transformMultiplier);
                else if (bType === ENUM_BOUNDARY.divergent) multiplier = Math.max(0, divergentMultiplier);
                weight += base * multiplier;
            } else {
                // Interior hotspot chance scales with how far we are from boundaries
                const interiorBand = 1 - closeness;
                weight += hotspotBase * interiorBand;
            }

            if (weight <= 0) continue;

            if (shieldWeight > 0) {
                const penalty = shield * shieldWeight;
                weight *= Math.max(0, 1 - penalty);
            }

            if (jitter > 0) {
                const randomScale = (TerrainBuilder.getRandomNumber(1000, "VolcanoJitter") || 0) / 1000;
                weight += randomScale * jitter;
            }

            if (weight > 0) {
                candidates.push({ x, y, weight, closeness, boundaryType: bType });
            }
        }
    }

    if (candidates.length === 0) {
        devLogIf &&
            devLogIf("LOG_VOLCANOES", "[Volcanoes] No candidates with positive weight; falling back to base generator.");
        baseAddVolcanoes(width, height, minSpacing);
        return;
    }

    candidates.sort((a, b) => b.weight - a.weight);

    const placed = [];
    const minSpacingClamped = Math.max(1, minSpacing | 0);
    for (const candidate of candidates) {
        if (placed.length >= targetVolcanoes) break;
        if (GameplayMap.getFeatureType(candidate.x, candidate.y) === globals.g_VolcanoFeature) continue;
        if (isTooCloseToExistingVolcanoes(candidate.x, candidate.y, placed, minSpacingClamped)) continue;

        if (ctx) {
            writeHeightfield(ctx, candidate.x, candidate.y, {
                terrain: globals.g_MountainTerrain,
                isLand: true,
            });
        }
        else {
            adapter.setTerrainType(candidate.x, candidate.y, globals.g_MountainTerrain);
        }
        adapter.setFeatureType(candidate.x, candidate.y, {
            Feature: globals.g_VolcanoFeature,
            Direction: -1,
            Elevation: 0,
        });
        placed.push({ x: candidate.x, y: candidate.y });
    }

    devLogIf &&
        devLogIf("LOG_VOLCANOES", "[Volcanoes] placement", {
            candidates: candidates.length,
            placed: placed.length,
            targetVolcanoes,
            minSpacing: minSpacingClamped,
        });
}

function clamp(value, min, max) {
    if (typeof max === "number" && max >= min) {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    }
    return Math.max(value, min);
}

export default layerAddVolcanoesPlateAware;
</file>

<file path="mod/maps/story/corridors.js">
// @ts-nocheck
/**
 * Strategic Corridors  lightweight, gameplayfocused path tagging
 *
 * Tags sparse corridors that other layers respect to preserve or emphasize
 * traversal routes:
 *  - Sea lanes: long open water lanes across the map (dont obstruct with coasts/islands)
 *  - Islandhop lanes: promote hotspot trails as navigable arcs (avoid clutter)
 *  - Land open corridors: long riftshoulder runs get gentle grassland bias
 *  - River chains: postrivers, lowland riveradjacent crosscontinent paths
 *
 * Invariants and constraints:
 *  - Pure tagging; no heavy flood fills. All passes are O(width  height) with small constants.
 *  - Consumers must remain lanesafe: do not create chokepoints or dense clutter.
 *  - Does not modify rainfall or terrain here; those effects belong to other layers.
 */
import { StoryTags } from "./tags.js";
import { inBounds, storyKey, isAdjacentToLand } from "../core/utils.js";
import { STORY_ENABLE_CORRIDORS, CORRIDORS_CFG, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { devLogIf } from "../bootstrap/dev.js";

const STYLE_PRIMITIVE_CACHE = new Map();

function freezeClone(obj) {
    if (!obj || typeof obj !== "object")
        return undefined;
    const out = {};
    for (const key of Object.keys(obj))
        out[key] = obj[key];
    return Object.freeze(out);
}

function fetchCorridorStylePrimitive(kind, style) {
    if (typeof kind !== "string" || typeof style !== "string")
        return null;
    const cacheKey = `${kind}:${style}`;
    if (STYLE_PRIMITIVE_CACHE.has(cacheKey))
        return STYLE_PRIMITIVE_CACHE.get(cacheKey);
    const kindCfg = CORRIDORS_CFG?.kinds?.[kind];
    const styleCfg = kindCfg && kindCfg.styles ? kindCfg.styles[style] : null;
    if (!styleCfg)
        return null;
    const primitive = Object.freeze({
        kind,
        style,
        biomes: styleCfg.biomes ? freezeClone(styleCfg.biomes) : undefined,
        features: styleCfg.features ? freezeClone(styleCfg.features) : undefined,
        edge: styleCfg.edge ? freezeClone(styleCfg.edge) : undefined,
    });
    STYLE_PRIMITIVE_CACHE.set(cacheKey, primitive);
    return primitive;
}

function assignCorridorMetadata(key, kind, style) {
    if (typeof key !== "string" || typeof kind !== "string" || typeof style !== "string")
        return;
    StoryTags.corridorKind.set(key, kind);
    StoryTags.corridorStyle.set(key, style);
    const primitive = fetchCorridorStylePrimitive(kind, style);
    if (primitive)
        StoryTags.corridorAttributes.set(key, primitive);
    else
        StoryTags.corridorAttributes.delete(key);
}

function clearCorridorStyleCache() {
    STYLE_PRIMITIVE_CACHE.clear();
}
/**
 * Safe random helper (engine provided).
 * @param {number} n
 * @param {string} label
 * @returns {number}
 */
function rand(n, label) {
    return TerrainBuilder.getRandomNumber(Math.max(1, n | 0), label || "Corr");
}
/**
 * Compute the longest contiguous run of water along a fixed column x.
 * @param {number} x
 * @param {number} height
 * @returns {{start:number,end:number,len:number}}
 */
function longestWaterRunColumn(x, height) {
    let bestStart = -1, bestEnd = -1, bestLen = 0;
    let curStart = -1, curLen = 0;
    for (let y = 0; y < height; y++) {
        if (GameplayMap.isWater(x, y)) {
            if (curLen === 0)
                curStart = y;
            curLen++;
            if (curLen > bestLen) {
                bestLen = curLen;
                bestStart = curStart;
                bestEnd = y;
            }
        }
        else {
            curLen = 0;
        }
    }
    return { start: bestStart, end: bestEnd, len: bestLen };
}
/**
 * Compute the longest contiguous run of water along a fixed row y.
 * @param {number} y
 * @param {number} width
 * @returns {{start:number,end:number,len:number}}
 */
function longestWaterRunRow(y, width) {
    let bestStart = -1, bestEnd = -1, bestLen = 0;
    let curStart = -1, curLen = 0;
    for (let x = 0; x < width; x++) {
        if (GameplayMap.isWater(x, y)) {
            if (curLen === 0)
                curStart = x;
            curLen++;
            if (curLen > bestLen) {
                bestLen = curLen;
                bestStart = curStart;
                bestEnd = x;
            }
        }
        else {
            curLen = 0;
        }
    }
    return { start: bestStart, end: bestEnd, len: bestLen };
}
/**
 * Tag long open water sea lanes across the map.
 * We prefer a handful of long, straight segments (columns/rows) that clear a large span.
 */
function tagSeaLanes() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.sea) || {};
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const maxLanes = Math.max(0, (cfg.maxLanes ?? 3) | 0);
    const stride = Math.max(2, (cfg.scanStride ?? 6) | 0);
    const minLenFrac = Math.min(1, Math.max(0.4, cfg.minLengthFrac ?? 0.7));
    const preferDiagonals = !!cfg.preferDiagonals;
    const laneSpacing = Math.max(0, (cfg.laneSpacing ?? 6) | 0);
    const requiredMinWidth = Math.max(1, (cfg.minChannelWidth ?? 3) | 0);
    // Helper: check perpendicular water width around (x,y) for given orientation
    // Orient: 'col' (vertical), 'row' (horizontal), 'diagNE' (x+y const), 'diagNW' (x-y const)
    function hasPerpWidth(x, y, orient, minWidth) {
        const r = Math.floor((minWidth - 1) / 2);
        if (r <= 0)
            return GameplayMap.isWater(x, y);
        if (!GameplayMap.isWater(x, y))
            return false;
        // Check along perpendicular line
        if (orient === "col") {
            // Perpendicular to vertical is horizontal  vary dx, fixed y
            for (let dx = -r; dx <= r; dx++) {
                const nx = x + dx;
                if (nx < 0 || nx >= width)
                    return false;
                if (!GameplayMap.isWater(nx, y))
                    return false;
            }
            return true;
        }
        else if (orient === "row") {
            // Perpendicular to horizontal is vertical  vary dy, fixed x
            for (let dy = -r; dy <= r; dy++) {
                const ny = y + dy;
                if (ny < 0 || ny >= height)
                    return false;
                if (!GameplayMap.isWater(x, ny))
                    return false;
            }
            return true;
        }
        else if (orient === "diagNE") {
            // Lane along NE-SW (x+y = const); perpendicular is NW-SE (x+=t, y+=t)
            for (let t = -r; t <= r; t++) {
                const nx = x + t, ny = y + t;
                if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                    return false;
                if (!GameplayMap.isWater(nx, ny))
                    return false;
            }
            return true;
        }
        else if (orient === "diagNW") {
            // Lane along NW-SE (x-y = const); perpendicular is NE-SW (x+=t, y-=t)
            for (let t = -r; t <= r; t++) {
                const nx = x + t, ny = y - t;
                if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                    return false;
                if (!GameplayMap.isWater(nx, ny))
                    return false;
            }
            return true;
        }
        return false;
    }
    // Helpers for diagonals
    function longestWaterRunDiagSum(k) {
        // NE-SW family: x+y = k
        const xs = Math.max(0, k - (height - 1));
        const xe = Math.min(width - 1, k);
        let bestStartX = -1, bestEndX = -1, bestLen = 0;
        let curStartX = -1, curLen = 0;
        for (let x = xs; x <= xe; x++) {
            const y = k - x;
            if (GameplayMap.isWater(x, y)) {
                if (curLen === 0)
                    curStartX = x;
                curLen++;
                if (curLen > bestLen) {
                    bestLen = curLen;
                    bestStartX = curStartX;
                    bestEndX = x;
                }
            }
            else {
                curLen = 0;
            }
        }
        return {
            xs,
            xe,
            startX: bestStartX,
            endX: bestEndX,
            len: bestLen,
            axisLen: xe - xs + 1,
        };
    }
    function longestWaterRunDiagDiff(d) {
        // NW-SE family: x - y = d
        const ys = Math.max(0, -d);
        const ye = Math.min(height - 1, width - 1 - d);
        let bestStartY = -1, bestEndY = -1, bestLen = 0;
        let curStartY = -1, curLen = 0;
        for (let y = ys; y <= ye; y++) {
            const x = d + y;
            if (GameplayMap.isWater(x, y)) {
                if (curLen === 0)
                    curStartY = y;
                curLen++;
                if (curLen > bestLen) {
                    bestLen = curLen;
                    bestStartY = curStartY;
                    bestEndY = y;
                }
            }
            else {
                curLen = 0;
            }
        }
        return {
            ys,
            ye,
            startY: bestStartY,
            endY: bestEndY,
            len: bestLen,
            axisLen: ye - ys + 1,
        };
    }
    // Build candidates with simple scores and spacing metadata
    // Directionality bias setup (uses foundation directionality config; safe fallbacks)
    const DIR = FOUNDATION_DIRECTIONALITY || {};
    const COH = Math.max(0, Math.min(1, DIR.cohesion ?? 0));
    const plateAxisDeg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
    let windAxisDeg = (DIR?.primaryAxes?.windBiasDeg ?? 0) | 0;
    let currentAxisDeg = (DIR?.primaryAxes?.currentBiasDeg ?? 0) | 0;
    const windsFollowPlates = Math.max(0, Math.min(1, DIR?.interplay?.windsFollowPlates ?? 0)) * COH;
    const currentsFollowWinds = Math.max(0, Math.min(1, DIR?.interplay?.currentsFollowWinds ?? 0)) *
        COH;
    windAxisDeg += Math.round(plateAxisDeg * windsFollowPlates);
    currentAxisDeg += Math.round(plateAxisDeg * windsFollowPlates * 0.5);
    // Vector helpers
    function axisVec(deg) {
        const r = (deg * Math.PI) / 180;
        return { x: Math.cos(r), y: Math.sin(r) };
    }
    function laneVec(orient) {
        if (orient === "col")
            return { x: 0, y: 1 };
        if (orient === "row")
            return { x: 1, y: 0 };
        if (orient === "diagNE")
            return { x: 1 / Math.SQRT2, y: -1 / Math.SQRT2 }; // NE-SW
        if (orient === "diagNW")
            return { x: 1 / Math.SQRT2, y: 1 / Math.SQRT2 }; // NW-SE
        return { x: 1, y: 0 };
    }
    const WV = axisVec(windAxisDeg);
    const CV = axisVec(currentAxisDeg);
    function directionalityBias(orient) {
        if (COH <= 0)
            return 0;
        const L = laneVec(orient);
        const dotWind = Math.abs(WV.x * L.x + WV.y * L.y); // 0..1
        const dotCurr = Math.abs(CV.x * L.x + CV.y * L.y); // 0..1
        // Weight wind higher; currents gain from interplay with winds
        const wW = 1.0;
        const wC = 0.8 + 0.6 * currentsFollowWinds;
        const align = (dotWind * wW + dotCurr * wC) / (wW + wC);
        // Scale modestly to keep lane selection conservative
        return Math.round(align * 25 * COH);
    }
    /** @type {Array<{orient:'col'|'row'|'diagNE'|'diagNW', index:number, start:number, end:number, len:number, minWidth:number, score:number}>} */
    const candidates = [];
    // Columns
    const minCol = Math.floor(height * minLenFrac);
    for (let x = 1; x < width - 1; x += stride) {
        const run = longestWaterRunColumn(x, height);
        if (run.len >= minCol) {
            // Sample perpendicular width at a few points
            const step = Math.max(1, Math.floor(run.len / 10));
            let ok = true;
            for (let y = run.start; y <= run.end; y += step) {
                if (!hasPerpWidth(x, y, "col", requiredMinWidth)) {
                    ok = false;
                    break;
                }
            }
            const minW = ok ? requiredMinWidth : 1;
            const coverage = run.len / height;
            let score = run.len + 3 * minW + Math.round(coverage * 10);
            score += directionalityBias("col");
            candidates.push({
                orient: "col",
                index: x,
                start: run.start,
                end: run.end,
                len: run.len,
                minWidth: minW,
                score,
            });
        }
    }
    // Rows
    const minRow = Math.floor(width * minLenFrac);
    for (let y = 1; y < height - 1; y += stride) {
        const run = longestWaterRunRow(y, width);
        if (run.len >= minRow) {
            const step = Math.max(1, Math.floor(run.len / 10));
            let ok = true;
            for (let x = run.start; x <= run.end; x += step) {
                if (!hasPerpWidth(x, y, "row", requiredMinWidth)) {
                    ok = false;
                    break;
                }
            }
            const minW = ok ? requiredMinWidth : 1;
            const coverage = run.len / width;
            let score = run.len + 3 * minW + Math.round(coverage * 10);
            score += directionalityBias("row");
            candidates.push({
                orient: "row",
                index: y,
                start: run.start,
                end: run.end,
                len: run.len,
                minWidth: minW,
                score,
            });
        }
    }
    // Diagonals (optional)
    if (preferDiagonals) {
        // NE-SW: k = x+y in [0, width-1+height-1]
        const kMax = width - 1 + (height - 1);
        for (let k = 0; k <= kMax; k += Math.max(2, stride)) {
            const run = longestWaterRunDiagSum(k);
            const minDiag = Math.floor(run.axisLen * minLenFrac);
            if (run.len >= minDiag && run.startX !== -1) {
                const step = Math.max(1, Math.floor(run.len / 10));
                let ok = true;
                for (let x = run.startX; x <= run.endX; x += step) {
                    const y = k - x;
                    if (!hasPerpWidth(x, y, "diagNE", requiredMinWidth)) {
                        ok = false;
                        break;
                    }
                }
                const minW = ok ? requiredMinWidth : 1;
                const coverage = run.len / run.axisLen;
                let score = run.len + 2 * minW + Math.round(coverage * 10);
                score += directionalityBias("diagNE");
                candidates.push({
                    orient: "diagNE",
                    index: k,
                    start: run.startX,
                    end: run.endX,
                    len: run.len,
                    minWidth: minW,
                    score,
                });
            }
        }
        // NW-SE: d = x - y in [-(height-1)..(width-1)]
        const dMin = -(height - 1);
        const dMax = width - 1;
        for (let d = dMin; d <= dMax; d += Math.max(2, stride)) {
            const run = longestWaterRunDiagDiff(d);
            const minDiag = Math.floor(run.axisLen * minLenFrac);
            if (run.len >= minDiag && run.startY !== -1) {
                const step = Math.max(1, Math.floor(run.len / 10));
                let ok = true;
                for (let y = run.startY; y <= run.endY; y += step) {
                    const x = d + y;
                    if (!hasPerpWidth(x, y, "diagNW", requiredMinWidth)) {
                        ok = false;
                        break;
                    }
                }
                const minW = ok ? requiredMinWidth : 1;
                const coverage = run.len / run.axisLen;
                let score = run.len + 2 * minW + Math.round(coverage * 10);
                score += directionalityBias("diagNW");
                candidates.push({
                    orient: "diagNW",
                    index: d,
                    start: run.startY,
                    end: run.endY,
                    len: run.len,
                    minWidth: minW,
                    score,
                });
            }
        }
    }
    // Select top-K by score while enforcing spacing within the same orientation family
    candidates.sort((a, b) => b.score - a.score);
    /** @type {{col:number[],row:number[],diagNE:number[],diagNW:number[]}} */
    const chosenIdx = { col: [], row: [], diagNE: [], diagNW: [] };
    let lanes = 0;
    function spaced(orient, index) {
        const arr = chosenIdx[orient];
        for (let i = 0; i < arr.length; i++) {
            if (Math.abs(arr[i] - index) < laneSpacing)
                return false;
        }
        return true;
    }
    for (const c of candidates) {
        if (lanes >= maxLanes)
            break;
        if (!spaced(c.orient, c.index))
            continue;
        chosenIdx[c.orient].push(c.index);
        // Tag tiles for this lane
        if (c.orient === "col") {
            const x = c.index;
            for (let y = c.start; y <= c.end; y++) {
                if (GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        else if (c.orient === "row") {
            const y = c.index;
            for (let x = c.start; x <= c.end; x++) {
                if (GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        else if (c.orient === "diagNE") {
            const k = c.index;
            for (let x = c.start; x <= c.end; x++) {
                const y = k - x;
                if (x >= 0 &&
                    x < width &&
                    y >= 0 &&
                    y < height &&
                    GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        else if (c.orient === "diagNW") {
            const d = c.index;
            for (let y = c.start; y <= c.end; y++) {
                const x = d + y;
                if (x >= 0 &&
                    x < width &&
                    y >= 0 &&
                    y < height &&
                    GameplayMap.isWater(x, y)) {
                    const kk = storyKey(x, y);
                    StoryTags.corridorSeaLane.add(kk);
                    const style = isAdjacentToLand(x, y, 2)
                        ? "coastal"
                        : "ocean";
                    assignCorridorMetadata(kk, "sea", style);
                }
            }
        }
        lanes++;
    }
    // Log a compact summary of selected sea lanes
    devLogIf &&
        devLogIf("LOG_STORY_TAGS", `[Corridors] Sea lanes selected: ${lanes} (col:${chosenIdx.col.length}, row:${chosenIdx.row.length}, diagNE:${chosenIdx.diagNE.length}, diagNW:${chosenIdx.diagNW.length}); tiles=${StoryTags.corridorSeaLane.size}`);
}
/**
 * Promote hotspot trail points to islandhop lanes (avoid clutter, just tag proximity).
 * We select up to N arcs from existing StoryTags.hotspot points.
 */
function tagIslandHopFromHotspots() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.islandHop) || {};
    if (!cfg.useHotspots)
        return;
    const maxArcs = Math.max(0, (cfg.maxArcs ?? 2) | 0);
    if (maxArcs === 0)
        return;
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    // Gather hotspot keys for indexed access
    const keys = Array.from(StoryTags.hotspot);
    if (!keys.length)
        return;
    // Randomly sample up to maxArcs seeds from the hotspot set
    const picked = new Set();
    let arcs = 0, attempts = 0;
    while (arcs < maxArcs && attempts < 100 && attempts < keys.length * 2) {
        attempts++;
        const idx = rand(keys.length, "IslandHopPick");
        const key = keys[idx % keys.length];
        if (picked.has(key))
            continue;
        picked.add(key);
        arcs++;
        // Tag the seed and a tight neighborhood to promote the trail locally
        const [sx, sy] = key.split(",").map(Number);
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const nx = sx + dx, ny = sy + dy;
                if (!inBounds(nx, ny))
                    continue;
                if (!GameplayMap.isWater(nx, ny))
                    continue;
                {
                    const kk = storyKey(nx, ny);
                    StoryTags.corridorIslandHop.add(kk);
                    assignCorridorMetadata(kk, "islandHop", "archipelago");
                }
            }
        }
    }
}
/**
 * Promote long riftshoulder runs as landopen corridors (plains/grass bias consumers).
 * MVP: tag shoulder tiles that form sufficiently long contiguous row segments.
 */
function tagLandCorridorsFromRifts() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.land) || {};
    if (!cfg.useRiftShoulders)
        return;
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const maxCorridors = Math.max(0, (cfg.maxCorridors ?? 2) | 0);
    const minRun = Math.max(12, (cfg.minRunLength ?? 24) | 0);
    if (maxCorridors === 0 || StoryTags.riftShoulder.size === 0)
        return;
    let corridors = 0;
    const spacing = Math.max(0, (cfg.spacing ?? 0) | 0);
    const usedRows = [];
    // Sweep rows; find shoulder segments of sufficient length, tag them until budget exhausted
    for (let y = 1; y < height - 1 && corridors < maxCorridors; y++) {
        let x = 1;
        while (x < width - 1 && corridors < maxCorridors) {
            // Skip nonshoulder
            while (x < width - 1 && !StoryTags.riftShoulder.has(storyKey(x, y)))
                x++;
            if (x >= width - 1)
                break;
            const start = x;
            while (x < width - 1 && StoryTags.riftShoulder.has(storyKey(x, y)))
                x++;
            const end = x - 1;
            const len = end - start + 1;
            if (len >= minRun) {
                // Enforce row spacing between chosen corridors
                let tooClose = false;
                for (let i = 0; i < usedRows.length; i++) {
                    if (Math.abs(usedRows[i] - y) < spacing) {
                        tooClose = true;
                        break;
                    }
                }
                if (!tooClose) {
                    // Determine corridor style for this segment using simple context heuristics
                    let totalElev = 0, totalRain = 0, samples = 0, reliefHits = 0;
                    for (let cx = start; cx <= end; cx++) {
                        if (GameplayMap.isWater(cx, y))
                            continue;
                        const e = GameplayMap.getElevation(cx, y);
                        const r = GameplayMap.getRainfall(cx, y);
                        totalElev += e;
                        totalRain += r;
                        samples++;
                        // simple local relief check (4-neighborhood)
                        const eN = GameplayMap.getElevation(cx, Math.max(0, y - 1));
                        const eS = GameplayMap.getElevation(cx, Math.min(GameplayMap.getGridHeight() - 1, y + 1));
                        const eW = GameplayMap.getElevation(Math.max(0, cx - 1), y);
                        const eE = GameplayMap.getElevation(Math.min(GameplayMap.getGridWidth() - 1, cx + 1), y);
                        const dMax = Math.max(Math.abs(e - eN), Math.abs(e - eS), Math.abs(e - eW), Math.abs(e - eE));
                        if (dMax >= 60)
                            reliefHits++;
                    }
                    const avgElev = samples > 0 ? Math.round(totalElev / samples) : 0;
                    const avgRain = samples > 0 ? Math.round(totalRain / samples) : 0;
                    const reliefFrac = samples > 0 ? reliefHits / samples : 0;
                    const latDeg = Math.abs(GameplayMap.getPlotLatitude(0, y));
                    // Baseline style from local context
                    let style = "plainsBelt";
                    if (reliefFrac > 0.35 && avgRain < 95) {
                        style = "canyon";
                    }
                    else if (avgElev > 650 && reliefFrac < 0.2) {
                        style = "plateau";
                    }
                    else if (avgElev > 550 && reliefFrac < 0.35) {
                        style = "flatMtn";
                    }
                    else if (avgRain < 85 && latDeg < 35) {
                        style = "desertBelt";
                    }
                    else if (avgRain > 115) {
                        style = "grasslandBelt";
                    }
                    // Directionality-influenced steering (cohesive macro alignment)
                    // Lanes here are row-oriented (east-west). Use global axes to nudge style.
                    try {
                        const DIR = FOUNDATION_DIRECTIONALITY || {};
                        const cohesion = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                        if (cohesion > 0) {
                            const plateDeg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
                            const windDeg = (DIR?.primaryAxes?.windBiasDeg ?? 0) | 0;
                            // Unit vectors for axes and this corridor orientation (row  east-west)
                            const radP = (plateDeg * Math.PI) / 180;
                            const radW = (windDeg * Math.PI) / 180;
                            const PV = { x: Math.cos(radP), y: Math.sin(radP) };
                            const WV = { x: Math.cos(radW), y: Math.sin(radW) };
                            const L = { x: 1, y: 0 }; // row-aligned
                            // Alignment 0..1 (absolute dot; we care about parallelism)
                            const alignPlate = Math.abs(PV.x * L.x + PV.y * L.y);
                            const alignWind = Math.abs(WV.x * L.x + WV.y * L.y);
                            // Heuristic thresholds scaled by cohesion
                            const hiAlign = 0.75 * cohesion + 0.1; // ~0.85 at cohesion 1.0
                            const midAlign = 0.5 * cohesion + 0.1;
                            // Plate-aligned corridors: bias toward structural styles
                            if (alignPlate >= hiAlign) {
                                if (avgElev > 650 && reliefFrac < 0.28) {
                                    style = "plateau";
                                }
                                else if (reliefFrac > 0.3 && avgRain < 100) {
                                    style = "canyon";
                                }
                                else if (avgElev > 560 && reliefFrac < 0.35) {
                                    style = "flatMtn";
                                }
                            }
                            else if (alignPlate >= midAlign) {
                                if (avgElev > 600 && reliefFrac < 0.25) {
                                    style = "plateau";
                                }
                            }
                            // Wind-aligned corridors: bias toward open belts (desert/grassland)
                            if (alignWind >= hiAlign) {
                                if (avgRain > 110 ||
                                    (latDeg < 25 && avgRain > 100)) {
                                    style = "grasslandBelt";
                                }
                                else if (avgRain < 90 && latDeg < 35) {
                                    style = "desertBelt";
                                }
                            }
                            else if (alignWind >= midAlign) {
                                if (avgRain > 120) {
                                    style = "grasslandBelt";
                                }
                            }
                        }
                    }
                    catch (_) {
                        // Keep baseline style on any error
                    }
                    for (let cx = start; cx <= end; cx++) {
                        if (!GameplayMap.isWater(cx, y)) {
                            const kk = storyKey(cx, y);
                            StoryTags.corridorLandOpen.add(kk);
                            assignCorridorMetadata(kk, "land", style);
                        }
                    }
                    usedRows.push(y);
                    corridors++;
                }
            }
        }
    }
}
/**
 * After rivers are modeled, tag riverchain corridors:
 * - Start near a coast and near rivers
 * - Greedily step to adjacent tiles that remain riveradjacent and prefer lowlands/downhill
 */
function tagRiverChainsPostRivers() {
    const cfg = (CORRIDORS_CFG && CORRIDORS_CFG.river) || {};
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const maxChains = Math.max(0, (cfg.maxChains ?? 2) | 0);
    const maxSteps = Math.max(20, (cfg.maxSteps ?? 80) | 0);
    const lowlandThresh = Math.max(0, (cfg.preferLowlandBelow ?? 300) | 0);
    const coastSeedR = Math.max(1, (cfg.coastSeedRadius ?? 2) | 0);
    if (maxChains === 0)
        return;
    let chains = 0, tries = 0;
    while (chains < maxChains && tries < 300) {
        tries++;
        const sx = rand(width, "RiverChainSX");
        const sy = rand(height, "RiverChainSY");
        if (!inBounds(sx, sy))
            continue;
        if (!GameplayMap.isCoastalLand(sx, sy))
            continue;
        if (!GameplayMap.isAdjacentToRivers(sx, sy, coastSeedR))
            continue;
        let x = sx, y = sy, steps = 0;
        const pathKeys = [];
        while (steps < maxSteps) {
            if (!GameplayMap.isWater(x, y) &&
                GameplayMap.isAdjacentToRivers(x, y, 1)) {
                pathKeys.push(storyKey(x, y));
            }
            // Greedy move: prefer neighbor thats riveradjacent and lower/similar elevation,
            // with a mild preference for lowlands
            let bx = x, by = y, be = GameplayMap.getElevation(x, y);
            let improved = false;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0)
                        continue;
                    const nx = x + dx, ny = y + dy;
                    if (!inBounds(nx, ny) || GameplayMap.isWater(nx, ny))
                        continue;
                    if (!GameplayMap.isAdjacentToRivers(nx, ny, 1))
                        continue;
                    const e = GameplayMap.getElevation(nx, ny);
                    const prefer = e <= be || // downhill or level near river
                        (e < lowlandThresh && be >= lowlandThresh); // moving toward lowland
                    if (prefer) {
                        // Soft tiebreak with slight randomness to avoid loops
                        if (!improved || rand(3, "RiverChainTie") === 0) {
                            bx = nx;
                            by = ny;
                            be = e;
                            improved = true;
                        }
                    }
                }
            }
            if (!improved)
                break;
            x = bx;
            y = by;
            steps++;
        }
        const minTiles = Math.max(0, (cfg.minTiles ?? 0) | 0);
        const mustEndNearCoast = !!cfg.mustEndNearCoast;
        let endOK = true;
        if (mustEndNearCoast) {
            endOK =
                GameplayMap.isCoastalLand(x, y) ||
                    GameplayMap.isAdjacentToShallowWater(x, y);
        }
        if (pathKeys.length >= minTiles && endOK) {
            for (let i = 0; i < pathKeys.length; i++) {
                const kk = pathKeys[i];
                StoryTags.corridorRiverChain.add(kk);
                assignCorridorMetadata(kk, "river", "riverChain");
            }
            chains++;
        }
    }
}
/**
 * Entrypoint for corridor tagging.
 * Call with:
 *  - stage="preIslands": After coast/margin shaping, before island seeding
 *  - stage="postRivers": After modelRivers/defineNamedRivers
 * @param {"preIslands"|"postRivers"} stage
 */
export function storyTagStrategicCorridors(stage) {
    if (!STORY_ENABLE_CORRIDORS)
        return;
    clearCorridorStyleCache();
    if (stage === "preIslands") {
        tagSeaLanes();
        tagIslandHopFromHotspots();
        tagLandCorridorsFromRifts();
        backfillCorridorKinds();
    }
    else if (stage === "postRivers") {
        tagRiverChainsPostRivers();
        backfillCorridorKinds();
    }
}
function backfillCorridorKinds() {
    // Sea lanes: classify as coastal when adjacent to shallow water; else ocean
    for (const key of StoryTags.corridorSeaLane) {
        let kind = StoryTags.corridorKind.get(key) || "sea";
        let style = StoryTags.corridorStyle.get(key);
        if (!style) {
            const [sx, sy] = key.split(",").map(Number);
            style = GameplayMap.isAdjacentToShallowWater(sx, sy)
                ? "coastal"
                : "ocean";
        }
        assignCorridorMetadata(key, kind, style);
    }
    // Island-hop lanes: archipelago style
    for (const key of StoryTags.corridorIslandHop) {
        const kind = StoryTags.corridorKind.get(key) || "islandHop";
        const style = StoryTags.corridorStyle.get(key) || "archipelago";
        assignCorridorMetadata(key, kind, style);
    }
    // Land-open corridors: default to plainsBelt style (playable open land)
    for (const key of StoryTags.corridorLandOpen) {
        const kind = StoryTags.corridorKind.get(key) || "land";
        const style = StoryTags.corridorStyle.get(key) || "plainsBelt";
        assignCorridorMetadata(key, kind, style);
    }
    // River-chain corridors: riverChain style
    for (const key of StoryTags.corridorRiverChain) {
        const kind = StoryTags.corridorKind.get(key) || "river";
        const style = StoryTags.corridorStyle.get(key) || "riverChain";
        assignCorridorMetadata(key, kind, style);
    }
    // Dev: style distribution summary (counts by kind:style)
    try {
        const styleCounts = {};
        for (const [k, kind] of StoryTags.corridorKind) {
            const st = StoryTags.corridorStyle.get(k) || "unknown";
            const bucket = `${kind}:${st}`;
            styleCounts[bucket] = (styleCounts[bucket] || 0) + 1;
        }
        devLogIf &&
            devLogIf("LOG_STORY_TAGS", `[Corridors] Style distribution: ${JSON.stringify(styleCounts)}`);
    }
    catch (_) {
        /* safe log */
    }
}
export default {
    storyTagStrategicCorridors,
};
</file>

<file path="mod/maps/story/overlays.js">
// @ts-nocheck
/**
 * Story Overlay Registry  immutable narrative data products.
 *
 * Overlays capture sparse storytelling metadata (margins, corridors, etc.) so
 * downstream stages can consume consistent snapshots without rerunning the
 * tagging passes that produced them.
 */

const overlayRegistry = new Map();

/** @typedef {import("../core/types.js").StoryOverlaySnapshot} StoryOverlaySnapshot */
/** @typedef {import("../core/types.js").StoryOverlayRegistry} StoryOverlayRegistry */

/**
 * Known overlay keys.
 */
export const StoryOverlayKeys = Object.freeze({
  MARGINS: "margins",
});

/**
 * Clear the global overlay registry. Primarily used by tests.
 */
export function resetStoryOverlays() {
  overlayRegistry.clear();
}

/**
 * Publish an overlay snapshot into the registry and attach it to the provided
 * MapContext when available.
 *
 * @param {import("../core/types.js").MapContext|null} ctx
 * @param {string} key
 * @param {Partial<StoryOverlaySnapshot>} overlay
 * @returns {StoryOverlaySnapshot}
 */
export function publishStoryOverlay(ctx, key, overlay) {
  const snapshot = normalizeOverlay(key, overlay);
  overlayRegistry.set(key, snapshot);
  if (ctx && typeof ctx === "object") {
    if (!ctx.overlays || typeof ctx.overlays.set !== "function") {
      ctx.overlays = new Map();
    }
    ctx.overlays.set(key, snapshot);
  }
  return snapshot;
}

/**
 * Finalize an overlay snapshot without publishing it to the registry.
 *
 * @param {string} key
 * @param {Partial<StoryOverlaySnapshot>} overlay
 * @returns {StoryOverlaySnapshot}
 */
export function finalizeStoryOverlay(key, overlay) {
  return normalizeOverlay(key, overlay);
}

/**
 * Retrieve an overlay snapshot. Prefers the MapContext registry when available
 * and falls back to the global module registry.
 *
 * @param {import("../core/types.js").MapContext|null} ctx
 * @param {string} key
 * @returns {StoryOverlaySnapshot|null}
 */
export function getStoryOverlay(ctx, key) {
  if (ctx && ctx.overlays && typeof ctx.overlays.get === "function") {
    const local = ctx.overlays.get(key);
    if (local)
      return local;
  }
  return overlayRegistry.get(key) || null;
}

/**
 * Populate StoryTags margin sets from a margin overlay snapshot.
 *
 * @param {StoryOverlaySnapshot|null|undefined} overlay
 * @param {{ activeMargin?: Set<string>, passiveShelf?: Set<string> }} storyTags
 * @param {{ clear?: boolean }} [options]
 * @returns {typeof storyTags}
 */
export function hydrateMarginsStoryTags(overlay, storyTags, options = {}) {
  if (!overlay || !storyTags || typeof storyTags !== "object")
    return storyTags;
  const active = Array.isArray(overlay.active) ? overlay.active : [];
  const passive = Array.isArray(overlay.passive) ? overlay.passive : [];
  const clear = options.clear !== false;
  const activeSet = storyTags.activeMargin;
  const passiveSet = storyTags.passiveShelf;
  if (clear) {
    activeSet?.clear?.();
    passiveSet?.clear?.();
  }
  if (activeSet && typeof activeSet.add === "function") {
    for (const key of active)
      activeSet.add(key);
  }
  if (passiveSet && typeof passiveSet.add === "function") {
    for (const key of passive)
      passiveSet.add(key);
  }
  return storyTags;
}

/**
 * Internal: normalize and freeze an overlay snapshot to guarantee immutability.
 *
 * @param {string} key
 * @param {Partial<StoryOverlaySnapshot>} overlay
 * @returns {StoryOverlaySnapshot}
 */
function normalizeOverlay(key, overlay) {
  const base = overlay && typeof overlay === "object" ? overlay : {};
  const width = Number.isFinite(base.width) ? base.width : 0;
  const height = Number.isFinite(base.height) ? base.height : 0;
  const version = Number.isFinite(base.version) ? base.version : 1;
  const kind = typeof base.kind === "string" && base.kind.length > 0 ? base.kind : key;
  const active = freezeKeyArray(base.active);
  const passive = freezeKeyArray(base.passive);
  const summary = freezeSummary(base.summary);
  return Object.freeze({
    key,
    kind,
    version,
    width,
    height,
    active,
    passive,
    summary,
  });
}

function freezeKeyArray(values) {
  if (!Array.isArray(values))
    return Object.freeze([]);
  const deduped = [];
  const seen = new Set();
  for (const value of values) {
    if (typeof value !== "string")
      continue;
    if (seen.has(value))
      continue;
    seen.add(value);
    deduped.push(value);
  }
  return Object.freeze(deduped);
}

function freezeSummary(summary) {
  if (!summary || typeof summary !== "object")
    return Object.freeze({});
  return Object.freeze({ ...summary });
}

/**
 * Expose the registry for diagnostics without allowing mutation.
 */
export const StoryOverlays = Object.freeze({
  get registry() {
    return overlayRegistry;
  },
});
</file>

<file path="mod/maps/story/tagging.js">
// @ts-nocheck
/**
 * Climate Story  Tagging functions
 *
 * This module generates lightweight, sparse tags (StoryTags) that imprint
 * narrative motifs onto the map without heavy simulation. Tags are consumed by
 * other layers (coast/island shaping, rainfall refinement, biome/feature nudges).
 *
 * Exports:
 *  - storyTagHotspotTrails(ctx?): Tag deepocean hotspot polylines.
 *  - storyTagRiftValleys(ctx?): Tag inland rift centerlines and shoulder tiles.
 *
 * Notes:
 *  - Tags are stored in StoryTags as "x,y" string keys for simplicity.
 *  - ctx is optional; functions will query GameplayMap directly if omitted.
 *  - All tunables are conservative; guardrails are preserved by consumers.
 *  - Climate tuning (baseline and refinement) is configured via map_config and consumed in the climate layers; this module only tags, while consumers preserve clamps.
 */
import { StoryTags } from "./tags.js";
import { publishStoryOverlay, finalizeStoryOverlay, StoryOverlayKeys, hydrateMarginsStoryTags } from "./overlays.js";
import { STORY_TUNABLES, STORY_ENABLE_SWATCHES, STORY_ENABLE_PALEO, MARGINS_CFG, MOISTURE_ADJUSTMENTS, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { inBounds, storyKey, isAdjacentToLand } from "../core/utils.js";
import { writeClimateField, syncClimateField, ctxRandom } from "../core/types.js";
import { WorldModel } from "../world/model.js";
import { applyClimateSwatches } from "../layers/climate-engine.js";
/**
 * Tag deepocean hotspot trails as sparse polylines.
 * Trails are later used to bias offshore island placement and microclimates.
 *
 * Rules:
 *  - Keep trails far from land (minDistFromLand).
 *  - Enforce minimum separation between different trails.
 *  - March a fixed number of steps with occasional gentle bends.
 *
 * @param {object} [ctx] - Optional context (unused; present for future parity).
 * @returns {{ trails:number, points:number }} summary counts
 */
export function storyTagHotspotTrails(ctx) {
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const baseHot = STORY_TUNABLES.hotspot;
    const areaHot = Math.max(1, width * height);
    const sqrtHot = Math.min(2.0, Math.max(0.6, Math.sqrt(areaHot / 10000)));
    const maxTrails = Math.max(1, Math.round(baseHot.maxTrails * (0.9 + 0.6 * sqrtHot)));
    const steps = Math.round(baseHot.steps * (0.9 + 0.4 * sqrtHot));
    const stepLen = baseHot.stepLen;
    const minDistFromLand = baseHot.minDistFromLand;
    const minTrailSeparation = baseHot.minTrailSeparation;
    // Helper: ensure a candidate is far enough from any previously tagged hotspot point
    function farFromExisting(x, y) {
        for (const key of StoryTags.hotspot) {
            const [sx, sy] = key.split(",").map(Number);
            const d = Math.abs(sx - x) + Math.abs(sy - y); // Manhattan is cheap/sufficient
            if (d < minTrailSeparation)
                return false;
        }
        return true;
    }
    let trailsMade = 0;
    let totalPoints = 0;
    let attempts = 0;
    while (trailsMade < maxTrails && attempts < 200) {
        attempts++;
        const sx = TerrainBuilder.getRandomNumber(width, "HotspotSeedX");
        const sy = TerrainBuilder.getRandomNumber(height, "HotspotSeedY");
        if (!inBounds(sx, sy))
            continue;
        if (!GameplayMap.isWater(sx, sy))
            continue;
        if (isAdjacentToLand(sx, sy, minDistFromLand))
            continue;
        if (!farFromExisting(sx, sy))
            continue;
        // Choose one of 8 compass directions; well allow small bends as we march.
        const dirs = [
            [1, 0],
            [1, 1],
            [0, 1],
            [-1, 1],
            [-1, 0],
            [-1, -1],
            [0, -1],
            [1, -1],
        ];
        let dIndex = TerrainBuilder.getRandomNumber(dirs.length, "HotspotDir");
        let [dx, dy] = dirs[dIndex];
        let x = sx;
        let y = sy;
        let taggedThisTrail = 0;
        for (let s = 0; s < steps; s++) {
            x += dx * stepLen;
            y += dy * stepLen;
            if (!inBounds(x, y))
                break;
            if (!GameplayMap.isWater(x, y))
                continue;
            if (isAdjacentToLand(x, y, minDistFromLand))
                continue;
            StoryTags.hotspot.add(storyKey(x, y));
            taggedThisTrail++;
            totalPoints++;
            // Gentle bend with small probability (creates subtle arcs)
            if (TerrainBuilder.getRandomNumber(5, "HotspotBend") === 0) {
                dIndex =
                    (dIndex +
                        (TerrainBuilder.getRandomNumber(3, "HotspotTurn") - 1) +
                        dirs.length) %
                        dirs.length;
                [dx, dy] = dirs[dIndex];
            }
        }
        if (taggedThisTrail > 0) {
            trailsMade++;
        }
    }
    return { trails: trailsMade, points: totalPoints };
}
/**
 * Tag inland rift valleys using WorldModel.riftPotential where available.
 * Fallback: legacy random-marching rifts when WorldModel is disabled.
 *
 * @param {object} [ctx]
 * @returns {{ rifts:number, lineTiles:number, shoulderTiles:number }}
 */
export function storyTagRiftValleys(ctx) {
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const baseRift = STORY_TUNABLES.rift;
    const areaRift = Math.max(1, width * height);
    const sqrtRift = Math.min(2.0, Math.max(0.6, Math.sqrt(areaRift / 10000)));
    const maxRiftsPerMap = Math.max(1, Math.round(baseRift.maxRiftsPerMap * (0.8 + 0.6 * sqrtRift)));
    const lineSteps = Math.round(baseRift.lineSteps * (0.9 + 0.4 * sqrtRift));
    const stepLen = Math.max(1, baseRift.stepLen | 0);
    const shoulderWidth = baseRift.shoulderWidth + (sqrtRift > 1.5 ? 1 : 0);
    const useWM = !!(WorldModel?.isEnabled?.() &&
        WorldModel.riftPotential &&
        WorldModel.boundaryType &&
        WorldModel.boundaryCloseness);
    const idx = (x, y) => y * width + x;
    const inb = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
    const latDegAt = (y) => Math.abs(GameplayMap.getPlotLatitude(0, y));
    if (useWM) {
        const RP = WorldModel.riftPotential;
        const BT = WorldModel.boundaryType; // 1=convergent, 2=divergent
        const BC = WorldModel.boundaryCloseness;
        // 1) Find sparse seeds: local maxima on divergent boundaries over land
        const seeds = [];
        let thr = 192;
        let attempts = 0;
        while (attempts++ < 6) {
            seeds.length = 0;
            for (let y = 1; y < height - 1; y++) {
                if (latDegAt(y) > 70)
                    continue;
                for (let x = 1; x < width - 1; x++) {
                    if (GameplayMap.isWater(x, y))
                        continue;
                    const i = idx(x, y);
                    if (BT[i] !== 2 || BC[i] <= 32 || RP[i] < thr)
                        continue;
                    // Local-maximum test
                    const v = RP[i];
                    let isPeak = true;
                    for (let dy = -1; dy <= 1 && isPeak; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0)
                                continue;
                            if (RP[idx(x + dx, y + dy)] > v) {
                                isPeak = false;
                                break;
                            }
                        }
                    }
                    if (isPeak)
                        seeds.push({ x, y, v });
                }
            }
            if (seeds.length >= maxRiftsPerMap * 2 || thr <= 112)
                break;
            thr -= 16;
        }
        seeds.sort((a, b) => b.v - a.v);
        // Space seeds out by Manhattan distance
        const chosen = [];
        const minSeedSep = Math.round(sqrtRift > 1.5 ? 18 : 14);
        for (const s of seeds) {
            if (chosen.length >= maxRiftsPerMap)
                break;
            const farEnough = chosen.every((c) => Math.abs(c.x - s.x) + Math.abs(c.y - s.y) >= minSeedSep);
            if (farEnough)
                chosen.push(s);
        }
        let riftsMade = 0;
        let lineCount = 0;
        let shoulderCount = 0;
        function tagShoulders(x, y, sdx, sdy) {
            for (let off = 1; off <= shoulderWidth; off++) {
                const px = x + -sdy * off;
                const py = y + sdx * off;
                const qx = x + sdy * off;
                const qy = y + -sdx * off;
                if (inb(px, py) && !GameplayMap.isWater(px, py)) {
                    const pk = storyKey(px, py);
                    if (!StoryTags.riftShoulder.has(pk)) {
                        StoryTags.riftShoulder.add(pk);
                        shoulderCount++;
                    }
                }
                if (inb(qx, qy) && !GameplayMap.isWater(qx, qy)) {
                    const qk = storyKey(qx, qy);
                    if (!StoryTags.riftShoulder.has(qk)) {
                        StoryTags.riftShoulder.add(qk);
                        shoulderCount++;
                    }
                }
            }
        }
        for (const seed of chosen) {
            let x = seed.x, y = seed.y;
            if (latDegAt(y) > 70)
                continue;
            // Initialize step direction toward highest neighboring RP
            let sdx = 1, sdy = 0;
            {
                let best = -1, bdx = 1, bdy = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        const nx = x + dx, ny = y + dy;
                        if (!inb(nx, ny) || GameplayMap.isWater(nx, ny))
                            continue;
                        const p = RP[idx(nx, ny)];
                        if (p > best) {
                            best = p;
                            bdx = dx;
                            bdy = dy;
                        }
                    }
                }
                sdx = bdx;
                sdy = bdy;
            }
            let placedAny = false;
            for (let s = 0; s < lineSteps; s++) {
                if (!inb(x, y) || GameplayMap.isWater(x, y) || latDegAt(y) > 70)
                    break;
                const k = storyKey(x, y);
                if (!StoryTags.riftLine.has(k)) {
                    StoryTags.riftLine.add(k);
                    lineCount++;
                }
                placedAny = true;
                tagShoulders(x, y, sdx, sdy);
                // Helper: directionality bias toward plateAxisDeg (cohesion  riftsFollowPlates)
                function stepDirBias(tx, ty) {
                    try {
                        const DIR = FOUNDATION_DIRECTIONALITY || {};
                        const coh = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                        const follow = Math.max(0, Math.min(1, DIR?.interplay?.riftsFollowPlates ?? 0)) * coh;
                        if (follow <= 0)
                            return 0;
                        const deg = (DIR?.primaryAxes?.plateAxisDeg ?? 0) | 0;
                        const rad = (deg * Math.PI) / 180;
                        const ax = Math.cos(rad);
                        const ay = Math.sin(rad);
                        const vlen = Math.max(1, Math.hypot(tx, ty));
                        const vx = tx / vlen;
                        const vy = ty / vlen;
                        const dot = ax * vx + ay * vy; // -1..1
                        // Scale to a small, safe bonus
                        return Math.round(10 * follow * dot);
                    }
                    catch {
                        return 0;
                    }
                }
                // Choose next step by RP gradient with straightness + directionality preference
                let bestScore = -1, ndx = sdx, ndy = sdy, nx = x, ny = y;
                for (let ty = -1; ty <= 1; ty++) {
                    for (let tx = -1; tx <= 1; tx++) {
                        if (tx === 0 && ty === 0)
                            continue;
                        const cx = x + tx * stepLen, cy = y + ty * stepLen;
                        if (!inb(cx, cy) || GameplayMap.isWater(cx, cy))
                            continue;
                        const p = RP[idx(cx, cy)];
                        const align = tx === sdx && ty === sdy
                            ? 16
                            : tx === -sdx && ty === -sdy
                                ? -12
                                : 0;
                        const score = p + align + stepDirBias(tx, ty);
                        if (score > bestScore) {
                            bestScore = score;
                            ndx = tx;
                            ndy = ty;
                            nx = cx;
                            ny = cy;
                        }
                    }
                }
                // Stop if leaving divergent boundary band or very weak RP
                const ii = inb(nx, ny) ? idx(nx, ny) : -1;
                if (ii < 0 || BT[ii] !== 2 || BC[ii] <= 16 || RP[ii] < 64)
                    break;
                x = nx;
                y = ny;
                sdx = ndx;
                sdy = ndy;
            }
            if (placedAny)
                riftsMade++;
            if (riftsMade >= maxRiftsPerMap)
                break;
        }
        return {
            rifts: riftsMade,
            lineTiles: lineCount,
            shoulderTiles: shoulderCount,
        };
    }
    // Legacy fallback: original random marching implementation
    {
        // Two families of headings to get continental-scale lines without zig-zag
        const dirsNS = [
            [0, 1],
            [0, -1],
            [1, 1],
            [-1, -1],
        ];
        const dirsEW = [
            [1, 0],
            [-1, 0],
            [1, 1],
            [-1, -1],
        ];
        let riftsMade = 0;
        let lineCount = 0;
        let shoulderCount = 0;
        let tries = 0;
        while (riftsMade < maxRiftsPerMap && tries < 300) {
            tries++;
            const sx = TerrainBuilder.getRandomNumber(width, "RiftSeedX");
            const sy = TerrainBuilder.getRandomNumber(height, "RiftSeedY");
            if (!inBounds(sx, sy))
                continue;
            if (GameplayMap.isWater(sx, sy))
                continue;
            const plat = Math.abs(GameplayMap.getPlotLatitude(sx, sy));
            if (plat > 70)
                continue; // avoid extreme polar artifacts
            const elev = GameplayMap.getElevation(sx, sy);
            if (elev > 500)
                continue; // seed away from high mountains
            // Pick axis family and a particular direction
            const useNS = TerrainBuilder.getRandomNumber(2, "RiftAxis") === 0;
            let dir = useNS
                ? dirsNS[TerrainBuilder.getRandomNumber(dirsNS.length, "RiftDirNS")]
                : dirsEW[TerrainBuilder.getRandomNumber(dirsEW.length, "RiftDirEW")];
            let [dx, dy] = dir;
            let x = sx;
            let y = sy;
            let placedAny = false;
            for (let s = 0; s < lineSteps; s++) {
                x += dx * stepLen;
                y += dy * stepLen;
                if (!inBounds(x, y))
                    break;
                if (GameplayMap.isWater(x, y))
                    continue;
                const k = storyKey(x, y);
                if (!StoryTags.riftLine.has(k)) {
                    StoryTags.riftLine.add(k);
                    lineCount++;
                }
                placedAny = true;
                // Tag shoulder tiles on both sides (perpendicular offset)
                for (let off = 1; off <= shoulderWidth; off++) {
                    const px = x + -dy * off;
                    const py = y + dx * off;
                    const qx = x + dy * off;
                    const qy = y + -dx * off;
                    if (inBounds(px, py) && !GameplayMap.isWater(px, py)) {
                        const pk = storyKey(px, py);
                        if (!StoryTags.riftShoulder.has(pk)) {
                            StoryTags.riftShoulder.add(pk);
                            shoulderCount++;
                        }
                    }
                    if (inBounds(qx, qy) && !GameplayMap.isWater(qx, qy)) {
                        const qk = storyKey(qx, qy);
                        if (!StoryTags.riftShoulder.has(qk)) {
                            StoryTags.riftShoulder.add(qk);
                            shoulderCount++;
                        }
                    }
                }
                // Occasional, small bend to avoid ruler-straight lines
                if (TerrainBuilder.getRandomNumber(6, "RiftBend") === 0) {
                    if (useNS) {
                        dir =
                            dirsNS[TerrainBuilder.getRandomNumber(dirsNS.length, "RiftDirNS2")];
                    }
                    else {
                        dir =
                            dirsEW[TerrainBuilder.getRandomNumber(dirsEW.length, "RiftDirEW2")];
                    }
                    [dx, dy] = dir;
                }
            }
            if (placedAny) {
                riftsMade++;
            }
        }
        return {
            rifts: riftsMade,
            lineTiles: lineCount,
            shoulderTiles: shoulderCount,
        };
    }
}
export const OrogenyCache = {
    belts: new Set(),
    windward: new Set(),
    lee: new Set(),
};
/**
 * Tag Orogeny belts using WorldModel uplift/tectonic stress near convergent boundaries.
 * Fallback: legacy elevation-density heuristic when WorldModel is disabled.
 *
 * Returns simple counts; results stored in OrogenyCache for consumers.
 */
export function storyTagOrogenyBelts(ctx) {
    // Clear previous cache
    OrogenyCache.belts.clear();
    OrogenyCache.windward.clear();
    OrogenyCache.lee.clear();
    const width = GameplayMap.getGridWidth();
    const height = GameplayMap.getGridHeight();
    const area = Math.max(1, width * height);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    const cfg = STORY_TUNABLES?.orogeny || {};
    const baseRadius = (cfg.radius ?? 2) | 0;
    const radius = baseRadius + (sqrtScale > 1.5 ? 1 : 0);
    const minLenSoft = Math.max(10, Math.round((cfg.beltMinLength ?? 30) * (0.9 + 0.4 * sqrtScale)));
    const useWM = !!(WorldModel?.isEnabled?.() &&
        WorldModel.upliftPotential &&
        WorldModel.tectonicStress &&
        WorldModel.boundaryType &&
        WorldModel.boundaryCloseness);
    if (useWM) {
        const U = WorldModel.upliftPotential;
        const S = WorldModel.tectonicStress;
        const BT = WorldModel.boundaryType; // 1=convergent
        const BC = WorldModel.boundaryCloseness;
        // Pass 1: seed belts from convergent boundaries with high uplift/stress combo
        // Combined metric: 0.7*U + 0.3*S; threshold search to keep belts sparse
        let thr = 180;
        let attempts = 0;
        while (attempts++ < 5) {
            OrogenyCache.belts.clear();
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    if (GameplayMap.isWater(x, y))
                        continue;
                    const i = y * width + x;
                    if (BT[i] !== 1 || BC[i] < 48)
                        continue;
                    const metric = Math.round(0.7 * U[i] + 0.3 * S[i]);
                    if (metric >= thr) {
                        // Light neighborhood density check to avoid salt-and-pepper
                        let dense = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0)
                                    continue;
                                const j = (y + dy) * width + (x + dx);
                                if (j >= 0 && j < width * height) {
                                    const m2 = Math.round(0.7 * U[j] + 0.3 * S[j]);
                                    if (m2 >= thr)
                                        dense++;
                                }
                            }
                        }
                        if (dense >= 2) {
                            OrogenyCache.belts.add(`${x},${y}`);
                        }
                    }
                }
            }
            if (OrogenyCache.belts.size >= minLenSoft || thr <= 128)
                break;
            thr -= 12;
        }
        // Soft reject trivial belts
        if (OrogenyCache.belts.size < minLenSoft) {
            return { belts: 0, windward: 0, lee: 0 };
        }
        // Prevailing wind step using WorldModel winds (fallback to zonal if unavailable)
        function windStepXY(x, y) {
            try {
                if (WorldModel?.windU && WorldModel?.windV) {
                    const width = GameplayMap.getGridWidth();
                    const i = y * width + x;
                    const u = WorldModel.windU[i] | 0;
                    const v = WorldModel.windV[i] | 0;
                    if (Math.abs(u) >= Math.abs(v)) {
                        return { dx: u === 0 ? 0 : u > 0 ? 1 : -1, dy: 0 };
                    }
                    else {
                        return { dx: 0, dy: v === 0 ? 0 : v > 0 ? 1 : -1 };
                    }
                }
            }
            catch {
                /* fall back to zonal below */
            }
            const lat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            return { dx: lat < 30 || lat >= 60 ? -1 : 1, dy: 0 };
        }
        // Pass 2: expand flanks on both sides of each belt tile
        for (const key of OrogenyCache.belts) {
            const [sx, sy] = key.split(",").map(Number);
            const { dx, dy } = windStepXY(sx, sy);
            const upwindX = -dx, upwindY = -dy;
            const downX = dx, downY = dy;
            for (let r = 1; r <= radius; r++) {
                const wx = sx + upwindX * r, wy = sy + upwindY * r;
                const lx = sx + downX * r, ly = sy + downY * r;
                if (inBounds(wx, wy) && !GameplayMap.isWater(wx, wy)) {
                    OrogenyCache.windward.add(storyKey(wx, wy));
                }
                if (inBounds(lx, ly) && !GameplayMap.isWater(lx, ly)) {
                    OrogenyCache.lee.add(storyKey(lx, ly));
                }
            }
        }
        return {
            belts: OrogenyCache.belts.size,
            windward: OrogenyCache.windward.size,
            lee: OrogenyCache.lee.size,
        };
    }
    // Legacy fallback: elevation-density heuristic
    {
        // Helper: elevation predicate (prefer GameplayMap.isMountain when exposed)
        function isHighElev(x, y) {
            if (!inBounds(x, y))
                return false;
            if (GameplayMap.isMountain && GameplayMap.isMountain(x, y))
                return true;
            return GameplayMap.getElevation(x, y) >= 500;
        }
        // Pass 1: collect belt candidates by local mountain density
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (!isHighElev(x, y))
                    continue;
                // Count high-elevation neighbors (8-neighborhood)
                let hi = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        const nx = x + dx, ny = y + dy;
                        if (isHighElev(nx, ny))
                            hi++;
                    }
                }
                if (hi >= 2) {
                    OrogenyCache.belts.add(storyKey(x, y));
                }
            }
        }
        // Soft reject trivial belts (very small mountain presence)
        if (OrogenyCache.belts.size < minLenSoft) {
            return { belts: 0, windward: 0, lee: 0 };
        }
        // Prevailing wind vector by latitude (zonal)
        function windDX(x, y) {
            const lat = Math.abs(GameplayMap.getPlotLatitude(x, y));
            return lat < 30 || lat >= 60 ? -1 : 1; // EW else WE
        }
        // Pass 2: expand flanks on both sides of each belt tile
        for (const key of OrogenyCache.belts) {
            const [x, y] = key.split(",").map(Number);
            const dx = windDX(x, y);
            const dy = 0;
            const upwindX = -dx, upwindY = -dy;
            const downX = dx, downY = dy;
            for (let r = 1; r <= radius; r++) {
                const wx = x + upwindX * r, wy = y + upwindY * r;
                const lx = x + downX * r, ly = y + downY * r;
                if (inBounds(wx, wy) && !GameplayMap.isWater(wx, wy)) {
                    OrogenyCache.windward.add(storyKey(wx, wy));
                }
                if (inBounds(lx, ly) && !GameplayMap.isWater(lx, ly)) {
                    OrogenyCache.lee.add(storyKey(lx, ly));
                }
            }
        }
        return {
            belts: OrogenyCache.belts.size,
            windward: OrogenyCache.windward.size,
            lee: OrogenyCache.lee.size,
        };
    }
}
/**
 * Tag ACTIVE_MARGIN and PASSIVE_SHELF coast segments.
 * Heuristic (lane-safe, size-aware):
 * - Scan rows to collect contiguous coastal-land segments (cheap linear pass).
 * - Choose sparse, long segments for margins using target fractions and a minimum segment length.
 * - Targets scale gently with map size (sqrt(area/base)).
 * Notes
 * - Works without continent IDs; segments stay local and sparse to avoid noisy toggling.
 * - Consumers (coastlines/islands/features) must preserve minimum sea-lane width.
 */
export function storyTagContinentalMargins(ctxOrOptions = null, maybeOptions = null) {
    let ctx = null;
    let options = maybeOptions || {};
    if (ctxOrOptions && typeof ctxOrOptions === "object") {
        if (ctxOrOptions.adapter && ctxOrOptions.dimensions) {
            ctx = ctxOrOptions;
        }
        else if (!maybeOptions) {
            options = ctxOrOptions;
        }
    }
    const width = ctx?.dimensions?.width ?? GameplayMap.getGridWidth();
    const height = ctx?.dimensions?.height ?? GameplayMap.getGridHeight();
    // Size-aware fractions (configurable with safe defaults)
    const area = Math.max(1, width * height);
    const sqrt = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    const mcfg = MARGINS_CFG || {};
    const baseActiveFrac = Number.isFinite(mcfg.activeFraction)
        ? mcfg.activeFraction
        : 0.25;
    const basePassiveFrac = Number.isFinite(mcfg.passiveFraction)
        ? mcfg.passiveFraction
        : 0.25;
    const activeFrac = Math.min(0.35, baseActiveFrac + 0.05 * (sqrt - 1));
    const passiveFrac = Math.min(0.35, basePassiveFrac + 0.05 * (sqrt - 1));
    const baseMinSeg = Number.isFinite(mcfg.minSegmentLength)
        ? mcfg.minSegmentLength
        : 12;
    const minSegLen = Math.max(10, Math.round(baseMinSeg * (0.9 + 0.4 * sqrt))); // size-aware minimum
    // First pass: count total coastal land to derive quotas
    let totalCoast = 0;
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (GameplayMap.isCoastalLand(x, y))
                totalCoast++;
        }
    }
    const targetActive = Math.floor(totalCoast * activeFrac);
    const targetPassive = Math.floor(totalCoast * passiveFrac);
    let markedActive = 0;
    let markedPassive = 0;
    const activeSet = new Set();
    const passiveSet = new Set();
    // Helper to mark a segment safely
    function markSegment(y, x0, x1, active) {
        for (let x = x0; x <= x1; x++) {
            const k = `${x},${y}`;
            if (!GameplayMap.isCoastalLand(x, y))
                continue;
            if (active) {
                if (markedActive >= targetActive)
                    break;
                if (!activeSet.has(k)) {
                    activeSet.add(k);
                    markedActive++;
                }
            }
            else {
                if (markedPassive >= targetPassive)
                    break;
                if (!passiveSet.has(k)) {
                    passiveSet.add(k);
                    markedPassive++;
                }
            }
        }
    }
    // Row sweep: build contiguous coastal-land segments and select some
    // Alternate selections to avoid clustering too many active or passive in a row.
    let preferActive = true;
    for (let y = 1; y < height - 1; y++) {
        let x = 1;
        while (x < width - 1) {
            // Find start of a coastal segment
            while (x < width - 1 && !GameplayMap.isCoastalLand(x, y))
                x++;
            if (x >= width - 1)
                break;
            const start = x;
            while (x < width - 1 && GameplayMap.isCoastalLand(x, y))
                x++;
            const end = x - 1;
            const segLen = end - start + 1;
            if (segLen >= minSegLen) {
                // Coin flip with bias toward the currently preferred type
                const roll = TerrainBuilder.getRandomNumber(100, "MarginSelect");
                const pickActive = (preferActive && roll < 60) || (!preferActive && roll < 40);
                if (pickActive && markedActive < targetActive) {
                    markSegment(y, start, end, true);
                }
                else if (markedPassive < targetPassive) {
                    markSegment(y, start, end, false);
                }
                // Alternate preference to reduce long runs of the same type
                preferActive = !preferActive;
            }
        }
        // Reset scanning x for next row
        x = 1;
    }
    const overlay = {
        kind: StoryOverlayKeys.MARGINS,
        version: 1,
        width,
        height,
        active: Array.from(activeSet),
        passive: Array.from(passiveSet),
        summary: {
            active: markedActive,
            passive: markedPassive,
            targetActive,
            targetPassive,
            minSegmentLength: minSegLen,
        },
    };
    const shouldPublish = options.publish !== false;
    const snapshot = shouldPublish
        ? publishStoryOverlay(ctx, StoryOverlayKeys.MARGINS, overlay)
        : finalizeStoryOverlay(StoryOverlayKeys.MARGINS, overlay);
    if (options.hydrateStoryTags !== false) {
        hydrateMarginsStoryTags(snapshot, StoryTags);
    }
    return snapshot;
}
// -------------------------------- Climate Swatches --------------------------------
/**
 * storyTagClimateSwatches  Paint one guaranteed macro swatch with soft edges.
 * - Selects one swatch type (weighted) and applies rainfall deltas with gentle falloff.
 * - Uses sqrt(area/base) to scale width/length modestly on large maps.
 * - Keeps all adjustments clamped to [0, 200] and local (single O(WH) pass).
 *
 * Swatch types (see STORY_TUNABLES.swatches.types):
 *  - macroDesertBelt: subtract rainfall around ~20 lat with soft bleed.
 *  - equatorialRainbelt: add rainfall around 0 lat with generous bleed.
 *  - rainforestArchipelago: add rainfall near warm coasts/islands (tropics).
 *  - mountainForests: add on orogeny windward, subtract a touch on lee.
 *  - greatPlains: lowland mid-lat dry bias (broad plains feel).
 */
export function storyTagClimateSwatches(ctx = null) {
    if (!STORY_ENABLE_SWATCHES)
        return { applied: false, kind: "disabled" };
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    if (!storyMoisture?.swatches)
        return { applied: false, kind: "missing-config" };
    const width = ctx?.dimensions?.width ?? GameplayMap.getGridWidth();
    const height = ctx?.dimensions?.height ?? GameplayMap.getGridHeight();
    const result = applyClimateSwatches(width, height, ctx, { orogenyCache: OrogenyCache });
    const summary = { ...result };
    if (STORY_ENABLE_PALEO) {
        try {
            const paleoResult = storyTagPaleoHydrology(ctx || undefined);
            summary.paleo = paleoResult;
        }
        catch (_) {
            /* keep generation resilient */
        }
    }
    return summary;
}
// -------------------------------- PaleoHydrology --------------------------------
/**
 * storyTagPaleoHydrology  elevationaware paleo motifs:
 *  - Deltas: slight humidity fans near river mouths (lowland, coastal).
 *  - Oxbows: a handful of lowland riveradjacent wet pockets (no rivers added).
 *  - Fossil channels: short polylines across dry lowlands toward local basins.
 * Elevation cues:
 *  - Canyon/bed dryness on the fossil centerline (small).
 *  - Optional bluff/rim hint via minor adjustments on immediate flanks.
 * Invariants:
 *  - All rainfall ops clamped [0, 200]. No broad floodfills. Strict caps.
 */
export function storyTagPaleoHydrology(ctx = null) {
    const storyMoisture = MOISTURE_ADJUSTMENTS?.story || {};
    const cfg = storyMoisture.paleo;
    if (!cfg)
        return { deltas: 0, oxbows: 0, fossils: 0 };
    const width = ctx?.dimensions?.width ?? GameplayMap.getGridWidth();
    const height = ctx?.dimensions?.height ?? GameplayMap.getGridHeight();
    const area = Math.max(1, width * height);
    const sqrtScale = Math.min(2.0, Math.max(0.6, Math.sqrt(area / 10000)));
    if (ctx) {
        syncClimateField(ctx);
    }
    const clamp = (v, lo, hi) => (v < lo ? lo : v > hi ? hi : v);
    const nearStartGuard = ( /*x,y*/) => true;
    const rand = (n, lbl) => (ctx ? ctxRandom(ctx, lbl || 'Paleo', n) : TerrainBuilder.getRandomNumber(n, lbl || 'Paleo'));
    const adapter = ctx?.adapter ?? null;
    const rainfallBuf = ctx?.buffers?.climate?.rainfall || null;
    const idx = (x, y) => y * width + x;
    const readRainfall = (x, y) => {
        if (ctx && rainfallBuf) {
            return rainfallBuf[idx(x, y)] | 0;
        }
        return GameplayMap.getRainfall(x, y);
    };
    const writeRainfall = (x, y, rf) => {
        const clamped = clamp(rf, 0, 200);
        if (ctx) {
            writeClimateField(ctx, x, y, { rainfall: clamped });
        }
        else {
            TerrainBuilder.setRainfall(x, y, clamped);
        }
    };
    let deltas = 0, oxbows = 0, fossils = 0;
    if (cfg.maxDeltas > 0) {
        for (let y = 1; y < height - 1 && deltas < cfg.maxDeltas; y++) {
            for (let x = 1; x < width - 1 && deltas < cfg.maxDeltas; x++) {
                if (!(adapter?.isCoastalLand ? adapter.isCoastalLand(x, y) : GameplayMap.isCoastalLand(x, y)))
                    continue;
                if (!(adapter?.isAdjacentToRivers ? adapter.isAdjacentToRivers(x, y, 1) : GameplayMap.isAdjacentToRivers(x, y, 1)))
                    continue;
                if ((adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y)) > 300)
                    continue;
                const fanR = Math.max(0, cfg.deltaFanRadius | 0);
                for (let dy = -fanR; dy <= fanR; dy++) {
                    for (let dx = -fanR; dx <= fanR; dx++) {
                        const nx = x + dx, ny = y + dy;
                        if (!inBounds(nx, ny))
                            continue;
                        if (adapter?.isWater ? adapter.isWater(nx, ny) : GameplayMap.isWater(nx, ny))
                            continue;
                        let rf = readRainfall(nx, ny);
                        if (rand(100, 'DeltaMarsh') < Math.round((cfg.deltaMarshChance || 0.35) * 100)) {
                            rf = clamp(rf + 6, 0, 200);
                        }
                        else {
                            rf = clamp(rf + 3, 0, 200);
                        }
                        writeRainfall(nx, ny, rf);
                    }
                }
                deltas++;
            }
        }
    }
    if (cfg.maxOxbows > 0) {
        let attempts = 0;
        while (oxbows < cfg.maxOxbows && attempts < 300) {
            attempts++;
            const x = rand(width, 'OxbowX');
            const y = rand(height, 'OxbowY');
            if (!inBounds(x, y))
                continue;
            if (adapter?.isWater ? adapter.isWater(x, y) : GameplayMap.isWater(x, y))
                continue;
            const elev = adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y);
            if (elev > (cfg.oxbowElevationMax ?? 280))
                continue;
            if (!(adapter?.isAdjacentToRivers ? adapter.isAdjacentToRivers(x, y, 1) : GameplayMap.isAdjacentToRivers(x, y, 1)))
                continue;
            if (!nearStartGuard(x, y))
                continue;
            let rf = readRainfall(x, y);
            writeRainfall(x, y, rf + 8);
            oxbows++;
        }
    }
    if (cfg.maxFossilChannels > 0) {
        const baseLen = Math.max(6, cfg.fossilChannelLengthTiles | 0);
        const step = Math.max(1, cfg.fossilChannelStep | 0);
        const len = Math.round(baseLen * (1 + (cfg.sizeScaling?.lengthMulSqrt || 0) * (sqrtScale - 1)));
        const hum = cfg.fossilChannelHumidity | 0;
        const minDistFromRivers = Math.max(0, cfg.fossilChannelMinDistanceFromCurrentRivers | 0);
        const canyonCfg = cfg.elevationCarving || {};
        const rimW = Math.max(0, canyonCfg.rimWidth | 0);
        const canyonDryBonus = Math.max(0, canyonCfg.canyonDryBonus | 0);
        let tries = 0;
        while (fossils < cfg.maxFossilChannels && tries < 120) {
            tries++;
            let sx = rand(width, 'FossilX');
            let sy = rand(height, 'FossilY');
            if (!inBounds(sx, sy))
                continue;
            if (adapter?.isWater ? adapter.isWater(sx, sy) : GameplayMap.isWater(sx, sy))
                continue;
            const startElev = adapter?.getElevation ? adapter.getElevation(sx, sy) : GameplayMap.getElevation(sx, sy);
            if (startElev > 320)
                continue;
            if ((adapter?.isAdjacentToRivers ? adapter.isAdjacentToRivers(sx, sy, minDistFromRivers) : GameplayMap.isAdjacentToRivers(sx, sy, minDistFromRivers)))
                continue;
            let x = sx, y = sy;
            let used = 0;
            while (used < len) {
                if (inBounds(x, y) && !(adapter?.isWater ? adapter.isWater(x, y) : GameplayMap.isWater(x, y))) {
                    let rf = readRainfall(x, y);
                    rf = clamp(rf + hum, 0, 200);
                    if ((canyonCfg.enableCanyonRim ?? true) && canyonDryBonus > 0) {
                        rf = clamp(rf - canyonDryBonus, 0, 200);
                    }
                    writeRainfall(x, y, rf);
                    if ((canyonCfg.enableCanyonRim ?? true) && rimW > 0) {
                        for (let ry = -rimW; ry <= rimW; ry++) {
                            for (let rx = -rimW; rx <= rimW; rx++) {
                                if (rx === 0 && ry === 0)
                                    continue;
                                const nx = x + rx, ny = y + ry;
                                if (!inBounds(nx, ny) || (adapter?.isWater ? adapter.isWater(nx, ny) : GameplayMap.isWater(nx, ny)))
                                    continue;
                                const e0 = adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y);
                                const e1 = adapter?.getElevation ? adapter.getElevation(nx, ny) : GameplayMap.getElevation(nx, ny);
                                if (e1 > e0 + 15) {
                                    const rfn = clamp(readRainfall(nx, ny) - (cfg.bluffWetReduction ?? 0), 0, 200);
                                    writeRainfall(nx, ny, rfn);
                                }
                            }
                        }
                    }
                }
                let bestNX = x, bestNY = y, bestElev = adapter?.getElevation ? adapter.getElevation(x, y) : GameplayMap.getElevation(x, y);
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0)
                            continue;
                        if ((dx !== 0 || dy !== 0) && (Math.abs(dx) + Math.abs(dy)) * step > 2)
                            continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (!inBounds(nx, ny))
                            continue;
                        const elev = adapter?.getElevation ? adapter.getElevation(nx, ny) : GameplayMap.getElevation(nx, ny);
                        if (elev < bestElev) {
                            bestElev = elev;
                            bestNX = nx;
                            bestNY = ny;
                        }
                    }
                }
                if (bestNX === x && bestNY === y)
                    break;
                x = bestNX;
                y = bestNY;
                used += step;
            }
            if (used >= len)
                fossils++;
        }
    }
    return { deltas, oxbows, fossils };
}

export default {
    storyTagHotspotTrails,
    storyTagRiftValleys,
    storyTagOrogenyBelts,
    storyTagContinentalMargins,
    storyTagClimateSwatches,
    storyTagPaleoHydrology,
    OrogenyCache,
};
</file>

<file path="mod/maps/story/tags.js">
// @ts-nocheck
/**
 * Climate Story  StoryTags
 *
 * A tiny singleton that holds sparse tag sets used to imprint narrative motifs
 * onto the map (e.g., hotspot trails, rift lines, shoulders, etc.). The object
 * itself is frozen to prevent reassignment, but the contained Sets are mutable.
 *
 * Usage:
 *   import { StoryTags, resetStoryTags } from './story/tags.js';
 *   StoryTags.hotspot.add(`${x},${y}`);
 *   resetStoryTags(); // clears all tag sets between generations
 */
/** @typedef {Set<string>} TagSet */
/**
 * StoryTags  singleton container for sparse tag sets.
 * Keys are tile-coordinate strings in the form "x,y".
 */
export const StoryTags = Object.freeze({
    /** @type {TagSet} Deep-ocean hotspot trail points */
    hotspot: new Set(),
    /** @type {TagSet} Centers of hotspot islands classified as "paradise" */
    hotspotParadise: new Set(),
    /** @type {TagSet} Centers of hotspot islands classified as "volcanic" */
    hotspotVolcanic: new Set(),
    /** @type {TagSet} Linear rift centerline tiles (inland) */
    riftLine: new Set(),
    /** @type {TagSet} Lateral shoulder tiles adjacent to rift lines */
    riftShoulder: new Set(),
    /** @type {TagSet} Active continental margin segments (trenchy/fjordy coast) */
    activeMargin: new Set(),
    /** @type {TagSet} Passive shelf segments (broad shallow shelf) */
    passiveShelf: new Set(),
    /** @type {TagSet} Naval open-water lanes (protected sea lanes) */
    corridorSeaLane: new Set(),
    /** @type {TagSet} Hotspot-based island-hop arcs (promoted trails) */
    corridorIslandHop: new Set(),
    /** @type {TagSet} Land open corridors (plains/grass bias zones) */
    corridorLandOpen: new Set(),
    /** @type {TagSet} River chain corridors (river-adjacent lowland paths) */
    corridorRiverChain: new Set(),
    /**
     * Corridor metadata  kind and style
     * - kind: high-level corridor family (e.g., "sea", "islandHop", "land", "river")
     * - style: sub-variant or motif (e.g., "ocean", "coastal", "canyon", "plateau", "flatMtn")
     * Keys match StoryTags tile keys ("x,y"). These maps are sparse like the tag sets.
     */
    /** @type {Map<string, string>} */
    corridorKind: new Map(),
    /** @type {Map<string, string>} */
    corridorStyle: new Map(),
    /** @type {Map<string, Readonly<Record<string, any>>>} */
    corridorAttributes: new Map(),
});
/**
 * Clears all StoryTags sets. Call once per generation (or when rebuilding tags)
 * to ensure callers never operate on stale data.
 */
export function resetStoryTags() {
    StoryTags.hotspot.clear();
    StoryTags.hotspotParadise.clear();
    StoryTags.hotspotVolcanic.clear();
    StoryTags.riftLine.clear();
    StoryTags.riftShoulder.clear();
    StoryTags.activeMargin.clear();
    StoryTags.passiveShelf.clear();
    StoryTags.corridorSeaLane.clear();
    StoryTags.corridorIslandHop.clear();
    StoryTags.corridorLandOpen.clear();
    StoryTags.corridorRiverChain.clear();
    // Corridor metadata maps
    StoryTags.corridorKind.clear();
    StoryTags.corridorStyle.clear();
    StoryTags.corridorAttributes.clear();
}
export default StoryTags;
</file>

<file path="mod/maps/world/model.js">
// @ts-nocheck
/**
 * WorldModel  Earth Forces Simulation (Physics-Based Plate Tectonics)
 *
 * Purpose
 * - Precompute global "world fields" (plates, plate boundaries, uplift/rift potentials,
 *   winds, ocean currents, mantle pressure) using proper Voronoi diagrams and physics.
 * - These fields are read-only for other layers (tagging, climate, coasts, corridors) to use later.
 * - Keep conservative defaults; remain fully optional via config toggle.
 *
 * Invariants
 * - Never mutate engine surfaces from here; this module only computes arrays/fields.
 * - Keep complexity O(width  height) with small constants; no flood fills.
 *
 * Dependencies (Base Game Scripts)
 * - Imports from /base-standard/scripts/voronoi-utils.js - Voronoi diagram generation
 * - Imports from /base-standard/scripts/voronoi-region.js - PlateRegion with movement vectors
 * - Imports from /base-standard/scripts/kd-tree.js - Spatial indexing for boundaries
 *
 * Status
 * - Phase 1.5 Complete: Proper Voronoi-based plates with physics-driven boundaries
 * - Phase 2 Pending: Wire WorldModel to consumers (mountains, climate, coasts)
 */
import { FOUNDATION_PLATES, FOUNDATION_DYNAMICS, FOUNDATION_DIRECTIONALITY, } from "../bootstrap/tunables.js";
import { computePlatesVoronoi } from "./plates.js";
import { PlateSeedManager } from "./plate_seed.js";
import { devLogIf } from "../bootstrap/dev.js";
/** @typedef {"none" | "convergent" | "divergent" | "transform"} BoundaryType */
const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});
/** Internal state holder (module singletons) */
const _state = {
    initialized: false,
    width: 0,
    height: 0,
    // Plates
    plateId: /** @type {Int16Array|null} */ (null),
    boundaryCloseness: /** @type {Uint8Array|null} */ (null), // 0..255 (higher = closer to boundary)
    boundaryType: /** @type {Uint8Array|null} */ (null), // ENUM_BOUNDARY
    tectonicStress: /** @type {Uint8Array|null} */ (null), // 0..255
    upliftPotential: /** @type {Uint8Array|null} */ (null), // 0..255
    riftPotential: /** @type {Uint8Array|null} */ (null), // 0..255
    shieldStability: /** @type {Uint8Array|null} */ (null), // 0..255 (higher = more interior/stable)
    // Plate movement vectors (new in Phase 1.5)
    plateMovementU: /** @type {Int8Array|null} */ (null), // -127..127 (horizontal plate movement)
    plateMovementV: /** @type {Int8Array|null} */ (null), // -127..127 (vertical plate movement)
    plateRotation: /** @type {Int8Array|null} */ (null), // -127..127 (plate rotation value)
    // Winds (per tile, basic vector)
    windU: /** @type {Int8Array|null} */ (null), // -127..127
    windV: /** @type {Int8Array|null} */ (null),
    // Ocean currents (only meaningful on water tiles)
    currentU: /** @type {Int8Array|null} */ (null),
    currentV: /** @type {Int8Array|null} */ (null),
    // Mantle pressure/bumps (0..255)
    pressure: /** @type {Uint8Array|null} */ (null),
    // Plate boundary spatial index (new in Phase 1.5)
    boundaryTree: /** @type {any|null} */ (null), // kdTree for fast boundary queries
    plateSeed: /** @type {Readonly<any>|null} */ (null),
};
/**
 * Public singleton API
 */
export const WorldModel = {
    /**
     * Returns true if WorldModel is toggled on and successfully initialized for this map.
     */
    isEnabled() {
        return !!_state.initialized;
    },
    /**
     * Initialize world fields. Safe to call multiple times; subsequent calls are no-ops.
     * Does nothing if the toggle is disabled or engine APIs are unavailable.
     */
    init() {
        if (_state.initialized)
            return true;
        // Guard: engine-provided API
        const ok = typeof GameplayMap?.getGridWidth === "function" &&
            typeof GameplayMap?.getGridHeight === "function" &&
            typeof GameplayMap?.isWater === "function" &&
            typeof GameplayMap?.getPlotLatitude === "function";
        if (!ok) {
            devLogIf &&
                devLogIf("LOG_STORY_TAGS", "[WorldModel] Engine APIs unavailable; skipping initialization.");
            return false;
        }
        const width = GameplayMap.getGridWidth();
        const height = GameplayMap.getGridHeight();
        _state.width = width | 0;
        _state.height = height | 0;
        const size = Math.max(0, width * height) | 0;
        // Allocate arrays
        _state.plateId = new Int16Array(size);
        _state.boundaryCloseness = new Uint8Array(size);
        _state.boundaryType = new Uint8Array(size);
        _state.tectonicStress = new Uint8Array(size);
        _state.upliftPotential = new Uint8Array(size);
        _state.riftPotential = new Uint8Array(size);
        _state.shieldStability = new Uint8Array(size);
        _state.plateMovementU = new Int8Array(size);
        _state.plateMovementV = new Int8Array(size);
        _state.plateRotation = new Int8Array(size);
        _state.windU = new Int8Array(size);
        _state.windV = new Int8Array(size);
        _state.currentU = new Int8Array(size);
        _state.currentV = new Int8Array(size);
        _state.pressure = new Uint8Array(size);
        // Compute placeholder fields (fast, coherent)
        computePlates(width, height);
        computePressure(width, height);
        computeWinds(width, height);
        computeCurrents(width, height);
        _state.initialized = true;
        devLogIf &&
            devLogIf("LOG_STORY_TAGS", "[WorldModel] Initialized fields for this map.", {
                width,
                height,
                plates: FOUNDATION_PLATES?.count ?? 0,
            });
        return true;
    },
    /**
     * Utility to fetch typed arrays (read-only by convention).
     * Returns null if not initialized or disabled.
     */
    get plateId() {
        return _state.plateId;
    },
    get boundaryCloseness() {
        return _state.boundaryCloseness;
    },
    get boundaryType() {
        return _state.boundaryType;
    },
    get tectonicStress() {
        return _state.tectonicStress;
    },
    get upliftPotential() {
        return _state.upliftPotential;
    },
    get riftPotential() {
        return _state.riftPotential;
    },
    get shieldStability() {
        return _state.shieldStability;
    },
    get windU() {
        return _state.windU;
    },
    get windV() {
        return _state.windV;
    },
    get currentU() {
        return _state.currentU;
    },
    get currentV() {
        return _state.currentV;
    },
    get pressure() {
        return _state.pressure;
    },
    get plateMovementU() {
        return _state.plateMovementU;
    },
    get plateMovementV() {
        return _state.plateMovementV;
    },
    get plateRotation() {
        return _state.plateRotation;
    },
    get boundaryTree() {
        return _state.boundaryTree;
    },
    get plateSeed() {
        return _state.plateSeed;
    },
};
/* ---------------------------------- helpers ---------------------------------- */
function idx(x, y, width) {
    return y * width + x;
}
/**
 * Compute plate assignment using proper Voronoi diagrams with physics-based boundaries
 * - Uses base game's VoronoiUtils for accurate boundary detection
 * - Calculates subduction/sliding from plate movement vectors
 * - Stores boundaries in kdTree for fast Phase 2 queries
 *
 * Phase 1.5 Upgrade: Replaced simple distance-based Voronoi with proper edge-based system
 */
function computePlates(width, height) {
    const platesCfg = FOUNDATION_PLATES || {};
    const count = Math.max(2, platesCfg?.count | 0 || 8);
    const convergenceMix = Math.max(0, Math.min(1, platesCfg?.convergenceMix ?? 0.5));
    const relaxationSteps = Math.max(0, platesCfg?.relaxationSteps | 0 || 5);
    const plateRotationMultiple = platesCfg?.plateRotationMultiple ?? 1.0;
    const seedMode = platesCfg?.seedMode === "fixed" ? "fixed" : "engine";
    const seedOffset = Number.isFinite(platesCfg?.seedOffset)
        ? Math.trunc(platesCfg.seedOffset)
        : 0;
    const fixedSeed = Number.isFinite(platesCfg?.fixedSeed)
        ? Math.trunc(platesCfg.fixedSeed)
        : undefined;

    const configSnapshot = {
        count,
        relaxationSteps,
        convergenceMix,
        plateRotationMultiple,
        seedMode,
        fixedSeed,
        seedOffset,
    };
    const generationConfig = {
        ...configSnapshot,
        directionality: FOUNDATION_DIRECTIONALITY,
    };
    const { snapshot: seedBase, restore: restoreSeed } = PlateSeedManager.capture(width, height, generationConfig);
    let plateData = null;
    try {
        // Call new Voronoi-based plate generation
        plateData = computePlatesVoronoi(width, height, generationConfig);
    }
    finally {
        if (typeof restoreSeed === "function") {
            try {
                restoreSeed();
            }
            catch (_err) {
                /* no-op */
            }
        }
    }
    if (!plateData) {
        const fallbackConfig = Object.freeze({ ...configSnapshot });
        const fallbackSeed = seedBase
            ? Object.freeze({
                ...seedBase,
                config: fallbackConfig,
            })
            : Object.freeze({
                width,
                height,
                config: fallbackConfig,
            });
        _state.plateSeed =
            PlateSeedManager.finalize(seedBase, {
                config: configSnapshot,
            }) || fallbackSeed;
        return;
    }

    // Copy results into WorldModel state arrays
    _state.plateId.set(plateData.plateId);
    _state.boundaryCloseness.set(plateData.boundaryCloseness);
    _state.boundaryType.set(plateData.boundaryType);
    _state.tectonicStress.set(plateData.tectonicStress);
    _state.upliftPotential.set(plateData.upliftPotential);
    _state.riftPotential.set(plateData.riftPotential);
    _state.shieldStability.set(plateData.shieldStability);
    _state.plateMovementU.set(plateData.plateMovementU);
    _state.plateMovementV.set(plateData.plateMovementV);
    _state.plateRotation.set(plateData.plateRotation);

    // Store boundary tree for Phase 2 mountain placement
    _state.boundaryTree = plateData.boundaryTree;
    const meta = plateData.meta || {};
    const fallbackConfig = Object.freeze({ ...configSnapshot });
    const fallbackSeed = seedBase
        ? Object.freeze({
            ...seedBase,
            config: fallbackConfig,
        })
        : Object.freeze({
            width,
            height,
            config: fallbackConfig,
        });
    _state.plateSeed =
        PlateSeedManager.finalize(seedBase, {
            config: configSnapshot,
            meta,
        }) || fallbackSeed;

    devLogIf &&
        devLogIf("LOG_STORY_TAGS", "[WorldModel] Plate generation complete", {
            plateCount: count,
            boundaryCount: plateData.boundaryTree ? "available" : "none",
        });
}
/**
 * Mantle pressure: small number of Gaussian bumps (very low frequency) + normalization.
 * Output: pressure 0..255
 */
function computePressure(width, height) {
    const size = width * height;
    const pressure = _state.pressure;
    if (!pressure)
        return;
    // Params
    const mantleCfg = FOUNDATION_DYNAMICS?.mantle || {};
    const bumps = Math.max(1, mantleCfg?.bumps | 0 || 4);
    const amp = Math.max(0.1, mantleCfg?.amplitude ?? 0.6);
    const scl = Math.max(0.1, mantleCfg?.scale ?? 0.4);
    const sigma = Math.max(4, Math.floor(Math.min(width, height) * scl));
    // Random bump centers
    const centers = [];
    for (let i = 0; i < bumps; i++) {
        const cx = TerrainBuilder?.getRandomNumber?.(width, "PressCX") ??
            (i * width) / bumps;
        const cy = TerrainBuilder?.getRandomNumber?.(height, "PressCY") ??
            (i * height) / bumps;
        const a = amp *
            (0.75 +
                (TerrainBuilder?.getRandomNumber?.(50, "PressA") ?? 0) / 100);
        centers.push({ x: Math.floor(cx), y: Math.floor(cy), a });
    }
    // Accumulate Gaussian bumps
    const acc = new Float32Array(size);
    const inv2s2 = 1.0 / (2 * sigma * sigma);
    let maxVal = 1e-6;
    for (let k = 0; k < centers.length; k++) {
        const { x: cx, y: cy, a } = centers[k];
        const yMin = Math.max(0, cy - sigma * 2);
        const yMax = Math.min(height - 1, cy + sigma * 2);
        const xMin = Math.max(0, cx - sigma * 2);
        const xMax = Math.min(width - 1, cx + sigma * 2);
        for (let y = yMin; y <= yMax; y++) {
            const dy = y - cy;
            for (let x = xMin; x <= xMax; x++) {
                const dx = x - cx;
                const e = Math.exp(-(dx * dx + dy * dy) * inv2s2);
                const v = a * e;
                const i = idx(x, y, width);
                acc[i] += v;
                if (acc[i] > maxVal)
                    maxVal = acc[i];
            }
        }
    }
    // Normalize 0..255
    for (let i = 0; i < size; i++) {
        pressure[i] = toByte(acc[i] / maxVal);
    }
}
/**
 * Winds: zonal baseline by latitude band + a few jet streaks; tiny V component.
 * Output: windU, windV in approximate tile-units (-127..127)
 */
function computeWinds(width, height) {
    const U = _state.windU;
    const V = _state.windV;
    if (!U || !V)
        return;
    const windCfg = FOUNDATION_DYNAMICS?.wind || {};
    const streaks = Math.max(0, windCfg?.jetStreaks | 0 || 3);
    const jetStrength = Math.max(0, windCfg?.jetStrength ?? 1.0);
    const variance = Math.max(0, windCfg?.variance ?? 0.6);
    // Build jet streak latitude centers (absolute degrees)
    const streakLats = [];
    for (let s = 0; s < streaks; s++) {
        const base = 30 + s * (30 / Math.max(1, streaks - 1)); // between 30 and ~60
        const jitter = (TerrainBuilder?.getRandomNumber?.(12, "JetJit") ?? 0) - 6;
        streakLats.push(Math.max(15, Math.min(75, base + jitter)));
    }
    for (let y = 0; y < height; y++) {
        const latDeg = Math.abs(GameplayMap.getPlotLatitude(0, y));
        // Zonal baseline (Coriolis): 030 and 6090 EW (-), 3060 WE (+)
        let u = latDeg < 30 || latDeg >= 60 ? -80 : 80;
        let v = 0;
        // Jet amplification near streak latitudes
        for (let k = 0; k < streakLats.length; k++) {
            const d = Math.abs(latDeg - streakLats[k]);
            const f = Math.max(0, 1 - d / 12); // within ~12 band
            if (f > 0) {
                const boost = Math.round(32 * jetStrength * f);
                u += latDeg < streakLats[k] ? boost : -boost; // simple shear orientation
            }
        }
        // Per-row variance
        const varU = Math.round(((TerrainBuilder?.getRandomNumber?.(21, "WindUVar") ?? 0) -
            10) *
            variance) | 0;
        const varV = Math.round(((TerrainBuilder?.getRandomNumber?.(11, "WindVVar") ?? 0) - 5) *
            variance) | 0;
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);
            // Directionality bias for winds (cohesive global control)
            (function applyWindBias() {
                try {
                    const DIR = FOUNDATION_DIRECTIONALITY || {};
                    const cohesion = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                    const followPlates = Math.max(0, Math.min(1, DIR?.interplay?.windsFollowPlates ?? 0));
                    let biasDeg = DIR?.primaryAxes?.windBiasDeg ?? 0;
                    biasDeg +=
                        (DIR?.primaryAxes?.plateAxisDeg ?? 0) *
                            followPlates *
                            cohesion;
                    // Optional hemisphere flip around equator
                    const rawLat = GameplayMap.getPlotLatitude(0, y);
                    if ((DIR?.hemispheres?.southernFlip ?? false) &&
                        rawLat < 0) {
                        biasDeg = -biasDeg;
                    }
                    const angleJitter = (DIR?.variability?.angleJitterDeg ?? 0) | 0;
                    const jitter = (TerrainBuilder?.getRandomNumber?.(angleJitter * 2 + 1, "WindDirJit") ?? 0) - angleJitter;
                    const rad = ((biasDeg + jitter) * Math.PI) / 180;
                    const biasMag = Math.round(30 * cohesion);
                    const bu = Math.round(biasMag * Math.cos(rad));
                    const bv = Math.round(biasMag * Math.sin(rad));
                    U[i] = clampInt(u + varU + bu, -127, 127);
                    V[i] = clampInt(v + varV + bv, -127, 127);
                    return;
                }
                catch (_) {
                    /* fall back to baseline below */
                }
                U[i] = clampInt(u + varU, -127, 127);
                V[i] = clampInt(v + varV, -127, 127);
            })();
        }
    }
}
/**
 * Ocean currents: placeholder banded flows.
 * - Equatorial westward current near 012
 * - Weak subpolar east/west hints at high latitudes
 */
function computeCurrents(width, height) {
    const U = _state.currentU;
    const V = _state.currentV;
    if (!U || !V)
        return;
    for (let y = 0; y < height; y++) {
        const latDeg = Math.abs(GameplayMap.getPlotLatitude(0, y));
        let baseU = 0;
        let baseV = 0;
        if (latDeg < 12) {
            baseU = -50; // westward
        }
        else if (latDeg >= 45 && latDeg < 60) {
            baseU = 20; // modest eastward mid-lat
        }
        else if (latDeg >= 60) {
            baseU = -15; // weak westward near polar
        }
        for (let x = 0; x < width; x++) {
            const i = idx(x, y, width);
            if (GameplayMap.isWater(x, y)) {
                // Directionality bias for currents + interplay with winds
                let cu = baseU;
                let cv = baseV;
                (function applyCurrentBias() {
                    try {
                        const DIR = FOUNDATION_DIRECTIONALITY || {};
                        const cohesion = Math.max(0, Math.min(1, DIR?.cohesion ?? 0));
                        const windsFactor = Math.max(0, Math.min(1, DIR?.interplay?.currentsFollowWinds ?? 0)) * cohesion;
                        // Sample prevailing wind vector at the row center (cheap proxy)
                        let wu = 0, wv = 0;
                        if (_state.windU && _state.windV) {
                            const wi = idx(Math.floor(width / 2), y, width);
                            wu = _state.windU[wi] | 0;
                            wv = _state.windV[wi] | 0;
                        }
                        cu += Math.round(wu * windsFactor);
                        cv += Math.round(wv * windsFactor);
                        // Add global current bias (optionally nudged toward plate axis via winds-follow-plates)
                        let biasDeg = DIR?.primaryAxes?.currentBiasDeg ?? 0;
                        biasDeg +=
                            (DIR?.interplay?.windsFollowPlates ?? 0) *
                                (DIR?.primaryAxes?.plateAxisDeg ?? 0) *
                                cohesion *
                                0.5;
                        const angleJitter = (DIR?.variability?.angleJitterDeg ?? 0) | 0;
                        const jitter = (TerrainBuilder?.getRandomNumber?.(angleJitter * 2 + 1, "CurrentDirJit") ?? 0) - angleJitter;
                        // Optional hemisphere flip around equator
                        const rawLat = GameplayMap.getPlotLatitude(0, y);
                        if ((DIR?.hemispheres?.southernFlip ?? false) &&
                            rawLat < 0) {
                            biasDeg = -biasDeg;
                        }
                        const rad = ((biasDeg + jitter) * Math.PI) / 180;
                        const biasMag = Math.round(25 * cohesion);
                        cu += Math.round(biasMag * Math.cos(rad));
                        cv += Math.round(biasMag * Math.sin(rad));
                    }
                    catch (_) {
                        /* keep baseline cu/cv */
                    }
                })();
                U[i] = clampInt(cu, -127, 127);
                V[i] = clampInt(cv, -127, 127);
            }
            else {
                U[i] = 0;
                V[i] = 0;
            }
        }
    }
}
/* --------------------------------- utilities -------------------------------- */
function clampInt(v, lo, hi) {
    return v < lo ? lo : v > hi ? hi : v | 0;
}
function toByte01(f) {
    const v = Math.max(0, Math.min(1, f));
    return Math.round(v * 255) | 0;
}
function toByte(v) {
    // Accept 0..1 or raw float values; clamp to [0..255]
    if (v <= 1 && v >= 0)
        return toByte01(v);
    return clampInt(Math.round(v), 0, 255);
}
export default WorldModel;
</file>

<file path="mod/maps/world/plate_seed.js">
// @ts-nocheck
/**
 * PlateSeedManager  deterministic Voronoi physics seeding
 *
 * Responsibilities
 * - Normalize plate seed config (mode, fixed seed, offsets).
 * - Capture the Civ VII RandomImpl state before plate generation, apply overrides,
 *   and provide a restoration callback so downstream systems share a single seed.
 * - Emit frozen snapshots for diagnostics (timestamp, RNG state, seed locations).
 */
import { RandomImpl } from "/base-standard/scripts/random-pcg-32.js";

function safeTimestamp() {
    try {
        return typeof Date?.now === "function" ? Date.now() : null;
    }
    catch (_err) {
        return null;
    }
}

function freezeRngState(state) {
    if (!state || typeof state !== "object")
        return null;
    const clone = {};
    for (const key of Object.keys(state)) {
        clone[key] = state[key];
    }
    return Object.freeze(clone);
}

function normalizeSeedConfig(config) {
    const cfg = config || {};
    const wantsFixed = cfg?.seedMode === "fixed";
    const hasFixed = wantsFixed && Number.isFinite(cfg?.fixedSeed);
    const seedMode = hasFixed ? "fixed" : "engine";
    const fixedSeed = hasFixed ? Math.trunc(cfg.fixedSeed) : null;
    const seedOffset = Number.isFinite(cfg?.seedOffset) ? Math.trunc(cfg.seedOffset) : 0;
    return { seedMode, fixedSeed, seedOffset };
}

function applySeedControl(seedMode, fixedSeed, seedOffset) {
    if (!RandomImpl || typeof RandomImpl.getState !== "function" || typeof RandomImpl.setState !== "function") {
        return { restore: null, seed: null, rngState: null };
    }
    let originalState = null;
    try {
        originalState = RandomImpl.getState();
    }
    catch (_err) {
        originalState = null;
    }
    if (!originalState || typeof originalState !== "object") {
        return { restore: null, seed: null, rngState: null };
    }
    const hasFixed = seedMode === "fixed" && Number.isFinite(fixedSeed);
    const offsetValue = Number.isFinite(seedOffset) ? Math.trunc(seedOffset) : 0;
    let seedValue = null;
    if (hasFixed) {
        seedValue = Math.trunc(fixedSeed);
    }
    else {
        const base = originalState.state;
        if (typeof base === "bigint") {
            seedValue = Number(base & 0xffffffffn);
        }
    }
    if (seedValue == null) {
        const restore = () => {
            try {
                RandomImpl.setState(originalState);
            }
            catch (_err) {
                /* no-op */
            }
        };
        return { restore, seed: null, rngState: freezeRngState(originalState) };
    }
    seedValue = offsetValue ? (seedValue + offsetValue) >>> 0 : seedValue >>> 0;
    let appliedState = null;
    try {
        if (typeof RandomImpl.seed === "function") {
            RandomImpl.seed(seedValue >>> 0);
            appliedState = RandomImpl.getState?.() ?? null;
        }
        else {
            const nextState = { ...originalState };
            if (typeof nextState.state === "bigint") {
                nextState.state = BigInt(seedValue >>> 0);
            }
            RandomImpl.setState(nextState);
            appliedState = nextState;
        }
    }
    catch (_err) {
        appliedState = null;
    }
    const restore = () => {
        try {
            RandomImpl.setState(originalState);
        }
        catch (_err) {
            /* no-op */
        }
    };
    return { restore, seed: seedValue >>> 0, rngState: freezeRngState(appliedState) };
}

function normalizeSites(sites) {
    if (!Array.isArray(sites) || sites.length === 0)
        return null;
    const frozen = sites.map((site, index) => {
        if (site && typeof site === "object") {
            const id = site.id ?? index;
            const x = site.x ?? (Array.isArray(site) ? site[0] ?? 0 : 0);
            const y = site.y ?? (Array.isArray(site) ? site[1] ?? 0 : 0);
            return Object.freeze({ id, x, y });
        }
        if (Array.isArray(site)) {
            const [x = 0, y = 0] = site;
            return Object.freeze({ id: index, x, y });
        }
        return Object.freeze({ id: index, x: 0, y: 0 });
    });
    return Object.freeze(frozen);
}

export const PlateSeedManager = {
    capture(width, height, config) {
        const seedCfg = normalizeSeedConfig(config);
        const timestamp = safeTimestamp();
        const control = applySeedControl(seedCfg.seedMode, seedCfg.fixedSeed, seedCfg.seedOffset);
        const snapshot = {
            width,
            height,
            seedMode: seedCfg.seedMode,
            seedOffset: seedCfg.seedOffset,
        };
        if (seedCfg.fixedSeed != null)
            snapshot.fixedSeed = seedCfg.fixedSeed;
        if (timestamp != null)
            snapshot.timestamp = timestamp;
        if (control.seed != null)
            snapshot.seed = control.seed;
        if (control.rngState)
            snapshot.rngState = control.rngState;
        return {
            snapshot: Object.freeze(snapshot),
            restore: typeof control.restore === "function" ? control.restore : null,
        };
    },
    finalize(baseSnapshot, extras = {}) {
        if (!baseSnapshot || typeof baseSnapshot !== "object")
            return null;
        const { config = null, meta = null } = extras || {};
        const result = {
            width: baseSnapshot.width,
            height: baseSnapshot.height,
            seedMode: baseSnapshot.seedMode,
        };
        if (baseSnapshot.timestamp != null)
            result.timestamp = baseSnapshot.timestamp;
        if (baseSnapshot.seedOffset != null)
            result.seedOffset = baseSnapshot.seedOffset;
        if (baseSnapshot.seed != null)
            result.seed = baseSnapshot.seed;
        if (baseSnapshot.fixedSeed != null)
            result.fixedSeed = baseSnapshot.fixedSeed;
        if (baseSnapshot.rngState)
            result.rngState = baseSnapshot.rngState;
        if (config && typeof config === "object") {
            result.config = Object.freeze({ ...config });
        }
        const seeds = Array.isArray(meta?.seedLocations)
            ? meta.seedLocations
            : Array.isArray(meta?.sites)
                ? meta.sites
                : null;
        const normalizedSites = normalizeSites(seeds);
        if (normalizedSites) {
            result.seedLocations = normalizedSites;
            result.sites = normalizedSites;
        }
        return Object.freeze(result);
    },
};
</file>

<file path="mod/maps/world/plates.js">
// @ts-nocheck
/**
 * Plate Tectonics Generation - Advanced Voronoi-based plate system
 *
 * Purpose:
 * - Generate tectonic plates using proper Voronoi diagrams (not simple distance)
 * - Calculate physics-based plate boundaries with subduction and sliding
 * - Provide structured data for WorldModel to consume
 *
 * Dependencies (from base-standard module):
 * - /base-standard/scripts/kd-tree.js - VoronoiUtils + spatial queries + region/boundary helpers
 * - /base-standard/scripts/voronoi-region.js - PlateRegion with movement vectors
 *
 * Architecture:
 * - Imports base game's proven plate generation algorithms
 * - Wraps them for WorldModel integration
 * - Returns typed arrays and boundary data structures
 */

import { VoronoiUtils, RegionCell, RegionCellPosGetter, kdTree } from '/base-standard/scripts/kd-tree.js';
import { PlateRegion } from '/base-standard/scripts/voronoi-region.js';

/**
 * @typedef {Object} PlateGenerationResult
 * @property {Int16Array} plateId - Plate assignment per tile
 * @property {Uint8Array} boundaryCloseness - 0..255, higher near boundaries
 * @property {Uint8Array} boundaryType - ENUM_BOUNDARY values
 * @property {Uint8Array} tectonicStress - 0..255, tracks boundary closeness
 * @property {Uint8Array} upliftPotential - 0..255, high at convergent boundaries
 * @property {Uint8Array} riftPotential - 0..255, high at divergent boundaries
 * @property {Uint8Array} shieldStability - 0..255, inverse of stress (plate interiors)
 * @property {Int8Array} plateMovementU - -127..127, horizontal plate movement
 * @property {Int8Array} plateMovementV - -127..127, vertical plate movement
 * @property {Int8Array} plateRotation - -127..127, plate rotation value
 * @property {null} boundaryTree - Deprecated: tile-precise boundaries used instead
 * @property {Array<PlateRegion>} plateRegions - Array of PlateRegion instances
 */

/**
 * @typedef {Object} PlateConfig
 * @property {number} count - Number of plates to generate
 * @property {number} relaxationSteps - Lloyd relaxation iterations (default 5)
 * @property {number} convergenceMix - 0..1, ratio of convergent vs divergent boundaries
 * @property {number} plateRotationMultiple - Multiplier for plate rotation influence
 * @property {Object} directionality - Optional directionality config
 * @property {"engine"|"fixed"} [seedMode] - Use Civ's seed (engine) or a fixed seed value (fixed)
 * @property {number} [fixedSeed] - Seed value when seedMode is "fixed"
 * @property {number} [seedOffset] - Integer offset applied to the chosen base seed
 */

const ENUM_BOUNDARY = Object.freeze({
    none: 0,
    convergent: 1,
    divergent: 2,
    transform: 3,
});

/**
 * Generate tectonic plates using proper Voronoi diagrams
 *
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {PlateConfig} config - Plate generation configuration
 * @returns {PlateGenerationResult} Complete plate data for WorldModel
 */
export function computePlatesVoronoi(width, height, config) {
    const {
        count = 8,
        relaxationSteps = 5,
        convergenceMix = 0.5,
        plateRotationMultiple = 1.0,
        directionality = null,
        seedMode = "engine",
        fixedSeed = undefined,
        seedOffset = 0,
    } = config;

    const size = width * height;
    const meta = {
        width,
        height,
        config: {
            count,
            relaxationSteps,
            convergenceMix,
            plateRotationMultiple,
            seedMode,
            fixedSeed,
            seedOffset,
        },
        seedLocations: [],
    };

    const runGeneration = (attempt = {}) => {
        const {
            // Density of intermediate Voronoi cells that approximate plate areas.
            // Lower density  larger cells  thicker interiors and fewer boundary seams.
            cellDensity = 0.003,
            // How far boundary influence propagates into interiors (in hex tiles).
            boundaryInfluenceDistance = 3,
            // Exponential falloff for boundary closeness; higher = faster decay.
            boundaryDecay = 0.8,
            // Optionally override plate count for retries.
            plateCountOverride = null,
        } = attempt;
        const plateCount = Math.max(2, plateCountOverride ?? count);
        // Create Voronoi diagram using base game utilities
        const bbox = { xl: 0, xr: width, yt: 0, yb: height };
        const sites = VoronoiUtils.createRandomSites(plateCount, bbox.xr, bbox.yb);
        const diagram = VoronoiUtils.computeVoronoi(sites, bbox, relaxationSteps);

        // Create PlateRegion instances with movement vectors
        const plateRegions = diagram.cells.map((cell, index) => {
            const region = new PlateRegion(
                `Plate${index}`,
                index,
                0, // type
                bbox.xr * bbox.yb, // maxArea
                { x: Math.random(), y: Math.random(), z: Math.random() } // color (not used in WorldModel)
            );
            region.seedLocation = { x: cell.site.x, y: cell.site.y };

            // Apply directionality bias if provided
            if (directionality) {
                applyDirectionalityBias(region, directionality);
            }

            return region;
        });
        if (!plateRegions.length) {
            throw new Error(
                `[WorldModel] Plate generation returned zero plates (sites=${sites.length}, cells=${diagram.cells?.length ?? 0}).`
            );
        }
        const invalidPlateIndex = plateRegions.findIndex(
            (p) => !p || !p.seedLocation || !isFinite(p.seedLocation.x) || !isFinite(p.seedLocation.y)
        );
        if (invalidPlateIndex >= 0) {
            throw new Error(
                `[WorldModel] Plate generation produced invalid plate ${invalidPlateIndex}; seed missing or NaN (cells=${diagram.cells?.length ?? 0}).`
            );
        }
        meta.seedLocations = plateRegions.map((region, id) => ({
            id,
            x: region.seedLocation?.x ?? 0,
            y: region.seedLocation?.y ?? 0,
        }));

        // Create RegionCells for the map grid
        // Note: For performance, we create a coarser Voronoi grid for plate assignment
        // This matches the base game's approach in ContinentGenerator.growPlates()
        const cellCount = Math.max(
            plateCount * 2, // keep cells per plate low to thicken interiors
            Math.floor(width * height * cellDensity),
            plateCount
        );
        const cellSites = VoronoiUtils.createRandomSites(cellCount, bbox.xr, bbox.yb);
        const cellDiagram = VoronoiUtils.computeVoronoi(cellSites, bbox, 2);

        const regionCells = cellDiagram.cells.map((cell, index) => {
            const area = VoronoiUtils.calculateCellArea(cell);
            return new RegionCell(cell, index, area);
        });

        // Build kdTree for fast spatial queries
        const cellKdTree = new kdTree(RegionCellPosGetter);
        cellKdTree.build(regionCells);

        // Assign each region cell to nearest plate
        for (const regionCell of regionCells) {
            const pos = { x: regionCell.cell.site.x, y: regionCell.cell.site.y };
            let bestDist = Infinity;
            let bestPlateId = -1;

            for (let i = 0; i < plateRegions.length; i++) {
                const dx = pos.x - plateRegions[i].seedLocation.x;
                const dy = pos.y - plateRegions[i].seedLocation.y;
                const dist = dx * dx + dy * dy;

                if (dist < bestDist) {
                    bestDist = dist;
                    bestPlateId = i;
                }
            }

            regionCell.plateId = bestPlateId;
        }
        const invalidCell = regionCells.find((c) => c.plateId < 0 || c.plateId >= plateRegions.length);
        if (invalidCell) {
            throw new Error(
                `[WorldModel] Plate assignment failed: invalid plateId ${invalidCell.plateId} for regionCell ${invalidCell.id} (plates=${plateRegions.length}, sites=${sites.length}).`
            );
        }

        // Allocate output arrays
        const plateId = new Int16Array(size);
        const boundaryCloseness = new Uint8Array(size);
        const boundaryType = new Uint8Array(size);
        const tectonicStress = new Uint8Array(size);
        const upliftPotential = new Uint8Array(size);
        const riftPotential = new Uint8Array(size);
        const shieldStability = new Uint8Array(size);
        const plateMovementU = new Int8Array(size);
        const plateMovementV = new Int8Array(size);
        const plateRotation = new Int8Array(size);

        // Step 1: Assign each map tile to nearest Voronoi cell for plateId and movement
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = y * width + x;
                const pos = { x, y };

                const nearestCellResult = cellKdTree.search(pos);
                const nearestCell = nearestCellResult?.data ?? nearestCellResult;
                if (!nearestCell) {
                    throw new Error(`[WorldModel] Nearest Voronoi cell not found at pos (${x},${y}).`);
                }
                const pId = nearestCell.plateId;
                plateId[i] = pId;

                const plate = plateRegions[pId];
                if (!plate || !plate.seedLocation) {
                    throw new Error(`[WorldModel] Missing plate data for plateId=${pId} at pos (${x},${y}).`);
                }
                const movement = calculatePlateMovement(plate, pos, plateRotationMultiple);
                plateMovementU[i] = clampInt8(Math.round(movement.x * 100));
                plateMovementV[i] = clampInt8(Math.round(movement.y * 100));
                plateRotation[i] = clampInt8(Math.round(plate.m_rotation * 100));
            }
        }

        // Step 2: Tile-precise boundary detection (replaces kdTree approach)
        // Detects boundaries by checking if any hex neighbor has a different plateId
        const { isBoundary, neighborPlates } = detectBoundaryTiles(plateId, width, height);

        // Step 3: Compute distance field from boundary tiles using BFS
        // This gives us precise tile distances instead of approximate kdTree distances
        const distanceField = computeDistanceField(
            isBoundary,
            width,
            height,
            boundaryInfluenceDistance + 1 // compute just past the influence band
        );

        // Step 4: Compute boundary physics (subduction/sliding) for boundary tiles
        const physics = computeBoundaryPhysicsForTiles(
            isBoundary, neighborPlates, plateId, plateRegions,
            width, height, plateRotationMultiple
        );

        // Step 5: Assign boundary types with inheritance for near-boundary tiles
        assignBoundaryTypesWithInheritance(
            distanceField, isBoundary, neighborPlates, physics,
            boundaryType, boundaryCloseness, upliftPotential, riftPotential,
            shieldStability, tectonicStress, width, height,
            boundaryInfluenceDistance, boundaryDecay
        );

        const boundaryStats = summarizeBoundaryCoverage(isBoundary, boundaryCloseness);
        meta.generationAttempts = meta.generationAttempts || [];
        meta.generationAttempts.push({
            params: { cellDensity, boundaryInfluenceDistance, boundaryDecay, cellCount },
            boundaryStats,
        });
        meta.boundaryStats = boundaryStats;

        return {
            plateId,
            boundaryCloseness,
            boundaryType,
            tectonicStress,
            upliftPotential,
            riftPotential,
            shieldStability,
            plateMovementU,
            plateMovementV,
            plateRotation,
            boundaryTree: null, // No longer using kdTree for boundaries
            plateRegions,
            meta,
        };
    };

    const attempts = [
        // Default: very coarse grid so plates span hundreds of tiles; fast decay keeps boundary belts thin.
        { cellDensity: 0.003, boundaryInfluenceDistance: 3, boundaryDecay: 0.8 },
        // Fallback: even coarser grid + shorter influence if boundaries still dominate.
        { cellDensity: 0.002, boundaryInfluenceDistance: 2, boundaryDecay: 0.9 },
        // Final fallback: reduce plate count modestly to grow interiors if saturation persists.
        { cellDensity: 0.002, boundaryInfluenceDistance: 2, boundaryDecay: 0.9, plateCountOverride: Math.max(6, Math.round(count * 0.6)) },
        // Extreme fallback: force low plate count and ultra-coarse cells to guarantee interiors.
        { cellDensity: 0.0015, boundaryInfluenceDistance: 2, boundaryDecay: 1.0, plateCountOverride: Math.max(4, Math.round(count * 0.4)) },
    ];
    const saturationLimit = 0.45; // if >45% of tiles are influenced by boundaries, reroll with coarser params
    const closenessLimit = 80;    // if average influenced closeness is too high, reroll

    let lastResult = null;
    for (const attempt of attempts) {
        const result = runGeneration(attempt);
        lastResult = result;
        const stats = result?.meta?.boundaryStats;
        const boundaryShare = stats?.boundaryInfluenceShare ?? 1;
        const boundaryTileShare = stats?.boundaryTileShare ?? 1;
        const avgInfluenceCloseness = stats?.avgInfluenceCloseness ?? 255;
        if (
            boundaryShare <= saturationLimit &&
            boundaryTileShare <= saturationLimit &&
            avgInfluenceCloseness <= closenessLimit
        ) {
            return result;
        }
    }

    return lastResult;
}

/**
 * Calculate plate movement at a specific position
 * Combines linear movement with rotational component
 * Based on ContinentGenerator.growPlates() lines 7908-7914
 *
 * @param {PlateRegion} plate - Plate region
 * @param {{x: number, y: number}} pos - Position to calculate movement at
 * @param {number} rotationMultiple - Rotation influence multiplier
 * @returns {{x: number, y: number}} Movement vector
 */
function calculatePlateMovement(plate, pos, rotationMultiple) {
    if (!plate || !plate.seedLocation) {
        return { x: 0, y: 0 };
    }
    // Relative position from plate center
    const relPos = {
        x: pos.x - plate.seedLocation.x,
        y: pos.y - plate.seedLocation.y,
    };

    // Rotation component: rotate relative position
    const angularMovement = plate.m_rotation * Math.PI / 180 * rotationMultiple;
    const rotatedPos = rotate2(relPos, angularMovement);

    // Rotation movement is difference between original and rotated position
    const rotationMovement = {
        x: relPos.x - rotatedPos.x,
        y: relPos.y - rotatedPos.y,
    };

    // Combine translation and rotation
    return {
        x: rotationMovement.x + plate.m_movement.x,
        y: rotationMovement.y + plate.m_movement.y,
    };
}

/**
 * Apply directionality bias to plate movement
 * Adjusts plate movement vectors to align with global directionality config
 *
 * @param {PlateRegion} plate - Plate region to modify
 * @param {Object} directionality - Directionality configuration
 */
function applyDirectionalityBias(plate, directionality) {
    const cohesion = Math.max(0, Math.min(1, directionality?.cohesion ?? 0));
    const plateAxisDeg = (directionality?.primaryAxes?.plateAxisDeg ?? 0) | 0;
    const angleJitterDeg = (directionality?.variability?.angleJitterDeg ?? 0) | 0;
    const magnitudeVariance = directionality?.variability?.magnitudeVariance ?? 0.35;

    // Current movement direction
    const currentAngle = Math.atan2(plate.m_movement.y, plate.m_movement.x) * 180 / Math.PI;
    const currentMag = Math.sqrt(plate.m_movement.x ** 2 + plate.m_movement.y ** 2);

    // Bias toward plate axis
    const jitter = (TerrainBuilder?.getRandomNumber?.(angleJitterDeg * 2 + 1, "PlateDirJit") ?? 0) - angleJitterDeg;
    const targetAngle = currentAngle * (1 - cohesion) + plateAxisDeg * cohesion + jitter * magnitudeVariance;

    // Apply biased angle
    const rad = targetAngle * Math.PI / 180;
    plate.m_movement.x = Math.cos(rad) * currentMag;
    plate.m_movement.y = Math.sin(rad) * currentMag;
}

// -------------------------------- Math Utilities --------------------------------

function toByte(f) {
    return Math.max(0, Math.min(255, Math.round(f * 255))) | 0;
}

function clampInt8(v) {
    return Math.max(-127, Math.min(127, v)) | 0;
}

function dot2(a, b) {
    return a.x * b.x + a.y * b.y;
}

function dot2_90(a, b) {
    // Dot product with 90-degree rotated vector: (x,y)  (-y,x)
    return -a.y * b.x + a.x * b.y;
}

function rotate2(v, angleRad) {
    const cos = Math.cos(angleRad);
    const sin = Math.sin(angleRad);
    return {
        x: v.x * cos - v.y * sin,
        y: v.x * sin + v.y * cos,
    };
}

function sub2(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
}

function add2(a, b) {
    return { x: a.x + b.x, y: a.y + b.y };
}

function summarizeBoundaryCoverage(isBoundary, boundaryCloseness) {
    const size = isBoundary?.length || 1;
    let boundaryTiles = 0;
    let influencedTiles = 0;
    let closenessSum = 0;
    let closenessInfluencedSum = 0;
    let maxCloseness = 0;

    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) boundaryTiles++;
        const c = boundaryCloseness[i] | 0;
        if (c > 0) influencedTiles++;
        closenessSum += c;
        if (c > 0) closenessInfluencedSum += c;
        if (c > maxCloseness) maxCloseness = c;
    }

    return {
        boundaryTileShare: boundaryTiles / size,
        boundaryInfluenceShare: influencedTiles / size,
        avgCloseness: closenessSum / size,
        avgInfluenceCloseness: influencedTiles > 0 ? closenessInfluencedSum / influencedTiles : 0,
        maxCloseness,
        boundaryTiles,
        influencedTiles,
        totalTiles: size,
    };
}

// -------------------------------- Tile-Precise Boundary Detection --------------------------------

/**
 * Get hex neighbors for a tile (odd-q vertical layout as used by Civ7)
 * @param {number} x - Tile x coordinate
 * @param {number} y - Tile y coordinate
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @returns {Array<{x: number, y: number, i: number}>} Array of valid neighbor coordinates and indices
 */
function getHexNeighbors(x, y, width, height) {
    const neighbors = [];
    const isOddCol = (x & 1) === 1;

    // Hex offsets for odd-q vertical layout
    const offsets = isOddCol
        ? [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, 1], [1, 1]]   // Odd column
        : [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, -1]]; // Even column

    for (const [dx, dy] of offsets) {
        const nx = x + dx;
        const ny = y + dy;
        // Handle cylindrical wrapping for x, but clamp y
        const wrappedX = ((nx % width) + width) % width;
        if (ny >= 0 && ny < height) {
            neighbors.push({ x: wrappedX, y: ny, i: ny * width + wrappedX });
        }
    }
    return neighbors;
}

/**
 * Detect boundary tiles by checking if any neighbor has a different plateId
 * @param {Int16Array} plateId - Plate assignment per tile
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @returns {{isBoundary: Uint8Array, neighborPlates: Int16Array}} Boundary detection results
 */
function detectBoundaryTiles(plateId, width, height) {
    const size = width * height;
    const isBoundary = new Uint8Array(size); // 1 if boundary, 0 otherwise
    const neighborPlates = new Int16Array(size); // Store the OTHER plate id for boundary tiles

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            const myPlate = plateId[i];
            neighborPlates[i] = -1; // Default: no neighboring plate

            const neighbors = getHexNeighbors(x, y, width, height);
            for (const n of neighbors) {
                const otherPlate = plateId[n.i];
                if (otherPlate !== myPlate) {
                    isBoundary[i] = 1;
                    neighborPlates[i] = otherPlate; // Store first different neighbor plate
                    break;
                }
            }
        }
    }

    return { isBoundary, neighborPlates };
}

/**
 * Compute distance field from boundary tiles using BFS
 * @param {Uint8Array} isBoundary - Boundary mask
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} maxDistance - Maximum distance to compute (default 20)
 * @returns {Uint8Array} Distance to nearest boundary (0 for boundary tiles)
 */
function computeDistanceField(isBoundary, width, height, maxDistance = 20) {
    const size = width * height;
    const distance = new Uint8Array(size);
    distance.fill(255); // Initialize with max

    // BFS queue: start with all boundary tiles
    const queue = [];
    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) {
            distance[i] = 0;
            queue.push(i);
        }
    }

    // BFS to compute distances
    let head = 0;
    while (head < queue.length) {
        const i = queue[head++];
        const d = distance[i];
        if (d >= maxDistance) continue;

        const x = i % width;
        const y = Math.floor(i / width);
        const neighbors = getHexNeighbors(x, y, width, height);

        for (const n of neighbors) {
            if (distance[n.i] > d + 1) {
                distance[n.i] = d + 1;
                queue.push(n.i);
            }
        }
    }

    return distance;
}

/**
 * Compute boundary physics (subduction/sliding) for boundary tiles
 * @param {Uint8Array} isBoundary - Boundary mask
 * @param {Int16Array} neighborPlates - Neighboring plate IDs for boundary tiles
 * @param {Int16Array} plateId - Plate assignment per tile
 * @param {Array<PlateRegion>} plateRegions - Plate regions with movement data
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} plateRotationMultiple - Rotation influence multiplier
 * @returns {{subduction: Float32Array, sliding: Float32Array}} Physics values for each tile
 */
function computeBoundaryPhysicsForTiles(isBoundary, neighborPlates, plateId, plateRegions, width, height, plateRotationMultiple) {
    const size = width * height;
    const subduction = new Float32Array(size);
    const sliding = new Float32Array(size);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = y * width + x;
            if (!isBoundary[i]) continue;

            const plate1Id = plateId[i];
            const plate2Id = neighborPlates[i];
            if (plate2Id < 0 || plate2Id >= plateRegions.length) continue;

            const plate1 = plateRegions[plate1Id];
            const plate2 = plateRegions[plate2Id];
            if (!plate1 || !plate2) continue;

            const pos = { x, y };

            // Calculate movement vectors at this position
            const movement1 = calculatePlateMovement(plate1, pos, plateRotationMultiple);
            const movement2 = calculatePlateMovement(plate2, pos, plateRotationMultiple);

            // Normal: direction from plate1 toward plate2 center
            const normal = VoronoiUtils.normalize({
                x: plate2.seedLocation.x - plate1.seedLocation.x,
                y: plate2.seedLocation.y - plate1.seedLocation.y,
            });

            // Subduction: relative movement along normal (positive = converging)
            subduction[i] = dot2(normal, movement1) - dot2(normal, movement2);

            // Sliding: relative movement perpendicular to normal
            sliding[i] = Math.abs(dot2_90(normal, movement1) - dot2_90(normal, movement2));
        }
    }

    return { subduction, sliding };
}

/**
 * Assign boundary types based on physics, with inheritance for near-boundary tiles
 * @param {Uint8Array} distanceField - Distance to nearest boundary
 * @param {Uint8Array} isBoundary - Boundary mask
 * @param {Int16Array} neighborPlates - Neighboring plate IDs
 * @param {{subduction: Float32Array, sliding: Float32Array}} physics - Physics values
 * @param {Uint8Array} boundaryType - Output: boundary type per tile
 * @param {Uint8Array} boundaryCloseness - Output: closeness to boundary (255 at boundary)
 * @param {Uint8Array} upliftPotential - Output: uplift potential
 * @param {Uint8Array} riftPotential - Output: rift potential
 * @param {Uint8Array} shieldStability - Output: shield stability
 * @param {Uint8Array} tectonicStress - Output: tectonic stress
 * @param {number} width - Map width
 * @param {number} height - Map height
 * @param {number} maxInfluenceDistance - Maximum distance for boundary influence (default 8)
 * @param {number} decay - Exponential decay applied to boundary influence
 */
function assignBoundaryTypesWithInheritance(
    distanceField, isBoundary, neighborPlates, physics,
    boundaryType, boundaryCloseness, upliftPotential, riftPotential, shieldStability, tectonicStress,
    width, height, maxInfluenceDistance = 5, decay = 0.55
) {
    const size = width * height;
    const convThreshold = 0.25;  // Slightly more permissive for convergent
    const divThreshold = -0.15;  // Slightly more permissive for divergent
    const transformThreshold = 0.4;

    // First pass: assign types to boundary tiles
    for (let i = 0; i < size; i++) {
        if (!isBoundary[i]) continue;

        const sub = physics.subduction[i];
        const slid = physics.sliding[i];

        if (sub > convThreshold) {
            boundaryType[i] = ENUM_BOUNDARY.convergent;
        } else if (sub < divThreshold) {
            boundaryType[i] = ENUM_BOUNDARY.divergent;
        } else if (slid > transformThreshold) {
            boundaryType[i] = ENUM_BOUNDARY.transform;
        } else {
            boundaryType[i] = ENUM_BOUNDARY.none;
        }
    }

    // Second pass: non-boundary tiles inherit from nearest boundary via BFS traversal
    // We need to track which boundary tile each interior tile inherits from
    const inheritedFrom = new Int32Array(size);
    inheritedFrom.fill(-1);

    // Mark boundary tiles as inheriting from themselves
    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) {
            inheritedFrom[i] = i;
        }
    }

    // BFS to propagate boundary type inheritance
    const queue = [];
    for (let i = 0; i < size; i++) {
        if (isBoundary[i]) queue.push(i);
    }

    let head = 0;
    while (head < queue.length) {
        const i = queue[head++];
        const d = distanceField[i];
        if (d >= maxInfluenceDistance) continue;

        const x = i % width;
        const y = Math.floor(i / width);
        const neighbors = getHexNeighbors(x, y, width, height);

        for (const n of neighbors) {
            if (inheritedFrom[n.i] < 0 && distanceField[n.i] === d + 1) {
                inheritedFrom[n.i] = inheritedFrom[i];
                queue.push(n.i);
            }
        }
    }

    // Third pass: compute all derived values
    for (let i = 0; i < size; i++) {
        const dist = distanceField[i];

        // Compute closeness: 255 at boundary, falls off with distance
        // Use exponential falloff for sharp boundary influence
        if (dist >= maxInfluenceDistance) {
            boundaryCloseness[i] = 0;
            boundaryType[i] = ENUM_BOUNDARY.none;
            upliftPotential[i] = 0;
            riftPotential[i] = 0;
            shieldStability[i] = 255;
            tectonicStress[i] = 0;
            continue;
        }

        const closeness = Math.exp(-dist * decay);
        const closeness255 = toByte(closeness);
        boundaryCloseness[i] = closeness255;

        // Inherit boundary type from nearest boundary tile
        const sourceIdx = inheritedFrom[i];
        if (sourceIdx >= 0 && !isBoundary[i]) {
            boundaryType[i] = boundaryType[sourceIdx];
        }

        // Compute derived values
        const bType = boundaryType[i];
        tectonicStress[i] = closeness255;
        // Shield stability is a simple inverse of boundary closeness:
        // deep interiors  255, boundary core  0. Landmass selection then
        // treats shield as the primary interior signal, while boundary
        // closeness is a secondary bias; do NOT make these perfectly
        // complementary, or the combined score becomes constant.
        shieldStability[i] = 255 - closeness255;

        // Uplift/rift potential scaled by closeness and boundary type
        if (bType === ENUM_BOUNDARY.convergent) {
            upliftPotential[i] = closeness255;
            riftPotential[i] = closeness255 >> 2;
        } else if (bType === ENUM_BOUNDARY.divergent) {
            upliftPotential[i] = closeness255 >> 2;
            riftPotential[i] = closeness255;
        } else {
            upliftPotential[i] = closeness255 >> 2;
            riftPotential[i] = closeness255 >> 2;
        }
    }
}
</file>

<file path="mod/maps/map_orchestrator.js">
// Epic Diverse Huge Map Generator
/**
 * Custom map script - Produces diverse terrain with cliffs, inland lakes,
 * coastal regions, mountains, jungle, tundra, and all biome variety on huge maps.
 * @packageDocumentation
 */
console.log("Loading Epic Diverse Huge Map Generator");
console.log("[SWOOPER_MOD] ========================================");
console.log("[SWOOPER_MOD] Map orchestrator loaded - v1.0");
console.log("[SWOOPER_MOD] Plate-aware mountain tuning enabled");
console.log("[SWOOPER_MOD] Diagnostics enabled");
console.log("[SWOOPER_MOD] ========================================");
import { chooseStartSectors } from "/base-standard/maps/assign-starting-plots.js";
import { expandCoasts, generateLakes } from "/base-standard/maps/elevation-terrain-generator.js";
import { layerAddMountainsPhysics } from "./layers/mountains.js";
import * as globals from "/base-standard/maps/map-globals.js";
import * as utilities from "/base-standard/maps/map-utilities.js";
import {
    stageEnabled,
    LANDMASS_CFG,
    LANDMASS_GEOMETRY,
    MOUNTAINS_CFG,
    VOLCANOES_CFG,
    FOUNDATION_SEED,
    FOUNDATION_PLATES,
    FOUNDATION_DYNAMICS,
    FOUNDATION_SURFACE,
    FOUNDATION_POLICY,
    FOUNDATION_DIAGNOSTICS,
    rebind,
} from "./bootstrap/tunables.js";
import { StoryTags, resetStoryTags } from "./story/tags.js";
import { storyTagStrategicCorridors } from "./story/corridors.js";
import { storyTagHotspotTrails, storyTagRiftValleys, storyTagOrogenyBelts, storyTagContinentalMargins, storyTagClimateSwatches, OrogenyCache, } from "./story/tagging.js";
import { StoryOverlayKeys, getStoryOverlay, hydrateMarginsStoryTags } from "./story/overlays.js";
import { layerAddVolcanoesPlateAware } from "./layers/volcanoes.js";
import { createPlateDrivenLandmasses } from "./layers/landmass_plate.js";
import { applyLandmassPostAdjustments, applyPlateAwareOceanSeparation } from "./layers/landmass_utils.js";
import { addRuggedCoasts as layerAddRuggedCoasts } from "./layers/coastlines.js";
import { addIslandChains as layerAddIslandChains } from "./layers/islands.js";
import { applyClimateBaseline, refineClimateEarthlike } from "./layers/climate-engine.js";
import { designateEnhancedBiomes as layerDesignateEnhancedBiomes } from "./layers/biomes.js";
import { addDiverseFeatures as layerAddDiverseFeatures } from "./layers/features.js";
import { runPlacement as layerRunPlacement } from "./layers/placement.js";
import { devLogIf, timeStart, timeEnd, logStoryTagsSummary, logRainfallHistogram, logRainfallStats, logCorridorAsciiOverlay, logFoundationSummary, logFoundationHistograms, logFoundationAscii, logBoundaryMetrics, logLandmassAscii, logTerrainReliefAscii, logRainfallAscii, logBiomeAscii, logBiomeSummary, logFoundationSeed, logFoundationPlates, logFoundationDynamics, logFoundationSurface, } from "./bootstrap/dev.js";
import { WorldModel } from "./world/model.js";
// Phase 1 Refactoring: Context + Adapter layer
import {
    createMapContext,
    syncHeightfield,
    syncClimateField,
    createFoundationContext,
    assertFoundationContext,
} from "./core/types.js";
import { addPlotTags } from "./core/plot_tags.js";
import { CivEngineAdapter } from "./core/adapters.js";

// Maintain compatibility with dev helpers that expect StoryTags on the global scope.
try {
    globalThis.StoryTags = StoryTags;
}
catch (_err) {
    // Swallow silently; the game VM should always expose globalThis but guard just in case.
}
/**
 * Climate Story v0.1  StoryTags scaffolding and toggles
 * Tags are sparse: store as "x,y" strings in Sets.
 * Per-map config is read at runtime from getConfig().
 */
// StoryTags are now imported from ./story/tags.js
function requestMapData(initParams) {
    console.log("=== EPIC DIVERSE HUGE GENERATOR STARTING ===");
    console.log(`Map dimensions: ${initParams.width} x ${initParams.height}`);
    console.log(`Latitude range: ${initParams.bottomLatitude} to ${initParams.topLatitude}`);
    engine.call("SetMapInitData", initParams);
}

/**
 * Lightweight surface sanity check before calling engine area/continent builders.
 * Reports aggregate land/water counts so crashes inside AreaBuilder or
 * TerrainBuilder can be correlated with the last known terrain mix.
 *
 * @param {number} width
 * @param {number} height
 */
function logSurfaceSanity(label, width, height) {
    try {
        let water = 0;
        let land = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (GameplayMap.isWater(x, y)) {
                    water++;
                } else {
                    land++;
                }
            }
        }
        const total = width * height || 1;
        const waterPct = ((water / total) * 100).toFixed(1);
        const landPct = ((land / total) * 100).toFixed(1);
        console.log(
            `[SWOOPER_MOD][SurfaceCheck] ${label}: water=${water} (${waterPct}%), land=${land} (${landPct}%)`
        );
    } catch (err) {
        console.warn("[SWOOPER_MOD][SurfaceCheck] Failed during", label, ":", err);
    }
}

function generateMap() {
    console.log("[SWOOPER_MOD] === generateMap() CALLED ===");
    console.log("Generating Epic Diverse Map with maximum terrain variety!");
    // Ensure tunables reflect the active entry config for this run.
    rebind();
    const stageFoundation = stageEnabled("foundation");
    const stageLandmassPlates = stageEnabled("landmassPlates");
    const stageCoastlines = stageEnabled("coastlines");
    const stageStorySeed = stageEnabled("storySeed");
    const stageStoryHotspots = stageEnabled("storyHotspots");
    const stageStoryRifts = stageEnabled("storyRifts");
    const stageStoryOrogeny = stageEnabled("storyOrogeny");
    const stageStoryCorridorsPre = stageEnabled("storyCorridorsPre");
    const stageIslands = stageEnabled("islands");
    const stageMountains = stageEnabled("mountains");
    const stageVolcanoes = stageEnabled("volcanoes");
    const stageLakes = stageEnabled("lakes");
    const stageClimateBaseline = stageEnabled("climateBaseline");
    const stageStorySwatches = stageEnabled("storySwatches");
    const stageRivers = stageEnabled("rivers");
    const stageStoryCorridorsPost = stageEnabled("storyCorridorsPost");
    const stageClimateRefine = stageEnabled("climateRefine");
    const stageBiomes = stageEnabled("biomes");
    const stageFeatures = stageEnabled("features");
    const stagePlacement = stageEnabled("placement");
    logFoundationSeed(FOUNDATION_SEED, null);
    logFoundationPlates(FOUNDATION_PLATES);
    logFoundationDynamics(FOUNDATION_DYNAMICS);
    logFoundationSurface(FOUNDATION_SURFACE);
    const mountainsConfig = MOUNTAINS_CFG || {};
    const mountainOptions = {
        // Physics-threshold controls (no quota - mountains only where physics justifies)
        tectonicIntensity: mountainsConfig.tectonicIntensity ?? 1.0,
        mountainThreshold: mountainsConfig.mountainThreshold ?? 0.45,
        hillThreshold: mountainsConfig.hillThreshold ?? 0.25,
        // Physics weights
        upliftWeight: mountainsConfig.upliftWeight ?? 0.75,
        fractalWeight: mountainsConfig.fractalWeight ?? 0.25,
        riftDepth: mountainsConfig.riftDepth ?? 0.3,
        boundaryWeight: mountainsConfig.boundaryWeight ?? 0.6,
        boundaryExponent: mountainsConfig.boundaryExponent ?? 1.4,
        interiorPenaltyWeight: mountainsConfig.interiorPenaltyWeight ?? 0.2,
        convergenceBonus: mountainsConfig.convergenceBonus ?? 0.9,
        transformPenalty: mountainsConfig.transformPenalty ?? 0.3,
        riftPenalty: mountainsConfig.riftPenalty ?? 0.75,
        hillBoundaryWeight: mountainsConfig.hillBoundaryWeight ?? 0.45,
        hillRiftBonus: mountainsConfig.hillRiftBonus ?? 0.5,
        hillConvergentFoothill: mountainsConfig.hillConvergentFoothill ?? 0.25,
        hillInteriorFalloff: mountainsConfig.hillInteriorFalloff ?? 0.2,
        hillUpliftWeight: mountainsConfig.hillUpliftWeight ?? 0.25,
    };
    const volcanoConfig = VOLCANOES_CFG || {};
    const volcanoOptions = {
        enabled: volcanoConfig.enabled ?? true,
        baseDensity: volcanoConfig.baseDensity ?? (1 / 170),
        minSpacing: volcanoConfig.minSpacing ?? 3,
        boundaryThreshold: volcanoConfig.boundaryThreshold ?? 0.35,
        boundaryWeight: volcanoConfig.boundaryWeight ?? 1.2,
        convergentMultiplier: volcanoConfig.convergentMultiplier ?? 2.4,
        transformMultiplier: volcanoConfig.transformMultiplier ?? 1.1,
        divergentMultiplier: volcanoConfig.divergentMultiplier ?? 0.35,
        hotspotWeight: volcanoConfig.hotspotWeight ?? 0.12,
        shieldPenalty: volcanoConfig.shieldPenalty ?? 0.6,
        randomJitter: volcanoConfig.randomJitter ?? 0.08,
        minVolcanoes: volcanoConfig.minVolcanoes ?? 5,
        maxVolcanoes: volcanoConfig.maxVolcanoes ?? 40,
    };
    console.log("[SWOOPER_MOD] Tunables rebound successfully");
    console.log(
        `[SWOOPER_MOD] Mountains: intensity=${mountainOptions.tectonicIntensity}, threshold=${mountainOptions.mountainThreshold} | Hills: threshold=${mountainOptions.hillThreshold}`
    );
    console.log(
        `[SWOOPER_MOD] Volcano config  base density ${(volcanoOptions.baseDensity ?? 0).toFixed(4)}, spacing ${volcanoOptions.minSpacing}`
    );
    let iWidth = GameplayMap.getGridWidth();
    let iHeight = GameplayMap.getGridHeight();
    let uiMapSize = GameplayMap.getMapSize();
    let startPositions = [];
    let mapInfo = GameInfo.Maps.lookup(uiMapSize);
    if (mapInfo == null)
        return;

    // Phase 1 Refactoring: Create MapContext with adapter
    console.log("[Refactoring] Creating MapContext with CivEngineAdapter...");
    const adapter = new CivEngineAdapter(iWidth, iHeight);
    const ctx = createMapContext(
        { width: iWidth, height: iHeight },
        adapter,
        {
            STORY_ENABLE_HOTSPOTS: stageStoryHotspots,
            STORY_ENABLE_RIFTS: stageStoryRifts,
            STORY_ENABLE_OROGENY: stageStoryOrogeny,
            LANDMASS_GEOMETRY,
        }
    );

    // Initialize WorldModel (optional) and attach to context
    if (!stageFoundation) {
        console.warn("[StageManifest] Foundation stage disabled; physics pipeline requires it.");
    }
    let foundationContext = null;
    if (stageFoundation) {
        try {
            if (!WorldModel.init()) {
                throw new Error("[WorldModel] Initialization failed; physics data unavailable.");
            }
            ctx.worldModel = WorldModel;
            foundationContext = createFoundationContext(WorldModel, {
                dimensions: ctx.dimensions,
                config: {
                    seed: FOUNDATION_SEED,
                    plates: FOUNDATION_PLATES,
                    dynamics: FOUNDATION_DYNAMICS,
                    surface: FOUNDATION_SURFACE,
                    policy: FOUNDATION_POLICY,
                    diagnostics: FOUNDATION_DIAGNOSTICS,
                },
            });
            ctx.foundation = foundationContext;
            devLogIf("LOG_STORY_TAGS", "[WorldModel] Initialized and attached to context");
            logFoundationSummary(WorldModel);
            logFoundationAscii(WorldModel);
            logFoundationSeed(FOUNDATION_SEED, foundationContext.plateSeed || null, { skipConfig: true });
        }
        catch (err) {
            const message = err && typeof err.message === "string" ? err.message : String(err);
            console.error(`[FoundationContext] Failed to initialize: ${message}`);
            throw err;
        }
    }
    let iNumNaturalWonders = Math.max(mapInfo.NumNaturalWonders + 1, mapInfo.NumNaturalWonders);
    let iTilesPerLake = Math.max(10, mapInfo.LakeGenerationFrequency * 2); // fewer lakes than base script used
    let iNumPlayers1 = mapInfo.PlayersLandmass1;
    let iNumPlayers2 = mapInfo.PlayersLandmass2;
    let iStartSectorRows = mapInfo.StartSectorRows;
    let iStartSectorCols = mapInfo.StartSectorCols;
    // Set up start sectors first (before terrain generation)
    let bHumanNearEquator = utilities.needHumanNearEquator();
    let startSectors = chooseStartSectors(iNumPlayers1, iNumPlayers2, iStartSectorRows, iStartSectorCols, bHumanNearEquator);
    console.log("Start sectors chosen successfully");
    // Create continent boundaries for start position assignment (simplified for compatibility)
    let westContinent = {
        west: globals.g_AvoidSeamOffset,
        east: iWidth / 2 - globals.g_AvoidSeamOffset,
        south: globals.g_PolarWaterRows,
        north: iHeight - globals.g_PolarWaterRows,
        continent: 0,
    };
    let eastContinent = {
        west: iWidth / 2 + globals.g_AvoidSeamOffset,
        east: iWidth - globals.g_AvoidSeamOffset,
        south: globals.g_PolarWaterRows,
        north: iHeight - globals.g_PolarWaterRows,
        continent: 0,
    };
    const landmassSource = stageLandmassPlates ? "plate" : "disabled";
    let landmaskDebug = null;
    let landmassWindowsFinal = [];
    const ensureFoundation = (stageName) => assertFoundationContext(ctx, stageName);
    if (stageLandmassPlates) {
        ensureFoundation("landmassPlates");
        const t = timeStart("Landmass (Plate-Driven)");
        const plateResult = createPlateDrivenLandmasses(iWidth, iHeight, ctx, {
            landmassCfg: LANDMASS_CFG,
            geometry: LANDMASS_GEOMETRY,
        });
        if (!plateResult || !Array.isArray(plateResult.windows) || plateResult.windows.length === 0) {
            console.error("[SWOOPER_MOD] ERROR: Plate-driven landmass generation failed (no windows).");
            timeEnd(t);
            return;
        }
        landmaskDebug = plateResult.landMask || null;
        let landmassWindows = plateResult.windows.slice();
        const separationResult = applyPlateAwareOceanSeparation({
            width: iWidth,
            height: iHeight,
            windows: landmassWindows,
            landMask: plateResult.landMask,
            context: ctx,
            adapter: ctx?.adapter,
            worldModel: WorldModel,
        });
        landmassWindows = separationResult.windows;
        if (separationResult.landMask) {
            landmaskDebug = separationResult.landMask;
        }
        landmassWindows = applyLandmassPostAdjustments(landmassWindows, LANDMASS_GEOMETRY, iWidth, iHeight);
        if (Array.isArray(landmassWindows) && landmassWindows.length >= 2) {
            const first = landmassWindows[0];
            const last = landmassWindows[landmassWindows.length - 1];
            if (first && last) {
                westContinent = {
                    west: first.west,
                    east: first.east,
                    south: first.south,
                    north: first.north,
                    continent: first.continent ?? 0,
                };
                eastContinent = {
                    west: last.west,
                    east: last.east,
                    south: last.south,
                    north: last.north,
                    continent: last.continent ?? 1,
                };
            }
        }
        landmassWindowsFinal = landmassWindows;
        console.log("[SWOOPER_MOD] Applied plate-driven landmass mask");
        timeEnd(t);

        // === FOUNDATION SURFACE GATE: Landmass  Engine Continents ===
        // At this point, the macro land/ocean pattern is established (plates + separation).
        // Stamp engine continents once here so downstream systems can rely on them.
        // Later surface tweaks (coasts, islands, mountains) should not require re-stamping.
        TerrainBuilder.validateAndFixTerrain();
        logSurfaceSanity("post-landmass", iWidth, iHeight);
        console.log("[SWOOPER_MOD] Recalculating areas after plate-driven landmass...");
        AreaBuilder.recalculateAreas();
        console.log("[SWOOPER_MOD] Stamping continents from plate-driven landmass...");
        TerrainBuilder.stampContinents();

        // Derive west/east macro regions from windows for placement & plot tagging.
        if (landmassWindowsFinal.length) {
            const windowSummary = landmassWindowsFinal.map((win, idx) => {
                if (!win)
                    return { index: idx };
                const spanX = Number.isFinite(win.east) && Number.isFinite(win.west) ? win.east - win.west + 1 : null;
                const spanY = Number.isFinite(win.north) && Number.isFinite(win.south) ? win.north - win.south + 1 : null;
                return {
                    index: idx,
                    continent: win.continent ?? idx,
                    west: win.west,
                    east: win.east,
                    south: win.south,
                    north: win.north,
                    width: spanX,
                    height: spanY,
                    area: spanX && spanY ? spanX * spanY : null,
                };
            });
            devLogIf("LOG_LANDMASS_WINDOWS", "[Landmass] windows summary", JSON.stringify(windowSummary));
        }
        else {
            devLogIf("LOG_LANDMASS_WINDOWS", "[Landmass] windows summary", "no plate windows");
        }

        // Update start-continent hints from the stamped landmass windows.
        if (Array.isArray(landmassWindowsFinal) && landmassWindowsFinal.length >= 2) {
            const first = landmassWindowsFinal[0];
            const last = landmassWindowsFinal[landmassWindowsFinal.length - 1];
            if (first && last) {
                westContinent = {
                    west: first.west,
                    east: first.east,
                    south: first.south,
                    north: first.north,
                    continent: first.continent ?? 0,
                };
                eastContinent = {
                    west: last.west,
                    east: last.east,
                    south: last.south,
                    north: last.north,
                    continent: last.continent ?? 1,
                };
            }
        }

        // Apply plot tags based on the macro east/west split.
        addPlotTags(iHeight, iWidth, eastContinent.west);
    }
    else {
        console.warn("[StageManifest] Landmass stage disabled  skipping landmass generation.");
    }
    logLandmassAscii(landmassSource, {
        windows: Array.isArray(landmassWindowsFinal) ? landmassWindowsFinal : [],
        landMask: landmaskDebug || undefined,
    });
    if (stageCoastlines) {
        ensureFoundation("coastlines");
        const t = timeStart("ExpandCoasts");
        expandCoasts(iWidth, iHeight);
        timeEnd(t);
    }
    else {
        console.log("[StageManifest] Coastlines stage disabled  skipping expandCoasts()");
    }
    // Reset StoryTags and tag continental margins before coast shaping
    let marginsOverlay = null;
    if (stageStorySeed) {
        ensureFoundation("storySeed");
        resetStoryTags();
        console.log("Imprinting continental margins (active/passive)...");
        marginsOverlay = storyTagContinentalMargins(ctx);
        if (!marginsOverlay) {
            marginsOverlay = getStoryOverlay(ctx, StoryOverlayKeys.MARGINS);
        }
    }
    // Add post-processing to make coasts more rugged (margin-aware) and place a few islands
    if (stageCoastlines) {
        const t = timeStart("RuggedCoasts");
        layerAddRuggedCoasts(iWidth, iHeight, ctx);
        timeEnd(t);
    }
    // Climate Story v0.1: Tag narrative motifs after coasts exist
    if (stageStoryHotspots || stageStoryRifts) {
        resetStoryTags();
        if (!marginsOverlay) {
            marginsOverlay = getStoryOverlay(ctx, StoryOverlayKeys.MARGINS);
        }
        if (marginsOverlay) {
            hydrateMarginsStoryTags(marginsOverlay, StoryTags);
        }
    }
    if (stageStoryHotspots) {
        ensureFoundation("storyHotspots");
        console.log("Drawing hotspot trails...");
        storyTagHotspotTrails(iWidth, iHeight);
    }
    if (stageStoryRifts) {
        ensureFoundation("storyRifts");
        console.log("Marking rift lines and shoulders...");
        storyTagRiftValleys(iWidth, iHeight);
    }
    if (stageStoryOrogeny) {
        ensureFoundation("storyOrogeny");
        console.log("Tagging orogenic belts...");
        storyTagOrogenyBelts();
        logFoundationHistograms(WorldModel, {
            riftSet: StoryTags.riftLine,
            beltSet: OrogenyCache.belts,
            bins: 12,
        });
    }
    // Re-tag continental margins for downstream consumers (islands/features) after reset
    if (stageStorySeed && marginsOverlay) {
        hydrateMarginsStoryTags(marginsOverlay, StoryTags);
    }
    // Strategic Corridors: tag pre-islands lanes and land corridors
    if (stageStoryCorridorsPre) {
        ensureFoundation("storyCorridorsPre");
        storyTagStrategicCorridors("preIslands");
        logCorridorAsciiOverlay();
    }
    if (stageStorySeed || stageStoryHotspots || stageStoryRifts || stageStoryOrogeny) {
        devLogIf("LOG_STORY_TAGS", "StoryTags summary follows");
        logStoryTagsSummary(StoryTags, OrogenyCache);
    }
    if (stageIslands) {
        ensureFoundation("islands");
        const t = timeStart("IslandChains");
        layerAddIslandChains(iWidth, iHeight, ctx);
        timeEnd(t);
    }
    // Mountains & Hills  Phase 2: Physics-based placement using plate boundaries
    if (stageMountains) {
        ensureFoundation("mountains");
        const t = timeStart("Mountains & Hills (Physics)");
        layerAddMountainsPhysics(ctx, mountainOptions);
        timeEnd(t);
        if (stageFoundation) {
            logBoundaryMetrics(WorldModel, { stage: "post-mountains" });
        }
    }
    if (stageVolcanoes) {
        ensureFoundation("volcanoes");
        const t = timeStart("Volcanoes");
        layerAddVolcanoesPlateAware(ctx, volcanoOptions);
        timeEnd(t);
        if (stageFoundation) {
            logBoundaryMetrics(WorldModel, { stage: "post-volcanoes" });
        }
    }
    if (stageMountains || stageVolcanoes) {
        logTerrainReliefAscii("post-volcanoes");
    }
    // Lakes  fewer than before
    if (stageLakes) {
        ensureFoundation("lakes");
        const t = timeStart("Lakes");
        generateLakes(iWidth, iHeight, iTilesPerLake);
        timeEnd(t);
        syncHeightfield(ctx);
    }
    // MAP STATISTICS LOGGING - Diagnostic for start placement failures
    console.log("[SWOOPER_MOD] About to calculate MAP_STATS...");
    {
        let waterCount = 0, mountainCount = 0, hillCount = 0, flatCount = 0;
        const totalTiles = iWidth * iHeight;
        for (let y = 0; y < iHeight; y++) {
            for (let x = 0; x < iWidth; x++) {
                if (GameplayMap.isWater(x, y))
                    waterCount++;
                else if (GameplayMap.isMountain(x, y))
                    mountainCount++;
                else if (GameplayMap.getTerrainType(x, y) === globals.g_HillTerrain)
                    hillCount++;
                else
                    flatCount++;
            }
        }
        const landCount = totalTiles - waterCount;
        const waterPct = ((waterCount / totalTiles) * 100).toFixed(1);
        const landPct = ((landCount / totalTiles) * 100).toFixed(1);
        const mtnPct = landCount > 0 ? ((mountainCount / landCount) * 100).toFixed(1) : 0;
        const hillPct = landCount > 0 ? ((hillCount / landCount) * 100).toFixed(1) : 0;
        const flatPct = landCount > 0 ? ((flatCount / landCount) * 100).toFixed(1) : 0;
        console.log(`[MAP_STATS] Total tiles: ${totalTiles}, Water: ${waterCount} (${waterPct}%), Land: ${landCount} (${landPct}%)`);
        console.log(`[MAP_STATS] Land breakdown: Mountains: ${mountainCount} (${mtnPct}%), Hills: ${hillCount} (${hillPct}%), Flat: ${flatCount} (${flatPct}%)`);
    }
    AreaBuilder.recalculateAreas();
    // Commit the latest mountain/hill assignments before climate stages.
    // Base-standard scripts call TerrainBuilder.buildElevation() here so the
    // engine propagates terrain height for rainfall, biomes, and placement.
    TerrainBuilder.buildElevation();
    // Create moderated rainfall patterns (keep enhanced but gentle)
    if (stageClimateBaseline) {
        ensureFoundation("climateBaseline");
        const t = timeStart("Climate: Baseline");
        applyClimateBaseline(iWidth, iHeight, ctx);
        timeEnd(t);
        logRainfallAscii("baseline");
        logRainfallStats("baseline", iWidth, iHeight);
    }
    if (stageStorySwatches) {
        ensureFoundation("storySwatches");
        const t = timeStart("Climate: Swatches");
        const swatchResult = storyTagClimateSwatches(ctx);
        if (swatchResult && swatchResult.kind) {
            devLogIf("LOG_STORY_TAGS", `Climate Swatch: ${swatchResult.kind} (${swatchResult.tiles} tiles)`);
        }
        devLogIf("LOG_SWATCHES", "[Swatches] result", swatchResult || null);
        timeEnd(t);
    }
    // Rivers  closer to base values for balance
    if (stageRivers) {
        ensureFoundation("rivers");
        const t = timeStart("Rivers");
        TerrainBuilder.modelRivers(5, 15, globals.g_NavigableRiverTerrain);
        timeEnd(t);
        TerrainBuilder.validateAndFixTerrain();
        syncHeightfield(ctx);
        syncClimateField(ctx);
        TerrainBuilder.defineNamedRivers();
    }
    // Strategic Corridors: tag river-chain corridors post-rivers
    if (stageStoryCorridorsPost) {
        ensureFoundation("storyCorridorsPost");
        storyTagStrategicCorridors("postRivers");
        logCorridorAsciiOverlay();
    }
    // Refine rainfall with earthlike dynamics after rivers exist
    if (stageClimateRefine) {
        ensureFoundation("climateRefine");
        const t = timeStart("Climate: Earthlike Refinements");
        // Phase 1: Pass context to refactored layer
        refineClimateEarthlike(iWidth, iHeight, ctx);
        timeEnd(t);
        logRainfallAscii("refined");
        logRainfallStats("refined", iWidth, iHeight);
    }
    // Enhanced biome diversity
    if (stageBiomes) {
        ensureFoundation("biomes");
        const t = timeStart("Biomes");
        layerDesignateEnhancedBiomes(iWidth, iHeight);
        timeEnd(t);
        logBiomeAscii("final");
        logBiomeSummary("final", iWidth, iHeight);
    }
    // Add extensive feature variety
    if (stageFeatures) {
        ensureFoundation("features");
        const t = timeStart("Features");
        layerAddDiverseFeatures(iWidth, iHeight, ctx);
        timeEnd(t);
        TerrainBuilder.validateAndFixTerrain();
        syncHeightfield(ctx);
        AreaBuilder.recalculateAreas();
    }
    if (stageClimateBaseline || stageClimateRefine) {
        devLogIf("RAINFALL_HISTOGRAM", "Rainfall histogram (land tiles)");
        logRainfallHistogram(iWidth, iHeight, 12);
    }
    TerrainBuilder.storeWaterData();
    // Placement phase (wonders, floodplains, snow, resources, starts, discoveries, fertility, advanced starts)
    if (stagePlacement) {
        ensureFoundation("placement");
        const t = timeStart("Placement");
        startPositions = layerRunPlacement(iWidth, iHeight, {
            mapInfo,
            wondersPlusOne: true,
            floodplains: { minLength: 4, maxLength: 10 },
            starts: {
                playersLandmass1: iNumPlayers1,
                playersLandmass2: iNumPlayers2,
                westContinent,
                eastContinent,
                startSectorRows: iStartSectorRows,
                startSectorCols: iStartSectorCols,
                startSectors,
            },
        });
        timeEnd(t);
    }
    console.log("=== EPIC DIVERSE HUGE GENERATOR COMPLETED ===");
}
// Register listeners
engine.on("RequestMapInitData", requestMapData);
engine.on("GenerateMap", generateMap);
console.log("Epic Diverse Huge Map Generator loaded and ready!");
</file>

<file path="mod/maps/swooper-desert-mountains.js">
// @ts-check
/**
 * Swooper Desert Mountains  Hyperarid, plate-driven world
 *
 * Purpose
 * - Deliver a mostly dry planet punctuated by brutal orographic walls.
 * - Lean on plate-aware uplift so convergent margins become mega ranges.
 * - Reserve humidity for narrow rainfall belts hugging those ranges and a
 *   few equatorial/monsoonal refuges.
 *
 * Notes
 * - Mountains: the config intentionally dampens shoreline stacking by
 *   reducing boundary bonuses, raising interior penalties, and enabling a
 *   light ocean-separation pass. If convergent belts begin clumping again,
 *   revisit `mountains.*` weights or tweak the plate seed/rotation knobs
 *   under the `foundation` config.
 */
import { bootstrap } from "./bootstrap/entry.js";

/** @typedef {import("./bootstrap/map_config.types.js").MapConfig} MapConfig */
/** @typedef {import("./bootstrap/map_config.types.js").ClimateRefine} ClimateRefine */
/** @typedef {import("./bootstrap/map_config.types.js").FoundationConfig} FoundationCfg */
/** @typedef {import("./bootstrap/map_config.types.js").StageConfigProviders} StageConfigProviders */

bootstrap({
    stageConfig: /** @type {StageConfigProviders} */ ({
        foundation: true,
        landmassPlates: true,
        coastlines: true,
        storySeed: true,
        storyHotspots: true,
        storyRifts: true,
        storyOrogeny: true,
        storyPaleo: true,
        storyCorridorsPre: true,
        mountains: true,
        volcanoes: true,
        climateBaseline: true,
        storySwatches: true,
        climateRefine: true,
        biomes: true,
        features: true,
    }),
    overrides: /** @type {Partial<MapConfig>} */ ({
        toggles: {
            STORY_ENABLE_HOTSPOTS: false,
            STORY_ENABLE_RIFTS: false,
            STORY_ENABLE_OROGENY: false,
            STORY_ENABLE_SWATCHES: false,
            STORY_ENABLE_PALEO: false,
            STORY_ENABLE_CORRIDORS: false,
        },
        landmass: {
            baseWaterPercent: 63,
            waterThumbOnScale: -6,
            jitterAmpFracBase: 0.02,
        },
        margins: {
            activeFraction: 0.34,
            passiveFraction: 0.18,
            minSegmentLength: 28,
        },
        coastlines: {
            plateBias: {
                threshold: 0.54,
                power: 1.25,
                convergent: 1.1,
                transform: 0.45,
                divergent: -0.2,
                interior: -0.15,
                bayWeight: 0.48,
                bayNoiseBonus: 1.2,
                fjordWeight: 1.05,
            },
        },
        mountains: {
            // Physics-threshold controls (higher intensity = more dramatic mountains)
            tectonicIntensity: 0.77,      // Moderate intensity for balanced mountains
            mountainThreshold: 0.62,     // Higher threshold = fewer mountains
            hillThreshold: 0.20,         // Higher threshold = fewer hills
            // Physics weights
            upliftWeight: 0.65,
            fractalWeight: 0.35,
            riftDepth: 0.4,
            boundaryWeight: 0.7,
            boundaryExponent: 1.35,
            interiorPenaltyWeight: 0.6,
            convergenceBonus: 0.9,
            transformPenalty: 0.3,
            riftPenalty: 0.9,
            hillBoundaryWeight: 0.5,
            hillRiftBonus: 0.52,
            hillConvergentFoothill: 0.4,
            hillInteriorFalloff: 0.3,
            hillUpliftWeight: 0.4,
        },
        volcanoes: {
            baseDensity: 1 / 175,
            minSpacing: 5,
            boundaryThreshold: 0.3,
            boundaryWeight: 1.6,
            convergentMultiplier: 3.25,
            transformMultiplier: 0.9,
            divergentMultiplier: 0.22,
            hotspotWeight: 0.16,
            shieldPenalty: 0.78,
            randomJitter: 0.12,
            minVolcanoes: 9,
            maxVolcanoes: 42,
        },
        climate: {
            baseline: {
                blend: {
                    baseWeight: 0.45,
                    bandWeight: 0.55,
                },
                bands: {
                    deg0to10: 92,
                    deg10to20: 64,
                    deg20to35: 32,
                    deg35to55: 52,
                    deg55to70: 34,
                    deg70plus: 18,
                },
                orographic: {
                    hi1Threshold: 280,
                    hi1Bonus: 6,
                    hi2Threshold: 540,
                    hi2Bonus: 18,
                },
                coastal: {
                    coastalLandBonus: 3,
                    shallowAdjBonus: 2,
                },
                noise: {
                    baseSpanSmall: 5,
                    spanLargeScaleFactor: 1.1,
                },
            },
            refine: /** @type {Partial<ClimateRefine>} */ ({
                waterGradient: {
                    radius: 7,
                    perRingBonus: 1.6,
                    lowlandBonus: 3,
                },
                orographic: {
                    steps: 6,
                    reductionBase: 34,
                    reductionPerStep: 14,
                },
                riverCorridor: {
                    lowlandAdjacencyBonus: 22,
                    highlandAdjacencyBonus: 11,
                },
                lowBasin: {
                    radius: 4,
                    delta: 16,
                },
            }),
        },
        story: {
            hotspot: {
                maxTrails: 9,
                steps: 13,
                stepLen: 2,
                minDistFromLand: 6,
                minTrailSeparation: 14,
                paradiseBias: 1,
                volcanicBias: 2,
                volcanicPeakChance: 0.58,
            },
            rift: {
                maxRiftsPerMap: 2,
                lineSteps: 22,
                stepLen: 3,
                shoulderWidth: 1,
            },
            orogeny: {
                beltMaxPerContinent: 4,
                beltMinLength: 16,
                radius: 7,
                windwardBoost: 24,
                leeDrynessAmplifier: 2.6,
            },
            swatches: {
                maxPerMap: 8,
                forceAtLeastOne: true,
                types: {
                    macroDesertBelt: {
                        weight: 20,
                        latitudeCenterDeg: 18,
                        halfWidthDeg: 18,
                        drynessDelta: 60,
                        bleedRadius: 10,
                    },
                    equatorialRainbelt: {
                        weight: 7,
                        latitudeCenterDeg: 4,
                        halfWidthDeg: 6,
                        wetnessDelta: 70,
                        bleedRadius: 5,
                    },
                    mountainForests: {
                        weight: 5,
                        coupleToOrogeny: true,
                        windwardBonus: 18,
                        leePenalty: 10,
                        bleedRadius: 5,
                    },
                    rainforestArchipelago: {
                        weight: 2,
                        islandBias: 1.5,
                        reefBias: 1.2,
                        wetnessDelta: 28,
                        bleedRadius: 4,
                    },
                },
            },
            paleo: {
                maxFossilChannels: 24,
                fossilChannelLengthTiles: 18,
                fossilChannelStep: 2,
                fossilChannelHumidity: 7,
                fossilChannelMinDistanceFromCurrentRivers: 5,
                sizeScaling: {
                    lengthMulSqrt: 0.8,
                },
                elevationCarving: {
                    enableCanyonRim: true,
                    rimWidth: 5,
                    canyonDryBonus: 12,
                    bluffWetReduction: 2,
                },
            },
        },
        microclimate: {
            rainfall: {
                riftBoost: 6,
                riftRadius: 2,
                paradiseDelta: 4,
                volcanicDelta: 5,
            },
            features: {
                paradiseReefChance: 18,
                volcanicForestChance: 14,
                volcanicTaigaChance: 12,
            },
        },
        biomes: {
            tundra: {
                latMin: 62,
                elevMin: 420,
                rainMax: 55,
            },
            tropicalCoast: {
                latMax: 22,
                rainMin: 115,
            },
            riverValleyGrassland: {
                latMax: 48,
                rainMin: 65,
            },
            riftShoulder: {
                grasslandLatMax: 48,
                grasslandRainMin: 55,
                tropicalLatMax: 28,
                tropicalRainMin: 95,
            },
        },
        featuresDensity: {
            rainforestExtraChance: 18,
            forestExtraChance: 12,
            taigaExtraChance: 2,
            shelfReefMultiplier: 0.85,
        },
        foundation: /** @type {Partial<FoundationCfg>} */ ({
            plates: {
                count: 23,
                convergenceMix: 0.55,
                relaxationSteps: 3,
                seedJitter: 5,
                interiorSmooth: 1.35,
                plateRotationMultiple: 3,
                // seedOffset: 2203, // tweak for alternate plate tessellations
            },
            dynamics: {
                wind: {
                    jetStreaks: 5,
                    jetStrength: 2.0,
                    variance: 0.4,
                    coriolisZonalScale: 2.1,
                },
                currents: {
                    basinGyreCountMax: 4,
                    westernBoundaryBias: 1.6,
                    currentStrength: 1.4,
                },
                mantle: {
                    bumps: 10,
                    amplitude: 6,
                    scale: 1.8,
                },
                directionality: {
                    cohesion: 0.48,
                    primaryAxes: {
                        plateAxisDeg: 47,
                        windBiasDeg: 24,
                        currentBiasDeg: 85,
                    },
                    interplay: {
                        windsFollowPlates: 0.55,
                        currentsFollowWinds: 0.62,
                        riftsFollowPlates: 0.78,
                        orogenyOpposesRifts: 0.62,
                    },
                    hemispheres: {
                        southernFlip: true,
                        equatorBandDeg: 14,
                        monsoonBias: 0.24,
                    },
                    variability: {
                        angleJitterDeg: 22,
                        magnitudeVariance: 0.45,
                        // seedOffset: 9053,
                    },
                },
            },
            policy: {
                windInfluence: 1.2,
                currentHumidityBias: 0.6,
                boundaryFjordBias: 1.1,
                shelfReefBias: 0.7,
                oceanSeparation: {
                    enabled: false,
                    baseSeparationTiles: 0,
                    boundaryClosenessMultiplier: 0,
                    maxPerRowDelta: 0,
                    minChannelWidth: 5,
                    respectSeaLanes: true,
                    edgeWest: {
                        enabled: false,
                        baseTiles: 0,
                        boundaryClosenessMultiplier: 1.0,
                        maxPerRowDelta: 1,
                    },
                    edgeEast: {
                        enabled: false,
                        baseTiles: 0,
                        boundaryClosenessMultiplier: 1.0,
                        maxPerRowDelta: 1,
                    },
                },
            },
        }),
    }),
});
import "./map_orchestrator.js";
</file>

<file path="mod/text/en_us/MapText.xml">
<?xml version="1.0" encoding="utf-8"?>
<Database>
	<EnglishText>
		<Row Tag="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_NAME">
			<Text>Swooper Desert Mountains</Text>
		</Row>
		<Row Tag="LOC_MAP_SWOOPER_DESERT_MOUNTAINS_DESCRIPTION">
			<Text>Plate-forged mega ranges carve a hyper-arid world into stark basins and windward oases. Expect towering boundary cordilleras, savage lee-side deserts, and a handful of monsoon belts clinging to the mountains that feed them.</Text>
		</Row>

	</EnglishText>
</Database>
</file>

<file path="mod/text/en_us/ModuleText.xml">
<?xml version="1.0" encoding="utf-8"?>
<Database>
	<EnglishText>
		<Row Tag="LOC_MODULE_SWOOPER_MAPS_NAME">
			<Text>Swooper's Physics-Based Maps</Text>
		</Row>
		<Row Tag="LOC_MODULE_SWOOPER_MAPS_DESCRIPTION">
			<Text>Advanced map generation using plate tectonics, climate simulation, and narrative storytelling systems. Features convergent mountain chains, rift valleys, atmospheric pressure systems, and physics-driven coastlines. Replaces random terrain generation with realistic geological processes.</Text>
		</Row>
	</EnglishText>
</Database>
</file>

<file path="mod/swooper-maps.modinfo">
<?xml version="1.0" encoding="utf-8"?>
<Mod id="swooper-maps" version="1" xmlns="ModInfo">
	<Properties>
		<Name>LOC_MODULE_SWOOPER_MAPS_NAME</Name>
		<Description>LOC_MODULE_SWOOPER_MAPS_DESCRIPTION</Description>
		<Authors>Matei Canavra</Authors>
		<Package>Mod</Package>
	</Properties>
	<Dependencies>
		<Mod id="base-standard" title="LOC_MODULE_BASE_STANDARD_NAME"/>
	</Dependencies>
	<ActionCriteria>
		<Criteria id="always">
			<AlwaysMet></AlwaysMet>
		</Criteria>
	</ActionCriteria>
	<ActionGroups>
		<!-- Shell scope: Register maps in UI -->
		<ActionGroup id="shell-swooper-maps" scope="shell" criteria="always">
			<Actions>
				<UpdateDatabase>
					<Item>config/config.xml</Item>
				</UpdateDatabase>
				<UpdateText>
					<Item>text/en_us/MapText.xml</Item>
				</UpdateText>
			</Actions>
		</ActionGroup>
	</ActionGroups>
	<LocalizedText>
		<File>text/en_us/ModuleText.xml</File>
	</LocalizedText>
</Mod>
</file>

</files>
</file>

</files>
